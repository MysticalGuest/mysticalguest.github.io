{"pages":[{"title":"","text":"友链 我的CSDN博客 我的博客园 申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://mysteryguest.gitee.io/img/shadow.jpg 网站名称：Longing(MysteryGuest的博客) 网站地址：https://mysteryguest.gitee.io 网站简介：后端开发，技术分享","link":"/friend/index.html"},{"title":"","text":"个人简介生日&ensp;&emsp;&emsp;09 Jan 1999 E-mail&ensp;&emsp;mysticalguest@163.com 英语&ensp;&emsp;&emsp;CET-6 在校大学生，致力于搬砖，想搬好每一块砖 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 职业技能 Java Maven Jsp Spring Thymeleaf HTML Javascript Vue 教育经历 &emsp;西北大学 &emsp;2017 - 2021 | 软件工程 个人作品闲时基于SpringBoot和JSP开发的宾馆管理系统 运用SSM框架开发的宾馆管理系统 Python大作业，基于Tkinter的餐厅信息管理系统 本站推荐索引 博客主题相关 Hexo迁移 ICARUS主题美化 技术知识点 Java笔记文档 数据结构进阶实训 计划2020计划 2020.01.09 2020-GOALS [ ] 考研 [x] 坚持完善博客","link":"/about/index.html"}],"posts":[{"title":"数据结构进阶实训九 二叉树的应用","text":"Data structure advanced training course notes and algorithm exercises Source Code: https://github.com/MysticalGuest/DataStructure/tree/master/AdvancedJuniorTraining 题目112345建二叉树二叉链表存储 - 扩展的先序序列（之前采用的方法） 此次要求：已知两个遍历序列建二叉树（先/中，后/中） - 其先、中序遍历序列分别存放在两个数组pre[]和inorder[]中。 - 其中、后序遍历序列分别存放在两个数组inorder[]和post中。 1.1 算法设计思想 两种建树的思想相同，都是分治的思想；通过前序遍历，第一个元素就是树的根节点；然后在重建左子树，找到左子树的根节点，重建右子树，找到右子树的根节点，递归下去；中序+后续遍历重建树也是如此；后续序列的最后一个元素就是树的根节点。 1.2 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;stdio.h&gt;#include&lt;Windows.h&gt;typedef char ElemType;typedef struct Node{ ElemType elem; struct Node *LChild; struct Node *RChild;}BiTNode, *BiTree;// 前序+中序重建二叉树void ReBuildByPreAndInOrder(char *prelist, char *inlist, int len, BiTree *bt){ if(!prelist || !inlist || len&lt;=0 ) //空树 return; int i; // 找到根结点在中序遍历中的位置 for(i = 0; i &lt; len; i++){ if(inlist[i] == prelist[0]) break; } if(i&gt;=len) return; // 初始化根结点 *bt = (BiTNode*)malloc(sizeof(BiTNode)); if(!bt) // 申请失败 return; (*bt)-&gt;LChild = (*bt)-&gt;RChild = NULL; (*bt)-&gt;elem = prelist[0]; // 重建左子树 ReBuildByPreAndInOrder(prelist+1, inlist, i, &amp;(*bt)-&gt;LChild); // 重建右子树 ReBuildByPreAndInOrder(prelist+i+1, inlist+i+1, len-i-1, &amp;(*bt)-&gt;RChild);}// 中序+后序重建二叉树void ReBuildByInAndPostOrder(char *inlist,char *postlist, int len, BiTree *bt){ if(!inlist || !postlist || len&lt;=0 ) //空树 return; int i; // 找到根结点在中序遍历中的位置 for(i = 0; i &lt; len; i++){ if(inlist[i] == postlist[len-1]) break; } if(i&gt;=len) return; // 初始化根结点 *bt = (BiTNode*)malloc(sizeof(BiTNode)); if(!bt) return; (*bt)-&gt;LChild = (*bt)-&gt;RChild = NULL; (*bt)-&gt;elem = postlist[len-1]; //重建左子树 ReBuildByInAndPostOrder(inlist, postlist, i, &amp;(*bt)-&gt;LChild); //重建右子树 ReBuildByInAndPostOrder(inlist+i+1, postlist+i, len-i-1, &amp;(*bt)-&gt;RChild);}void PrintTree(BiTree bt,int nLayer){ int i; if(bt==NULL) return; PrintTree(bt-&gt;RChild,nLayer+1); for(i=0;i&lt;nLayer;i++) printf(\" \"); printf(\"%c\\n\", bt-&gt;elem); PrintTree(bt-&gt;LChild,nLayer+1);}void main(){ char pre[7]={'A', 'B', 'D', 'E', 'C', 'F', 'G'}, inorder1[7] = {'D', 'B', 'E', 'A', 'F', 'C', 'G'}, inorder2[9] = {'G', 'D', 'H', 'B', 'A', 'E', 'C', 'I', 'F'}, post[9] = {'G', 'H', 'D', 'B', 'E', 'I', 'F', 'C', 'A'}; int i=0; /* 前序+中序重建二叉树 */ printf(\"Give the preorder and midorder traversal of a binary tree: \\nPreorder = \"); for(i=0; i&lt;7; i++){ printf(\"%c \", pre[i]); } printf(\"\\nMidorder = \"); for(i=0; i&lt;7; i++){ printf(\"%c \", inorder1[i]); } BiTree T1=NULL; ReBuildByPreAndInOrder(pre, inorder1, 7, &amp;T1); printf(\"\\nThe binary tree constructed by two traversal sequences is: \\n\"); PrintTree(T1, 1); /* 前序+中序重建二叉树 */ /* 中序+后序重建二叉树 */ printf(\"Give the midorder and postorder traversal of a binary tree: \\nMidorder = \"); for(i=0; i&lt;9; i++){ printf(\"%c \", inorder2[i]); } printf(\"\\nPostorder = \"); for(i=0; i&lt;9; i++){ printf(\"%c \", post[i]); } BiTree T2=NULL; ReBuildByInAndPostOrder(inorder2, post, 9, &amp;T2); printf(\"\\nThe binary tree constructed by two traversal sequences is: \\n\"); PrintTree(T2, 1); /* 中序+后序重建二叉树 */ system(\"pause\");} 1.3 运行情况截图 题目2123求二叉树中值为x的节点所在的层号。二叉树bt采用二叉链表存储；设计一个算法level（bt,x）求二叉树中值为x的节点所在的层号 2.1 算法设计思想 在求二叉树深度算法的基础上改进算法；在含有目标节点的子树上查找，到达目标节点即结束递归 2.2 源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 算法1int layer(BiTree bt, char x){ int cot = 0; if(bt==NULL) return cot; else if(bt-&gt;elem==x){ cot = 1; return cot; } else{ // printf(\"layer(bt-&gt;LChild, x): %d\\n\", layer(bt-&gt;LChild, x)); if(layer(bt-&gt;LChild, x)){ cot = layer(bt-&gt;LChild, x)+1; return cot; } // printf(\"layer(bt-&gt;RChild, x): %d\\n\", layer(bt-&gt;RChild, x)); if(layer(bt-&gt;RChild, x)){ cot = layer(bt-&gt;RChild, x)+1; return cot; } } return cot;}// 算法2int find_node_level(BiTree bt, char x, int h){ if (bt == NULL) return 0; else if (bt-&gt;elem == x) return h; else{ int l = find_node_level(bt-&gt;LChild, x, h+1); if (l != 0) return l; else return find_node_level(bt-&gt;RChild, x, h+1); }}// 算法3void level_in_x(BiTree BT,char x,int level){ if (BT == NULL){ return ; } if(BT-&gt;elem == x){ printf(\"x in %d\",level); } level++; printf(\"1:%d----\\n\", level); level_in_x(BT-&gt;LChild,x,level); printf(\"2:%d----\\n\", level); level_in_x(BT-&gt;RChild,x,level); printf(\"3:%d----\\n\", level); level--;} 2.3 运行情况截图 题目3123求二叉树的宽度。利用二叉树层次遍历求二叉树的宽度；二叉树的宽度即二叉树同层结点数的最大值 3.1 算法设计思想 我利用一个足够大的全局数组来记录遍历过程中的二叉树宽度；利用一个变量max来记录最大宽度，即为所求；求宽度的函数依然采用的是先序遍历递归的思想，加一个形参k，对应width数组下标，记录当前深度，来传给子层信息；如果当前深度k的节点不为空，那么width[k]++，来记录宽度；max为宽度最大值 3.2 源代码 1234567891011121314#define size 100int width[size];int max=0;void MaxWidth(BiTree T,int k){ if(T==NULL) return; width[k]++; if(max&lt;width[k]) max=width[k]; MaxWidth(T-&gt;LChild, k+1); MaxWidth(T-&gt;RChild, k+1);} 3.3 运行情况截图 题目412345678二叉树bt采用二叉链表存储，设计算法实现采用括号表示法输出该二叉树。 A / \\ B C / / \\ D E F \\ G A(B(D(,G)),C(E,F)) 4.1 算法设计思想 把题目中的括号表示法A(B(D(,G)),C(E,F))，去掉括号变为：ABDGCEF这种写法不是我们熟悉的先序遍历吗！所以我就在二叉树先序遍历算法的基础上改进算法； a.在节点的左右子树不为空时输出“（”；b.当节点右子树不为空时输出“，”；c.在节点的左右子树不为空时输出“）” 4.2 源代码 12345678910111213void Brackets(BiTree T){ if (T==NULL) return; printf(\"%c\", T-&gt;elem); if(T-&gt;LChild!=NULL||T-&gt;RChild!=NULL) printf(\"( \"); Brackets(T-&gt;LChild); if(T-&gt;RChild!=NULL) printf(\", \", T-&gt;elem); Brackets(T-&gt;RChild); if(T-&gt;LChild!=NULL||T-&gt;RChild!=NULL) printf(\" )\");} 4.3 运行情况截图 题目51234求二叉树的路径长度。二叉树二叉链表存储二叉树的路径长度即：二叉树中所有结点的路径长度之和。（结点的路径长度即：从根到结点的分支数） 5.1 算法设计思想 路径长度即为分支数之和；根据二叉树的性质；每个节点的头部都有一个分支，除了根节点；所以分支数之和就是二叉树节点数-1；那么采用递归的方法求得节点数，就可以求得路劲长度了 5.2 源代码 123456789int Node(BiTree T){ if (T==NULL) return 0; else{ return 1 + Node(T-&gt;LChild) + Node(T-&gt;RChild); }}printf(\"The path length of this binary tree is: %d\\n\", Node(T)-1); 5.3 运行情况截图","link":"/2020/06/23/DS/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E4%B9%9D/"},{"title":"数据结构进阶实训一 位运算，优化算法","text":"Data structure advanced training course notes and algorithm exercises 数据结构进阶实训课程笔记和算法练习 Source Code: https://github.com/MysticalGuest/DataStructure/tree/master/AdvancedJuniorTraining 题目112对于一个字节（8bit)的无符号整型变量求其二进制表示中“1”的个数。要求算法的执行效率尽可能高。 1.1 算法设计思想 用户直接输入一个8位无符号整型常数，并进行用户输入的校验，如果不满足条件，提示用户重新输入，直到输入正确； 将十进制转换为二进制； 持续下面循环8次： 将二进制数模2，结果为1，计数器加1，然后二进制数右移一位； 循环结束，1的个数为计数器值。 1.2 源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;conio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;void main(){ printf(\"Please enter an 8-bit unsigned integer constant:\"); char array[8]; scanf(\"%s\", array); int len = strlen(array); // 判断用户输入是否是8位无符号整型常量 // 并判断用户输入是否为二进制 // 如果长度不为8,或不是二进制数,则重新输入 while(len!=8 || strspn(array, \"01\")!=len){ printf(\"Your input does not meet the conditions!\\n \\ Please enter an 8-bit unsigned integer constant as required:\"); scanf(\"%s\", array); len = strlen(array); } int arrayToInt = strtol(array, NULL, 2); //十进制转二进制函数的声明 int transfer(int x); int i=0, num=0; for(i; i&lt;len; i++){ if(transfer(arrayToInt)%2 == 1) num++; arrayToInt=arrayToInt&gt;&gt;1; } printf(\"The number of \\\"1\\\" in its binary representation is: %d.\\n\", num); printf(\"The program will continue to run, press any key to close it.\"); getch();}int transfer(int x){ int i=0; int binary = 0b0; for(i ; i&lt;x ; i++){ binary++; } return binary;} 1.3 运行情况截图 题目21给定一个整数N，N！末尾会有多少个0呢？编写算法计算给定的N！末尾有多少个0？ 2.1 算法设计思想 一个数的阶乘末尾有多少0，即判断这个数除以10的余数是否为0，如果为0，则末尾是0。 2.2 源代码 1234567while(factorial&gt;0){ if(factorial%10==0) numOfZero++; else break; factorial = factorial / 10;} 2.3 运行情况截图 题目31求N!的二进制表示中最低位的1的位置。 3.1 算法设计思想 初始化计数器为0； 先把n!化为二进制表示的形式，再把其二进制形式模2，如果结果为0，将其二进制形式右移一位，并且计数器加1； 循环上面的操作，直到模2结果为1，结束循环，计数器即为最后结果。 3.2 源代码 1234567891011121314151617181920212223242526int convert(int x){ // 十进制转二进制 int binary=0b0, i=0; for(i; i&lt;x; i++){ binary++; } return binary;}void main(){ int n,factorial=1, i=1, numOfZero=0; printf(\"Please enter an integer and the program will calculate its factorial:\"); scanf(\"%d\", &amp;n); for(i ; i&lt;=n; i++){ // 求阶乘 factorial *= i; } printf(\"The factorial of n is %d\\n\", factorial); int binary = convert(factorial); while(1){ // 求位置 numOfZero++; if(binary%2==1) break; binary = binary&gt;&gt;1; } printf(\"When representing n! In binary, \\ the position of the lowest bit 1 is (from right to left): %d\\n\", numOfZero);} 3.3 运行情况截图 题目41对于一个由N个整数组成的数组，设计算法（程序），求出该数组中的最大值和最小值。 4.1 算法设计思想 先判断数组的前两个值，将小的赋给min，将大的赋给max； 循环从数组的下标2开始，将数组下标为2的值记为num，如果num小于min，则将num赋值给min，反之则不变； 如果num大于max，则将num赋值给max，反之则不变； 直到循环结束，max则为最大值，min为最小值。 4.2 源代码 123456789101112131415161718192021222324252627void main(){ int random, num[20], i=0, max, min; printf(\"Give an array of 20 integers:\\n\"); for(i; i&lt;20; i++){ // 使用随机数初始化数组 random = rand()%100; num[i] = random; printf(\"%d \", num[i]); } if(num[0]&lt;num[1]){ max=num[1]; min=num[0]; } else{ max=num[0]; min=num[1]; } i=2; // 从2开始比较 for(i; i&lt;20; i++){ if(num[i]&gt;max) max=num[i]; if(num[i]&lt;min) min=num[i]; } printf(\"\\nThe maximum value of the array is: %d\", max); printf(\"\\nThe minimum value of the array is: %d\\n\", min); system(\"pause\");} 4.3 运行情况截图 题目51快速找出一个数组中所有满足条件的的两个数。（条件：这两个数的和等于一个给定的值sum.）。 5.1 算法设计思想 从第1个数开始循环与后面的数相加，判断结果如果等于给定值sum就输出这两个值； 然后从第2个数开始循环与后面的数相加，以此循环直到把数组遍历完。 5.2 源代码 123456789101112131415161718192021void main(){ int sum=100 int num[20]={41, 67, 34, 0, 69, 24, 78, 58, 62, 64, 5, 45, 81, 27, 61, 91, 95, 42, 27, 36}; printf(\"Give an array of 20 integers:\\n\"); int i=0, j; for(i; i&lt;20; i++){ printf(\"%d \", num[i]); } printf(\"\\n\"); i=0; for(i; i&lt;20; i++){ int add=num[i]; j= i+1; for(j; j&lt;20; j++){ if(add+num[j]==sum){ printf(\"The sum of the two numbers found is 100, which are: %d and %d.\\n\", add, num[j]); } } } system(\"pause\");} 5.3 运行情况截图","link":"/2020/05/19/DS/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E4%B8%80/"},{"title":"数据结构进阶实训八 数组，规律","text":"Data structure advanced training course notes and algorithm exercises Source Code: https://github.com/MysticalGuest/DataStructure/tree/master/AdvancedJuniorTraining 题目1123荷兰国旗现有n个红蓝白三种不同颜色的小球，乱序排列在一起；请通过两两交换任意两个球，使得从左到右的球依次：红球、白球、蓝球 1.1 算法设计思想 把题目理解为这样的问题：一个循环，把红色球和剩余的球交换，那么红球就排序好了，就是两两交换问题；另一个循环，把剩下没排序好的白球和蓝球也排序好，也是两两交换；程序的时间复杂度取决于长度取决于第一个循环，O(n) 1.2 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#define RED 0#define WHITE 1#define BLUE 2void swap(int *p, int *q){ int temp; temp = *p; *p = *q; *q = temp;}void sort(int array[], int start, int end, int collor){ int i=start, j=end; while(i &lt; j){ while(array[i]==collor){ i++; } while(array[j]!=collor){ j--; } swap(&amp;array[i], &amp;array[j]); i++; }}void main(){ int ball[20]={1,2,2,0,1,0,1,2,0,0,0,1,2,1,0,1,2,0,0,1}; int i, num_red=0; printf(\"There are 20 red, blue and white balls in three different colors, \\ arranged together in disorder:\\n\"); for(i=0; i&lt;20; i++){ if(ball[i]==RED){ num_red++; printf(\"Red \"); } if(ball[i]==WHITE) printf(\"White \"); if(ball[i]==BLUE) printf(\"Blue \"); } printf(\"\\n\"); sort(ball, 0, 20, RED); // 把红色球排好序 sort(ball, num_red, 20, WHITE); // 把白色球排好序 printf(\"\\nAfter sorting: \\n\"); for(i=0; i&lt;20; i++){ if(ball[i]==RED) printf(\"Red \"); if(ball[i]==WHITE) printf(\"White \"); if(ball[i]==BLUE) printf(\"Blue \"); } printf(\"\\n\");} 1.3 运行情况截图 题目21234完美洗牌算法有一个长度为2n的数组{a1,a2,a3,…an,b1,b2,b3, …bn},希望“排序”后，变为{a1, b1, a2, b2, a3, b3,…an, bn}。要求：尽可能高效。能否在时间复杂度为O(n)，空间复杂度为O（1）的解法 2.1 算法设计思想 依次考察每个位置的变化规律a1: 0 -&gt; 不变a2: 1 -&gt; 2a3: 2 -&gt; 4a4: 3 -&gt; 6…an: n-1 -&gt; 2n-2b1: n -&gt; 1b2: n+1 -&gt; 3b3: n+2 -&gt; 5…bn-1: 2n-2 -&gt; 2n-3bn: 2n-1 -&gt; 不变可以得出下标的变化规律：j=(i * 2) % (n2 -1)所以将值赋给辅助数组即可 2.2 源代码 1234567891011void perfect_shuffle(char *a[],int n) { int n2 = n * 2, i, j; char *b[20]; for (i = 1; i &lt; n2-1; i++) { j=(i * 2) % (n2 -1); b[j] = a[i]; } for (i = 1; i &lt; n2-1; i++) { a[i] = b[i]; }} 2.3 运行情况截图 题目312345买票找零问题在一场激烈的球赛开始之前，售票工作正在紧张地进行中，每张球票为50元。现有2n个人排队购票，其中有n个人手持50元的钞票，另外的n个人手持100元的钞票，假设开始售票时，售票处没有零钱。要求：问这2n个人有多少种排队方式，不至于使售票处出现找不开钱的局面呢 3.1 算法设计思想 找规律递推的方法；要求持50元n人，100元n人，多少种排队方式，那么排在最后的一定是持100元的人，所以和持50元n人，100元n-1人的排队方式相同；发现规律，持50元n-1人，100元n-1人和持50元n-1人，100元n-2人的排队方式相同；所以这就可以从最小的1开始求了，然后累加到n，得到最后结果 3.2 源代码 123456789101112131415161718#define N 100int arrange(int n){ int array[N][N]; int i, j; // 当100元和50元人数不相等，100元0人，则只有1中解决方案 for(i=0; i&lt;n; i++){ array[i][0]=1; } // 若50元人数小于100元人数，则没有解决方案 // 则二维数组的上三角的值都为0，不用初始化赋值 // 开始递推，填满下三角矩阵数组 for(i=1; i&lt;=n; i++){ for(j=0; j&lt;=i; j++) array[i][j]=array[i-1][j]+array[i][j-1]; } return array[n][n];} 3.3 运行情况截图","link":"/2020/06/21/DS/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E5%85%AB/"},{"title":"电子商务课程复习","text":"第1章 计算机、Internet与Visual C#简介 课后习题1.1 填空题 计算机只能直接理解其本身的机器语言，这种语言是由1和0构成的。 计算机处理数据时由一组指令控制，这组指令称为计算机程序。 本章介绍的3种语言是机器语言、汇编语言和高级语言。 将高级语言程序变成机器语言程序称为编译器。 Visual Studio是开发C#程序的集成开发环境（IDE）。 C语言是作为UNIX操作系统的开发语言而著称的。 Web服务分别用XML和SOAP在Internet上标记和发送消息。 2.2 判断题（更正过的） UML主要用于设计面向对象系统。 C#是面向对象语言。 C#是多个.NET语言之一（还有Visual Basic与Visual C++）。 面向对象编程（针对事情）是比过程式编程更自然的建模方式。 计算机只能直接理解其机器语言。 MSIL是公共中间格式，不管原.NET语言是什么，所有.NET程序都要编译成这种格式。 .NET框架可以移植到非Windows平台 第2章 Visual C# 2008 Express简介课后习题2.1 填空题 可视化编程技术可以创建GUI而不用编写任何代码。 方案是一个或多个工程，一起形成Visual C#程序。 自动隐藏特性在鼠标指针移到窗口区外时隐藏窗口。 工具提示在鼠标指针放到图标上时显示。 Solution Explorer窗口可以浏览方案文件。 加号框表示Solution Explorer中的树可以展开。 属性窗口的属性按字母顺序或类别排序 窗体的Text属性指定窗体标题栏中显示的文本。 工具栏可以直观地将控件加进窗体中。 用动态帮助根据当前上下文显示相关帮助文章。 TextAlign属性指定文本在卷标边界中的对齐方式。 2.2 判断题（更正过的） 标题栏显示IDE的方式。 图钉图标切换，自动隐藏，而X框关闭窗口。 工具栏图标表示各种菜单命令。 工具箱包括表示控件的图标。 窗体有标题栏，卷标没有（但有卷标文本）。 控制属性可以用属性窗口修改。 图形框通常显示图形。 Visual C#文件扩展名为.cs。 窗体背景颜色用BackColor属性设置。 第3章 C#程序简介简单程序： 12345678910111213//console.WriteLine()和console.Write()区别在于最后是否有换行。using System;public class Welcome { public static void Main(string[] args) { Console.WriteLine(\"Hello world!\"); //使用formating Console.WriteLine(\"{0}\\n{1}\",\"Welcome to\", \"C# Programming!\"); //读入加转换 Convert.ToInt32(Console.ReadLine()); //输出指定长度,如果需要在左侧则使用{0，-20}表示 Console.WriteLine(\"{0,4}{1,20:C}\", year, acc ount); }} 课后习题3.1 填空题 左花括号（ { ）开始方法体，右花括号（ } ）结束方法体。 每条语句以分号结束。 if是决策语句。 单行注释以//开始。 空行、空格和制表符称为空白符，新行符也是空白符。 关键字保留给C#使用。 C#程序从Main方法开始执行。 方法Console.WriteLine()和Console.Write()在控制台窗口显示信息。 3.2 判断题（更正过的） 注释不在程序执行时导致操作，而是建档程序和改进其可读性。 C#是大小写相关的，所以number和NuMbEr是不同变量。 求余运算符（%）也可以在C#中处理非整数算子。 *、/和%同一优先级，而+和-低一级。 第4章 类与对象简介Main是个特殊方法，在程序执行时自动调用，但大多数方法并不自动调用。 习惯上，方法名从大写字母开始，后续单词首字母大写。 get和set方法的使用： 1234567891011121314151617181920212223242526272829303132using System;public class GradeBook{ private string courseName; public GradeBook(string name) { CourseName = name; } // 之后直接使用CourseName获取到其变量 public string CourseName { get { return courseName; } set { courseName = value } } /*更好的get和set方法： *public string CourseName{get; set;} *称为：自实现属性 *直接写出来，声明+实现一起出现 */ public void DisplayMessage() { Console.WriteLine(\"Hello\\n{0}\", CourseName) }} Main方法 12345678using System;public class GradeBookTest{ public static void Main(String[] args) { GradeBook myGradeBook = new GradeBook(); }} 让Main方法执行程序的关键部分是static关键字，表示这个Main方法是静态方法，调用是不必先创建这个类的对象。 可以在需要时声明新的类类型，因此C#称为可扩展语言。 关于using指令注意上面的程序，这个指令告诉编译器程序使用System名字空间中的类，如Console类。默认情况下，GradeBook类和GradeBookTest类在相同名字空间，一个类使用同一名字空间的另一个类，不需要using指令。 没有显式放进一个名字空间的类隐式放进全局名字空口。 实际上也可以不用using指令，使用类的完全限定类名，包括完全名字空间和类名，System.Console.WriteLine(); GradeBook类带实例变量与属性GradeBook类的每个实例包含每个实例变量的一个副本。 访问修饰符public与private用private声明的变量与方法只能在声明这个方法的类中访问。 用private声明的实例变量称为信息隐藏。在GradeBook类中，属性CourseName操纵实例变量courseName。 设置与读取专用实例变量、属性属性（Property） 是类（class）、结构（structure）和接口（interface）的命名（named）成员。类或结构中的成员变量或方法称为 域（Field）。属性（Property）是域（Field）的扩展，且可使用相同的语法来访问。它们使用 访问器（accessors） 让私有域的值可被读写或操作。 尽管可以定义get和set方法，但C#属性更方便。 上面程序GradeBook类中的CourseName就是属性。属性声明可以有get访问函数、set访问函数或两者皆有。 定义属性后，可以在代码中像变量一样使用。可以用赋值运算符对属性赋值，其执行属性set函数代码。 get和set访问方法1String name = gradeBook.CourseName; 用户不能直接操纵实例变量courseName，因为它是专用的。 1gradeBook.CourseBook = \"OS\"; 这时文本“OS”传入隐式参数value，执行set访问方法。注意value在set访问方法中隐式声明和初始化，在set方法体中声明局部变量value会发生编译错误。set方法完成任务后不返回任何数据。 声明顺序不做要求。 在公用属性中，get方法可以是公用的，set方法可以是专用的。 值类型与引用类型C#语言的类型分为两类——值类型与引用类型。C#的简单类型都是值类型。值类型的变量（如int）只包含这个类型的值。例如：int count = 7表示：int类型的变量count，只能包含像7这样的整数。 引用类型的变量（也称为引用）包含存储变量所引用数据的内存地址。这个变量在程序中称为引用一个对象。即引用类型（GradeBook）的变量（gradeBook）包含该类型对象的引用（内存地址）。 引用类型实例变量默认初始化为null。string是个引用类型实例变量。 值为null的字符串变量不是空串。空串表示””或string.Empty。null表示引用的不是对象。空串是不含字符的string对象。 用构造函数初始化对象默认情况下，编译器在没有显式提供构造函数的类中提供一个没有变元的默认构造方法，因此任何类都有函数。默认构造方法不修改实例变量的默认值。如果声明类的任何构造函数，则C#不对这个类创建默认构造函数。 构造函数名必须与类名相同。与方法不同，构造函数不指定返回类型（连void也没有）。 浮点数与decimal类型float、double和decimal可以在内存中存储实数。float和double类型称为浮点类型，它们与decimal的主要区别在于：decimal变量精确存储有限范围的实数，而浮点数只存储实数的近似值，但取值范围大得多。 简单类型 有效位 float 单精度浮点数 7 double 双精度浮点数 15~16 精度是float的2倍 decimal 28~29 7.33M或7.33m 需要double变量2倍内存 整数直接赋值给上面3种类型，隐式转换成这些类型。 格式项{0:C}将数据格式化为金额值：$3.3 课后习题4.1 填空题 房子的蓝图就像对象的类。 运算符new创建关键字右边所指定的对象。 默认情况下，没有显式在名字空间中声明的类隐式放在全局名字空间。 类的每个对象维护属性复制时，表示属性的字段也称为实例变量。 Convert方法ToDecimal返回decimal值。 Console方法ReadLine读取字符，直到遇到新行符，然后用string返回这些字符（不包含新行符）。 对于自实现属性，编译器自动生成专用实例变量及其get与set方法。 4.2 判断题 方法和属性体用左右花括号定界。 实例变量默认初始化，局部变量不是。 源代码中的实数值称为浮点数直接输，默认类型为float。 第5章 控制语句：第一部分算法解决问题的过程（procedure）称为算法（algorithm），包括： 执行的操作（action） 执行的操作的顺序（order） 伪代码伪代码是人为的非正式语言，帮助程序员开发算法。 控制结构程序中的语句按编写的顺序一条一条地执行，称为顺序执行。 指定下一个执行的语句不是紧邻其后的语句，这称为控制转移。 结构化编程更清晰、更易调试与修改并且不容易出错。 研究表明，所有程序都可以只用三种控制结构，即顺序结构、选择结构和重复结构。 顺序结构是C#内置的，除非另外指定，计算机总是按编写的顺序一条一条地执行。 选择结构有三种，称为选择语句。 if语句称为单选择语句，if…else语句称为双选择语句，switch语句称为多选择语句。 C#提供四种重复结构，称为重复语句（也称为迭代语句或循环），重复语句有while、do…while、for与foreach。 控制语句小结：C#只有三种控制语句，分别是顺序结构、选择结构（三种）和重复语句（四种）。 C#提供条件运算符（? :），可以代替if…else语句。是C#中唯一的三元运算符（ternary operator），操作数和条件运算符一起形成条件表达式（conditional expression）。 垂悬else问题：C#编译器总是将else与最接近的if相关联，除非用花括号指定。（就近原则） 放在花括号中的一组语句称为块。 简单类型间的显式和隐式转换 123double average;int total,gradeCounter;average = (double)total / gradeCounter; 这里使用double类型转换符称为显式转换，这是的计算式浮点数除以整数，要保证操作数的数据类型一致，C#将int操作数提升为double（提升操作，也称为隐式转换）。 C#支持复合赋值运算符 分别为：+=，-=，*=，/=和%= 也支持自增自减，前置和后置 C#也是强类型语言，即要求所有变量都具有类型。 课后习题5.1 填空题 将一组指令重复特定次数称为计数器控制或确定重复。 事先不知道一组指令的重复次数，可以用标记（记号，标志或哑元）值终止重复。 5.2 判断题 指定计算机程序执行语句的顺序称为程序控制。 第6章 控制语句：第二部分for循环语句 1234for( int counter = 1; counter &lt;= 10; counter++, total += counter ){ statement/empty statement;} switch多选择语句 12345678910switch(grade / 10){ case 9: case 10: ++aCount; break; default: ++bCount; break;} break语句 continue语句在循环结构中执行时跳过该结构体的其余语句，进入下一轮循环。 逻辑运算符有&amp;&amp;（条件与）、||（条件或）、&amp;（布尔逻辑与）、|（布尔逻辑或）、^（布尔逻辑异或）和!（逻辑非）。 只有逻辑非是一元运算符。 短路求值： 1(gender == 'F') &amp;&amp; (++age &gt;= 65) 将在gender不等于“F”时立即停止（整个表达式为假）。 布尔逻辑（&amp;和|）不进行短路求值，所以如果用布尔表达式++age&gt;=会执行，age值会发生改变。 课后习题6.1 填空题 通常，for语句用于计数器控制循环，while语句用于标记控制循环。 6.2 判断题 switch选择结构的每个case中可以使用break语句退出当前case结构，也可以使用return语句。 第7章 方法详述分治法（divide and conquer）：经验表明，要开发和维护大程序，最好的办法是从更容易管理的小块和小组件开始。 C#代码包装代码包装的三种常见途径是方法、类和名字空间。 方法（函数、过程）可以将程序模块化，用户定义方法。分治，复用。 静态方法，静态变量和Math类所有Math方法都是静态的。 1Console.WriteLine( Math.Sqrt( a + b * c ) ) 静态常量 12Math.PIMath.E 这些变量在Math类中声明，修饰符为public与const。任何用关键字const声明的变量都是常量，声明之后不能改变数值。 前面提到，属性的变量也称为实例变量，类的每个对象在内存中有这个变量的不同实例。但静态变量，类的每个对象在内存中没有这个变量的不同实例。类的对象包含静态变量时，这个类的所有对象共享静态变量的同一备份。 为什么Main方法声明为static？ 123public static void Main(string args[]){ ...} Main方法声明为static是执行环境可以调用Main方法而不必创建类的实例。 string args[]可以省略，public也可以省略，void也可替换为int 用字符串接合组装字符串 C#中生成string对象时可以用运算符+（或复合赋值运算符+=）将小字符串组装成大字符串。 12double result = 9.35000;Console.WriteLine(\"Maximum is: \" + result); 控制台输出为：Maximum is: 9.35 布尔值也会隐式转换成string。 关于方法的声明与使用可以用三种方式调用方法。 方法调用堆栈云激活记录堆栈是后进先出（LIFO）数据结构。 程序调用方法是，被调的方法要知道如何放回调用者，因此把调用者的返回地址压入程序执行堆栈（也称方法调用堆栈）。 程序执行堆栈还包含程序执行期间每个方法调用使用的局部变量。这个数据存放成程序执行堆栈的一部分，称为方法调用的激活记录( activation record)或堆栈帧( stack frame)。进行方法调用时，这个方法调用的激活记录压进程序执行堆栈。方法返回调用者时，这个方法调用的激活记录出栈，程序不再知道这些局部变量。如果局部变量保存对象引用，是具有该对象引用的程序中唯一变量，则包含这个局部变量的激活记录出栈时，程序不能再访问这个对象，最终会在“内存回收”时从内存中删除。当然，计算机的内存量有限,因此只能用一定量的内存存储程序执行堆栈中的激活记录。如果发生的方法调用太多，程序执行堆栈无法存储其激活记录,则会发生堆栈溢出错误。 变元提升与类型转换方法调用的另一个重要特性是变元提升——隐式地将变元值变成方法参数所需要的类型。 1Console.WriteLine( Math.Sqrt( 4 ) ); 虽然Sqrt方法要求double变元，但也可以使用整型值，打印数值2.0。方法声明的参数表使C#将int值4转换成double值4.0，然后传入Sqrt方法。 隐式转换要求满足升级规则，否则必须显式转换。 所有简单类型都可以隐式转换为object类型。 .NET框架类库许多预定义类组成相关类的名字空间。名字空间组成.NET框架类库（即FCL）。 1using System; 程序可以使用System名字空间的类名，不必用完全限定名。 C#的一个强大之处是FCL的名字空间中有许多类。 随机数生成可以用随机数生成器对象产生随机byte、int与double值。 123456789Random randomNumbers = new Random();// Next方法产生值：0&lt;=randomValue&lt;=+2147483646int randomValue = randomNumber.Next();// 返回0、1、2、3、4、5。变元6称为比例因子，表示Next要产生的数值的个数int randomValue = randomNumber.Next( 6 );// 返回1、2、3、4、5、6int randomValue = 1 + randomNumber.Next( 6 );// 返回1、2、3、4、5、6int randomValue = randomNumber.Next( 1, 7 ); Next返回的值实际上是伪随机数——通过复杂数学计算产生的数值序列。用当前时间作为种子。 比例缩放与移动随机数12返回2、5、8、11、14int number = 2 + 3 * randomNumber.Next( 5 ) 随机数可重复性与测试/调试要保证运行和调试是随机数一致 1Random randomNumbers = new Random( seedValue ); seedValue变元（int类型）提供随机数计算的种子。如果每次使用相同的seedValue，则Random对象产生相同的随机数列。 案例12345678private enum Status { CONTINUE, WON, LOST }private enum DiceNames{ SNAKE_EYES = 2, ... TREY = 3} 声明作用域 参数声明的作用域是声明所在的方法体。 局部变量声明的作用域从声明点开始，到声明所在块结束为此。 for语句首部初始化部分出现的局部变量声明的作用域是for语句体和首部的其他表达式。 类的方法、属性、字段的作用域是整个类体。这就使类的非静态方法与属性可以使用类的任何方法、属性、字段，不管声明顺序如何。同样，静态属性与方法可以使用类的任何静态成员。 方法重载一个类中可以声明同名方法，只要其参数集不同（参数个数、类型和顺序），称为方法重载。 区别重载方法 编译器根据签名区别重载方法，签名是方法名和参数个数、类型与顺序地组合。 重载方法的返回类型 123456789public int Square( int x ){ return x * x;}public double Square( int y ){ return y * y;} 上面2个方法签名相同，返回值类型不同，会产生编译错误。 递归12345678public static long Factorial( long number ){ // base case if(number &lt;= 1) return 1; else return number * Factorial( number -1 );} 按值与按引用传递变元参数声明中使用关键字ref可以按引用将变量传递给方法——被调方法可以修改调用者的原变量。ref关键字用于调用方法中已经初始化的变量。 在参数前面加上关键字out可以建立输出参数，告诉编译器这个变元按引用传入被调方法，被调方法对调用者的原变量赋值。如果方法中没有在每个执行路径上对输出参数赋值，则编译器报错。 一个方法只能通过return语句向调用者返回一个值，但指定多个输出参数（ref或out）可以返回多个值。 123456789101112131415161718public void ReferenceAndOutParameters(){ int y = 5; // initialize y to 5 int z; // declare z, but does not initilize it SquareRef(ref y); SquareOut(out z);}void SquareRef(ref int x){ x = x * x;}void SquareOut(out int x){ x = 10;} 课后习题7.1 填空题 数据只能从堆栈顶增加和取出。 将控制从被调方法返回调用者的三种方法是：return，return expression或方法右花括号处 程序执行堆栈包含程序执行期间每次调用方法时局部变量的内存。这个数据存放在程序执行堆栈中，称为方法调用的活动记录或堆栈顶。 第8章 数组前面说过，类型可以分为两类——值类型和引用类型。数组是引用类型。 我们通常意义上的数组实际上是内存中数组实例的引用。 数组的元素可以是值类型或引用类型。 123456789a=5;b=6;// 索引应为非负整数或整型表达式c[a + b] +=2;// 将元素c[11]加2// 用数组的Length属性确定数组长度// 注意数组的Length属性不能改变，因为它没有set方法c.Length 数组索引值应为int、uint、long、ulong类型或可以隐式升级为这些类型的值。 声明与创建数组 12345int[] array1 = new int[12];string[] array2;array2 = new string[12];// 每个元素接收默认值, 数组简单类型元素为0, 布尔元素为false, 引用为null 改变数组长度 虽然数组是定长实体，但可以用静态Array方法Resize改变数组长度。这个方法创建指定长度的新数组，将原数组内容复制到新数组，并将收到的变量设置为引用新数组的第一个。 12int[] array3 = new int[5];Array.Resize( ref array3, 10 ); 如果新数组比旧数组小，则后面的内容被截尾。 使用数组初始化器 逗号分隔的表达式清单（称为初始化清单），放在花括号中： 1int[] array4 = { 10, 20, 30, 40, 50}; 编译器遇到包括初始化清单的数组声明时，首先计算清单中的初始化器个数，确定数组长度，然后在“幕后”建立相应的new操作。 声明常量全部用大写字母。 用数组元素作为计数器 1234567891011121314151617using System;public class RollDie{ public static void Main( string[] args ) { Random randomNumbers = new Random(); int[] frequency = new int[ 7 ]; for(int roll = 1; roll &lt;= 6000; roll++) ++frequency[ randomNumber.Next(1, 7) ]; Console.writeLine(\"{0}{1, 10}\", \"Face\", \"Frequency\"); for(int face = 1; face &lt; frequency.Length; face++) Console.writeLine(\"{0, 4}{1, 10}\", face, frequency[face]); }} 运行结果： 1234567Face Frequency 1 956 2 981 3 1001 4 1030 5 1035 6 997 foreach语句 foreach语句只能访问数组元素，不能修改元素。否则编译错误。 隐式类型局部变量 C#提供了隐式类型局部变量特性，是编译器可以根据变量初始化值类型推出局部变量的类型。 123var 7; // 编译器推出变量x类型为int，因为编译器认为7之类的整数是int类型var -123.45; // doublevar array5 = new[] (32, 27, 64, 18, 95, 14); 将数组与数组元素传入方法 指定不带方括号的数组名。 12345678910// 方法声明void ModifyArray(double[] a){ ...}// 方法调用语句double[] array6 = new double[24];ModifyArray( array6 );// 接收double数组的引用, a与array6是相同对象 按值与按引用传递数组 C#中“存储”数组之类对象的变量并不实际存储对象本身，而是存储对象的引用（即存储对象的计算机内存地址）。 多维数组二维的多维数组也称为数值表，把信息放在行和列中。 c#支持两种二维数组——矩形数组和齿状数组。 矩形数组 1int[ , ] array7 = { {1, 2}, {3, 4} } 编译器在每行的初始化器个数不同时产生一个错误，因为矩形数组的每一行要长度相同。 齿状数组 12345int[][] jagged = { new int[] {1,2}, new int[] {3}, new int[] {4, 5, 6}}; 数组jagged本身是三个元素的数组，各引用一个int值的一维数组。 注意矩形数组与齿状数组的数组生成表达式差别。jagged数组后面是两组方括号，表示这是个int数组的数组。在数组初始化器中，C#要求用new关键字创建每一行的数组对象。 用数组生成表达式创建二维数组 123456789int[,] array8;array8 = new int[3, 4]; // 3行4列// 齿状数组不能如此int[][] array9 = new int[2][5]; // error// 而是int[][] a;a = new int[2][]; // 2行a[0] = new int[5];a[1] = new int[3]; 游长变元表（Variable-length argument lists） 可以创建接收任意个变元的方法。 一维数组型变元前面加上关键字params在方法参数表中，表示这个方法接收任意个变元，类型为数组元素类型。params修饰符的这个用法只能在参数表最后一个项目中出现。 12345678910111213141516171819public static double Average(params double[] numbers){ double total = 0.0; foreach(double d in numbers) total += d; return total / numbers.Length;}public static void Main(String[] args){ double d1 = 10.0; double d2 = 10.0; double d3 = 10.0; Console.WriteLine( Average(d1, d2) ); // 15.0 Console.WriteLine( Average(d1, d2, d3) ); // 20.0} 使用命令行变元 12345678910public class ArgTest{ public static void Main(String[] args) { if(args.Length == 0) Console.WriteLine(\"The number of arg is 0!\"); else foreach(var arg in args) Console.WriteLine(arg); }} 使用： 1234$ ArgTest.exe 1 2 3123 课后习题8.1 填空题 清单与数值表可以存放在数组中。 命令行变元存放在strings数组，通常称args中。 第9章 LINQ与泛型集合简介一组预包装数据结构——.NET框架集合类。 LINQ（language Integrated Query，语言集成查询表达式）。利用LINQ可以编写与SQL查询相识的查询表达式，从各种数据源，不限于数据库，还有数组和list驱动信息，选择符合一组条件的元素，称为筛选。 声明式编程：LINQ指定的不是读取结果所要的步骤，而是所选元素要满足的条件。 指定式编程：指定执行任务所有的步骤，面向对象是指示式编程的子集。 1234567891011121314151617181920212223242526272829303132333435363738394041using System;using System.Linq;using System.Collections.Generic;class LINQWithArray{ public static void Main(string[] args) { int[] values = {2, 9, 5, 0, 3, 7, 1, 4, 8, 5}; var filtered = from value in values where value &gt; 4 select value; Display(filtered); // 9 5 7 8 5 var sorted = from value in values orderby value select value; Display(sorted); // 0 1 2 3 4 5 7 8 9 var sortedAndfiltered = from value in values where value &gt; 4 orderby value // orderby value desending 都是降序 select value; // Display(sortedAndfiltered); // 9 8 7 5 5 } // IEnumerable&lt;int&gt;是个接口，描述的对象可迭代 public static void Display(IEnumerable&lt;int&gt; results) { foreach(var element in results) Console.WriteLine(\" {0}\", element); }} 用泛型方法显示LINQ查询结果 泛型方法，指定一个类型参数表。 1234567891011public static void Display&lt;T&gt;(IEnumerable&lt;T&gt; results){ foreach(T element in results) Console.WriteLine(element);}Employee[] employees;int[] array;Display(employees);Display(array); T是类型变元的占位符。调用泛型方法时，编译器根据调用中的变元指定每个类型表示的类型。 T可以在参数表和方法体中多次出现，也可以作为返回值。 集合简介.NET框架类库提供了几个类（称为集合），可以存储相关对象集合。 123456789101112using System;using System.Collection.Generic;public class ListCollection{ List&lt;string&gt; items = new List&lt;string&gt;(); items.Add(\"red\"); items.Insert(0, \"yellow\"); // yellow, red items.Add(\"yellow\"); // yellow, red, yellow items.Remove(\"yellow\"); // red, yellow} 用LINQ查询泛型集合12345678910111213141516171819202122232425262728293031using System;using System.Linq;using System.Collection.Generic;public class LINQListCollection{ List&lt;string&gt; items = new List&lt;string&gt;(); items.Add(\"aQua\"); items.Add(\"RusT\"); items.Add(\"yElLow\"); items.Add(\"rEd\"); // List&lt;string&gt; items = new List&lt;string&gt;{\"aQua\", \"RusT\", \"yElLow\", \"rEd\"}; var startWithR = from item in items let uppercasedString = item.ToUpper() where uppercasedString.StartsWith(\"R\") orderby uppercasedString select uppercasedString; foreach(var item in startWithR) Console.Write(\"{0} \", item); // RED RUST items.Add(\"rUby\"); items.Add(\"SaFfRon\"); foreach(var item in startWithR) Console.Write(\"{0} \", item); // RED RUBY RUST } 注意查询只创建一次，但对结果迭代得到两个不同的列表。这里演示了LINQ的延迟执行——查询只在访问结果时才执行，而不是在定义查询时执行。一次创建，多次执行，数据改变，返回结果。 课后习题9.1 填空题 集合类专门用于存储对象组和提供组织、存储与读取对象的方法。 第10章 再论类与对象1string.Format(\"{0:D2}:{1:D2}:{2:D2}\", hour, minute, second); Format()返回格式化字符串，而不是在控制台显示。 用this引用访问当前对象成员每个对象都可以用关键字this引用自己。调用特点对象的非静态方法时，方法体隐式用关键字this引用这个对象的实例变量和其他成员。 1234567891011121314151617181920public class SimpleTime{ private int hour; public SimpleTime(int hour) { this.hour = hour; } public string BuildString() { this.ToString(); ToString(); } public string ToString() { reutrn string.Format(\"0:D2\", this.hour); }} 索引器类可以用关键字this定义属性式的类成员，称为索引器，可以像数组一样用索引访问元素清单。索引器的好处是可以定义整数索引和非整数索引。 索引器在类中像属性一样定义，用关键字this定义，不能用static修饰。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Box{ private string[] names = {\"length\", \"width\", \"height\"}; private double[] dimensions = new double[3]; public Box(double length, double width, double heght) { dimensions[0] = length; dimensions[1] = width; dimensions[2] = height; } public double this[int index] { get { if( (index&lt;0) || (index&gt;=dimensions.Length) ) return -1; else return dimensions[index]; } set { if( (index&gt;=0) || (index&lt;dimensions.Length) ) dimensions[index] = vlaue; } } public double this[string name] { get { int i=0; while((i&lt;names.Length) &amp;&amp; (name.ToLower()!=names[i])) ++i; return (i == naems.Length) ? -1 : dimensions[i]; } set { int i=0; while((i&lt;names.Length) &amp;&amp; (name.ToLower()!=names[i])) ++i; if(i != names.Length) dimensions[i] = value; } }} BoxTest.cs 123456789101112131415public class BoxTest{ public static void Main(String[] args) { Box box = new Box(30, 30 ,30); // box[0] 30 // box[1] 30 // box[2] 30 box[0]=10; box[\"width\"]=20; // box[0] 10 // box[1] 20 // box[2] 30 }} 索引器可以重载。 重载构造函数12345678910111213141516171819202122232425262728293031323334353637383940public class Time{ private int hour; private int minute; public Time() : this(0, 0, 0){} public Time(int h) : this(h, 0, 0){} public Time(int h, int m) { SetTime(h ,m); } public Time(Time time) : this(time.Hour, time.Minute){} public SetTime(int h, int m) { Hour = h; Minute = m; } public int Hour { get { return hour; } // 这个类外不能使用set方法 private set { hour = ((value&gt;=0 &amp;&amp; value&lt;24) ? value : 0); } } public int Minute { ... }} 这里的this引用用法称为构造函数初始化器，易维护。 默认与无参数构造函数注意上面Time无参构造函数，显式初始化Time对象，为每个参数传递三个参数0。如果省略无参构造函数，则无法用表达式new Time()创建对象，会发生编译错误。 合成类可以引用其他类的对象，作为成员。这个功能称为合成，也称为“有”（has-a）关系。 Employee类中引用其他对象 123456public class Employee{ private Date birthDate; private Date hireDate; ...} 内存回收与析构函数Garbage Collection and Destructors 如果管理资源的对象失去所有引用，而还没有显式释放资源，则程序不能再访问和释放这个资源。这就产生了资源泄露。 公共语言运行环境（CLR）进行自动内存管理，用内存回收单元（Garbage Collection）释放对象不再需要的内存，其他对象可以使用这个内存。 对象失去所有引用时，成为可析构对象。每个对象有个特殊成员，称为析构函数。 析构函数由内存回收单元调用，在内存回收单元释放对象内存之前用于进行对象的终止整理工作。 静态类成员static Class Members 某些情况下，类的所有对象要共享某个变量的一个副本。这时就要使用静态变量。静态变量表示类信息，类的所有对象共享同一数据。静态变量的作用域是类体。 类的公用静态成员访问方法：类名和点号运算符Math.PI； 类的专用静态成员只能通过类的方法和属性访问。 如果没有Employee类的对象，则成员count任然可以引用，弹药通过静态属性Count，如Employee.CountC#的字符串对象创建后不能修改。 声明为静态的方法不能直接访问非静态类成员，因为即使类对象不存在，也可以调用静态方法。静态方法也不能使用this引用，this引用要引用特定类对象。 只读实例变量readonly Instance Variables C#提供了readonly关键字，可以指定对象的实例变量不能修改，想修改会发生错误。 构造函数可以多次对readonly实例变量赋值。 声明为const的成员要在编译时赋值，常量成员的值不能在编译时确定要用readonly关键字声明。如果构造函数不初始化readonly声明的成员，则编译器产生一个警告。 123456789public class Increment{ private readonly int INCREMENT; public Increment(int incrementValue) { INCREMENT = incrementValue; }} 软件复用性Software Reusability 类库，快速程序开发（RAD），FCL，CLR 数据抽象与封装Data Abstraction and Encapsulation 信息隐藏：类通常对类的客户隐藏其实现细节。 数据抽象：描述类的功能而不管其实现细节。 int、double与char类的类型，还有队列都是抽象数据类型（ADT）。抽象数据类型（ADT）实际上包含两个概念，即数据表达和该数据允许的操作。 internal Access目前为止我们所定义的类，只能用两个访问修饰符声明：public与internal。顶级类。C#支持嵌套类——定义在其他类中的类。除了public与internal，类还可以声明为private或protected。如果类声明没有访问修饰符，默认internal访问。声明为internal的方法。实例变量和其他成员可以让同一汇编中的所有代码访问，而其他汇编中的代码则不行。同一汇编中，internal相当于public。 Class View and Object Browser使用Class View窗口 使用Object Browser 对象初始化器Object Initializers 创建对象并在同一语句中将其属性初始化。 123456789class ObjectInitialzerTest{ static void Main(string[] args) { Time aTime = new Time{Hour=14, Minutre=145, Second=12}; Time anotherTime = new Time{Minute=45}; }} 代理delegate代理对象保存一个方法的引用。代理可以把方法看成数据，通过代理可以将方法赋值给一个变量，将这个方法与其他方法相互传递。 代理类型只是描述一组具有特定参数和特定返回类型的方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243using System;using System.Collections.Generic;class Delegates{ // 委托一个接收int并返回布尔值的函数 public delegate bool NumberPredicate(int number); static void Main(string[] args) { int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9 ,10}; // 创建NumberPredicate委托类型的实例 NumberPredicate evenPredicate = IsEven; List&lt;int&gt; evenNumbers = FilterArray(numbers, evenPredicate); // evenNumber: 2 4 6 8 10 List&lt;int&gt; oddNumbers = FilterArray(numbers, IsOdd); // oddNumber: 1 3 5 7 9 private static list&lt;int&gt; FilterArray(int[] intArray, NumberPredicate predicate) { List&lt;int&gt; result = new List&lt;int&gt;(); foreach(int item in inArray) { if(predicate(item)) result.Add(item); } return result; } private static bool IsEven(int number) { return (number%2 == 0); } private static bool IsOdd(int number) { return (number%2 == 1); } }} 由于IsEven方法的签名与NumberPredicate代理的签名匹配，因此可以用NumberPredicate类型的变量引用IsEven方法。 Lambda Expressionslambda表达式首先是个参数表。 123456789101112131415161718192021222324252627282930313233343536using System;using System.Collections.Generic;class Lambda{ public delegate bool NumberPredicate(int number); static void Main(string[] args) { int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9 ,10}; NumberPredicate evenPredicate = number =&gt; (number%2 == 0); evenPredicate(4); // True List&lt;int&gt; evenNumbers = FilterArray(numbers, evenPredicate); // evenNumber: 2 4 6 8 10 List&lt;int&gt; oddNumbers = FilterArray(numbers, (int number) =&gt; (number%2 == 1)); // evenNumber: 1 3 5 7 9 List&lt;int&gt; numberOver5 = FilterArray(numbers, number =&gt; {return number&gt;5; } ); // 6 7 8 9 10 private static list&lt;int&gt; FilterArray(int[] intArray, NumberPredicate predicate) { List&lt;int&gt; result = new List&lt;int&gt;(); foreach(int item in inArray) { if(predicate(item)) result.Add(item); } return result; } }} 参数表后面是lambda运算符（=&gt;，读作go to）和一个表示函数体的表达式。 没有指定返回类型，返回类型可以从返回值或代理的返回值推定。 同样，lambda表达式定义的方法要与代理类型定义的方法有相同签名。 匿名类型Anonymous Types可以创建简单类，用于存储数据，不必编写类定义。 匿名类型的属性都是公用和不可变的。匿名类型是只读的，创建对象之后不能修改属性值。 12345678910111213141516using System;using System.Collections.Generic;class Lambda{ public delegate bool NumberPredicate(int number); static void Main(string[] args) { var bob1 = new {Name = \"Bob Smith\", Age = 37}; bob.ToString(); // {Name = Bob Smith, Age = 37} var bob2 = new {Name = \"Bob Smith\", Age = 37}; bob1.Equals(bob2); // True // 两者属性值相同，声明顺序相同 }} LINQ中的匿名类型 123var names = from e in employees select new {e.FirstName, Last = e.LastName}; 课后习题10.1 填空题 最低权限原则要求代码只能分配完成指定任务所需的访问量。 编译器将类库工程监理在所谓动态链接库的汇编中。 10.2 判断题 lambda表达式必须返回一个值。 第11章 面向对象编程：继承基类和派生类Base Classes and Derived Classes 继承形成了树状层次结构。 并非每个类关系都是继承关系。“有”关系，类的成员是其他类对象的引用。 protected成员protected介于公用与专用之间，基类的protected成员可以让基类成员和派生类成员访问。所有非专用基类成员在派生类中保持原访问修饰符。 基类和派生类的关系C#中除object以外的每个类都扩展现有类。object是唯一没有基类的类。 123456789// CommissionEmployee类显式扩展（继承自）object类（FCL中的System.Object）public class CommissionEmployee : object{ ... public override string ToString() { ... }} 构造函数不继承，但隐式调用object类的构造函数。 1234567891011121314151617public class BaseCommissionEmployee : CommissionEmployee{ private decimal baseSalary; // 构造函数初始化器和关键字base调用基类构造函数 public BaseCommissionEmployee(string name, decimal sales, decimal salary): base(name, sales) { BaseSalary = salary; } public decimal BaseSalary{get; set} public virtual decimal Earnings() { ... }} 关键字virtual与abstract表示派生类中可以覆盖基类方法。 使用父类private实例变量 12345678public class BaseCommissionEmployee : CommissionEmployee{ ... public override decimal Earnings() { return BaseSalary + base.Earnings(); }} 派生类的构造函数Constructors in Derived Classes 派生类构造函数在执行自己的任务之前要显示（通过base引用和构造函数初始化器）或隐式（调用基类默认构造函数或无参构造函数）调用直接基类的构造函数。链中最后一个调用的构造函数总是object类的构造函数。 继承和软件工程Software Engineering with Inheritance Object类 第12章 多态、接口与运算符重载多态举例程序通过基类变量调用方法时，发生多态——执行时，根据引用对象的类型调用这个方法的正确派生类版本。 程序通过向下转换技术显式将基类引用转换为派生类类型，程序可以调用基类中没有的派生类方法。 123456789101112public class PolymorphismTest{ public static void Main(string[] args) { BaseCommissionEmployee baseCommissionEmployee = new BaseCommissionEmployee(\"Bob\", 5000, 300); CommissionEmployee commissionEmployee = baseCommissionEmployee; CommissionEmployee.ToString(); CommissionEmployee.Earnings(); }} 抽象类与方法定义不实例化为任何对象的类，抽象类。抽象基类。 抽象类用关键字abstract声明。抽象类通常包含一个或几个抽象方法。 抽象属性声明形式如下： 12345public abstract int property{ get; set;} 构造函数和静态方法不能声明为abstract。派生类不能覆盖静态方法。 不能实例化抽象基类的对象，但可以用抽象基类声明变量，保存这些抽象类派生的任何具体类的对象引用。程序通常用这种变量多态操纵派生类对象。可以用抽象基类名调用抽象基类中声明的静态方法。 as运算符进行向下转换 1var employee = currentEmployee as BaseCommissionEmployee; sealed方法与类基类中声明为sealed的方法不能在派生类中覆盖，声明为static和private的方法隐含sealed，因为派生类中不能覆盖（但派生类可以声明与基类中专用方法同名的新方法）。同时声明override与sealed的派生方法可以覆盖基类方法。 声明为sealed的类不能作为基类（不能扩展）。 创建与使用接口Creating and Using Interfaces 接口定义和标准化人与系统交互的方式。 软件对象也是通过接口通信。 所有接口成员隐式声明为public与abstract。 每个接口可以扩展一个或多个其他接口。 实现这个接口的具体类要声明接口中指定了签名的每个接口成员。实现接口而不实现其所有成员的类是个抽象类，要声明为abstract，每个未实现的接口成员要包含一个abstract声明。 和公用抽象类一样，接口通常为公用类型，因此通常在单独文件中声明，文件名与接口名相同，文件扩展名为.cs。 声明接口IPayable 12345// IPayable.cspublic interface IPayable{ decimal GetPaymentAmount();} 创建Invoice类 123456789// Invoice.cspublic class Invoice : IPayable{ ... public decimal GetPaymentAmount() { ... }} 修改Employee类，实现IPayable接口 1234567// Employee.cspublic abstract class Employee : IPayable{ public string Name {get; private set;} ... public abstract decimal GetPaymentAmount();} .NET框架类库公共接口 运算符重载使运算符适用于类对象，这个过程称为运算符重载。 123456789101112131415161718192021222324252627282930313233343536// ComplexNumber.cspublic class ComplexNumber{ public double Real {get; private set;} public double Imaginary {get; private set;} public ComplexNumber(double a, double b) { Real = a; Imaginary = b; } public override string ToString() { return string.Format( \"{0} {1} {2}i\", Real, (Imaginary &lt; 0 ? \"-\":\"+\"), Math.Abs(Imaginary)) } public static ComplexNumber operator +(ComplexNumber x, ComplexNumber y) { reutrn new ComplexNumber(x.Real+y.Real, x.Imaginary+y.Imaginary); }}// OperatorOverloading.cspublic class ComplexTest{ public static void Main(string[] args) { ComplexNumber x, y; x = new ComplexNumber(2, 4); y = new ComplexNumber(4, -2); x+y; // (2+4i)+(4-2i)=(6+2i) }} 第13章 异常处理异常就是程序执行期间发生的问题。 异常处理使应用程序能够解决异常。异常处理可实现清晰，健壮和更多容错的程序。 异常处理概述Exception Handling Overview 程序员可以决定处理任何异常——所有异常，某种类型的所有异常或相关类型的所有异常。 例子：除数为0不用异常处理其他信息（称为堆栈跟踪）显示异常名称和导致异常的执行路径。 堆栈跟踪中的每一行“ at”都表示发生异常时正在执行的特定方法中的一行代码。该信息说明异常的起源，以及达到该点之前进行了哪些方法调用。 当Convert方法ToInt32接收到不代表有效整数的字符串时，将发生FormatException。即使发生异常并且已打印堆栈跟踪，程序也可能继续执行。在这种情况下，应用程序可能会产生错误的结果。 使用异常处理123456789101112131415161718192021222324252627282930313233343536373839404142// DivideByZeroTest.csusing System;using System.Windows.Forms;namespace DivideByZeroTest{ public partial class DivideByZeroTestForm : Form { public DivideByZeroTestForm() { InitializeComponent(); } // 从用户那里获得2个整数 // 将分子除以分母 private void divideButton_click(object sender, EventArgs e) { outputLabel.Text = \"\"; // 清除标签OutputLabel try { int numerator = Convert.ToInt32( numeratorTextBox.Text ); int denominator = Convert.ToInt32( denominatorTextBox.Text ); int result = numerator / denominator; outputLabel.Text = result.ToString(); } catch(FormatException) { MessageBox.Show( \"You must enter two integers.\", \"Invalid Number Format\", MessageBoxButtons.OK, MessageBoxIcon.Error ); } catch ( DivideByZeroException divideByZeroExceptionParameter ) { MessageBox.Show( divideByZeroExceptionParameter.Message, \"Attempted to Divide by Zero\", MessageBoxButtons.OK, MessageBoxIcon.Error ); } } }} 另一种有效的方法： Int32.TryParse方法将字符串转换为int值。该方法需要两个参数-一个是要解析的字符串，另一个是要将转换后的值存储在其中的变量。如果成功解析了字符串，则该方法返回true。如果无法转换字符串，则将值0分配给第二个参数。 Enclosing Code in a try Block（用try块界定代码） try块包含可能引发异常的代码以及发生异常时被跳过的代码。 catch块至多只能有一个参数。 Catching Exceptions（捕获异常） 当try块中发生异常时，相应的catch块将捕获该异常并进行处理。一个try块之后必须至少有一个catch块。catch块指定一个异常参数，该参数表示catch块可以处理的异常。catch块也可以不指定异常类型或标识符，这种catch块（称为通用catch子句），捕获所有异常类型。 未捕获异常 未捕获的异常（或未处理的异常）是没有匹配的catch块的异常。 Termination Model of Exception Handling（异常处理的终止模型） 当程序或CLR中调用的方法检测到问题时，该方法或CLR会引发异常。发生异常的点称为抛出点。如果try块中发生异常，则try块立即终止，程序控制将立即转移到后面第一个异常参数类型与所有抛出类型匹配的catch块中。处理异常后，程序控制在最后一个catch块之后恢复。这称为异常处理的终止模型 .NET Exception层次C#中的异常处理机制只能抛出和捕获Exception类（命名空间System）及其派生类的对象。 其他.NET语言（如C++）引发的异常可以通过常规catch子句捕获。 SystemException类 Exception类是.NET异常类层次结构的基类。从Exception派生的一个最重要的类是SystemException。CLR产生SystemException，可以在程序执行期间的任何时候发生。 如果程序尝试访问超出范围的数组索引，则CLR会引发IndexOutOfRangeException类型的异常。尝试使用空引用会导致NullReferenceException。 catch块可以使用基类类型来捕获相关异常的层次结构。指定异常类型参数的catch块可以捕获所有异常。仅当基类和所有派生类的处理行为相同时，此技术才有意义。 确定方法抛出什么异常（Determining Which Exceptions a Method Throws） finally块程序经常动态地请求和释放资源。操作系统通常会阻止多个程序处理文件。因此，该程序应关闭文件（即释放资源），以便其他程序可以使用它。如果未关闭文件，则会发生资源泄漏。 处理资源时经常会发生异常。无论程序是否遇到异常，该程序都应在不再需要该文件时将其关闭。C#提供了finally块，无论是否发生异常，该块都可以保证执行。这使得finally块非常适合从相应的try块中释放资源。 try块中的局部变量无法在相应的finally块中访问，因此必须在try块之前声明必须在两者中访问的变量。 using语句 1234using(ExampleObject e = new ExampleObject()){ e.SomeMethod{};} 可以简化取得资源、在try块中使用资源和在相应finally中释放资源的代码。文件处理程序，保证文件不再使用时正确关闭。 using语句代码等效于 1234567891011{ ExampleObject e = new ExampleObject(); try{ e.SomeMethod(); } finally { if ( e != null ) ( ( IDisposable ) e ).Dispose(); }} Exception Properties 类Exception的属性用于制定错误消息，指示捕获到的异常。属性Message存储与Exception对象关联的错误消息。属性StackTrace包含一个表示方法调用堆栈的字符串 发生异常时，程序员可能会使用其他错误消息或指示新的异常类型。原始异常对象存储在InnerException属性中。 类异常提供其他属性： HelpLink指定描述问题的帮助文件的位置。 Source指定引起异常的应用程序或对象的名称。 TargetSite指定异常发生的方法。 最近调用的方法出现在堆栈的顶部。第一种方法（Main）出现在底部。 StackTrace表示抛出点处方法调用堆栈的状态。内部异常信息包括内部异常堆栈跟踪。 用户定义异常类（User-Defined Exception Classes）用户定义的异常类应直接或间接从名称空间System的Exception类派生。 用户定义的异常应定义三个构造函数： 无参数构造函数 接收字符串参数的构造函数（错误消息） 接收字符串参数和Exception参数的构造函数（错误消息和内部异常对象） 第14章 图形用户界面概念：第一部分图形用户界面（GUI）允许用户在视觉上与程序进行交互。 GUI控件是可以在屏幕上显示信息或使用户能够与应用程序交互的对象。 Windows FormsForm是出现在计算机桌面上的图形元素； 它可以是对话框，窗口或MDI窗口。组件是实现IComponent接口的类的实例，该接口定义了组件必须实现的行为，例如如何加载组件。诸如按钮或标签的控件在运行时具有图形表示。","link":"/2020/08/18/CSharp/CSharpReview/"},{"title":"数据结构进阶实训七 链表，数组","text":"Data structure advanced training course notes and algorithm exercises Source Code: https://github.com/MysticalGuest/DataStructure/tree/master/AdvancedJuniorTraining 题目1123判断两个链表是否相交？ - 给定两个单链表，判断两个单链表是否相交？ - 假设两个单链表均没有环 1.1 算法设计思想 如果链表有交点，那么他们一定有共同后缀，转化为共同后缀问题 1.2 源代码 12345678910111213141516171819202122LinkList commonSuffix(LinkList L1, LinkList L2){ Node *p, *q; int len1, len2; len1=listlen(L1); len2=listlen(L2); if(lastChar(L1) != lastChar(L2)){ return NULL; } else{ for(p=L1; len1&gt;len2; len1--){ p=p-&gt;next; } for(q=L2; len2&gt;len1; len2--){ q=q-&gt;next; } while(p-&gt;next != NULL &amp;&amp; p-&gt;next != q-&gt;next){ p=p-&gt;next; q=q-&gt;next; } return p-&gt;next; }} 1.3 运行情况截图 题目2123456连续子数组的最大和。输入一个整形数组，数组里有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O（n） - 例如输入数组为（1、-2、3、10、-4、7、2、-5） - 和最大的子数组为（ 3、10、-4、7、2 ） - 该子数组的和为18 2.1 算法设计思想 将第一个元素默认最大值，往后遍历，并相加；如果此时和sum小于当前元素，就舍弃之前的元素；如果当前sum大于记录的max值，将max值改为sum；直到遍历结束数组所有元素 2.2 源代码 1234567891011121314151617181920212223242526int MaxSum(int a[], int size, int *s, int *e){ if(a == NULL || size == 0){ //非法输入 return -1; } int sum = 0;//初始和为0 int i = 0; int max = a[i];//最大值最初必为数组第一个元素 for(i; i &lt; size; i++){ sum = sum + a[i];//遍历一个元素，累加一次 if(sum &lt; a[i]){//如果加上当前元素之后的和比当前元素还小，则舍弃之前的元素，从当前元素开始累加 *s = i; sum = a[i]; } //如果加上当前元素之后的和比当前元素大 //说明可以继续累加 //如果当前和比最大值大，则更新最大值为当前和 //否则，不做更新 if(sum &gt; max){ *e = i; max = sum; } } return max;} 2.3 运行情况截图 题目31234数组中的逆序对。在数组中的两个数字，如果前面的数字大于后面的数字，则这两个数字组成一个逆序对。 - 输入一个数组，输出逆序对、并求出这个数组中出现的逆序对的总数 - 例如：数组中元素{7，5，6，4}，一共有5个逆序对分别是（7,6）、（7,5）（7,4）、（6,4）、（5,4） 3.1 算法设计思想 利用归并的思想；在排序交换元素的时候就输出这两数，就是逆序对，并用计数器记录 3.2 源代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#define MAX 32767int merge(int *array, int p,int q,int r) { //归并array[p...q] 与 array[q+1...r] int tempSum=0; int n1 = q-p+1; int n2 = r-q; int* left = NULL; int* right = NULL; int i, j, k, l; left = ( int *)malloc(sizeof(int) * (n1+1)); right = ( int *)malloc(sizeof(int) * (n2+1)); for(i=0; i&lt;n1; i++) left[i] = array[p+i]; for(j=0; j&lt;n2; j++) right[j] = array[q+1+j]; left[n1] = MAX; //哨兵，避免检查每一部分是否为空 right[n2] = MAX; i=0; j=0; for(k=p; k&lt;=r; k++) { if(left[i] &lt;= right[j]) { array[k] = left[i]; i++; } else { if(array[k]&gt;right[j]){ l=k+1; for(l; l&lt;n1; l++) printf(\"(%d, %d)\\t\", array[l], right[j]); } printf(\"(%d, %d)\\t\", left[i], right[j]); array[k] = right[j]; j++; tempSum += n1 - i; } } return tempSum;}int mergeSort(int *array, int start, int end ) { int sum=0; if(start &lt; end) { int mid = (start + end) /2; sum += mergeSort(array, start, mid); sum += mergeSort(array, mid+1, end); sum += merge(array,start,mid,end); } return sum;} 3.3 运行情况截图","link":"/2020/06/17/DS/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E4%B8%83/"},{"title":"数据结构进阶实训二 顺序表","text":"Data structure advanced training course notes and algorithm exercises 数据结构进阶实训课程笔记和算法练习 Source Code: https://github.com/MysticalGuest/DataStructure/tree/master/AdvancedJuniorTraining 题目11234输入数字n,按顺序打印输出从1到最大的n位十进制数。比如输入3，则打印出1,2,3，一直到最大的3位数999。 - 要考虑若n很大，我们求最大的n位数用int 或long long 也可能会溢出； - 考虑大数问题； - 提示：关于大数的表示和存储：用字符数组(取值为数字型字符)来表达大数 1.1 算法设计思想 这题主要解决大数问题。我用字符串来解决大数问题。那么字符串中所有字符都是数字；首先动态分配字符串空间为（n+1）*char，字符串最后要有一个结束符’\\0’，初始化其他位为0；然后每一次为字符串表示的数字加1，再打印出来；方法print()会遍历字符串，直到遇到第一个非0字符后，打印后面的字符；关键方法printRecursively()，每10个数，对具体位数加1，然后进位，递归。 1.2 源代码 1234567891011121314151617181920212223void printRecursively(char *number, int n, int index){ int i; if(index == n){ print(number, n); return; } for(i = 0; i&lt;10; i++){ number[index] = i + '0'; // printf(\"NUMBER: %s\\n\", number); printRecursively(number, n, index + 1); }}void printToMaxOfNDigits(int n){ if (n &lt;= 0) return; char *number = (char *)malloc((n+1)*sizeof(char)); memset(number, '0', (n+1)*sizeof(char)); // 在一段内存块中填充某个给定的值,初始化为0 number[n] = '\\0'; printRecursively(number, n, 0); free(number);} 1.3 运行情况截图 题目2123456已知一个顺序表L（整数）实现一个函数将调整顺序表中的数字顺序，使得所有奇数位于表L的前半部分，所有偶数位于数组的后半部分。 - 如果把题目改成把顺序表中的数按照大小分为两部分，负数都在非负数的前面，该怎么做？再定义一个函数？？ - 或者再改为：把顺序表中的数分为两部分， 能被3整除的数放在前面，不能被3整除的数放在后面；再定义一个函数？？ - 是否有更好的办法？增加代码的可扩展性。 2.1 算法设计思想 定义一个规则rule方法，根据用户输入，确定排序规则，增加代码复用性；三种排序规则思想一样：（1）start=0从顺序表头开始往后，end从尾开始往前，start遇到偶数停止，end遇到奇数停止，交换下标为start和下标为end的元素，然后继续前进；（2）start=0从顺序表头开始往后，end从尾开始往前，start遇到正数停止，end遇到负数停止，交换下标为start和下标为end的元素，然后继续前进；（3）start=0从顺序表头开始往后，end从尾开始往前，start遇到不能被3整除的数停止，end遇到能被3整除的数停止，交换下标为start和下标为end的元素，然后继续前进。 2.2 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/*宏定义*/#define MAXSIZE 30//宏定义布尔类型#define BOOL int#define TRUE 1#define FALSE 0typedef int ElemType; /*顺序表中存放整型元素*/typedef struct{ ElemType elem[MAXSIZE]; int last;}SeqList;/*函数声明*/void initList(SeqList *L);void printList(SeqList L);BOOL rule(int elem, int select);void sortList(SeqList *L, SeqList *L1, int select);void main(){ SeqList La, Lb; Lb.last=-1; // 初始化Lb int select; initList(&amp;La); // 给出一个顺序表La printf(\"Give a sequence table: \\nLa = \"); printList(La); /* 给出下列几种排序规则: 奇数在前，偶数在后; 负数在前，非负数在后; 能被3整除的数在前面，不能被3整除的数在后面. */ printf(\"\\nGive the following sorting rules: \\ \\n1.Odd number first, even number behind;\\ \\n2.Negative numbers first, non-negative numbers last;\\ \\n3.Numbers divisible by 3 are in the front, \\ and numbers that are not divisible by 3 are in the back.\\ \\nPlease select the sorting rule you want and enter the rule number:\"); scanf(\"%d\", &amp;select); while(select != 1 &amp;&amp; select != 2 &amp;&amp; select != 3){ printf(\"Please reselect: \"); scanf(\"%d\", &amp;select); } sortList(&amp;La, &amp;Lb, select); printf(\"The adjusted sequence table is: \\n\"); printList(Lb); system(\"pause\");}/*函数定义*/void initList(SeqList *L){ L-&gt;last=-1; int i=0; for(i; i&lt;MAXSIZE; i++){ L-&gt;elem[i]=rand()%100 - 50; } L-&gt;last=MAXSIZE-1;}void printList(SeqList L){ int i; printf(\"(\"); for(i=0; i&lt;=L.last; i++) printf(\"%d \", L.elem[i]); printf(\")\\n\");}void sortList(SeqList *L, SeqList *L1, int select){ int i=0, end=L-&gt;last, start=0; for(i; i&lt;=L-&gt;last; i++){ if( rule(L-&gt;elem[i], select) == TRUE){ // 偶数尾插法 L1-&gt;elem[end] = L-&gt;elem[i]; end--; } else{ // 奇数前插法 L1-&gt;elem[start] = L-&gt;elem[i]; start++; } } L1-&gt;last=L-&gt;last;}BOOL rule(int elem, int select){ switch (select) { case 1: if(elem%2==0) return TRUE; return FALSE; break; case 2: if(elem&gt;=0) return TRUE; return FALSE; break; case 3: if(elem%3!=0) return TRUE; return FALSE; break; default: return FALSE; break; }} 2.3 运行情况截图 题目31给定一个整数数组，删除相邻的重复数字，结果数组中不能存在任何相邻的重复数字。 3.1 算法设计思想 将数组存入顺序表；遍历顺序表，将下标为i和下标i+1的元素比较如果相等，进行判断：如果下标为i和下标i+2的元素相等，所有元素往前移动1位；如果下标为i和下标i+2的元素不相等，所有元素往前移动2位；持续上述循环，结束的标志是遍历顺序表，没有相邻相同元素就结束循环。 3.2 源代码 123456789101112131415161718192021222324252627282930313233343536373839while(flag==1){ if(L.last==0) // 代表顺序表中只有一个元素 break; if(L.elem[i]==L.elem[j]){ if(L.elem[i]==L.elem[j+1]){ // 判断是否3数相连 for(k=i; k&lt;L.last; k++){ L.elem[k]=L.elem[k+1]; // 所有元素前移1位 } L.last = L.last-1; } else{ // 不是3数相连，那就是2数相连 for(k=i; k&lt;L.last-1; k++){ L.elem[k]=L.elem[k+2]; // 所有元素前移2位 } L.last = L.last-2; if(j&gt;L.last){ i=0; j=1; } } } if(j==L.last){ for(k=0; k&lt;L.last; k++){ if(L.elem[k]==L.elem[k+1]){ flag=1; break; } else flag=0; } i=-1; j=0; } i++; j++;} 3.3 运行情况截图 题目4123已知顺序表L（数组表示即可），编写一个时间复杂度O(n)，空间复杂度为O（1）的算法将表L中所有值为x 的元素删除。 - 表中元素无序。 4.1 算法设计思想 遍历顺序表，将顺序表a的元素赋给顺序表b，遇到要删除的元素就跳过。 4.2 源代码 12345678910111213void deleteList(SeqList *LA, SeqList *LB, int n){ int count=0, i=0, j=0; for(i; i&lt;LA-&gt;last+1; i++){ if(LA-&gt;elem[i]==n){ count++; // 记录删除元素的个数 } else{ LB-&gt;elem[j] = LA-&gt;elem[i]; j++; } } LB-&gt;last = LA-&gt;last-count;} 4.3 运行情况截图 题目51234567将n 个整数存入顺序表L，实现将L中的整数序列循环左移p(0&lt;p&lt;n)个位置，即将L中的数据序列(x0, x1, ... , xp-1, xp, xp+1, ... , xn-1)变换为(xp, xp+1, ... , xn-1, x0, x1, ... , xp-1) - 类似的实现循环右移K位； - 要求：时间复杂度为O(n)。空间复杂度为S(1)。 5.1 算法设计思想 将下标0到p的元素逆置；将下标p+1到n 的元素逆置；最后将整个顺序表逆置得到最终结果。 5.2 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960void main(){ SeqList L = {{1,2,3,4,5,6,7,8,9,10},10}; int n; int temp; char direction; printf(\"Give a sequence table: \\n\"); printlist(L); printf(\"Please enter a positive integer n to cycle through the sequence: \"); scanf(\"%d\", &amp;n); getchar(); // 吃掉回车 printf(\"Please select the direction of movement (L for left, R for right): \"); while(direction!='R' &amp;&amp; direction!='L'){ scanf(\"%c\", &amp;direction); getchar(); if(direction=='L'){ n = n%L.last; } else if(direction=='R'){ // 右移n格就是左移L.last-n格 n = L.last - n%L.last; } else{ printf(\"Wrong input, please re-enter: \"); } } int i = 0, j = n-1; //将子表(X0,X1...,Xp-1)逆序为(Xp-1,...,X1,X0) reverse(&amp;L, i, j); //将子表(Xp,Xp+1,...,Xn-1)逆序为(Xn-1,...,Xp+1,Xp) i = n; j = L.last-1; reverse(&amp;L, i, j); //将整张表(Xp-1,...,X1,X0,Xn-1,...,Xp+1,Xp)逆序为(Xp,Xp+1,...,Xn-1,X0,X1...,Xp-1) i = 0; j = L.last-1; reverse(&amp;L, i, j); printf(\"The sequence table after moving is: \\n\"); printlist(L); system(\"pause\");}void reverse(SeqList *L,int i, int j){ int temp; while(i &lt; j){ temp = L-&gt;elem[i]; L-&gt;elem[i] = L-&gt;elem[j]; L-&gt;elem[j] = temp; ++i; --j; }} 5.3 运行情况截图","link":"/2020/05/25/DS/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E4%BA%8C/"},{"title":"数据结构进阶实训六 多维数组","text":"Data structure advanced training course notes and algorithm exercises Source Code: https://github.com/MysticalGuest/DataStructure/tree/master/AdvancedJuniorTraining 题目1123我们把只包含因子2,3,5的数称为丑数。求从小到大的第1500个丑数。 -例如：6,8都是丑数，但14不是丑数，因为它包含因子7.习惯上我们把1当做丑数。 -编写尽可能高效的算法。提示：（可以用空间换时间） 1.1 算法设计思想 准备一个数组，初始化第1个丑数的下标0，值1；然后1X2得到2，就是第2个丑数；然后1X3得到3，就是第3个丑数；不能直接1X5就是第4个丑数，因为还有一个丑数2X2=4；所以难点就是判断中间丑数，然后存储在数组中；往下循环；然后1X5得到5，就是第5个丑数 1.2 源代码 1234567891011121314151617181920212223int min_num(int n1,int n2,int n3){ int min=(n1&lt;n2)?n1:n2; min=(min&lt;n3)?min:n3; return min;}void solution(long int array[]){ int i; int t2=0;//记录M2的下标 int t3=0; int t5=0; for(i=1; i&lt;1500; i++){ while(array[t2]*2&lt;=array[i-1])//查找到新的M2，即乘以2后第一个大于M的数 t2++; while(array[t3]*3&lt;=array[i-1]) t3++; while(array[t5]*5&lt;=array[i-1]) t5++; int min=min_num(array[t2]*2, array[t3]*3, array[t5]*5); array[i]=min; }} 1.3 运行情况截图 题目21顺时针打印矩阵 2.1 算法设计思想 针对一般矩阵，先顺时针打印最外部一圈，那么这个矩阵去掉外部一圈，内部也是一个小矩阵；按照这样的规律，依次打印最外部一圈就可以了 2.2 源代码 1234567891011121314151617181920212223void PrintMatrix(int (*num)[4], int col, int row, int layer){ int i; int new_col = col - layer; int new_row = row - layer; for(i=layer; i&lt;new_col; i++){ // 从左至右打印第一行 printf(\"%d \", num[layer][i]); } if(new_row&gt;layer){ for(i=layer+1; i&lt;new_row; i++){ // 从上至下打印最右一列 printf(\"%d \", num[i][new_row-1]); } } if(new_col-1&gt;layer &amp;&amp; new_row-1&gt;layer){ for(i=new_col-2; i&gt;=layer; i--){ // 从右至左打印最后一行 printf(\"%d \", num[new_col-1][i]); } } if(new_col-1&gt;layer &amp;&amp; new_row-1&gt;layer+1){ for(i=new_row-2; i&gt;layer; i--){ // 从下至上打印最左一列 printf(\"%d \", num[i][layer]); } }} 2.3 运行情况截图 题目3123设二维数组B[0..m-1][0..n-1]的数据在行、列方向上都按从小到大的顺序有序，且x在B中存在。试设计一个算法，找出x在B数组中的位置i,j。要求比较的次数不超过m+n 3.1 算法设计思想 第一个循环（最多4次）： 将要定位的元素与每一行的最后一个元素比较，如果小于等于最后一个元素就结束循环，此时的i值就是元素的行坐标； 第二次循环（最多5次）： 将要定位的元素与每一列的所有元素比较，如果小于等于这个值，就结束循环，此时的j值就是元素的列坐标 3.2 源代码 123456789int matrix[4][5] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20}, i, j;for(i=0; i&lt;4; i++){ // 定位行坐标i if(obj &lt;= matrix[i][4]) break;}for(j=0; j&lt;5; j++){ // 定位列坐标j if(obj &lt;= matrix[i][j]) break;} 3.3 运行情况截图","link":"/2020/06/12/DS/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E5%85%AD/"},{"title":"数据结构进阶实训三 字符串，数组","text":"Data structure advanced training course notes and algorithm exercises 数据结构进阶实训课程笔记和算法练习 Source Code: https://github.com/MysticalGuest/DataStructure/tree/master/AdvancedJuniorTraining 题目11234实现将一个字符串中的每个空格字符换成“%20”。 - 例如：输入“We are happy.”, 则输出: - “We%20are%happy.”要求在时间复杂度O（n）,空间复杂度O（1）下完成。假设存放字符串的数组空间足够大。 1.1 算法设计思想 前提假设存放字符串的数组空间足够大； 第一次，遍历，计算出字符串长度，和替换后字符串长度； i从原字符串末尾出发，j从新字符串末尾出发，遇到空格就替换为“%20”。 1.2 源代码 12345678910111213141516171819202122232425char str[100] = \"We are happy.\"; // 假设空间足够大int length=0, blank=0, i, j;while(str[length]!='\\0'){ printf(\"%c\", str[length]); if(str[length]==' '){ blank++; } length++;}length += 2 * blank;i=length-2*blank;j=length;while(i&gt;=0 &amp;&amp; j&gt;i){ if(str[i]==' '){ str[j--]='0'; str[j--]='2'; str[j--]='%'; } else{ str[j--]=str[i]; } i--;} 1.3 运行情况截图 题目21234数组中出现次数超过一半的数字已知数组中有一个数字其出现的次数超过了数组长度的一半，请找出这个数组。要求： - 高效 - 分析时空效率 2.1 算法设计思想 一个数字出现的次数超过了数组的一半，那么将其排序后，称为有序数列，中间的元素即为所求。 2.2 源代码 1234567891011121314151617void sort(int a[], int length){ int i, j, min, temp; for(i=0; i&lt;length; i++){ min=i; for(j=i; j&lt;length; j++){ if(a[min]&gt;a[j]) min=j; } if(min!=i){ temp=a[min]; a[min]=a[i]; a[i]=temp; } }}printf(\"%d\\n\", array[length/2]); 2.3 运行情况截图 题目31234已知数组中的n个正数，找出其中最小的k个数。要求： - 高效 - 分析时空效率 3.1 算法设计思想 先将数组从小到大排序； 即可顺序打印出前k个数，即为数组中最小的k个数。 时间复杂度为O(n)，空间复杂度为O(1)。 3.2 源代码 12345678910111213141516171819202122void sort(int a[], int length){ int i, j, min, temp; for(i=0; i&lt;length; i++){ min=i; for(j=i; j&lt;length; j++){ if(a[min]&gt;a[j]) min=j; } if(min!=i){ temp=a[min]; a[min]=a[i]; a[i]=temp; } }}printf(\"\\nEnter the value k and output the smallest k number among them, k = \");scanf(\"%d\", &amp;k);printf(\"The smallest %d number in the array is: \\n\", k);for(i=0; i&lt;k; i++){ printf(\"%d\\t\", array[i]);} 3.3 运行情况截图","link":"/2020/05/30/DS/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E4%B8%89/"},{"title":"数据结构进阶实训十三 图的应用","text":"数据结构进阶实训课程笔记和算法练习 Source Code C语言中文网 题目1123判断给定的图G是否是连通图。若连通，则输出该生成树。若不连通，则输出其所有的连通子图（生成森林） - 图G分别采用邻接矩阵或邻接表存储表示 - 实现在该两种存储表示方法下的上述操作 1.1 算法设计思想 深度优先搜索算法的改进。 如果一次深度优先搜索没有把所有顶点遍历完，即visited数组有false值，那么就可以证明图不是连通的。 1.2 源代码 12345678910111213141516171819202122232425262728293031323334353637// 邻接矩阵void Judge(MGraph G, bool *b){ printf(\"The spanning tree or forest of this graph is: \"); int v; //将用做标记的visit数组初始化为false for( v = 0; v &lt; G.vexnum; ++v){ visited[v] = false; } DFS( G, 0); //从任意一点遍历，这里从下标为0的点开始 for( v = 1; v &lt; G.vexnum; v++){ if(!visited[v]){ DFS( G, v); *b = false; printf(\" | \"); } } *b = true;}//邻接表void JudgeAdjList(ALGraph *g, bool *b){ printf(\"The spanning tree or forest of this graph is: \"); int i; int visited[MAX_VERtEX_NUM]; for(i=0;i&lt;g-&gt;vexnum;i++){ visited[i]=0; } DFSAdjList(g, 0, visited); for(i=1;i&lt;g-&gt;vexnum;i++){ if(!visited[i]){ printf(\" | \"); DFSAdjList(g, i, visited); *b = false; } } *b = true;} 1.3 运行情况截图 题目21无向图G（不带权值）采用邻接表结构，试设计一个算法，求图G中从顶点u到顶点v的最短路径。 2.1 算法设计思想 运用Dijkstra(迪杰斯特拉)算法的思想。 visit[]：这个数组用来标记结点的访问与否，如果该结点被访问，则为1，如果该结点还没有访问，则为0； distance[]：这个数组用来记录当前从v到各个顶点的最短路径长度，算法的核心思想就是通过不断修改这个表实现。 先遍历直达源顶点的所有顶点，距离记为1，置visit[]已访问； 后面遍历所有其他未访问的顶点，更新distance[]数组。 1234567 实例 1 / \\ 0 2 / \\ 3 4程序将以此图作为输入 2.2 源代码 123456789101112131415161718192021222324252627282930313233void Dijkstra(ALGraph G, int s, int t){//求 s 到 t 的最短路径 int i, j; int visit[MAX_VERTEX_NUM]; int distance[MAX_VERTEX_NUM]; //从 s 到各点的距离 for(i=0; i&lt;G.vexnum; i++){ distance[i]=INFINITY; visit[i]=false; } distance[s]=0; visit[s]=1; ArcNode *p=G.vertices[s].firstarc; while(p){ //先把距离源点距离最近的顶点都遍历完 if(!visit[p-&gt;adjvex]){ distance[p-&gt;adjvex]=1; visit[p-&gt;adjvex]=1; //当前顶点已访问 } p=p-&gt;nextarc; } for(i=0; i&lt;G.vexnum; i++){ //再求其他顶点 if(!visit[G.vertices[i].data]){ p=G.vertices[i].firstarc; //未访问的节点 while(p){ if(distance[p-&gt;adjvex]&lt;INFINITY){ distance[G.vertices[i].data]=distance[p-&gt;adjvex]+1; } p=p-&gt;nextarc; } } }} 2.3 运行情况截图 题目31无向图G（不带权值）采用邻接表表示，试设计一个算法，输出从顶点Vi到顶点Vj的所有简单路径。 3.1 算法设计思想 利用递归算法，从起始点出发，分别递归遍历它的所有顶点，将遍历过的顶点访问数组置false，并将节点记录进path数组，当遇到目标加点将path数组中顶点全部输出，即为简单路径。 1234567 实例 0 / \\ 1 2 \\ / 3程序将以此图作为输入 3.2 源代码 1234567891011121314151617181920212223int path[MAX_VERTEX_NUM];path[0]=start; //记录源点void findAllSimplePath(ALGraph G, int start, int end, int path[], int i){ ArcNode *p; int j, n; visited[start]=1; // 记录已近访问过这个顶点 p=G.vertices[start].firstarc; while (p){ n=p-&gt;adjvex; if(n==end){ //找到一个路径 path[i+1] = end; for(j=0; j&lt;=i+1; j++) printf(\"%-3d\", path[j]); printf(\"\\n\"); } else if(!visited[n]){ //改点未被遍历 path[i+1]=n;//存入路径 findAllSimplePath(G, n, end, path, i+1); // 递归 } p=p-&gt;nextarc; }} 3.3 运行情况截图 题目41图G采用邻接表表示，试设计一个算法，求无向连通图G中距离顶点v最远的一个顶点。 4.1 算法设计思想 同题目2的算法思想，既然用Dijkstra算法求出了所有一个点到其他所有顶点的路径，那么取distance数组中的最大值即为最远顶点。 4.2 源代码 12345678910111213141516171819202122232425262728293031323334353637383940int Dijkstra(ALGraph G, int s){ int i, j; int visit[MAX_VERTEX_NUM]; int distance[MAX_VERTEX_NUM]; //从 s 到各点的距离 for(i=0; i&lt;G.vexnum; i++){ distance[i]=INFINITY; visit[i]=false; } distance[s]=0; visit[s]=1; ArcNode *p=G.vertices[s].firstarc; while(p){ //先把距离源点距离最近的顶点都遍历完 if(!visit[p-&gt;adjvex]){ distance[p-&gt;adjvex]=1; visit[p-&gt;adjvex]=1; //当前顶点已访问 } p=p-&gt;nextarc; } for(i=0; i&lt;G.vexnum; i++){ //再求其他顶点 if(!visit[G.vertices[i].data]){ p=G.vertices[i].firstarc; //未访问的节点 while(p){ if(distance[p-&gt;adjvex]&lt;INFINITY){ distance[G.vertices[i].data]=distance[p-&gt;adjvex]+1; } p=p-&gt;nextarc; } } } int max=0; //最远顶点的位置 for(i=1; i&lt;G.vexnum; i++){ if(distance[max]&lt;distance[i]) max=i; } return max;} 4.3 运行情况截图","link":"/2020/07/11/DS/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E5%8D%81%E4%B8%89/"},{"title":"数据结构进阶实训五 栈与递归","text":"Data structure advanced training course notes and algorithm exercises Source Code: https://github.com/MysticalGuest/DataStructure/tree/master/AdvancedJuniorTraining 题目1123假设算术表达式只包含“+”、“-”、“*”、“/”，正整数和括号的合法数学表达式。根据算符优先关系， - 将算术表达式的中缀表示法转换为后缀表示法。 - 对得到的后缀表达式进行求值 1.1 算法设计思想 1.1.1 转后缀表达式： 从左到右扫描每一个字符。如果扫描到的字符是操作数（如a、b等），就直接输出这些操作数。 如果扫描到的字符是一个操作符，分三种情况：（1）如果堆栈是空的，直接将操作符存储到堆栈中（pushCStack it）（2）如果该操作符的优先级大于堆栈出口的操作符，就直接将操作符存储到堆栈中（pushCStack it）（3）如果该操作符的优先级低于堆栈出口的操作符，就将堆栈出口的操作符导出（popCStack it）,直到该操作符的优先级大于堆栈顶端的操作符。将扫描到的操作符导入到堆栈中（pushCStack） 如果遇到的操作符是左括号”（”，就直接将该操作符输出到堆栈当中。该操作符只有在遇到右括号“ )”的时候移除。这是一个特殊符号该特殊处理。 如果扫描到的操作符是右括号“ ”，将堆栈中的操作符导出（popCStack）到output中输出，直到遇见左括号“（”。将堆栈中的左括号移出堆栈（popCStack ）。继续扫描下一个字符。 如果输入的中缀表达式已经扫描完了，但是堆栈中仍然存在操作符的时候，我们应该讲堆栈中的操作符导出并输入到output 当中。 1.1.3 求值 后缀表达式求值的算法是:遍历后缀表达式，如果遇到运算数，那么运算数入栈如果遇到运算符，那么弹出栈里面两个元素，先弹出的是右运算数，后弹出的是左运算数，计算运算结果，然后将结果入栈最后遍历到后缀表达式末尾，当结果只有一个元素时，就是答案 1.2 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239#define StackSize 50#define INFINITY 32768// 定义运算符栈typedef struct{ char elem[StackSize]; int top;}SeqCStack;void InitCStack(SeqCStack *S){ S-&gt;top=-1;}void pushCStack(SeqCStack *S, char operator){ if(S-&gt;top == StackSize - 1){ // 栈满 return ; } else{ S-&gt;top++; S-&gt;elem[S-&gt;top] = operator; return ; }}void popCStack(SeqCStack *S, char *e){ if(S-&gt;top == -1){ // 栈空 return ; } else{ *e = S-&gt;elem[S-&gt;top]; S-&gt;top--; return ; }}char getCStackTop(SeqCStack S){ if(S.top == -1){ // 栈空 return '#'; } else{ return S.elem[S.top]; }}void traverse(SeqCStack S){ int i=0; while(i &lt;= S.top){ printf(\"%c \", S.elem[i++]); } printf(\"\\n\");}// 定义运算数栈typedef struct{ int data[StackSize]; int top;}SeqNStack;void InitNStack(SeqNStack *S){ S-&gt;top=-1;}void pushNStack(SeqNStack *S, int num){ if(S-&gt;top == StackSize - 1){ // 栈满 return ; } else{ S-&gt;top++; S-&gt;data[S-&gt;top] = num; return ; }}void popNStack(SeqNStack *S, int *e){ if(S-&gt;top == -1){ // 栈空 return ; } else{ *e = S-&gt;data[S-&gt;top]; S-&gt;top--; return ; }}int getNStackTop(SeqNStack S){ if(S.top == -1){ // 栈空 return INFINITY; } else{ return S.data[S.top]; }}char compare(char operator, char top){ if(top == '#') // 空栈，操作符直接进栈 return '&gt;'; else if(operator==')' &amp;&amp; top=='(') return '='; else if(top=='(') return '&gt;'; else if(operator=='+') // 如果操作符是'+', 无论栈顶元素是什么, '+'优先级都小 return '&lt;'; else if(operator=='-') return '&lt;'; else if(operator=='*' &amp;&amp; top=='+') return '&gt;'; else if(operator=='*' &amp;&amp; top=='-') return '&gt;'; else if(operator=='*' &amp;&amp; top=='*') return '&lt;'; else if(operator=='*' &amp;&amp; top=='/') return '&lt;'; else if(operator=='*' &amp;&amp; top=='(') return '&lt;'; else if(operator=='/' &amp;&amp; top=='+') return '&gt;'; else if(operator=='/' &amp;&amp; top=='-') return '&gt;'; else if(operator=='/' &amp;&amp; top=='*') return '&lt;'; else if(operator=='/' &amp;&amp; top=='(') return '&lt;'; else if(operator=='(') return '&gt;'; else if(operator==')') return '&lt;';}int caculate(int left, int right, char c){ int re = 0; switch (c){ case '+': re = left + right; break; case '-': re = left - right; break; case '*': re = left * right; break; case '/': re = left / right; break; default: break; } return re;}void main(){ SeqCStack OS, SuffixExp; SeqNStack NS; /* 初始化运算符栈 */ InitCStack(&amp;OS); /* 初始化运算数栈 */ InitNStack(&amp;NS); /* 初始后缀表达式栈 */ InitCStack(&amp;SuffixExp); char exp[] = {'5', '+', '2', '*', '(', '1', '+', '6', ')', '-', '8', '/', '2', '\\0'}; printf(\"Infix expression is: %s\\n\", exp); char suffixstr[50], temp; int i = 0, tempNum; while (exp[i]!='\\0'){ if(isdigit(exp[i])){ // 如果是数字直接进后缀表达式栈 pushCStack(&amp;SuffixExp, exp[i]); // printf(\"num------%c\\n\", exp[i]); i++; } else{ // printf(\"char------\\n\"); // printf(\"compare----%c\\n\", compare(exp[i], getCStackTop(OS))); switch(compare(exp[i], getCStackTop(OS))){ case '&gt;': pushCStack(&amp;OS, exp[i]); // printf(\"case1 &gt;---%c\\n\", exp[i]); i++; break; case '=': popCStack(&amp;OS, &amp;temp); // 脱括号 // printf(\"case2 =---%c\\n\", temp); i++; break; case '&lt;': while(compare(exp[i], getCStackTop(OS))=='&lt;'){ // printf(\"case3 &lt;---%c\\n\", exp[i]); // printf(\"case3 getCStackTop %c\\n\", getCStackTop(OS)); popCStack(&amp;OS, &amp;temp); // printf(\"case3 after getCStackTop %c\\n\", getCStackTop(OS)); pushCStack(&amp;SuffixExp, temp); } // if(exp[i]!=')'){i++;} break; } } } /* 最后把栈中剩余的运算符依次弹栈打印 */ while(getCStackTop(OS)!='#'){ popCStack(&amp;OS, &amp;temp); pushCStack(&amp;SuffixExp, temp); } traverse(SuffixExp); for(i=SuffixExp.top; i&gt;=0; i--){ popCStack(&amp;SuffixExp, &amp;temp); suffixstr[i] = temp; } printf(\"Infix expression to suffix expression is: %s\\n\", suffixstr); /* 后缀表达式求值的算法是: 遍历后缀表达式， 如果遇到运算数，那么运算数入栈 如果遇到运算符，那么弹出栈里面两个元素，先弹出的是右运算数，后弹出的是左运算数， 计算运算结果，然后将结果入栈。 最后遍历到后缀表达式末尾，当结果只有一个元素时，就是答案 */ char *p=suffixstr; while (*p != '\\0'){ if (isdigit(*p)){ pushNStack(&amp;NS, *p-'0'); } else{ popNStack(&amp;NS, &amp;tempNum); int rightNum = tempNum; // printf(\"rightNum:::%d\\n\", rightNum); // free(temp); popNStack(&amp;NS, &amp;tempNum); int leftNum = tempNum; // free(temp); int result = caculate(leftNum, rightNum, *p); // printf(\"caculate result----%d\\n\", result); pushNStack(&amp;NS, result); } p++; } printf(\"result: %d\\n\", getNStackTop(NS)); system(\"pause\");} 1.3 运行情况截图 题目21设L为带头结点的单链表，实现从尾到头反向输出链表中每个结点的值。（递归思想） 2.1 算法设计思想 递归语句在打印之前就可以了 2.2 源代码 123456void printReversely(LinkList L){ if(L-&gt;next!=NULL){ printReversely(L-&gt;next); printf(\"%c \", L-&gt;next-&gt;data); }} 2.3 运行情况截图 题目312345一只青蛙一次可以跳上1级台阶，也可以跳上2级。编写代码求青蛙跳上一个n级的台阶，总共有多少种跳法？ - 若条件改为： 一只青蛙一次可以跳上1级台阶，也可以跳上2级，也可以跳上3级，...，也可以跳上n级。 编写代码求青蛙跳上一个n级的台阶，总共有多少种跳法？ 3.1 算法设计思想 Q： 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 A： f(n) = f(n-1)+f(n-2)+…+f(1)f(n-1) = f(n-2)+ f(n-3)…+f(1)两式相减，得到f(n) = 2*f(n-1) 3.2 源代码 1234567891011121314151617181920int Jump(int i, int n) { //表示当前台阶数大于总台阶数，很显然这种情况不符合，走不通，记为 0 if (i &gt; n) { return 0; } //表示当前台阶数正好等于总的台阶数，那么这种情况符合，记为 1 if (i == n) { return 1; } return Jump(i + 1, n) + Jump(i + 2, n);}int JumpN(int num){ if (num == 1){ return 1; } else{ return 2*JumpN(num-1); }} 3.3 运行情况截图 题目4123用一个2X1的小矩形横着或竖着去覆盖更大的矩形。如下图 - 具体：用8个2X1小矩形横着或竖着去覆盖2X8的大矩形，覆盖方法有多少种？ - 编写代码求用2X1小矩形横着或竖着去覆盖2Xn的大矩形。输出总共有多少种覆盖方法 4.1 算法设计思想 当n=1时，覆盖方法有1种；当n=2时，覆盖方法有2种；当n=3时，覆盖方法有2+1=3种；当n=4时，覆盖方法有3+2=5种；按照规律就转化成了斐波那契数列问题 4.2 源代码 1234567891011int Cover(int n){ if(n&lt;=0){ return 0; } else if(n==1||n==2){ return n; } else{ return Cover(n-1) + Cover(n-2); }} 4.3 运行情况截图 题目5123借助自定义栈以非递归形式求解汉诺塔问题（n,a,b,c）；即将n个盘子从起始塔座a通过辅助塔座b移动到目标塔座c,并保证每个移动符合汉诺塔问题的要求 5.1 算法设计思想 利用递归的思想，用栈来处理；比如n=3时，转化的问题是：先要移动A塔座上面2个盘子到B塔座，这个操作进栈后续处理；然后移动A塔座上面最后一个大盘子到C塔座，这个操作进栈后续处理；最后再移动B塔座上最后两个盘子到C塔座；一直访问栈，如果栈顶处理的盘子数不是1，就在把操作细分，进栈；直到盘子数为1，移动盘子；直到栈为空 5.2 源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// 定义汉诺塔数据typedef struct{ char A; char B; char C; int n;}HanoiData;// 定义栈typedef struct{ HanoiData elem[StackSize]; int top;}SeqStack;void InitStack(SeqStack *S){ S-&gt;top=-1;}void push(SeqStack *S, HanoiData hd){ if(S-&gt;top == StackSize - 1){ // 栈满 return ; } else{ S-&gt;top++; S-&gt;elem[S-&gt;top] = hd; return ; }}void pop(SeqStack *S, HanoiData *e){ if(S-&gt;top == -1){ // 栈空 return ; } else{ *e = S-&gt;elem[S-&gt;top]; S-&gt;top--; return ; }}// HanoiData getTop(SeqStack S){// if(S.top == -1){ // 栈空// return ;// }// else{// return S.elem[S.top];// }// }void move1(int n,char A,char B,char C){ if(n==1){ printf(\"%c--&gt;%c\\n\",A,C); } else{ move1(n-1,A,C,B); move1(1,A,B,C); move1(n-1,B,A,C); } }void hanoi(int n){ SeqStack S; InitStack(&amp;S); HanoiData h = {'A', 'B', 'C', n}; push(&amp;S,h);//初始栈 // hanoi_data x;//用来保存出栈的n,A,B,C while(S.top!=-1){ pop(&amp;S, &amp;h);//出栈并用x带回 if(h.n==1){ printf(\"%c--&gt;%c\\n\",h.A,h.C);//打印出移动方案 } else{ HanoiData h1 = {h.B, h.A, h.C, h.n-1}; push(&amp;S,h1); HanoiData h2 = {h.A, h.B, h.C, 1}; push(&amp;S,h2); HanoiData h3 = {h.A, h.C, h.B, h.n-1}; push(&amp;S,h3); } }} 5.3 运行情况截图","link":"/2020/06/08/DS/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E4%BA%94/"},{"title":"数据结构进阶实训十 二叉排序树","text":"Data structure advanced training course notes and algorithm exercises 数据结构进阶实训课程笔记和算法练习 Source Code: https://github.com/MysticalGuest/DataStructure/tree/master/AdvancedJuniorTraining 题目112判断二叉树是否为正则二叉树。 - 正则二叉树的定义：指在二叉树中不存在度为1的分支点。 1.1 算法设计思想 利用二叉树遍历递归的思想；先判断当前节点是否正则；然后递归判断该节点的左右子树。 1.2 源代码 1234567891011// 1代表是正则二叉树，0代表不是int IsRegular(BiTree T){ if(T==NULL) return 1; else if(T-&gt;LChild==NULL ^ T-&gt;RChild==NULL) return 0; else{ IsRegular(T-&gt;LChild); IsRegular(T-&gt;RChild); }} 1.3 运行情况截图 题目21判断二叉树是否为完全二叉树？ 2.1 算法设计思想 一个树是否为完全二叉树，每个节点有以下4中情况： 1234情况一： 情况二： 情况三： 情况四： A A A A / \\ / \\ / \\ / \\B C B NULL NULL B NULL NULL 规律是： （1）如果当前访问的节点的左右孩子是情况三，说明不是完全二叉树，直接返回false； （2）如果当前访问的节点的左右孩子是情况1，继续访问其他节点； （3）如果当前访问的节点的左右孩子是情况2或者情况4，那么我们定义一个状态（接下来访问的所有节点必须全部是叶子节点）。只要遇到情况2或者情况4，这个状态就开启了。 算法就是层次遍历所有节点并做判断。 2.2 源代码 1234567891011121314151617181920212223242526BOOL IsCBT(BiTree bt){ if(bt==NULL) // 空树 return TRUE; BOOL leaf = FALSE; SeqQueue Q; BiTree p; InitQueue(&amp;Q); EnterQueue(&amp;Q, bt); while(!IsEmpty(Q)){ DeleteQueue(&amp;Q, &amp;p); if(p-&gt;LChild==NULL &amp;&amp; p-&gt;RChild!=NULL) // 情况3: 当前节点有右孩子，没有左孩子 return FALSE; //上述的状态已经发生，但是当前访问到的节点不是叶节点（有左孩子或者右孩子） if(leaf &amp;&amp; (p-&gt;LChild!=NULL||p-&gt;RChild!=NULL)) return FALSE; if(p-&gt;LChild!=NULL) //左孩子不为空，加入到队列中去 EnterQueue(&amp;Q, p-&gt;LChild); if(p-&gt;RChild!=NULL) //右孩子不为空，加入到队列中去 EnterQueue(&amp;Q, p-&gt;RChild); //这个if语句就是判断状态是否要发生 if((p-&gt;LChild!=NULL &amp;&amp; p-&gt;RChild==NULL)||(p-&gt;LChild==NULL &amp;&amp; p-&gt;RChild==NULL)) leaf=TRUE; } return TRUE;} 2.3 运行情况截图 题目3123456二叉树二叉链表存储，结点数据域的值为整数，且取值各不相同。编写代码判断该二叉树是否为二叉排序树。二叉排序树，又称二叉查找树。它或者是一颗空树，或者是具有下列性质的二叉树。 - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； - 它的的左、右子树也分别为二叉排序树。 3.1 算法设计思想 由于二叉排序树的中序遍历得到的是一个单调递增的序列； 所以根据这个想法，我们可以中序遍历这个二叉树，将得到的序列存入temp数组； 通过检验temp数组的单调递增性来判断这个二叉树是否为二叉排序树。 3.2 源代码 123456789101112131415161718192021#define N 100int temp[N];int i = 0;void inorder(BiTree root){ if(root == NULL) return; if(root-&gt;LChild != NULL) inorder(root-&gt;LChild); temp[i++] = root-&gt;data; if(root-&gt;RChild != NULL) inorder(root-&gt;RChild);}int ISBST(int temp[], int k){ int flag=0; for(int i=1; i&lt;k; i++) if(temp[i]&lt;temp[i-1]) return 0; return 1;} 3.3 运行情况截图 题目4123二叉树二叉链表存储，结点数据域的值为整数，且取值各不相同。编写代码判断该二叉排序树是否为平衡二叉排序树。 - 平衡二叉树，是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1。 4.1 算法设计思想 通过平衡二叉树的定义可以将判断平衡二叉树的条件分为以下2个： （1）首先是一颗二叉排序树； （2）每个节点的左右子树的高度差至多为1； 基于以上两个条件写两个方法； 第一个条件思想和上一题一样，判断二叉排序树； 第二个条件通过递归判断每个节点的左右子树高度； 将两个条件返回值综合，就可以判断出。 4.2 源代码 12345678910111213141516171819202122232425262728293031323334int Deep(BiTree bt){ int ld=0,rd=0; if(bt){ ld=Deep(bt-&gt;LChild)+1; rd=Deep(bt-&gt;RChild)+1; } return ld &gt;= rd?ld:rd;}BiTree pre=NULL;BOOL ISAVL(BiTree root){ int lcd=0,rcd=0; if(root!=NULL){ int l = ISAVL(root-&gt;LChild); // printf(\"pre: %d\\n\", pre-&gt;data); lcd=Deep(root-&gt;LChild); // 左子树的深度 rcd=Deep(root-&gt;RChild); // 右子树的深度 // printf(\"Deep(root-&gt;LChild): %d\\n\", Deep(root-&gt;LChild)); // printf(\"Deep(root-&gt;RChild): %d\\n\", Deep(root-&gt;RChild)); // printf(\"root: %d\\n\", root-&gt;data); if(abs(lcd-rcd)&gt;1){ // 条件1:每一个节点的左子树和右子树的高度差至多等于1 return FALSE; } if(pre!=NULL){ if(pre-&gt;data &gt; root-&gt;data){ // 条件2:中序遍历的前驱节点大于后面节点的值,就不是平衡二叉树 return FALSE; } } pre=root; int r = ISAVL(root-&gt;RChild); return l &amp;&amp; r; } return TRUE;} 4.3 运行情况截图 题目51编写代码完成：输入一棵二叉树，输出它的镜像。 5.1 算法设计思想 利用二叉树遍历递归的思想； 先交换左右子树； 然后分别镜像左右子树。 5.2 源代码 12345678910111213141516void swap(BiTree *node1, BiTree *node2){ BiTree temp; temp = *node1; *node1=*node2; *node2=temp;}void Mirror(BiTree *bt){ if((*bt)==NULL) return; swap(&amp;((*bt)-&gt;LChild), &amp;((*bt)-&gt;RChild)); Mirror(&amp;((*bt)-&gt;LChild)); Mirror(&amp;((*bt)-&gt;RChild));} 5.3 运行情况截图 题目6123输入：一个整数和一棵二叉树（树中结点的数据值为int）；输出：二叉树中结点值的和为输入的的整数的所有路径。路径的定义：从树的根结点开始往下一直到叶子结点形成的，称为一条路径。 6.1 算法设计思想 用先序遍历的方式访问节点，使用栈数组ResultStack存储满足条件的路径，使用栈SeqStack存储当前路径节点。 遍历二叉树的过程：按先序遍历顺序访问每一个节点，访问每个结点时，将结点添加到SeqStack中。 如果当前结点是叶子结点，则判断当前路径是否是符合条件的路径，符合条件的路径存入到栈数组ResultStack； 如果当前结点不是叶子结点，则递归当前节点的左右子节点。 6.2 源代码 123456789101112131415161718192021SeqStack ResultStack[10];int i=0;void SumPath(BiTree bt, SeqStack *S, int value){ BiTree p; Push(S, bt); if(bt){ if(!bt-&gt;LChild &amp;&amp; !bt-&gt;LChild){ if(value == bt-&gt;data){ ResultStack[i] = *S; i++; } } else{ SumPath(bt-&gt;LChild, S, value-bt-&gt;data); SumPath(bt-&gt;RChild, S, value-bt-&gt;data); } if(!IsEmpty(*S)) Pop(S, &amp;p); }} 6.3 运行情况截图 题目7123输入：一个整数数组，判断该数组是否为某二叉排序树的后序遍历序列；输出：若是，则返回true，若不是，则返回false； 假设该数组中的任何两个数值都互不相同。 7.1 算法设计思想 后续遍历中，最后一个数字是根结点，将数组中的数字分为两部分： 第一部分是左子树的值，它的值都比根结点小； 另一部分是右子树的值，它的值都比根结点大； 后续遍历（5,7,6,9,11,10,8）的最后一个结点是8，所以在这个数组中，5,7,6都比8小时该数的左子树；而9,11,10都比8大，是该树的右子树。 我们以同样的方法来分析其左子树和右子树5,7,6，其中6将左子树分为5和7两部分；10将右子树9和11分为两部分。所以这个序列就是一个后续遍历序列。但是（7,4,5,6）就不是它的一个后续遍历序列。因为6大于7，所以也就是说7,4,5都是其右子树，但是很不幸还有4比6小，所以不可能是一个后续遍历。 7.2 源代码 12345678910111213141516171819202122BOOL VerifySequenceOfBST(int *array,int length){ if(array==NULL || length&lt;=0) return FALSE; int root=array[length-1]; int i=0; //左子树的结点小于根节点； for(;i&lt;length-1;i++){ if(array[i]&gt;root) break; //找完了全部的左子树的序列； } int j=i;//右子树的结点大于根结点； for(;j&lt;length-1;j++){ if(array[j]&lt;root) return FALSE; } BOOL left=TRUE; if(i&gt;0) left=VerifySequenceOfBST(array,i); BOOL right=TRUE; if(j&lt;length-1) right=VerifySequenceOfBST(array+i,length-i-1); return left &amp;&amp; right;} 7.3 运行情况截图","link":"/2020/06/26/DS/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E5%8D%81/"},{"title":"数据结构进阶实训十二 图的存储结构","text":"Data structure advanced training course notes and algorithm exercises 数据结构进阶实训课程笔记和算法练习 Source Code 1.图的定义 图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V, E），其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。 对于图的定义，需要注意的几个地方： 线性表中把数据元素叫元素，树中将数据元素叫结点，图中将数据元素称之为顶点（Vertex）。 线性表中可以没有数据元素，称之为空表。树中可以没有结点，叫做空树。但在图结构中，不允许没有顶点。在定义中，若V是顶点的集合，则强调顶点集合V有穷非空。 线性表中，相邻的元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。 1.1 各种图定义 无向边：若顶点v_i到v_j之间的边没有方向，则称这条边为无向边（Edge），用无序偶对(v_i, v_j)来表示。 无向图：图中任意两顶点之间的边都是无向边。 有向图：若从顶点v_i到v_j之间的边有方向，则称这条边为有向边（Edge），也称为弧（Arc）。用有序偶来表示，v_i称为弧尾（Tail），v_j称为弧头（Head）。 有向图：图中任意两个顶点之间的边都是有向边。 在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。即不存在自环和重复边。 无向完全图：在无向图中，如果任意两顶点之间都存在边。含有n个顶点的无向完全图有\\frac{n*(n-1)}{2}条边。 有向完全图：在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧。含有n个顶点的有向完全图有n*(n-1)条边。 有很少条边或弧的图称为稀疏图反之称之为稠密图。 有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权（Weight）。这种带权的图通常称为网（Network）。 假设有两个图G=(V, \\{E\\})和G^`=(V^`, \\{E^`\\})，如果V^`\\subseteq V且E^`\\subseteq E，则称G^`为G的子图（Subgraph）。 1.2 连通图相关术语 在无向图G中，如果从顶点v到顶点v^`有路径，则称v和v^`是连通的。如果对于图中任意两个顶点v_i、v_j \\in E，v_i和v_j都是连通的，则称G是连通图（Connected Graph）。 无向图中的极大连通子图称为连通分量。 在有向图G中，如果对于每一对v_i、v_j \\in V、v_i\\ne v_j，从v_i到v_j和从v_j到v_i都存在路径，则称G是强连通图。有向图中的极大强连通子图称做有向图的强连通分量。 一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边。 如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一棵有向树。 一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。 2.图的存储结构图的存储方式一般有两类，用边的集合方式有邻接矩阵，用链式方式有邻接链表、十字链表、邻接多重表、边集数组等。 2.1 邻接矩阵图的邻接矩阵（Adjacency Matrix）存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。 代码实现： 123456789typedef char VertexType; /* 顶点类型应由用户定义 */typedef int EdgeType; /* 边上的权值类型应由用户定义 */#define MAXVEX 100 /* 最大顶点树，应由用户定义 */#define INFINITY 65535 /* 用65535来代表无穷大 */typedef struct{ VertexType vexs[MAXVEX]; /* 顶点表 */ EdgeType arc[MAXVEX][MAXVEX]; /* 邻接矩阵，可看作表 */ int numVertexes, numEdges; /* 图中当前的顶点数和边数 */}MGraph; 无向网图的创建代码： 1234567891011121314151617/* 建立无向图的邻接矩阵表示 */void CreateMGraph(MGraph *G){ int i, j, k, w; printf(\"输入顶点数和边数： \\n\"); scanf(\"%d%d\", &amp;G-&gt;numVertexes, &amp;G-&gt;numEdges); /* 输入顶点数和边数 */ for(i = 0; i&lt;G-&gt;numVertexes; i++) /* 读入顶点信息，建立顶点表 */ scanf(&amp;G-&gt;vexs[i]); for(i = 0; i&lt;G-&gt;numVertexes; i++) for(j = 0; j&lt;G-&gt;numVertexes; j++) G-&gt;arc[i][j] = INFINITY; /* 邻接矩阵初始化 */ for(k = 0; k&lt;G-&gt;numEdges; k++){ /* 读入numEdges条边，建立邻接矩阵 */ printf(\"输入边(vi, vj)上的下标i，下标j和权w: \\n\"); scanf(\"%d%d%d\", &amp;i, &amp;j, &amp;w); /* 输入边（vi, vj）上的权w */ G-&gt;arc[i][j]=w; G-&gt;arc[j][i]=G-&gt;arc[i][j]; /* 因为是无向图，矩阵对称 */ }} 从代码中可以得到，n个顶点和e条边的无向网图的创建，时间复杂度为O(n+n^2+e)，其中对邻接矩阵Garc的初始化耗费了O(n^2)的时间。 2.2 邻接表数组与链表相结合的存储方法称为邻接表（Adjacency List）。图中顶点用一个一维数组存储，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息。 代码实现： 123456789101112131415161718typedef char VertexType; /* 顶点类型由用户定义 */typedef int EdgeType; /* 边上的权值类型应由用户定义 */typedef struct EdgeNode{ /* 边表结点 */ int adjvex; /* 邻接点域，存储该顶点对应的下标 */ EdgeType weight; /* 用于存储权值，对于非网图可以不需要 */ struct EdgeNode *next; /* 链域，指向下一个邻接点 */}EdgeNode;typedef struct VertexNode{ /* 顶点表节点 */ VertexType data; /* 顶点域 */ EdgeNode *firstedge; /* 边表头指针 */}VertexNode, AdjList[MAXVEX];typedef struct{ AdjList adjList; int numVertexes, numEdges; /* 图中当前顶点数和边数 */}GraphAdjList; 无向图的邻接表创建代码如下： 123456789101112131415161718192021222324/* 建立图的邻接表结构 */void CreateALGraph(GraphAdjList *G){ int i, j, k; EdgeNode *e; printf(\"输入顶点数和边数： \\n\"); scanf(\"%d%d\", &amp;G-&gt;numVertexes, &amp;G-&gt;numEdges); /* 输入顶点数和边数 */ for(i=0; i&lt;G-&gt;numVertexes; i++){ /* 读入顶点信息，建立顶点表 */ scanf(&amp;G-&gt;adjList[i].data); /* 输入顶点信息 */ G-&gt;adjList[i].firstedge=NULL; /* 将边表置为空表 */ } for(k=0; k&lt;G-&gt;numEdges; k++){ /* 建立边表 */ printf(\"输入边(vi, vj)上的顶点序号：\\n\"); scanf(\"%d%d\", &amp;i, &amp;j); /* 输入边(vi, vj)上的顶点序号 */ e=(EdgeNode *)malloc(sizeof(EdgeNode)); /* 向内存申请空间 *//* 生成边表结点 */ e-&gt;adjvex=j; /* 邻接序号为j */ e-&gt;next=G-&gt;adjList[i].firstedge; /* 将e指针指向当前顶点指向的结点 */ G-&gt;adjList[i].firstedge=e; /* 将当前顶点的指针指向e */ e=(EdgeNode *)malloc(sizeof(EdgeNode)); /* 向内存申请空间 *//* 生成边表结点 */ e-&gt;adjvex=i; /* 邻接序号为i */ e-&gt;next=G-&gt;adjList[j].firstedge; /* 将e指针指向当前顶点指向的结点 */ G-&gt;adjList[j].firstedge=e; /* 将当前顶点的指针指向e */ }} 这里采用头插法来建立两顶点间关系，对于n个顶点e条边来说，很容易得出算法的时间复杂度是O(n+e)。 2.3 图的基本操作 为实现遍历必须设置访问标志数组，以防止走回路或未访问到。 图的遍历规律有两种：深度优先遍历DFS和广度优先遍历BFS。可用邻接矩阵和邻接表实现。 DFS算法是以递归技术为支持，BFS算法是以队列技术为支持。 2.4 图的应用图的遍历算法是图应用的重要基础。求解生成树、最小生成树、连通分量、拓扑排序、关键路径、单源最短路径及所有顶点之间的最短路径的重要算法应用。 3.建立图的邻接矩阵存储3.1 有向图，无向图，有向网，无向网 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#define MAX_VERtEX_NUM 20 //顶点的最大个数#define VRType int //表示顶点之间的关系的变量类型#define InfoType char //存储弧或者边额外信息的指针变量类型#define VertexType int //图中顶点的数据类型typedef enum{DG=1,DN=2,UDG=3,UDN=4}GraphKind; //枚举图的 4 种类型typedef struct { VRType adj; //对于无权图，用 1 或 0 表示是否相邻；对于带权图，直接为权值。 InfoType *info; //弧或边额外含有的信息指针}ArcCell, AdjMatrix[MAX_VERtEX_NUM][MAX_VERtEX_NUM];typedef struct { VertexType vexs[MAX_VERtEX_NUM]; //存储图中顶点数据 AdjMatrix arcs; //二维数组，记录顶点之间的关系 int vexnum, arcnum; //记录图的顶点数和弧（边）数 GraphKind kind; //记录图的种类}MGraph;//根据顶点本身数据，判断出顶点在二维数组中的位置int LocateVex(MGraph * G,VertexType v){ int i=0; //遍历一维数组，找到变量v for (; i&lt;G-&gt;vexnum; i++) { if (G-&gt;vexs[i]==v) { break; } } //如果找不到，输出提示语句，返回-1 if (i&gt;G-&gt;vexnum) { printf(\"no such vertex.\\n\"); return -1; } return i;}//构造有向图void CreateDG(MGraph *G){ //输入图含有的顶点数和弧的个数 printf(\"Enter the number of vertices and edges: \"); scanf(\"%d%d\",&amp;(G-&gt;vexnum),&amp;(G-&gt;arcnum)); //依次输入顶点本身的数据 printf(\"Please enter all vertices: \"); for (int i=0; i&lt;G-&gt;vexnum; i++) { scanf(\"%d\",&amp;(G-&gt;vexs[i])); } //初始化二维矩阵，全部归0，指针指向NULL for (int i=0; i&lt;G-&gt;vexnum; i++) { for (int j=0; j&lt;G-&gt;vexnum; j++) { G-&gt;arcs[i][j].adj=0; G-&gt;arcs[i][j].info=NULL; } } //在二维数组中添加弧的数据 for (int i=0; i&lt;G-&gt;arcnum; i++) { int v1,v2; //输入弧头和弧尾 printf(\"Enter arc head and arc tail: \"); scanf(\"%d%d\", &amp;v1, &amp;v2); //确定顶点位置 int n=LocateVex(G, v1); int m=LocateVex(G, v2); //排除错误数据 if (m==-1 ||n==-1) { printf(\"no this vertex\\n\"); return; } //将正确的弧的数据加入二维数组 G-&gt;arcs[n][m].adj=1; }}//构造无向图void CreateDN(MGraph *G){ printf(\"Enter the number of vertices and edges: \"); scanf(\"%d%d\", &amp;(G-&gt;vexnum),&amp;(G-&gt;arcnum)); printf(\"Please enter all vertices: \"); for (int i=0; i&lt;G-&gt;vexnum; i++) { scanf(\"%d\", &amp;(G-&gt;vexs[i])); } for (int i=0; i&lt;G-&gt;vexnum; i++) { for (int j=0; j&lt;G-&gt;vexnum; j++) { G-&gt;arcs[i][j].adj=0; G-&gt;arcs[i][j].info=NULL; } } for (int i=0; i&lt;G-&gt;arcnum; i++) { int v1,v2; printf(\"Enter the subscript i and j on the side (vi, vj):\"); scanf(\"%d%d\", &amp;v1,&amp;v2); int n=LocateVex(G, v1); int m=LocateVex(G, v2); if (m==-1 ||n==-1) { printf(\"no this vertex\\n\"); return; } G-&gt;arcs[n][m].adj=1; G-&gt;arcs[m][n].adj=1; //无向图的二阶矩阵沿主对角线对称 }}//构造有向网，和有向图不同的是二阶矩阵中存储的是权值。void CreateUDG(MGraph *G){ printf(\"Enter the number of vertices and edges: \"); scanf(\"%d%d\",&amp;(G-&gt;vexnum),&amp;(G-&gt;arcnum)); printf(\"Please enter all vertices: \"); for (int i=0; i&lt;G-&gt;vexnum; i++) { scanf(\"%d\",&amp;(G-&gt;vexs[i])); } for (int i=0; i&lt;G-&gt;vexnum; i++) { for (int j=0; j&lt;G-&gt;vexnum; j++) { G-&gt;arcs[i][j].adj=0; G-&gt;arcs[i][j].info=NULL; } } for (int i=0; i&lt;G-&gt;arcnum; i++) { int v1,v2,w; printf(\"Enter the arc head, arc tail and the weight of this edge: \"); scanf(\"%d%d%d\",&amp;v1,&amp;v2,&amp;w); int n=LocateVex(G, v1); int m=LocateVex(G, v2); if (m==-1 ||n==-1) { printf(\"no this vertex\\n\"); return; } G-&gt;arcs[n][m].adj=w; }}//构造无向网。和无向图唯一的区别就是二阶矩阵中存储的是权值void CreateUDN(MGraph* G){ printf(\"Enter the number of vertices and edges: \"); scanf(\"%d,%d\",&amp;(G-&gt;vexnum),&amp;(G-&gt;arcnum)); printf(\"Please enter all vertices: \"); for (int i=0; i&lt;G-&gt;vexnum; i++) { scanf(\"%d\",&amp;(G-&gt;vexs[i])); } for (int i=0; i&lt;G-&gt;vexnum; i++) { for (int j=0; j&lt;G-&gt;vexnum; j++) { G-&gt;arcs[i][j].adj=0; G-&gt;arcs[i][j].info=NULL; } } for (int i=0; i&lt;G-&gt;arcnum; i++) { int v1,v2,w; printf(\"Enter the two vertices of the edge and the weight of this edge: \"); scanf(\"%d%d%d\",&amp;v1,&amp;v2,&amp;w); int m=LocateVex(G, v1); int n=LocateVex(G, v2); if (m==-1 ||n==-1) { printf(\"no this vertex\\n\"); return; } G-&gt;arcs[n][m].adj=w; G-&gt;arcs[m][n].adj=w; //矩阵对称 }} 4.邻接矩阵的深度和广度优先搜索12345678写出上述建立图的深度和广度优先搜索序列。 示例 v1 / \\ v2 v3 / \\ / v4 -- v5程序运行将以这个图作为输入。 4.1 算法设计思想 深度优先搜索 深度优先搜索的过程类似于树的先序遍历 所谓深度优先搜索，是从图中的一个顶点出发，每次遍历当前访问顶点的临界点，一直到访问的顶点没有未被访问过的临界点为止。然后采用依次回退的方式，查看来的路上每一个顶点是否有其它未被访问的临界点。访问完成后，判断图中的顶点是否已经全部遍历完成，如果没有，以未访问的顶点为起始点，重复上述过程。 深度优先搜索是一个不断回溯的过程。 广度优先搜索 广度优先搜索类似于树的层次遍历 从图中的某一顶点出发，遍历每一个顶点时，依次遍历其所有的邻接点，然后再从这些邻接点出发，同样依次访问它们的邻接点。按照此过程，直到图中所有被访问过的顶点的邻接点都被访问到。 最后还需要做的操作就是查看图中是否存在尚未被访问的顶点，若有，则以该顶点为起始点，重复上述遍历的过程。 4.2 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119typedef enum{false,true}bool; //定义bool型常量bool visited[MAX_VERtEX_NUM]; //设置全局数组，记录标记顶点是否被访问过typedef struct Queue{ //广度优先搜索的实现需要借助队列 VertexType data; struct Queue * next;}Queue;int FirstAdjVex(MGraph G,int v){ //查找与数组下标为v的顶点之间有边的顶点，返回它在数组中的下标 for(int i = 0; i&lt;G.vexnum; i++){ if( G.arcs[v][i].adj ){ return i; } } return -1;}int NextAdjVex(MGraph G,int v,int w){ //从前一个访问位置w的下一个位置开始，查找之间有边的顶点 for(int i = w+1; i&lt;G.vexnum; i++){ if(G.arcs[v][i].adj){ return i; } } return -1;}void visitVex(MGraph G, int v){ printf(\"%d \",G.vexs[v]);}void DFS(MGraph G,int v){ visited[v] = true;//标记为true visitVex( G, v); //访问第v 个顶点 //从该顶点的第一个边开始，一直到最后一个边，对处于边另一端的顶点调用DFS函数 for(int w = FirstAdjVex(G,v); w&gt;=0; w = NextAdjVex(G,v,w)){ //如果该顶点的标记位false，证明未被访问，调用深度优先搜索函数 if(!visited[w]){ DFS(G,w); } }}//深度优先搜索void DFSTraverse(MGraph G){ int v; //将用做标记的visit数组初始化为false for( v = 0; v &lt; G.vexnum; ++v){ visited[v] = false; } //对于每个标记为false的顶点调用深度优先搜索函数 for( v = 0; v &lt; G.vexnum; v++){ //如果该顶点的标记位为false，则调用深度优先搜索函数 if(!visited[v]){ DFS( G, v); } }}/* 队列操作 *///初始化队列void InitQueue(Queue ** Q){ (*Q)=(Queue*)malloc(sizeof(Queue)); (*Q)-&gt;next=NULL;}//顶点元素v进队列void EnQueue(Queue **Q,VertexType v){ Queue * element=(Queue*)malloc(sizeof(Queue)); element-&gt;data=v; element-&gt;next = NULL; Queue * temp=(*Q); while (temp-&gt;next!=NULL) { temp=temp-&gt;next; } temp-&gt;next=element;}//队头元素出队列void DeQueue(Queue **Q,int *u){ (*u)=(*Q)-&gt;next-&gt;data; (*Q)-&gt;next=(*Q)-&gt;next-&gt;next;}//判断队列是否为空bool QueueEmpty(Queue *Q){ if (Q-&gt;next==NULL) { return true; } return false;}//广度优先搜索void BFSTraverse(MGraph G){ int v; //将用做标记的visit数组初始化为false for( v = 0; v &lt; G.vexnum; ++v){ visited[v] = false; } //对于每个标记为false的顶点调用深度优先搜索函数 Queue * Q; InitQueue(&amp;Q); for( v = 0; v &lt; G.vexnum; v++){ if(!visited[v]){ visited[v]=true; visitVex(G, v); EnQueue(&amp;Q, G.vexs[v]); while (!QueueEmpty(Q)) { int u; DeQueue(&amp;Q, &amp;u); u=LocateVex(&amp;G, u); for (int w=FirstAdjVex(G, u); w&gt;=0; w=NextAdjVex(G, u, w)) { if (!visited[w]) { visited[w]=true; visitVex(G, w); EnQueue(&amp;Q, G.vexs[w]); } } } } }} 4.3 运行情况截图以下演示的是图采用邻接矩阵存储结构的有向图和无向图的建立。 5.建立图的邻接表存储5.1 有向图，无向图，有向网，无向网123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#define MAX_VERTEX_NUM 20//最大顶点个数#define VertexType int//顶点数据的类型#define InfoType int//图中弧或者边包含的信息的类型typedef enum{DG=1,DN=2,UDG=3,UDN=4}GraphKind; //枚举图的 4 种类型typedef enum{false,true}bool; //定义bool型常量typedef struct ArcNode{ int adjvex;//邻接点在数组中的位置下标 struct ArcNode * nextarc;//指向下一个邻接点的指针 int weight; //权值 InfoType * info;//信息域}ArcNode;typedef struct VNode{ VertexType data;//顶点的数据域 ArcNode * firstarc;//指向邻接点的指针}VNode, AdjList[MAX_VERTEX_NUM];//存储各链表头结点的数组typedef struct { AdjList vertices;//图中顶点的数组 int vexnum,arcnum;//记录图中顶点数和边或弧数 GraphKind kind;//记录图的种类}ALGraph;/* 建立有向图图的邻接表结构 */void CreateDGALGraph(ALGraph *G){ int i, j, k; ArcNode *e; printf(\"Enter the number of vertices and edges: \"); scanf(\"%d%d\", &amp;G-&gt;vexnum, &amp;G-&gt;arcnum); /* 输入顶点数和边数 */ printf(\"Please enter all vertices: \"); for(i=0; i&lt;G-&gt;vexnum; i++){ /* 读入顶点信息，建立顶点表 */ scanf(\"%d\", &amp;G-&gt;vertices[i].data); /* 输入顶点信息 */ G-&gt;vertices[i].firstarc=NULL; /* 将边表置为空表 */ } for(k=0; k&lt;G-&gt;arcnum; k++){ /* 建立边表 */ printf(\"Enter the vertex number on the edge (vi, vj): \"); scanf(\"%d%d\", &amp;i, &amp;j); /* 输入边(vi, vj)上的顶点序号 */ e=(ArcNode *)malloc(sizeof(ArcNode)); /* 向内存申请空间 *//* 生成边表结点 */ e-&gt;adjvex=j; /* 邻接序号为j */ /* 头插法 */ e-&gt;nextarc=G-&gt;vertices[i].firstarc; /* 将e指针指向当前顶点指向的结点 */ G-&gt;vertices[i].firstarc=e; /* 将当前顶点的指针指向e */ }}/* 建立无向图图的邻接表结构 */void CreateDNALGraph(ALGraph *G){ int i, j, k; ArcNode *e; printf(\"Enter the number of vertices and edges: \"); scanf(\"%d%d\", &amp;G-&gt;vexnum, &amp;G-&gt;arcnum); /* 输入顶点数和边数 */ printf(\"Please enter all vertices: \"); for(i=0; i&lt;G-&gt;vexnum; i++){ /* 读入顶点信息，建立顶点表 */ scanf(\"%d\", &amp;G-&gt;vertices[i].data); /* 输入顶点信息 */ G-&gt;vertices[i].firstarc=NULL; /* 将边表置为空表 */ } for(k=0; k&lt;G-&gt;arcnum; k++){ /* 建立边表 */ printf(\"Enter the vertex number on the edge (vi, vj): \"); scanf(\"%d%d\", &amp;i, &amp;j); /* 输入边(vi, vj)上的顶点序号 */ e=(ArcNode *)malloc(sizeof(ArcNode)); /* 向内存申请空间 *//* 生成边表结点 */ e-&gt;adjvex=j; /* 邻接序号为j */ /* 头插法 */ e-&gt;nextarc=G-&gt;vertices[i].firstarc; /* 将e指针指向当前顶点指向的结点 */ G-&gt;vertices[i].firstarc=e; /* 将当前顶点的指针指向e */ e=(ArcNode *)malloc(sizeof(ArcNode)); /* 向内存申请空间 *//* 生成边表结点 */ e-&gt;adjvex=i; /* 邻接序号为i */ e-&gt;nextarc=G-&gt;vertices[j].firstarc; /* 将e指针指向当前顶点指向的结点 */ G-&gt;vertices[j].firstarc=e; /* 将当前顶点的指针指向e */ }}/* 建立有向网的邻接表结构 */void CreateUDGALGraph(ALGraph *G){ int i, j, k, w; ArcNode *e; printf(\"Enter the number of vertices and edges: \"); scanf(\"%d%d\", &amp;G-&gt;vexnum, &amp;G-&gt;arcnum); /* 输入顶点数和边数 */ printf(\"Please enter all vertices: \"); for(i=0; i&lt;G-&gt;vexnum; i++){ /* 读入顶点信息，建立顶点表 */ scanf(\"%d\", &amp;G-&gt;vertices[i].data); /* 输入顶点信息 */ G-&gt;vertices[i].firstarc=NULL; /* 将边表置为空表 */ } for(k=0; k&lt;G-&gt;arcnum; k++){ /* 建立边表 */ printf(\"Enter the arc head, arc tail and the weight of this edge: \"); scanf(\"%d%d%d\", &amp;i, &amp;j, &amp;w); /* 输入边(vi, vj)上的顶点序号 */ e=(ArcNode *)malloc(sizeof(ArcNode)); /* 向内存申请空间 *//* 生成边表结点 */ e-&gt;adjvex=j; /* 邻接序号为j */ e-&gt;weight=w; /* 头插法 */ e-&gt;nextarc=G-&gt;vertices[i].firstarc; /* 将e指针指向当前顶点指向的结点 */ G-&gt;vertices[i].firstarc=e; /* 将当前顶点的指针指向e */ }}/* 建立无向网的邻接表结构 */void CreateUDNALGraph(ALGraph *G){ int i, j, k, w; ArcNode *e; printf(\"Enter the number of vertices and edges: \"); scanf(\"%d%d\", &amp;G-&gt;vexnum, &amp;G-&gt;arcnum); /* 输入顶点数和边数 */ printf(\"Please enter all vertices: \"); for(i=0; i&lt;G-&gt;vexnum; i++){ /* 读入顶点信息，建立顶点表 */ scanf(\"%d\", &amp;G-&gt;vertices[i].data); /* 输入顶点信息 */ G-&gt;vertices[i].firstarc=NULL; /* 将边表置为空表 */ } for(k=0; k&lt;G-&gt;arcnum; k++){ /* 建立边表 */ printf(\"Enter the arc head, arc tail and the weight of this edge: \"); scanf(\"%d%d%d\", &amp;i, &amp;j, &amp;w); /* 输入边(vi, vj)上的顶点序号 */ e=(ArcNode *)malloc(sizeof(ArcNode)); /* 向内存申请空间 *//* 生成边表结点 */ e-&gt;adjvex=j; /* 邻接序号为j */ e-&gt;weight=w; /* 头插法 */ e-&gt;nextarc=G-&gt;vertices[i].firstarc; /* 将e指针指向当前顶点指向的结点 */ G-&gt;vertices[i].firstarc=e; /* 将当前顶点的指针指向e */ e=(ArcNode *)malloc(sizeof(ArcNode)); /* 向内存申请空间 *//* 生成边表结点 */ e-&gt;adjvex=i; /* 邻接序号为i */ e-&gt;weight=w; e-&gt;nextarc=G-&gt;vertices[j].firstarc; /* 将e指针指向当前顶点指向的结点 */ G-&gt;vertices[j].firstarc=e; /* 将当前顶点的指针指向e */ }} 6.邻接表的广度和深度优先搜索123456写出上述建立图的深度和广度优先搜索序列。 示例 v0 / \\ v1 -- v2程序运行将以这个图作为输入。 6.1 源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//DFS遍历void DFS(ALGraph *g,int i,int *visited){ ArcNode *p; visited[i]=1; printf(\"%d \",g-&gt;vertices[i].data); p=g-&gt;vertices[i].firstarc; while( p ){ if(!visited[p-&gt;adjvex]){ DFS(g,p-&gt;adjvex,visited); } p=p-&gt;nextarc; }}void TraDFS(ALGraph *g){ int i; int visited[MAX_VERTEX_NUM]; for(i=0;i&lt;g-&gt;vexnum;i++){ visited[i]=0; } for(i=0;i&lt;g-&gt;vexnum;i++){ if(!visited[i]){ DFS(g,i,visited); } }}//BFS遍历void TraBFS(ALGraph *g){ int i,j; Queue *q; int visited[MAX_VERTEX_NUM]; for(i=0; i&lt;g-&gt;vexnum; i++){ visited[i]=0; } InitQueue(&amp;q); for(i=0; i&lt;g-&gt;vexnum;i++){ if(!visited[i]){ printf(\"%d \",g-&gt;vertices[i].data); visited[i]=1; EnQueue(&amp;q, i); while(!QueueEmpty(q)){ DeQueue(&amp;q,&amp;i); ArcNode *p = g-&gt;vertices[i].firstarc; while( p ){ if(!visited[p-&gt;adjvex]){ printf(\"%d \",g-&gt;vertices[p-&gt;adjvex].data); visited[p-&gt;adjvex]=1; EnQueue(&amp;q,p-&gt;adjvex); } p=p-&gt;nextarc; } } } }} 6.2 运行截图以下演示的是图采用邻接表存储结构的无向图和有向网的建立。","link":"/2020/07/07/DS/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E5%8D%81%E4%BA%8C/"},{"title":"Hexo博客迁移","text":"Hexo用户指南 - 博客迁移GitHub+Hexo搭建博客的过程比较平滑，但是它的配置却非常耗时，一旦电脑出现问题或者需要在另外一台电脑上写博客，那么Hexo博客的迁移非常就让人头疼。下面参考其他博客的方法，针对类似问题，整理出一个能在平时就管理重要文件的方法，方便随时迁移。 解决类似问题 创建Git分支将Hexo博客迁移到其它电脑换了电脑如何使用hexo继续写博客 我整理了网上的方法并根据自己的实际情况总结出了我的解决方法 操作步骤1.基础配置电脑的基础配置还是要有的，比如： Git客户端NodeJS生成SSH密钥等 2.源文件拷贝Hexo博客系统中影响迁移的只有一部分文件和文件夹，所以只需要备份它们即可 文件（夹） 说明 scaffolds/ 博客文章的模版 source/ 所有博客文章，以及about、tags、categories等page themes/ 网站的主题所在文件夹 .gitignore 在push时需要忽略的文件和文件夹 _config.yml 站点配置文件 package.json 依赖包的名称和版本号 我们要做的就是通过各种方式备份这些文件和文件夹，比如说以下两种静态备份方式： 1.通过U盘或移动硬盘保存2.通过网盘保存 3.本地配置 3.1 创建目录 创建一个名为&quot;自己的git用户名.github.io&quot;的文件夹（推荐用这个用户名以免后面遇到问题）， 3.2 初始化 Hexo 1$ hexo init 3.3 初始化git本地仓库 1$ git init 3.4 复制文件到指定目录 把备份过的文件和文件夹都复制到hexo文件夹下完成后hexo的目录结构应该如下123456789101112.deploy_git.gitnode_modulespublicscaffoldsscourcethemes.gitignore_config.ymldb.jsonpackage.jsonpackage-lock.json 4.测试1$ hexo s 这时候浏览器基本可以看到博客了。 5.部署发布文章12345678910// 清除缓存 网页正常情况下可以忽略此条命令$ hexo clean// 生成静态网页$ hexo g // 开始部署$ hexo d$ hexo g -d","link":"/2020/06/21/Hexo/Hexo%E8%BF%81%E7%A7%BB/"},{"title":"数据结构进阶实训十一 树","text":"Data structure advanced training course notes and algorithm exercises 数据结构进阶实训课程笔记和算法练习 Source Code C语言中文网 题目11建立树的孩子兄弟表示法存储 1.1 算法设计思想 孩子兄弟表示法：任意一棵树，它的节点的第一个孩子如果存在就是唯一的，它的右兄弟存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟 给定一颗树，可以找到唯一的一颗二叉树与之对应，因此，可以用一颗二叉树来表示一颗树的结构。如图： 123456789101112131415 A A /​ / | \\ B / \\​ B C D E C \\ \\ / \\ | F D /E F G G /​ / | \\ H \\​ H I J I \\​ J 和二叉树建树的方法相同，递归的思想，先建立左子树，左子树建立完（即遇到结束标志字符’#’），退层建立右子树。 所以按照将树转化为二叉树，然后输入先序序列来建这棵树。 1.2 源代码 123456789101112131415161718192021#define ElemType chartypedef struct CSNode{ ElemType data; struct CSNode *firstchild, *nextsibling;}CSNode, *CSTree;// eg. ABE#F##C#DGH#I#J#####void CreatCSTree(CSTree *t){ ElemType ch; scanf(\"%c\", &amp;ch); if(ch=='#') { (*t)=NULL; } else { (*t)=(CSTree)malloc(sizeof(CSNode)); (*t)-&gt;data=ch; CreatCSTree(&amp;((*t)-&gt;firstchild)); CreatCSTree(&amp;((*t)-&gt;nextsibling)); }} 1.3 运行情况截图 题目21在树的孩子兄弟表示法下，求取树T的高度。 2.1 算法设计思想 既然我们可以将树转化为孩子兄弟表示法，这种方法用二叉链表的形式实现，那么我们考虑用求二叉树深度的方法来求树的深度。 区别在于，孩子兄弟表示法中每个节点的右子树是这个节点的兄弟，在原树中并不占深度，所以只需修改算法的求右子树高度的部分即可。 2.2 源代码 123456789// eg. ABE#F##C#DGH#I#J#####int depth(CSTree t){ if(t){ int fd = depth(t-&gt;firstchild)+1; int nd = depth(t-&gt;nextsibling); return fd&gt;nd? fd:nd; }} 2.3 运行情况截图 题目31树采用孩子兄弟表示法存储。 fch data nsib level 12345678910编写算法，将树中所有结点层次值置入每个结点的level域，并要求由根开始逐层输出树中的各条边；边的输出格式为（ki,kj） 示例 A 转化为 A / | \\ 孩子兄弟表示 / B C D B / \\ | / \\ E F G E C \\ / \\ F G D 3.1 算法设计思想 要输出树中各边，存在边，即两节点在树中是父子关系 在孩子兄弟表示法中，就是与这个节点的左孩子节点，和左孩子节点的所有右孩子节点有边， 所以一个递归打印当前节点和左孩子构成的边，另一个递归打印当前节点与其左孩子的所有右孩子节点所构成的边。 3.2 源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#define ElemType chartypedef struct CSNode{ ElemType data; struct CSNode *firstchild, *nextsibling; int level;}CSNode, *CSTree;// eg. ABE#F##CG##D###CSTree T;int layer(CSTree t, char x){ int cot = 0; if(t==NULL) return cot; else if(t-&gt;data==x){ cot = 1; return cot; } else{ if(layer(t-&gt;firstchild, x)){ cot = layer(t-&gt;firstchild, x)+1; return cot; } if(layer(t-&gt;nextsibling, x)){ cot = layer(t-&gt;nextsibling, x); return cot; } } return cot;}void CreatCSTree(CSTree *t){ ElemType ch; scanf(\"%c\", &amp;ch); if(ch=='#') { (*t)=NULL; } else { (*t)=(CSTree)malloc(sizeof(CSNode)); (*t)-&gt;data=ch; (*t)-&gt;level=layer(T, ch); CreatCSTree(&amp;((*t)-&gt;firstchild)); CreatCSTree(&amp;((*t)-&gt;nextsibling)); }}void borderNextSibling(CSTree t, CSTree nt){ printf(\"%c%c, \", t-&gt;data, nt-&gt;data); if(nt-&gt;nextsibling) borderNextSibling(t, nt-&gt;nextsibling);}void border(CSTree t){ if(t){ if(t-&gt;firstchild){ printf(\"%c%c, \", t-&gt;data, t-&gt;firstchild-&gt;data); if(t-&gt;firstchild-&gt;nextsibling) borderNextSibling(t, t-&gt;firstchild-&gt;nextsibling); } border(t-&gt;firstchild); border(t-&gt;nextsibling); }} 3.3 运行情况截图 题目41234567891011已知树采用孩子兄弟表示法表示试编写算法按如下的凹入方式打印树。 示例 A A / | \\ B B C D E / \\ | F E F G C G D利用树的先序遍历完成；细化访问visit（）操作：先打空格，在输出结点；打印输出的空格数目和结点所在的层次号有关。 4.1 算法设计思想 首先不考虑前面的每个元素前面的空格，得到打印序列是ABEFCGD，发现这是孩子兄弟表示法的前序遍历结果，然后利用上面第二题的算法获得每个元素的层号，然后打印空格，就可以实现凹入方式打印这棵树了。 4.2 源代码 12345678910111213141516171819202122232425262728293031323334CSTree T; // 全局变量// eg. ABE#F##CG##D###int layer(CSTree t, char x){ int cot = 0; if(t==NULL) return cot; else if(t-&gt;data==x){ cot = 1; return cot; } else{ if(layer(t-&gt;firstchild, x)){ cot = layer(t-&gt;firstchild, x)+1; return cot; } if(layer(t-&gt;nextsibling, x)){ cot = layer(t-&gt;nextsibling, x); return cot; } } return cot;}void visit(CSTree t){ int i; if(t){ for(i=1; i&lt;layer(T, t-&gt;data); i++) printf(\" \"); printf(\"%c\\n\", t-&gt;data); visit(t-&gt;firstchild); visit(t-&gt;nextsibling); }} 4.3 运行情况截图","link":"/2020/07/04/DS/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E5%8D%81%E4%B8%80/"},{"title":"Icarus主题美化","text":"Icarus用户指南 - 主题美化Icarus的主题样式编码文件为themes/icarus/layout/layout.jsx。此文件定义了站点全局的样式设置。本文详细介绍了本主题针对文章分类的详细配置说明。 自定义 Icarus 主题 主题默认是三列排列，第一列是个人信息，第二列是文章的简介或者内容，第三列是标签云等组件。 在首页的时候阅读体验也很好，但是在文章页面查看全文的时候就感觉文章内容显示有些太少。 于是打算在文章页面隐藏掉右边的侧边栏。 我想应该是我用的icarus主题版本是3+，网上都是2+版本的教程，没有找到对应教程。 于是就自己阅读源码自己解决了问题。 默认配置也基本能用了，但是有一个痛点就是，阅读模式文章宽度太短了，还是根据个人习惯做下配置。 解决方案 1. 首先找到了控制侧边栏的代码文件在 ../themes/icarus/layout/layout.jsx 源码为(版本差别，大同小异)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445const { Component } = require('inferno');const classname = require('hexo-component-inferno/lib/util/classname');const Head = require('./common/head');const Navbar = require('./common/navbar');const Widgets = require('./common/widgets');const Footer = require('./common/footer');const Scripts = require('./common/scripts');const Search = require('./common/search');module.exports = class extends Component { render() { const { env, site, config, page, helper, body } = this.props; const language = page.lang || page.language || config.language; const columnCount = Widgets.getColumnCount(config.widgets); return &lt;html lang={language ? language.substr(0, 2) : ''}&gt; &lt;Head env={env} site={site} config={config} helper={helper} page={page} /&gt; &lt;body class={`is-${columnCount}-column`}&gt; &lt;Navbar config={config} helper={helper} page={page} /&gt; &lt;section class=\"section\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"columns\"&gt; &lt;div class={classname({ column: true, 'order-2': true, 'column-main': true, 'is-12': columnCount === 1, 'is-8-tablet is-8-desktop is-8-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3 })} dangerouslySetInnerHTML={{ __html: body }}&gt;&lt;/div&gt; &lt;Widgets site={site} config={config} helper={helper} page={page} position={'left'} /&gt; &lt;Widgets site={site} config={config} helper={helper} page={page} position={'right'} /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;Footer config={config} helper={helper} /&gt; &lt;Scripts site={site} config={config} helper={helper} page={page} /&gt; &lt;Search config={config} helper={helper} /&gt; &lt;/body&gt; &lt;/html&gt;; }}; 三栏分别为：（从第24行开始） 12345678&lt;div class={classname({ column: true, 'order-2': true, 'column-main': true, 'is-12': columnCount === 1, 'is-8-tablet is-8-desktop is-8-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3 })} dangerouslySetInnerHTML={{ __html: body }}&gt;&lt;/div&gt; // 中 1&lt;Widgets site={site} config={config} helper={helper} page={page} position={'left'} /&gt; // 左 1&lt;Widgets site={site} config={config} helper={helper} page={page} position={'right'} /&gt; //右 2. 那能不能逻辑改为只有主页才显示右边侧栏呢？ 我从源码中分析到，函数返回return的就是样式页面。既然找到了这3栏，我可以通过改变返回值，就可以达到控制主体样式的目的。 所以加一个判断语句即可： 12345678if(page.path==='index.html'){ // index.html即主页面 // 返回3栏 return '...';}else{ // 返回2栏，改变宽度即可 return '...';} 上面代码只会在主页面显示3栏，后续博主我在使用的过程中发现有且只有主页面是3栏；换页、分类页等页面就会变成2栏！ 因为我们的代码只为主页面返回3栏！ 后来在读源码后，找到了解决方法：在 ../themes/icarus/layout/layout.jsx 文件中第16行添加如下代码：12console.log(\"Page\", page);console.log(\"Page.path: \", page.path);这样就可以查看页面具体信息；控制台执行hexo g -d后，会出现以下信息；由于每个page信息可能会很多，尤其是博客文章内容过多，就会使page包含的信息过多，会使控制台信息溢出；所以我只选择其中一个较短的信息展示如下： 2.1 page信息12345678910111213Page: { base: 'tags/Hexo/', total: 1, current: 1, current_url: 'tags/Hexo/', posts: _Query { data: [ [_Document], [_Document] ], length: 2 }, prev: 0, prev_link: '', next: 0, next_link: '', tag: 'Hexo', path: 'tags/Hexo/index.html', lang: 'en', canonical_path: 'tags/Hexo/index.html' } 2.2 page.path信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354ubuntu~/github/mysticalguest.github.io$ hexo g -dInferno is in development mode.INFO ======================================= ██╗ ██████╗ █████╗ ██████╗ ██╗ ██╗███████╗ ██║██╔════╝██╔══██╗██╔══██╗██║ ██║██╔════╝ ██║██║ ███████║██████╔╝██║ ██║███████╗ ██║██║ ██╔══██║██╔══██╗██║ ██║╚════██║ ██║╚██████╗██║ ██║██║ ██║╚██████╔╝███████║ ╚═╝ ╚═════╝╚═╝ ╚═╝╚═╝ ╚═╝ ╚═════╝ ╚══════╝=============================================INFO === Checking package dependencies ===INFO === Checking the configuration file ===INFO === Registering Hexo extensions ===INFO Start processingINFO Files loaded in 6.76 sPage.path: 2020/06/18/ICARUS主题美化/Page.path: 2020/06/17/数据结构进阶实训八/Page.path: 2020/06/17/数据结构进阶实训五/Page.path: 2020/06/17/数据结构进阶实训二/Page.path: 2020/06/17/数据结构进阶实训一/Page.path: 2020/06/17/数据结构进阶实训六/Page.path: 2020/06/17/数据结构进阶实训七/Page.path: 2020/06/16/Java笔记文档2/Page.path: 2020/06/16/Java笔记文档1/Page.path: 2020/06/15/数据结构进阶实训三/Page.path: 2020/06/15/数据结构进阶实训四/Page.path: 2020/06/14/hello-world/Page.path: archives/index.htmlPage.path: archives/page/2/index.htmlPage.path: archives/2020/index.htmlPage.path: archives/2020/page/2/index.htmlPage.path: archives/2020/06/index.htmlPage.path: archives/2020/06/page/2/index.htmlPage.path: categories/配置/index.htmlPage.path: categories/Document-Compile/index.htmlPage.path: categories/主题/index.htmlPage.path: categories/算法/index.htmlPage.path: index.htmlPage.path: page/2/index.htmlPage.path: tags/Hexo/index.htmlPage.path: tags/Java/index.htmlPage.path: tags/C/index.htmlPage.path: categories/index.htmlPage.path: tags/index.htmlINFO 0 files generated in 3.37 sINFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder...INFO Copying files from extend dirs...位于分支 master无文件要提交，干净的工作区分支 'master' 设置为跟踪来自 'git@github.com:*/*.git' 的远程分支 'master'。Everything up-to-dateINFO Deploy done: git 从控制台打印出的信息，可以明显看出每个页面的详细路径信息；所以我们想要那些页面3栏都可以；12345678910var path = /\\Sindex.html/; if(page.path==='index.html' || path.test(page.path)){ // 返回3栏 return '...';}else{ // 返回2栏，改变宽度即可 return '...';} 这里我利用正则表达式，将非博客文章页面都设为3栏显示，大家可根据自己喜好自行对想要的页面设置指定栏数。 3. 其他修改逻辑 +表示添加代码，没有标记表示代码不做修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 从16行开始修改代码+ if(page.path==='index.html'){ return &lt;html lang={language ? language.substr(0, 2) : ''}&gt; &lt;Head env={env} site={site} config={config} helper={helper} page={page} /&gt; &lt;body class={`is-${columnCount}-column`}&gt; &lt;Navbar config={config} helper={helper} page={page} /&gt; &lt;section class=\"section\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"columns\"&gt; &lt;div class={classname({ column: true, 'order-2': true, 'column-main': true, 'is-12': columnCount === 1, 'is-8-tablet is-8-desktop is-8-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3 })} dangerouslySetInnerHTML={{ __html: body }}&gt;&lt;/div&gt; &lt;Widgets site={site} config={config} helper={helper} page={page} position={'left'} /&gt; &lt;Widgets site={site} config={config} helper={helper} page={page} position={'right'} /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;Footer config={config} helper={helper} /&gt; &lt;Scripts site={site} config={config} helper={helper} page={page} /&gt; &lt;Search config={config} helper={helper} /&gt; &lt;/body&gt; &lt;/html&gt;;+ }+ else{+ return &lt;html lang={language ? language.substr(0, 2) : ''}&gt;+ &lt;Head env={env} site={site} config={config} helper={helper} page={page} /&gt;+ &lt;body class={`is-${columnCount}-column`}&gt;+ &lt;Navbar config={config} helper={helper} page={page} /&gt;+ &lt;section class=\"section\"&gt;+ &lt;div class=\"container\"&gt;+ &lt;div class=\"columns\"&gt;+ &lt;div class={classname({+ column: true,+ 'order-2': true,+ 'column-main': true,+ 'is-12': columnCount === 1,+ 'is-8-tablet is-8-desktop is-10-widescreen': columnCount === 2+ })} dangerouslySetInnerHTML={{ __html: body }}&gt;&lt;/div&gt;+ &lt;Widgets site={site} config={config}helper={helper} page={page} position={'left'}/&gt;+ &lt;/div&gt;+ &lt;/div&gt;+ &lt;/section&gt;+ &lt;Footer config={config} helper={helper} /&gt;+ &lt;Scripts site={site} config={config} helper={helper} page={page} /&gt;+ &lt;Search config={config} helper={helper} /&gt;+ &lt;/body&gt;+ &lt;/html&gt;;+ } 好啦，大工告成！ 其中只有两处代码改动较大，让我们来看看吧！ 我们只是修改了栏数，但每一栏的宽度没有改变，这里更关注的是文章栏的宽度。具体修改代码下： 1234// 渲染相应栏的标签，只添加‘中’和‘左’// 根据自己的喜好可以选择任意组合，‘中’和‘右’也可以// 第45行'is-8-tablet is-8-desktop is-10-widescreen': columnCount === 2 即将原来的 is-8-widescreen修改为is-10-widescreen。 4. 下面详细解释一下代码 icarus 可以设置资料、toc、归档等等插件在文章的左侧或者右侧。也就是说，包括插件和文章在内，列数在1~3列不等： 无插件的时候，为1列；插件统一在左侧或右侧时，为2列；插件左、右侧都有时，为3列。Bulma 引擎将屏幕横向分为12份，所有元素按照自己的需求使用即可。 通过 layout或widget.jsx 文件，我们可以看到，对于插件而言： 如果屏幕分为2列，则插件的宽度为 is-4-widescreen，也即是4/12=33.33%的宽度；如果屏幕分为3列，则插件的宽度为 is-3-widescreen，也即是3/12=25%的宽度，两列插件占了50%宽。同样的，layout.jsx 文件针对文章也做了宽度限制： 如果屏幕分为1列，则文章的宽度为 is-12，也即是12/12=100%的宽度；如果屏幕分为2列，则文章的宽度为 is-8-widescreen，也即是8/12=66.66%的宽度；如果屏幕分为3列，则文章的宽度为 is-6-widescreen，也即是6/12=50%的宽度。 那么调整插件宽度的方法也就差不多想出来啦！","link":"/2020/06/21/Hexo/ICARUS%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"},{"title":"Java编译原理","text":"Java development notes document Source Code 解决的问题1在CMD上运行java文件时出现错误：找不到或者无法加载主类的问题。 解决方案 1. 首先写一个测试文件 12345public class TestDemo { public static void main(String args[]) { System.out.println(\"Run successfully!\"); }} 2. 通过cmd编译如下 2.1 通过命令：javac TestDemo.java将其编译成字节码文件。要运行一段Java源码，必须先将源码转换为class文件，class文件就是编译器编译之后供虚拟机解释执行的二进制字节码文件。 2.2 通过命令：java TestDemo将其运行，并打印输出结果。 从图中可以看出，在这种情况下编译是正常的。 3. 那么，我们修改刚开始的代码 在首行加入在java中最常见的package关键字。如下： 1234567package CourseExercise;public class TestDemo { public static void main(String args[]) { System.out.println(\"Run successfully!\"); }} 3.1 通过命令：javac TestDemo.java将其编译成字节码文件 在编译成字节码文件时，是没有问题的。也就是说，在当前文件目录下，可以成class文件。好的，继续往下进行。 3.2 通过命令： `java TestDemo` 尝试将其运行，并打印输出结果。 这个时候就会报错了。提示错误：找不到或无法加载主类。很明显，这个错误是由于在代码首行加入了package CourseExercise;造成的。 4. 那么，遇到这种问题该怎么解决呢 方法如下： 4.1 通过命令： `javac -d . TestDemo.java` 将目标文件编译成class文件。 说明： -d ：表示生成目录，设置编译生成的class文件保存路径，路径与定义的包名和层次相关。 . ：表示在当前目录中生成。 4.2 通过命令： `java CourseExercise/TestDemo` 或者 `java CourseExercise.TestDemo` 来运行程序。 4.3 通过命令： `javap -verbose TestDemo.class` 将class文件中的字节码转换为字节码指令。","link":"/2020/06/21/Java/Java%E7%AC%94%E8%AE%B0%E6%96%87%E6%A1%A31/"},{"title":"树的要点归纳","text":"数据结构第六章要点归纳 1.树的基础知识点1.1 树的相关概念 结点拥有的子树数称为节点的度（Degree）。 度为0的结点称为叶结点（Leaf）或终端结点；度不为0的结点称为非终端结点或分支节点。 除根节点之外，分支节点也称为内部结点。 树的度是树内部各结点的度的最大值。 如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。 森林是$m(m \\geq 0)$棵互不相交的树的集合。 1.2 树的存储结构 双亲表示法 孩子表示法 孩子兄弟表示法 1.3 二叉树的相关概念 斜树：所有的结点都只有左子树的二叉树叫左斜树。所有结点都只有右子树的二叉树叫右斜树。这二者统称为斜树。 满二叉树：在一颗二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。 完全二叉树：对一棵具有n个结点的二叉树按层序编号，如果编号为$i(1 \\leq i \\leq n)$的节点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。 完全二叉树的特点： ​ （1）叶子结点只能出现在最下两层。 ​ （2）最下层的叶子一定集中在左部连续位置。 ​ （3）倒数二层，若有叶子结点，一定都在右部连续位置。 ​ （4）如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况。 ​ （5）同样结点数的二叉树，完全二叉树的深度最小。 1.4 二叉树的存储结构 顺序存储结构 二叉链表 2.二叉树5个基本性质及灵活应用 二叉树的定义：二叉树(Binary Tree)是n(n≥0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根节点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。 2.1 性质1在二叉树的第i层上至多有$2^{i-1}$个结点（$i \\geq 1$）。 2.2 性质2深度为k的二叉树至多有$2^k-1$个结点（$k \\geq1$）。 2.3 性质3对任何一棵二叉树T，如果其终端结点数为$n_0$，度为2的结点数为$n_2$，则$n_0=n_2+1$。 2.4 性质4具有n个结点的完全二叉树的深度为$\\lfloor log_2{n} \\rfloor +1$ （$\\lfloor x \\rfloor$表示不大于x的最大整数）。 2.5 性质5如果对一棵有$n$个结点的完全二叉树（其深度为$\\lfloor log_2{n} \\rfloor +1$）的结点按层序编号（从第1层到第$\\lfloor log_2{n} \\rfloor+1$层，每层从左到右），对任一结点$i(1 \\leq i \\leq n)$有： 如果$i=1$，则节点$i$是二叉树的根，无双亲；如果$i \\geq 1$，则其双亲是节点$\\lfloor \\frac{i}{2} \\rfloor$。 如果$2i &gt; n$，则结点$i$无左孩子（结点i为叶子节点）；否则其左孩子是结点$2i$。 如果$2i+1 &gt; n$，则结点$i$无右孩子；否则其右孩子是结点$2i+1$。 3.二叉树遍历（基础知识掌握） 二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。 3.1 前、中、后序遍历3.2 二叉树的建立3.3 线索二叉树3.3.1 对于一个有$n$个结点的二叉链表，每个结点有指向左右孩子的两个指针域，所以一共是$2n$个指针域。而$n$个结点的二叉树一共有$n-1$条分支线数，也就是说，其实是存在$2n-(n-1) =n+1$个空指针域。 12345678 A / \\ B C / \\ / \\ D E F G / \\ /H I J 图3-1 3.3.2 如上图，中序遍历得到HDIBJEAFCG这样的字符，可以知道，结点I的前驱是D，后继是B，结点F的前驱是A，后继是C。 3.3.3 指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树(Threaded Binary Tree)。 3.3.4 其实线索二叉树，等于是把一棵二叉树转变成了一个双向链表，这样对我们的插入删除结点都带来了方便。 3.3.5 对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化。 3.3.6 在每个节点再增设两个标志域ltag和rtag，只存放0或1数字的布尔型变量，其占用的内存空间要小于像lchild和rchild的指针变量。结点结构如下： lchild ltag data rtag rchild 其中： ltag为0时指向该结点的左孩子，为1时指向该结点的前驱。 rtag为0时指向该结点的右孩子，为1时指向该结点的后继。 因此对于图3-1的二叉链表图可以修改为图3-2的样子。 12345678 0A0 / \\ 0B0 0C0 / \\ / \\ 0D0 0E1 1F1 1G1 / \\ /1H1 1I1 1J1 图3-2 3.4 线索二叉树结构实现 线索化的过程就是在遍历的过程中修改空指针的过程。 中序遍历线索化的递归函数代码如下： 12345678910111213141516171819BiThrTree pre; /* 全局变量，始终指向刚刚访问过的节点 *//* 中序遍历进行中序线索化 */void InThreading(BiThrTree p){ if(p){ InThreading(p-&gt;lchild); /* 递归左子树线索化 */ if(!p-&gt;lchild){ /* 没有左孩子 */ p-&gt;LTag=Thread; /* 前驱线索 */ p-&gt;lchild=pre; /* 左孩子指针指向前驱 */ } if(!pre-&gt;rchild){ /* 前驱没有右孩子 */ p-&gt;RTag=Thread; /* 后继线索 */ p-&gt;rchild=p; /* 前驱右孩子指针指向后继（当前结点p） */ } pre=p; /* 保持pre指向p的前驱 */ InThreading(p-&gt;rchild); /* 递归右子树线索化 */ }} 有了线索二叉树后，我们对它进行遍历时发现，其实就等于是操作一个双向链表结构。 和双向链表结构一样，在二叉树线索链表上添加一个头结点，如图3-3所示，并另其lchild域的指针指向二叉树的根节点（图中的a），其rchild域的指针指向中序遍历时访问的最后一个结点（图中的b）。 反之，令中序序列中的第一个结点H的lchild域指针和最后一个结点的rchild域指针均指向头结点。这样定义的好处就是我们既可以从第一个节点起顺后继进行遍历，也可以从最后一个结点起顺前驱进行遍历。 12345678910 头指针-&gt;| |0#1| | a/ | 0A0 | / \\ |b 0B0 0C0 | / \\ / \\| 0D0 0E1 1F1 1G1 / \\ /1H1 1I1 1J1 图3-3 遍历代码如下： 1234567891011121314151617/* T指向头结点，头结点左链lchild指向根节点，头结点右键rchild指向中序遍历的 *//* 最后一个结点。中序遍历二叉线索链表表示的二叉树T */Status InOrderTraverse_Thr(BiThrTree T){ BiThrTree p; p = T-&gt;lchild; /* p指向根结点 */ while(p != T){ /* 空树或遍历结束时，p==T */ while(p-&gt;LTag==Link) /* 当LTag==0时循环到中序序列第一个结点 */ p = p-&gt;lchild; printf(\"%c\", p-&gt;data); /* 显示结点数据，可以更改为其他对结点操作 */ while(p-&gt;RTag==Thread &amp;&amp; p-&gt;rchild!=T){ p = p-&gt;rchild; printf(\"%c\", p-&gt;data); } p = p-&gt;rchild; /* p进至其右子树根 */ } return OK;} 相当于是一个链表的扫描，所以时间复杂度为O(n)。 如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。 4.二叉树遍历算法应用算法都在二叉树的应用和二叉排序树噢！ 5.树遍历算法应用 树转换为二叉树 森林转换为二叉树 二叉树转换为树 二叉树转换为森林 5.1 树的遍历两种方式 一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。 另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。 比如图5-1中的树，它的先根遍历序列为ABEFCDG，后根遍历序列为EFBCGDA。 123456 A / | \\ B C D / \\ /E F G 图5-1 5.2 森林的遍历两种方式 前序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。比如图5-2中的森林，前序遍历序列的结果就是ABCDEFGHJI。 123456 A E G / | \\ | / \\B C D F H I | J 图5-2 后序遍历：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。比如图5-2中的森林，后序遍历序列的结果就是BCDAFEJHIG。","link":"/2020/06/26/DS/%E6%A0%91%E7%9A%84%E8%A6%81%E7%82%B9%E5%BD%92%E7%BA%B3/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/05/10/Hexo/hello-world/"},{"title":"Java中main方法参数String[] args的使用","text":"Java development notes document Source Code Java规定12main方法参数必须为字符串数组(String [ ])，变量名可以随意，通常使用args即是arguments（”参数”的复数形式）的缩写。 Main方法12345public static void main(String[] args) {}public static void main(String args[]) {} 两种写法都是一样的，都表示字符串数组args，其中args只是普通变量名，可以随意定义（前提是符合变量名规则） 思考讨论 1. 不按Java规定 123456public class TestDemo { public static void main(String args) { // 将 String[] 改为 String System.out.println(\"Test!\"); }} 如果按照上面代码进行编码，那就不能被系统识别为主方法；系统就会提示类似如下错误：Error: Main method not found in the file, please define the main method as: public static void main(String[] args) 2. 同名main方法 如果已经有正确main方法，再有同名的main方法就是方法重载了。 1234567public static void main(String[] args){ // 正确标准完美的main方法}public static void main(String args){ // 方法重载} 3. 回归正题：参数String[] args的作用 参数String[] args的作用就是可以在main方法运行前将参数传入main方法中。 3.1 从控制台，输入编译执行命令时传参数。例如下面代码： 123456public class TestMain { public static void main(String[] args) { for(int i=0; i&lt;args.length; i++) System.out.println(args[i]); }}3.2 但是此时args[]并没有赋值，我们需要从控制台命令行进行赋值，就像这样： 所以在命令行中使用String[] args即传入参数的使用为： 1$ java java_file_name arg1 arg2 arg3 ... 4. eclipse举例 在Eclipse使用String[] args4.1 4.2 最后点击Run运行即可。","link":"/2020/06/21/Java/Java%E7%AC%94%E8%AE%B0%E6%96%87%E6%A1%A32/"},{"title":"高级操作系统","text":"文件系统 课堂笔记 1.文件与文件系统文件：具有符号名的一组相关元素的集合。 通常，文件由记录组成，记录用于描述对象的属性，记录又可包含若干个数据项。 文件系统是OS中管理文件的子系统，它实现文件的存储、检索、更新、共享和保护等，并为用户提供方便有效的文件使用和操作方法。 1.1 文件系统的功能 文件的按名存取 文件目录建立和维护 实现逻辑文件到物理文件的转换 文件存储空间的分配和管理 提供合适的文件存取方法 实现文件的共享、保护和保密 提供一组可供用户使用的文件操作 1.2 文件系统的优点使用方便：由于文件系统实现了案名存取，因而用户无需关心文件存放的物理位置数据安全：文件系统可以提供各种保护措施，防止用户对文件有意或无意的破坏接口统一：用户可以使用统一的接口来操作各种介质上的文件 1.3 文件系统的分层结构 文件管理—实现文件的逻辑结构，为用户提供各种文件系统调用，及种文件系统调用，及文件访问权限的设置等工作； 目录管理—负责查找文件描述符，进而找到需要访问的文件，及进行访问权限检查等工作; 外存映射管理—将文件的逻辑地址转换成磁盘的物理地址，即由逻辑块号找到柱面号、磁道号和扇区号，具体的数据传输操作由设备管理实现。 1.4 文件的存取存取方法是操作系统为用户程序提供的使用文件的技术和手段。 存取方法（决定和影响着文件的物理结构） ​ -顺序存取：若当前存取的记录是Ri，则下次必存取Ri+1 ​ -直接（随机）存取 ​ -索引存取 ​ -按（键）值存取 1.5 文件的操作对记录的操作：检索、插入、删除、修改 对文件的操作：创建文件、删除文件、打开文件、关闭文件、读文件、写文件 2 文件目录与文件检索 通过文件目录实现文件的“按名存取”； 文件系统基本功能之一是负责文件目录的建立、维护和检索。 存放管理文件所需信息的数据结构即文件目录，一个文件的文件目录即其目录项又称文件控制块FCB（File Control Block）： -文件和文件控制块是一一对应的； -FCB通常包括：文件名、用户名、类型、文件结构、建立日期、存取权限、物理地址等 2.1 文件目录与目录项目录文件：把FCB集中起来，组成文件，保存于外存，这个文件称作目录文件 文件检索：给定一个文件名，查找相应的目录文件找到该文件所对应的目录项 2.1.1 单级目录整个系统只有一张目录表，所有文件均登记在该表中，每个文件占有一项。 目录表存放在存储设备的固定地方，系统启动时调用内存。 单级目录的优点是非常简单，但： ​ -不允许重名 ​ -查找速度慢 2.1.2 二级目录 系统设置唯一一个主文件目录MFD（Master File Directiry）。 每个用户设立一个用户文件目录UFD（User）。UFD由该用户所有文件的FCB构成。 每个UFD在MFD中占有一个目录项，其中包括用户名和指向该用户文件的指针。 优点： ​ -提高了查找速度​ -解决了重名问题 2.1.3 多级目录 树形目录结构，最高层是根目录，最低层是数据文件，其他是目录文件。 2.1.4 层级目录结构 每一级目录即可以包含下一级目录(即目录文件的目录项)，也可以包含具体文件(即具体文件的目录项)，形成层次关系。 多级目录结构采用树形结构，是一棵倒向有根树，树根是根目录；从根向下，每个树枝是一个子目录；而树叶是文件。 树型多级目录优点：组织灵活、便于命名、检索高效。 2.1.5 UNIX/Linux目录项文件名 inode节点号14字节 2字节0号目录项和索引节点 思考：UNIX使用i-node的好处是什么? ➢因为按文件名检索目录文件时，只用到了文件名。当找到该文件名时，才需要它的其它描述信息。所以在把存放该目录文件的盘块从外存调入内存进行比较时，应使一个盘块中包含尽量多的文件名，以减少访问磁盘次数，加快文件检索速度。 例:设物理块大小为512B,某目录下有128个文件。 原来的FCB占64B，则每物理块能容纳512/64=8个FCB，则该目录文件需占128/8= 16块，查找一个文件的平均访盘次数为:(1+16) /2= 8.5次。 采用i-node后:文件名部分有16B，i-node部 分有64B，每物理块能容纳512/16=32个文件名部分或512/64=8个i-node，则该目录的文件名部分需占128/32=4块，i-node部分需占128/8=16块。查找一个文件的平均访盘次数为:(1+4)/2+1=3.5次。 3 文件逻辑结构与数据存储 文件的逻辑结构：用户所看到的文件结构 -记录式文件，文件由若干记录所构成 -流式文件，文件由若干字符（字节）序列构成 文件的物理结构：文件在外存的存放形式 -顺序文件:逻辑文件中的信息顺序地存放在相邻的物理块中 -链接文件:文件中的信息不是顺序排列的，它们可以存放在不相邻的物理块中，通过指针连接成链表索引文件:为每一文件建立一个索引表，用以实现逻辑记录和物理块号之间的映射 3.1 文件结构与文件存储物理块是存储介质上连续信息所组成的一个区域。 块是主存储器和辅助存储设备信息交换的物理单位，每次交换一块或整块数。 决定块的大小要考虑到用户使用方式、数据传输效率和存储设备类型等多种因素。 不同类型的存储介质，块的大小常常各不相同；同一类型的存储介质，块的大小也可以不同。 间隙是块之间不记录用户代码信息的空闲区城。 3.2 文件的逻辑结构文件的逻辑结构是用户所见的信息组织方式。 文件的逻辑结构分为：流式文件，记录式文件。 流式文件指文件内的数据不再组成记录，只是依次的一串信息(字节)集合。 流式文件常按字节数来读取所需信息，也可用插入特殊字符作为分界。 记录式文件由逻辑记录组成，逻辑记录具有特定的逻辑含意。 3.3 记录组块和分解逻辑记录和块的关系： 逻辑记录是按信息的逻辑含义所划分的单位，块是存储介质上连续的存储区域。 逻辑记录存放到文件存储器上时，一个记录可能占用一块或多块，也可能多个存放到一个物理块中。 记录组块—将多个记录置于一个存储块中。 记录分解—从存储块中分解出逻辑记录。 块因子—一个存储块中包含多少个记录。 3.4 记录组块3.4.1 需考虑的问题： 块的长度是固定的还是可变的? ​ -大多数系统中，块的固定长度的的。 与记录的平均大小相比，块的相对大小是多少？ ​ -综合考虑顺序访问的频率和访问的局部性潜能，倾向于用大的块，以减少I/O传送时间。 3.4.2 记录组块的方法固定组块 可变长度跨越式组块 可变长度非跨越式组块 4.文件存储器管理4.1 空闲盘块管理-》磁盘分配表 -》常用的空闲空间管理技术 ​ -位示图 ​ -空闲块列表 ​ -空闲区链表 ​ -空闲块索引 -》文件卷 ​ -一组在辅助存储上可寻址的扇区的集合，操作系统或应用程序用卷来存储数据。一个卷中的扇区在物理上并不需要是连续的，只需要对操作系统或应用程序来讲是连续的。一个卷可能是更小的卷合并或组合后的结果。 4.2文件存储空间管理4.2.1 预分配与动态分配 预分配策略要求在发出创建文件的请求时，声明该文件的最大大小。 ​ -若不能可靠地估计文件可能的最大大小，通常会多估计一些，以避免分配的空间不够。—浪费 动态分配只有在需要时才给文件分配空间。 ​ -当创建一个新文件时，是否一次性地分配所需要的最大空间？ 预分配与动态分配 ​ -在分配时，采用什么分配策略? ​ a.可变大小的连续分区(类似分区式) ​ b.大小相等但不连续的块(类似页式) ​ c.采用什么数据结构记录分配给文件的空间?—文件分配表 4.2.2 分配策略 文件分配时，需要综合考虑单个文件的效率和整个系统的效率 ​ -连续空间可以提高磁盘访问性能； ​ -使用可变大小的分区，可以减少由于超额分配而产生的未使用存储空间的派费； ​ -使用固定大小的分区可以简化空间的再分配； ​ -数目较多的小分区会增加用于管理分配信息表的大小。 综合考虑的两种选择: ​ -可变大小的连续分区 ​ a.大小可变避免了浪費，文件分配表比较小 ​ b.空间很难再次利用 ​ -大小相等但不连续的块 ​ a.小的固定分区提供了更多的灵活性 ​ b.可能需要较大的文件分配表或更复杂的结构 5.文件的物理结构文件的物理结构是指文件在物理存储空间中存放(分配)的形式，亦称为文件的物理组织。 文件的物理结构涉及：块的划分、记录的排列索引的组织、信息的搜索，其优劣直接影响文件系统的性能。 文件的物理结构：顺序文件、链式文件、索引文件、直接文件 5.1 顺序文件（连续文件） 将一个文件存放到文件存储器连续的物理块中，便形成了顺序文件。 顺序文件中逻辑记录和物理记录顺序完全一致。通常记录按次序被读出或修改。 顺序文件的优点/缺点：读写高效/改变大小困难，磁盘碎片问题。File Allocation Table 5.2 链式文件（串联文件） 链式文件通过链指针将存放文件内容的各物理块联系起来 连接结构的优/缺点：文件读写效率低/易于扩展，不存在磁盘碎片问题 5.3 直接文件（哈希文件） 通过hash函数在记录的关键字与其存储地址之间建立关系，据此实现存取即称为直接文件。 文件控制块 5.4 索引文件（链式文件的高效实现，现在几乎都采用）索引结构是实现非连续存储的另一种方法，适用于数据记录保存有随机存取存储设备上的文件。 使用索引表，其中登记了存放文件的物理块。 如果块长4KB (即索引块和数据块长4K)，每个指针(盘块号) 4B，则采用这种索引分配时，允许的文件最大尺寸是多少? 直接地址: 10 * 4KB= 40KB 一级索引: 4KB * (4KB/4B) = 4MB 二级索引: 4KB * (4KB/4B)^2= 4GB 三级索引: 4KB * (4KB/4B)^3 = 4TB 合计大小: 40KB+4MB+4GB+4TB 6.文件共享与保护 访问权限 ​ -无 ​ -知道 ​ -执行 ​ -读 ​ -追加 ​ -更新 ​ -改变保护 ​ -删除 同时访问 ​ -加锁 ​ -互斥和死锁问题 6.1 文件共享6.1.1 基于目录指针实现文件共享允许一个文件可以有多个父目录，即有多个属于不同用户的目录，同时指向同一个文件，即可实现文件共享(但这会破坏树的特性一多个父节点! ) 6.1.2 利用索引节点利用索引结点，存放文件的物理地址、文件属性和文件共享与保护相关信息，而不同用户在其文件目录中设置共性文件的别名及指向相应索引结点的指针。 6.1.3 利用符号链实现共享由操作系统为被共享文件的创建一个LINK类型的文件(即该共享文件的路径名，称为符号链)，用户通过在自己的文件目录中包含指向该符号链文件的方法实现文件共享。 6.2 文件保护利用符号链实现共享的优缺点 优点：只有文件主才拥有指向其索引结点的指针，而其他共享用户则只有该文件的路径名，因此不会因文件主删除一个共享 文件后留下悬空指针的问题。共享者通过符号链访问一个已被删除的共享文件将会访问失败时，则删除符号链。 缺点：用户访问共享文件时，系统是根据给定的文件路径名逐个分量(名)去查找目录，直至找到该文件的索引结点。因此，可能要多次读盘，开销大。此外，要为每个共享用户建立一条符号链，而由于链本身实际上是一个文件，也要为它分配索引结点，这也要耗费磁盘空间。 文件保护用于防止文件被破坏。包括两个方面: ​ 一是防止系统崩溃所造成的文件破坏; ​ 二是防止文件主和其他用户有意或无意的非法操作所造成的文件不安全性。 防止系统崩溃造成文件破坏的方法: ​ ➢定时转储 ​ ➢多副本 防止非法操作的方法:基本思想是建立三元组: (用户、 对象、存取权限)—访问控制 访问矩阵 ​ -主体 ​ -对象 访问权限 6.3 UNIX文件保护 UNIX/Linux把用户分为3类：文件主、同组用户、其他用户 定义3种存取权限：可读r、可写w、可执行x。文件属性共有10位： ​ -rwxrwxrwx","link":"/2020/07/01/OS/OS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"title":"数据结构进阶实训四 链表","text":"Data structure advanced training course notes and algorithm exercises 数据结构进阶实训课程笔记和算法练习 Source Code: https://github.com/MysticalGuest/DataStructure/tree/master/AdvancedJuniorTraining 题目11给定一个单链表L，L为头指针，判断该链表内是否局部存在环？ 1.1 算法设计思想 使用快慢指针判断单链表是否存在环。 使用slow、fast 2个指针，slow慢指针每次向前走1步，fast快指针每次向前走2步，若存在环的话，必定存在某个时候 slow = fast 快慢指针相遇。 返回值为1：存在环 返回值为0：不存在环 1.2 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657typedef struct Node { int data; struct Node *next;}Node, *LinkList;void InitLinkList(LinkList *L) { *L = (LinkList)malloc(sizeof(Node)); (*L)-&gt;next = NULL; Node *r=*L, *s, *temp; int i=0; while(i&lt;10){ s=(Node*)malloc(sizeof(Node)); s-&gt;data=i; r-&gt;next=s; s-&gt;next=NULL; if(i==4){ // 记住一个元素,以助后面成环 temp=r; } r=s; i++; } r-&gt;next=temp; // 成环}int IsLoopLinkList(LinkList list){ //空指针 if(list == NULL){ return 0; } //只有头结点,没有元素 if(list-&gt;next == NULL){ return 0; } Node* slow = list; Node* fast = list; int loc = 0; while (1){ if(fast-&gt;next == NULL){ //快指针 到底链表尾结点说明 没有环，此时slow 指向中间结点 return 0; } else{ if (fast-&gt;next != NULL &amp;&amp; fast-&gt;next-&gt;next != NULL){ fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; } else{ fast = fast-&gt;next; } } //某个时刻 快慢指针相遇，说明此处存在环！ if(slow == fast){ return 1; } } return 0;} 1.3 运行情况截图 题目21234找到单链表中倒数第k个结点。找出解决方法要求：尽可能高效例如：一个链表有6个结点，（1,2,3,4,5,6）这个链表的倒数第3个结点是：值为4的结点 2.1 算法设计思想 先遍历获得链表长度listlen(L)； 然后计算得出倒数第k个节点的正数位置，也就是listlen(L)-k+1； 遍历到listlen(L)-k+1的节点，然后输出 2.2 源代码 12345678910111213141516/* 求链表长度 */int listlen(LinkList L){ int len=0; Node *head=L; while(head-&gt;next!=NULL){ len++; head=head-&gt;next; } return len;}// mainscanf(\"%d\", &amp;k);for(i=0; i&lt;listlen(L)-k+1; i++){ p=p-&gt;next;} 2.3 运行情况截图 题目312在O(1)时间删除单链表结点；给定单链表L及其中一个结点地址p,定义一个函数实现在O(1)时间删除该结点。 3.1 算法设计思想 将节点p的下一个节点的值赋给p；p的后继指向p的后继的后继；然后free掉p的后继 3.2 源代码 12345678910111213141516171819202122232425void InitLinkList(LinkList *L, LinkList *temp) { *L = (LinkList)malloc(sizeof(Node)); (*L)-&gt;next = NULL; Node *r=*L, *s; int i=0; while(i&lt;10){ s=(Node*)malloc(sizeof(Node)); s-&gt;data=i; r-&gt;next=s; s-&gt;next=NULL; if(i==5){ // 记住一个节点地址 *temp=r; } r=s; i++; }}// mainInitLinkList(&amp;L, &amp;p);s=p-&gt;next;p-&gt;data = s-&gt;data;p-&gt;next=s-&gt;next;free(s); 3.3 运行情况截图 题目4123假定用带头结点的单链表保存单词，当两个单词有相同的后缀时，则可共享相同的后缀存储空间，例如：loading和being。 - 设计一个高效的算法，找出str1和str2的共同后缀的起始位置。（可能有也可能没有。） - 分析算法的时空效率 4.1 算法设计思想 分别获得链表str1和str2的长度；移动长度较长的链表的头指针，使得两指针的起始位置相同；然后同时往后移动，遇到相同地址的节点即为共同后缀的起始位置 4.2 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657LinkList reverse(LinkList L){ if(L-&gt;next == NULL || L-&gt;next-&gt;next == NULL) { return L; /*链表为空或只有一个元素则直接返回*/ } Node *r, *p = L-&gt;next, *q = L-&gt;next-&gt;next; while(q != NULL){ r = q-&gt;next; q-&gt;next = p; p = q; q = r; } /*此时q指向原始链表最后一个元素，也是逆转后的链表的表头元素*/ L-&gt;next-&gt;next = NULL; /*设置链表尾*/ L-&gt;next = p; /*调整链表头*/ return L;}LinkList commonSuffix1(LinkList L1, LinkList L2){ Node *p, *q; int len1, len2; len1=listlen(L1); len2=listlen(L2); if(lastNode(L1) != lastNode(L2)){ return NULL; } else{ for(p=L1; len1&gt;len2; len1--){ p=p-&gt;next; } for(q=L2; len2&gt;len1; len2--){ q=q-&gt;next; } while(p-&gt;next != NULL &amp;&amp; p-&gt;next != q-&gt;next){ p=p-&gt;next; q=q-&gt;next; } return p-&gt;next; }}LinkList commonSuffix2(LinkList L1, LinkList L2){ Node *p=L1, *q=L2; if(L1-&gt;next == NULL || L2-&gt;next == NULL){ // 空，直接返回 return NULL; } // else if(L1-&gt;next != L2-&gt;next){ // 这里的第一个元素,是原来的最后一个元素 // return NULL; // 不相等直接返回 // } else{ while(p-&gt;next != NULL &amp;&amp; q-&gt;next != NULL &amp;&amp; p-&gt;next != q-&gt;next){ p=p-&gt;next; q=q-&gt;next; } return p-&gt;next; }} 4.3 运行情况截图","link":"/2020/06/03/DS/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E5%9B%9B/"},{"title":"Spring Boot与缓存","text":"1、Spring Boot与缓存 缓存应该是每个系统都应考虑的功能，用来加速系统的访问以及提升系统的性能； 引入缓存中间件，将高频信息从数据库存入缓存，从缓存拿数据；如果缓存中没有，在到数据库中查找吗，继续放入缓存。应用程序和缓存的交互式非常快的。 还有验证码这些临时性数据就没有必要存在数据库中了，缓存是不错的选择。 那么为了统一缓存的开发规范以及提升系统的扩展性，J2EE发布了JSR-107规范，但由于整合难度大，用的比较少。JSR-107规范定义的都是一些接口，这样的好处就类似JDBC一样，面向接口编程。但市面上的组件不都提供JSR-107的实现。但为了简化开发，Spring更多使用的是自己的Spring缓存抽象。 1.1 JSR107Java Caching定义了5个核心接口，分别是CachingProvider, CacheManager, Cache, Entry 和 Expiry。 CachingProvider定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可以在运行期访问多个CachingProvider。 CacheManager定义了创建、配置、获取、管理和控制多个唯一命名的Cache，这些Cache存在于CacheManager的上下文中。一个CacheManager仅被一个CachingProvider所拥有。 Cache是一个类似Map的数据结构并临时存储以Key为索引的值。一个Cache仅被一个CacheManager所拥有。 Entry是一个存储在Cache中的key-value对。 Expiry 每一个存储在Cache中的条目有一个定义的有效期。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置。 1.2 Spring缓存抽象Spring从3.1开始定义了org.springframework.cache.Cache和org.springframework.cache.CacheManager接口来统一不同的缓存技术； 并支持使用JCache（JSR-107）注解简化我们开发； Cache接口为缓存的组件规范定义，包含缓存的各种操作集合； Cache接口下Spring提供了各种xxxCache的实现；如RedisCache，EhCacheCache , ConcurrentMapCache等； 每次调用需要缓存功能的方法时，Spring会检查检查指定参数的指定的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取。 使用Spring缓存抽象时我们需要关注以下两点； 确定方法需要被缓存以及他们的缓存策略 从缓存中读取之前缓存存储的数据 1.3 几个重要概念&amp;缓存注解 Cache 缓存接口，定义缓存操作。实现有：RedisCache、EhCacheCache、ConcurrentMapCache等 CacheManager 缓存管理器，管理各种缓存（Cache）组件 @Cacheable 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存 @CacheEvict 清空缓存 @CachePut 保证方法被调用，又希望结果被缓存。 @EnableCaching 开启基于注解的缓存 keyGenerator 缓存数据时key生成策略 serialize 缓存数据时value序列化策略 都是作用于缓存，不作用于数据库？ 1.4 搭建基本环境 创建出department和employee表 创建javaBean封装数据 整合MyBatis操作数据库 配置数据源信息 使用注解版的MyBatis @MapperScan指定需要扫描的mapper接口所在的包 2、快速体验缓存缓存SpEL可用元数据 名字 位置 描述 示例 methodName root object 当前被调用的方法名 #root.methodName method root object 当前被调用的方法 #root.method.name target root object 当前被调用的目标对象 #root.target targetClass root object 当前被调用的目标对象类 #root.targetClass args root object 当前被调用的方法的参数列表 #root.args[0] caches root object 当前方法调用使用的缓存列表（如@Cacheable(value={“cache1”, “cache2”})），则有两个cache #root.caches[0].name argument name evaluation context 方法参数的名字. 可以直接 #参数名 ，也可以使用 #p0或#a0 的形式，0代表参数的索引； #iban 、 #a0 、 #p0 result evaluation context 方法执行后的返回值（仅当方法执行之后的判断有效，如‘unless’，’cache put’的表达式 ’cache evict’的表达式beforeInvocation=false） #result 步骤： 2.1 开启基于注解的缓存 @EnableCaching1234567891011// 启动类@SpringBootApplication@EnableCachingpublic class SpringinitializrApplication { public static void main(String[] args) { System.out.println(\"Start...\"); SpringApplication.run(SpringinitializrApplication.class, args); System.out.println(\"Success...\"); }} 2.2 标注缓存注解即可将方法的运行结果进行缓存；以后再要相同的数据，直接从缓存中获取，不用调用方法； CacheManager管理多个Cache组件的，对缓存的真正CRUD操作在Cache组件中，每一个缓存组件有自己唯一一个名字； 2.3 @Cacheable12345678910111213// DepartmentController.java@RestControllerpublic class DepartmentController { @Autowired DepartmentService departmentService; @GetMapping(\"/service/dept/{id}\") public Department getDepart(@PathVariable(\"id\") Integer id){ return departmentService.getDepartment(id); } ...} 2.3.1 几个属性： @Cacheable的属性 详情 用法 cacheNames/value 指定缓存组件的名字;将方法的返回结果放在哪个缓存中，是数组的方式，可以指定多个缓存 key 缓存数据使用的key；可以用它来指定。默认是使用方法参数的值 1-方法的返回值 编写SpEL； #i d;参数id的值 #a0 #p0 #root.args[0]getEmp[2] keyGenerator key的生成器；可以自己指定key的生成器的组件id key/keyGenerator：二选一使用 cacheManager 指定缓存管理器；或者cacheResolver指定获取解析器 condition 指定符合条件的情况下才缓存； condition = “#id&gt;0”condition = “#a0&gt;1”：第一个参数的值&gt;1的时候才进行缓存 unless 否定缓存；当unless指定的条件为true，方法的返回值就不会被缓存；可以获取到结果进行判断 unless = “#result == null”unless = “#a0==2”:如果第一个参数的值是2，结果不缓存 sync 是否使用异步模式 2.3.2 应用举例123456789101112131415161718// DepartmentService.java@Servicepublic class DepartmentService { @Autowired DepartmentMapper departmentMapper; // @Cacheable(cacheNames = \"dept\", key = \"#id\") // @Cacheable(cacheNames = {\"dept\", \"tdept\"}, key = \"#id\") 多缓存名 // @Cacheable(cacheNames = \"dept\", key = \"#root.args[0]\", condition = \"#id&gt;0\") // @Cacheable(cacheNames = \"dept\", key = \"#root.args[0]\", unless = \"#result == null\") @Cacheable(cacheNames = \"dept\", key = \"#root.args[0]\") public Department getDepartment(Integer id){ System.out.println(\"查询\"+id+\"号部门\"); Department dept = departmentMapper.getDeptById(id); return dept; }} 2.3.3 运行主程序访问http://localhost:8088/service/dept/1，查看控制台，然后在刷新浏览器再查看控制台，发现后台并不执行数据库查询： 2.3.4 分析缓存的工作原理以及工作步骤结合以上例子来： 自动配置类入手：CacheAutoConfiguration.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Configuration@ConditionalOnClass({CacheManager.class})@ConditionalOnBean({CacheAspectSupport.class})@ConditionalOnMissingBean( value = {CacheManager.class}, name = {\"cacheResolver\"})@EnableConfigurationProperties({CacheProperties.class})@AutoConfigureBefore({HibernateJpaAutoConfiguration.class})@AutoConfigureAfter({ CouchbaseAutoConfiguration.class, HazelcastAutoConfiguration.class, RedisAutoConfiguration.class})@Import({CacheAutoConfiguration.CacheConfigurationImportSelector.class})public class CacheAutoConfiguration { static final String VALIDATOR_BEAN_NAME = \"cacheAutoConfigurationValidator\"; public CacheAutoConfiguration() { } @Bean @ConditionalOnMissingBean public CacheManagerCustomizers cacheManagerCustomizers( ObjectProvider&lt;List&lt;CacheManagerCustomizer&lt;?&gt;&gt;&gt; customizers ) { return new CacheManagerCustomizers((List)customizers.getIfAvailable()); } ... static class CacheConfigurationImportSelector implements ImportSelector { CacheConfigurationImportSelector() { } public String[] selectImports(AnnotationMetadata importingClassMetadata) { CacheType[] types = CacheType.values(); String[] imports = new String[types.length]; for(int i = 0; i &lt; types.length; ++i) { imports[i] = CacheConfigurations.getConfigurationClass(types[i]); } return imports; } }} 放了一些缓存管理的自定义器（CacheManagerCustomizers）等； 关注一下@Import({CacheAutoConfiguration.CacheConfigurationImportSelector.class})，查看源码来到上面代码中的CacheConfigurationImportSelector方法；在方法体中调用的selectImports打上断点，debug来查看给容器中导入了哪些缓存组件：缓存的配置类 哪个配置类默认生效？配置文件加入以下配置，然后运行主程序 12# 打开自动配置报告debug=true 可以看到控制台： 1234567891011121314151617181920212223242526272829=========================AUTO-CONFIGURATION REPORT=========================Positive matches:----------------- SimpleCacheConfiguration matched: - Cache org.springframework.boot.autoconfigure.cache.SimpleCacheConfiguration automatic cache type (CacheCondition) - @ConditionalOnMissingBean (types: org.springframework.cache.CacheManager; SearchStrategy: all) did not find any beans (OnBeanCondition) ... Negative matches:----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration.CglibAutoProxyConfiguration: Did not match: - @ConditionalOnProperty (spring.aop.proxy-target-class=true) did not find property 'proxy-target-class' (OnPropertyCondition) ... 可以看出是SimpleCacheConfiguration配置类生效；给容器中注册了一个CacheManager：ConcurrentMapCacheManager 可以获取和创建ConcurrentMapCache类型的缓存组件；其的作用将数据保存在ConcurrentMap中； 2.3.5 @Cacheable运行流程 方法运行之前，先去查询Cache（缓存组件），按照cacheNames指定的名字获取； （CacheManager先获取相应的缓存），第一次获取缓存如果没有Cache组件会自动创建。 去Cache中查找缓存的内容，使用一个key，默认就是方法的参数； key是按照某种策略生成的；默认是使用keyGenerator生成的，默认使用SimpleKeyGenerator生成key； SimpleKeyGenerator生成key的默认策略； 如果没有参数；key=new SimpleKey()； 如果有一个参数：key=参数的值 如果有多个参数：key=new SimpleKey(params)； 没有查到缓存就调用目标方法； 将目标方法返回的结果，放进缓存中 @Cacheable标注的方法执行之前先来检查缓存中有没有这个数据，默认按照参数的值作为key去查询缓存，如果没有就运行方法并将结果放入缓存；以后再来调用就可以直接使用缓存中的数据。 核心： 使用CacheManager【ConcurrentMapCacheManager】按照名字得到Cache【ConcurrentMapCache】组件 key使用keyGenerator生成的，默认是SimpleKeyGenerator 2.4 @CacheEvict2.5 @CachePut默认使用的是ConcurrentMapCacheManager==ConcurrentMapCache；将数据保存在 ConcurrentMap中 开发中使用缓存中间件；redis、memcached、ehcache； 三、整合redis作为缓存 Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 1、安装redis：使用docker； 2、引入redis的starter 3、配置redis 4、测试缓存 原理：CacheManager===Cache 缓存组件来实际给缓存中存取数据 1）、引入redis的starter，容器中保存的是 RedisCacheManager； 2）、RedisCacheManager 帮我们创建 RedisCache 来作为缓存组件；RedisCache通过操作redis缓存数据的 3）、默认保存数据 k-v 都是Object；利用序列化保存；如何保存为json 1、引入了redis的starter，cacheManager变为 RedisCacheManager； 2、默认创建的 RedisCacheManager 操作redis的时候使用的是 RedisTemplate 3、RedisTemplate 是 默认使用jdk的序列化机制 4）、自定义CacheManager；","link":"/2020/08/28/Spring/AdvancedSpringBootCache/"},{"title":"Spring Boot应用","text":"1、Restful风格简介 1.1 概念一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 1.2 URL定义 资源：互联网所有的事物都可以被抽象为资源 资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。 分别对应：添加、 删除、修改、查询。 传统方式操作资源 查询GET：http://127.0.0.1/query.action?id=1 新增POST：http://127.0.0.1/save.action 更新POST：http://127.0.0.1/update.action 删除GET或POST：http://127.0.0.1/delete.action?id=1 可以通过 GET、 POST、 PUT、 PATCH、 DELETE 等方式对服务端的资源进行操作。其中，GET 用于查询资源，POST 用于创建资源，PUT 用于更新服务端的资源的全部信息，PATCH 用于更新服务端的资源的部分信息，DELETE 用于删除服务端的资源。 使用RESTful操作资源 查询用户信息列表GET：http://127.0.0.1/users 查看某个用户信息GET：http://127.0.0.1/users/001 新建用户信息POST：http://127.0.0.1/users 更新用户信息（全部字段）PUT：http://127.0.0.1/users/001 更新用户信息（部分字段）PATCH：http://127.0.0.1/users/001 删除用户信息DELETE：http://127.0.0.1/users/001 1.3 API设计风格基本规则 使用名词而不是动词 /getAllUsers /updateUser /deleteUser/001 使用子资源表达关系（如果一个资源与另外一个资源有关系，使用子资源） 返回所有用户GET：/getUser/ 返回001用户GET： /getUser/001 总而言之restful是一种旧技术新风格 2、RestfulCRUD2.1 默认访问首页123456789101112131415@Configurationpublic class SpringMVCConfig extends WebMvcConfigurerAdapter { //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter(){ WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); } }; return adapter; }} 2.2 国际化 编写国际化配置文件； 使用ResourceBundleMessageSource管理国际化资源文件 在页面使用fmt:message（JSP）取出国际化内容 Spring Boot都自动配置好了，唯一要做的就是编写国际化配置文件了 步骤 编写国际化配置文件，抽取页面需要显示的国际化消息 SpringBoot自动配置好了管理国际化资源文件的组件； Ctrl+N搜索MessageSourceAutoConfiguration类，查看源码 12345678910111213141516171819202122232425262728293031323334353637@Configuration@ConditionalOnMissingBean( value = {MessageSource.class}, search = SearchStrategy.CURRENT)@AutoConfigureOrder(-2147483648)@Conditional({MessageSourceAutoConfiguration.ResourceBundleCondition.class})@EnableConfigurationProperties@ConfigurationProperties( prefix = \"spring.messages\")public class MessageSourceAutoConfiguration { private static final Resource[] NO_RESOURCES = new Resource[0]; private String basename = \"messages\"; //我们的配置文件可以直接放在类路径下叫messages.properties ... @Bean public MessageSource messageSource() { ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(this.basename)) { // 设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames( StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(this.basename) ) ); } if (this.encoding != null) { messageSource.setDefaultEncoding(this.encoding.name()); } messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale); messageSource.setCacheSeconds(this.cacheSeconds); messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat); return messageSource; }} 去页面获取国际化的值； Thymeleaf官方文档查看message 主配置文件： 1234#设置国际化资源路径spring.messages.basename=i18n/login#设置国际化编码格式spring.messages.encoding=UTF-8 HTML文件： 1234567891011121314151617181920&lt;img class=\"mb-4\" th:src=\"@{/asserts/img/bootstrap-solid.svg}\" src=\"asserts/img/bootstrap-solid.svg\" alt=\"\" width=\"72\" height=\"72\"&gt;&lt;h1 class=\"h3 mb-3 font-weight-normal\" th:text=\"#{login.tip}\"&gt;Please sign in&lt;/h1&gt;&lt;label class=\"sr-only\" th:text=\"#{login.username}\"&gt;Username&lt;/label&gt;&lt;input type=\"text\" class=\"form-control\" placeholder=\"Username\" th:placeholder=\"#{login.username}\" required=\"\" autofocus=\"\"&gt;&lt;label class=\"sr-only\" th:text=\"#{login.password}\"&gt;Password&lt;/label&gt;&lt;input type=\"password\" class=\"form-control\" placeholder=\"Password\" th:placeholder=\"#{login.password}\" required=\"\"&gt;&lt;div class=\"checkbox mb-3\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" value=\"remember-me\"&gt; [[#{login.rememberme}]] &lt;/label&gt;&lt;/div&gt;&lt;button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\" th:text=\"#{login.signin}\"&gt; Sign in&lt;/button&gt;&lt;p class=\"mt-5 mb-3 text-muted\"&gt;© 2017-2018&lt;/p&gt;&lt;a class=\"btn btn-sm\"&gt;中文&lt;/a&gt;&lt;a class=\"btn btn-sm\"&gt;English&lt;/a&gt; 效果：根据浏览器语言设置的信息切换了国际化； 原理：国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）； 1234567891011121314151617@Bean@ConditionalOnMissingBean@ConditionalOnProperty( prefix = \"spring.mvc\", name = {\"locale\"})public LocaleResolver localeResolver() { if (this.mvcProperties.getLocaleResolver() == org.springframework.boot.autoconfigure.web.WebMvcProperties.LocaleResolver.FIXED) { return new FixedLocaleResolver(this.mvcProperties.getLocale()); } else { AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; }} 默认的就是根据请求头带来的区域信息获取Locale进行国际化 点击链接切换国际化 自定义组件MyLocaleResolver类 123456789101112131415161718192021222324/** * 可以在连接上携带区域信息 */public class MyLocaleResolver implements LocaleResolver { @Override public Locale resolveLocale(HttpServletRequest httpServletRequest) { String l = httpServletRequest.getParameter(\"l\"); Locale locale = Locale.getDefault(); // 是否携带语言信息 if(!StringUtils.isEmpty(l)){ String[] split = l.split(\"_\"); locale = new Locale(split[0],split[1]); } return locale; } @Override public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) { }} 然后个组件添加进容器，在配置文件SpringMVCConfig类文件中： 12345// 区域信息解析器组件@Beanpublic LocaleResolver localeResolver(){ return new MyLocaleResolver();} 2.3 登录开发期间模板引擎页面修改以后，要实时生效 禁用模板引擎的缓存 12# 禁用缓存spring.thymeleaf.cache=false 页面修改完成以后ctrl+F9：重新编译； 登陆错误消息的显示 1&lt;p style=\"color: red\" th:text=\"${msg}\" th:if=\"${not #strings.isEmpty(msg)}\"&gt;&lt;/p&gt; 2.4 拦截器进行登陆检查拦截器组件类： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 登陆检查， */public class LoginHandlerInterceptor implements HandlerInterceptor { //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception { Object user = httpServletRequest.getSession().getAttribute(\"loginUser\"); if(user == null){ //未登陆，返回登陆页面 httpServletRequest.setAttribute(\"msg\",\"没有权限请先登陆\"); httpServletRequest.getRequestDispatcher(\"/index.html\").forward( httpServletRequest, httpServletResponse ); return false; }else{ //已登陆，放行请求 return true; } } @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception { }} 注册拦截器 123456789101112131415161718//所有的WebMvcConfigurerAdapter组件都会一起起作用@Bean //将组件注册在容器public WebMvcConfigurerAdapter webMvcConfigurerAdapter(){ WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() { ... // 注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) { // super.addInterceptors(registry); // \"/**\"表示任意多层路径下的任意请求 // 静态资源； *.css , *.js // SpringBoot已经做好了静态资源映射 registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(\"/**\") .excludePathPatterns(\"/index.html\", \"/\", \"/login\"); } }; return adapter;} 3、CRUD-员工列表3.1 RestfulCRUD：CRUD满足Rest风格；URI： /资源名称/资源标识 HTTP请求方式区分对资源CRUD操作 普通CRUD（uri来区分操作） RestfulCRUD 查询 getEmp emp—-GET 添加 addEmp?xxx emp—-POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/{id}—-PUT 删除 deleteEmp?id=1 emp/{id}—-DELETE 3.2 thymeleaf公共页面元素抽取12345678910111213141、抽取公共片段&lt;div th:fragment=\"copy\"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;2、引入公共片段&lt;div th:insert=\"~{footer :: copy}\"&gt;&lt;/div&gt;~{templatename::selector}：模板名::选择器~{templatename::fragmentname}:模板名::片段名3、默认效果：insert的公共片段在div标签中如果使用th:insert等属性进行引入，可以不用写~{}：行内写法可以加上：[[~{}]];[(~{})]； 三种引入公共片段的th属性： th:insert：将公共片段整个插入到声明引入的元素中 th:replace：将声明引入的元素替换为公共片段 th:include：将被引入的片段的内容包含进这个标签中 页面示例： 123&lt;div th:fragment=\"copy\"&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 其他页面使用方式： 12345&lt;div th:insert=\"footer :: copy\"&gt;&lt;/div&gt;&lt;div th:replace=\"footer :: copy\"&gt;&lt;/div&gt;&lt;div th:include=\"footer :: copy\"&gt;&lt;/div&gt; 效果： 1234567891011&lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;div&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 3.3 引入片段的时候传入参数：父页面： 12&lt;!--引入侧边栏;传入参数--&gt;&lt;div th:replace=\"commons/bar::#sidebar(activeUri='main.html')\"&gt;&lt;/div&gt; 子页面： 12345678910111213141516171819202122232425262728&lt;!-- sidebar --&gt;&lt;nav class=\"col-md-2 d-none d-md-block bg-light sidebar\" id=\"sidebar\"&gt; &lt;div class=\"sidebar-sticky\"&gt; &lt;ul class=\"nav flex-column\"&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link active\" th:class=\"${activeUri=='main.html'?'nav-link active':'nav-link'}\" href=\"http://getbootstrap.com/docs/4.0/examples/dashboard/#\" th:href=\"@{main.html}\"&gt; &lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" s troke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-home\"&gt; &lt;path d=\"M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z\"&gt;&lt;/path&gt; &lt;polyline points=\"9 22 9 12 15 12 15 22\"&gt;&lt;/polyline&gt; &lt;/svg&gt; Dashboard &lt;span class=\"sr-only\"&gt;(current)&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; ... &lt;/ul&gt; &lt;/div&gt;&lt;/nav&gt; 3.4 添加操作添加页面： 123456789101112131415161718192021222324252627282930313233343536&lt;form th:action=\"@{addEmployee}\" method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name=\"lastName\" type=\"text\" class=\"form-control\" placeholder=\"name\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name=\"email\" type=\"email\" class=\"form-control\" placeholder=\"name@163.com\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\"&gt; &lt;label class=\"form-check-label\"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\"&gt; &lt;label class=\"form-check-label\"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;department&lt;/label&gt; &lt;select class=\"form-control\" name=\"department.id\"&gt; &lt;!-- 提交的是部门的id --&gt; &lt;option th:value=\"${dept.id}\" th:each=\"dept: ${departments}\" th:text=\"${dept.departmentName}\"&gt; 1 &lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input name=\"birth\" type=\"text\" class=\"form-control\" placeholder=\"2020/01/01\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;添加&lt;/button&gt;&lt;/form&gt; 提交的数据格式不对：生日：日期； 2017-12-12；2017/12/12；2017.12.12； 日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型; 2017-12-12—-Date； 类型转换，格式化; 默认日期是按照/的方式； 3.5 修改操作修改添加二合一表单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!-- 需要区分员工修改还是添加 --&gt;&lt;form th:action=\"${employee!=null}?@{updateEmployee}:@{addEmployee}\" method=\"post\"&gt; &lt;!-- 发送put请求修改原数据 --&gt; &lt;!-- 1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的） 2、页面创建一个post表单 3、创建一个input项，name=\"_method\";值就是我们指定的请求方式 --&gt; &lt;!-- th:if=\"${employee!=null}\"修改页面采用put方式 --&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"put\" th:if=\"${employee!=null}\"/&gt; &lt;input type=\"hidden\" name=\"id\" th:if=\"${employee!=null}\" th:value=\"${employee.id}\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name=\"lastName\" type=\"text\" class=\"form-control\" placeholder=\"name\" th:value=\"${employee!=null}?${employee.lastName}\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name=\"email\" type=\"email\" class=\"form-control\" placeholder=\"name@163.com\" th:value=\"${employee!=null}?${employee.email}\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\" th:checked=\"${employee!=null}?${employee.gender}==1\"&gt; &lt;label class=\"form-check-label\"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\" th:checked=\"${employee!=null}?${employee.gender}==0\"&gt; &lt;label class=\"form-check-label\"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;department&lt;/label&gt; &lt;select class=\"form-control\" name=\"department.id\"&gt; &lt;!-- 提交的是部门的id --&gt; &lt;option th:selected=\"${employee!=null}?${dept.id == employee.department.id}\" th:value=\"${dept.id}\" th:each=\"dept: ${departments}\" th:text=\"${dept.departmentName}\"&gt;1&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input name=\"birth\" type=\"text\" class=\"form-control\" placeholder=\"2020/01/01\" th:value=\"${employee!=null}?${#dates.format(employee.birth, 'yyyy-MM-dd HH:mm')}\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\" th:text=\"${employee!=null}?'修改':'添加'\"&gt; &lt;/button&gt;&lt;/form&gt; 3.6 删除操作123456789101112131415161718192021222324252627282930313233343536373839404142&lt;main role=\"main\" class=\"col-md-9 ml-sm-auto col-lg-10 pt-3 px-4\"&gt; &lt;h2&gt;&lt;a class=\"btn btn-sm btn-success\" th:href=\"@{addEmployeePage}\"&gt;添加员工&lt;/a&gt;&lt;/h2&gt; &lt;div class=\"table-responsive\"&gt; &lt;table class=\"table table-striped table-sm\"&gt; ... &lt;tbody&gt; &lt;tr th:each=\"emp: ${employees}\"&gt; &lt;td th:text=\"${emp.id}\"&gt;&lt;/td&gt; &lt;td&gt;[[${emp.lastName}]]&lt;/td&gt; &lt;td th:text=\"${emp.email}\"&gt;&lt;/td&gt; &lt;td th:text=\"${emp.gender}==0?'女':'男'\"&gt;&lt;/td&gt; &lt;td th:text=\"${emp.department.departmentName}\"&gt;&lt;/td&gt; &lt;td th:text=\"${#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')}\"&gt;&lt;/td&gt; &lt;td&gt; &lt;a class=\"btn btn-sm btn-primary\" th:href=\"@{/employee/}+${emp.id}\"&gt;编辑&lt;/a&gt; &lt;!-- &lt;form th:action=\"@{/employee/}+${emp.id}\" method=\"post\"&gt;--&gt; &lt;!-- &lt;input type=\"hidden\" name=\"_method\" value=\"delete\"/&gt;--&gt; &lt;!-- &lt;button type=\"submit\" class=\"btn btn-sm btn-danger\"&gt;删除&lt;/button&gt;--&gt; &lt;!-- &lt;/form&gt;--&gt; &lt;!-- th:attr自定义标签属性 --&gt; &lt;button th:attr=\"del_uri=@{/employee/}+${emp.id}\" class=\"btn btn-sm btn-danger deleteBtn\"&gt; 删除 &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt;&lt;/main&gt;&lt;!-- 将表单放在里面，每个删除按钮就会有个表单，放在外面简洁 --&gt;&lt;form id=\"deleteEmpForm\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"delete\"/&gt;&lt;/form&gt;&lt;script&gt; $(\".deleteBtn\").click(function(){ //删除当前员工的 $(\"#deleteEmpForm\").attr(\"action\",$(this).attr(\"del_uri\")).submit(); return false; });&lt;/script&gt;","link":"/2020/08/14/Spring/SpringBootCRUD/"},{"title":"处理机调度与进程死锁","text":"处理机调度与进程死锁笔记整理 处理机调度1 调度类型 1.1 三类调度 长程调度——作业调度 决定哪个作业可以进入系统 中程调度——内存调度 决定将哪个（些）进程调入内存 ​ 换入：取决于管理系统并发度的需求； ​ 换出：进程的存储需求。 短程调度——进程调度 决定哪个进程将获得CPU 长程调度程序执行频率较低； 中程调度程序执行频率稍高； 短程调度程序执行频率最高。 1.2 调度的时机和策略 何时调度？ 有任务终止时 处理器的空闲时 终端用户登录时 有更紧急任务到达时 调度哪个？ 先来先服务 优先级 实时性 服务时间 I/O需求 1.3 调度算法的评价准则1.3.1 面向用户，与性能相关 周转时间 从提交到完成之间的时间间隔 响应时间 从提交到开始接收响应之间的时间间隔 截止期限 进程完成的最后期限 1.3.2 面向用户，与性能无关 可预测性 希望提供给用户的服务能够随着时间的流逝展现给用户一贯相同的特性，而与系统执行的其他工作无关。 1.3.3 面向系统，与性能相关 吞吐量 单位时间内完成的进程数目 处理器利用率 处理器处于忙的状态的时间百分比 1.3.4 面向系统，与性能无关 公平性 进程被公平对待 强制优先级 进程被指定优先级，调度策略优先选择高优先级进程 平衡资源 保持系统中所有资源处于繁忙状态，较少适用紧缺资源的进程应该受到照顾 1.4 调度模式 抢占（剥夺）——对有实时性或响应时间要求的任务，必须采用抢占式调度 非抢占（非剥夺）——对没有响应时间要求的任务，可采用非抢占式调度 1.5 优先级的使用 每个进程被指定一个优先级，调度程序总是选择具有较高优先级的进程。 纯粹的优先级调度方案可能会导致第优先级进程长时间处于饥饿状态 一个进程的优先级可随着它的时间或执行历史而变化 2 调度算法2.1 几种常用调度算法的比较 算法 FCFS(先来先服务) RR(轮转) SPN(最短进程优先) SRT(最短剩余时间) HRRN(最高响应比优先) 优先级高者优先 反馈法多队里 选择依据 max((w+s)/s) 调度方式 非抢占式 抢占式（按时间片） 非抢占式 抢占式（进程到达时） 非抢占式 抢占式（时间片） 响应时间 可能很高 对于短进程提供良好的响应时间 提供较好的响应时间 提供较好的响应时间 不突出 开销 最小 低 可能高 可能高 可能高 可能高 对进程的作用 不利于短作业（进程）和I/O繁忙作业 公平对待 不利于长作业（进程） 不利于长作业（进程） 较好均衡个 偏爱I/O繁忙型进程 “饥饿”问题 无 无 可能 可能 无 可能 2.2 补充2.2.1 HRRN 公式：R=(w+s)/s，其中： R：响应比 w：等待处理器的时间 预计的服务时间 2.2.2 优先级高者优先 约定：数小代表优先级高 2.2.3 传统的UNIX调度 多级反馈 每个优先级队列中使用轮转方法 使用1秒抢占方式 每秒都会重新计算每个进程的优先级 2.3 线程调度 负载分配 系统维护一个就绪线程的全局队列，每个处理器只要空闲就从队列中选择一个线程。 组调度 一组相关的线程基于一对一的原则，同时调度到一组处理器上运行。 专用处理器调度 组调度的一种极端形式，在一个应用程序执行期间，把一组处理器专门分配给这个应用程序。 动态调度 某些应用程序允许动态地改变进程中线程数目，需要动态调度。操作系统负责分配处理器给作业，作业自行调度。 3 多机系统与实时系统调度3.1实时调度 实时计算 系统的正确性不仅取决于计算的逻辑结果，还依赖于产生结果的时间。 实时任务 硬实时任务、软实时任务 周期性任务、非周期性任务 实时系统应用的例子 目前：实验控制、过程控制、机器人、空中交通管制、电信、军事指挥与控制系统。 下一代：自动驾驶汽车、具有弹性关节的机器人控制器、智能化生产中系统查找、空间站和海底勘探。 3.2 实时操作系统的特点 可确定性 按照固定的、预先确定的时间或时间间隔执行操作。 可响应性 为中断提供服务时间。 用户控制 允许用户细粒度地控制任务优先级，指定一些特性等。 可靠性 性能的损失或降低可能产生灾难性的后果。 故障弱化操作 系统在故障时尽可能多地保存其性能和数据的能力。 3.3 实时系统调度的特征 快速的进程或线程切换。 体积小（只具备最小限度的功能）。 迅速响应外部中断的能力。 通过诸多信号量、信号和时间之类的进程间通信工具，实现多任务处理。 使用特殊的顺序文件，可以快速存储数据。 基于优先级的抢占式调度。 最小化禁止中断的时间间隔。 用于使任务延迟一段固定的时间或暂停/恢复任务的原语。 特别的警报和超时设定。 3.4 实时系统调度算法 静态表法 执行关于可行调度的静态分析。分析的结果是一个调度，它用于确定在运行时一个任务何时必须开始执行。 静态优先级抢占法 执行一个静态分析，但是没有制定调度，通过给任务制定优先级，使用传统的基于优先级的抢占式调度。 基于动态规划调度法 在运行时动态地确定可行性，可行性分析的结果是一个调度或规划，可用于确定何时分派这个任务。 动态尽力调度法 不执行可行性分析。系统试图满足所有的最后期限，并终止任何已经开始运行但错过最后期限的进程。 3.5 截止时间调度 实时应用程序通常并不关注绝对速度，它关注的是在最有价值的时间完成（或启动）任务。 截止时间调度：最早最后截止时间优先。 最后期限 开始截止时间：任务必须开始的时间。 完成截止时间：任务必须完成的时间。 3.6 优先级反转 在任何优先级调度方案中，系统应该不停地执行具有最高优先级的任务。当系统内的环境迫使一个较高优先级的任务去等待一个较低优先级的任务时，优先级反转就会发生。 优先级：T_1>T_2>T_3，高优先级的T_1被低优先级的T_2占先。 解决方案：优先级继承。 进程死锁1 死锁存在的条件 互斥 无抢占 保持并等待 循环等待","link":"/2020/07/17/OS/DispatchandDeadlock/"},{"title":"Spring Boot自定义starter","text":"1、SpringBoot自定义starters SpringBoot的强大点就是把所有的场景抽象成starter场景启动器。 尽管已经定义好了，但依然可能无法满足我们的需求。 1.1 starter： 这个场景需要使用到的依赖是什么？ 如何编写自动配置 以WebMvcAutoConfiguration.class为例； 12345678@Configuration //指定这个类是一个配置类@ConditionalOnXXX //在指定条件成立的情况下自动配置类生效@AutoConfigureAfter //指定自动配置类的顺序@Bean //给容器中添加组件@ConfigurationPropertie结合相关xxxProperties类来绑定相关的配置@EnableConfigurationProperties //让xxxProperties生效加入到容器中 自动配置类要能加载 1234# 将需要启动就加载的自动配置类，配置在META-INF/spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\ 模式： 启动器只用来做依赖导入； 专门来写一个自动配置模块； 启动器依赖自动配置；别人只需要引入启动器（starter） mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter 1.2 步骤 首先在IDEA创建两个基础Maven项目：starter和autoconfiguration工程 启动器模块 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.custom.starter&lt;/groupId&gt; &lt;artifactId&gt;custom-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--启动器--&gt; &lt;dependencies&gt; &lt;!--引入自动配置模块--&gt; &lt;dependency&gt; &lt;groupId&gt;com.custom.starter&lt;/groupId&gt; &lt;artifactId&gt;custom-spring-boot-starter-autoconfiguration&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 自动配置模块 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.custom.starter&lt;/groupId&gt; &lt;artifactId&gt;custom-spring-boot-starter-autoconfiguration&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;custom-spring-boot-starter-autoconfiguration&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--引入spring-boot-starter；所有starter的基本配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 编写可配置属性 12345678910111213141516171819202122@ConfigurationProperties(prefix = \"custom.hello\")public class HelloProperties { private String prefix; private String suffix; public String getPrefix() { return prefix; } public void setPrefix(String prefix) { this.prefix = prefix; } public String getSuffix() { return suffix; } public void setSuffix(String suffix) { this.suffix = suffix; }} 编写场景 12345678910111213141516public class HelloService { HelloProperties helloProperties; public HelloProperties getHelloProperties() { return helloProperties; } public void setHelloProperties(HelloProperties helloProperties) { this.helloProperties = helloProperties; } public String sayHello(String name){ return helloProperties.getPrefix()+\"-\" +name + helloProperties.getSuffix(); }} 编写属性生效的自动配置类 1234567891011121314@Configuration@ConditionalOnWebApplication //web应用才生效@EnableConfigurationProperties(HelloProperties.class)public class HelloServiceAutoConfiguration { @Autowired HelloProperties helloProperties; @Bean public HelloService helloService(){ HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; }} 同样，想要配置类生效，就要在resources/META-INF/spring.factories编写路径 12org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\com.custom.starter.HelloServiceAutoConfiguration 最后将这2个项目都安装到Maven仓库中，点击IDEA右边Maven Projects，在两个项目的Lifecycle下点击install安装即可。 1.3 测试创建一个新的项目，测试上面我们自定义的starters 在项目的pom.xml文件中引入，自定义starters 123456&lt;!--引入自定义的starter--&gt;&lt;dependency&gt; &lt;groupId&gt;com.custom.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 控制类 1234567891011@RestControllerpublic class HelloController { @Autowired HelloService helloService; @GetMapping(\"/hello\") public String hello(){ return helloService.sayHello(\"starter\"); }} 配置文件 12custom.hello.prefix=CUSTOMcustom.hello.suffix=HELLO WORLD 2、更多SpringBoot整合示例GitHub示例","link":"/2020/08/28/Spring/SpringBootCustomStarters/"},{"title":"Spring Boot配置","text":"1、配置文件 1.1 文件类型Spring Boot使用一个全局配置文件，配置文件名是固定的 application.properties application.yml 配置文件的作用：修改Spring Boot自动配置的默认值（Spring Boot在底层都给我们自动配置好） YAML(YAML Ain’t a Markup Language) YAML 不是一种标记语言的递归缩写 在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言） 标记语言 以前的配置文件，大多都使用XML文件 YAML以数据为中心，比JSON，XML等更适合做配置文件 例子 YAML 12server: port: 8081 XML 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2、YAML语法2.1 基本语法key:(空格)value表示一对键值对 以空格的缩进来控制层级关系，只要是做对齐的一列数据，都是统一层级的 属性和值也是大小写敏感 2.2 值的写法字面量：普通值（数字，字符串，布尔）key: value字面直接来写 字符串默认不用加上单引号或双引号 双引号：不会转义字符串里面的特殊字符，特殊字符会作为本身想表示的意思 name: “Hello \\n World”，输出：Hello 换行 World 单引号：会转义特殊字符，特殊字符最终只是一个普通的字符串数据 name: ‘Hello \\n World’，输出：Hello \\n World 对象、Map（属性和值）（键值对）key: value在下一行来写对象的属性和值的关系，注意缩进 对象还是key: value的方式 123friends: name: Tom age: 20 行内写法 1friends: (name: Tom,age 20) 数组（List、Set）用- value表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat, dog, pig] 2.3 配置文件值注入配置文件application.yml 1234567891011person: name: MysteryGuest age: 21 birth: 1999/01/09 map: {k1: v1, k2: v2} list: - China - Hubei pet: name: niuniu age: 5 @ConfigurationProperties的方式 javaBean 1234567891011121314151617181920212223/** * 将配置文件中配置的每一个属性的值，映射到这个数组中 * @ConfigurationProperties: 告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定 * prefix = \"person\": 配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能 */@Component@ConfigurationProperties(prefix = \"person\")public class Person { private String name; private Integer age; private Date birth; private Map&lt;String, Object&gt; map; private List&lt;Object&gt; list; private Pet pet; // getter() and setter() @Override public String toString() {...}} 我们可以导入配置文件处理器，以后就有自动提示了 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; @Value的方式 123456789101112131415161718192021222324252627@Componentpublic class Person { // 另一种方式，Spring的底层注解 /** * 类似以前 * &lt;bean class=\"Person\"&gt; * &lt;property name=\"name\" value=\"MysteryGuest\"&gt;&lt;/property&gt; * &lt;/bean&gt; * &lt;bean&gt;标签相当于@Compoent * &lt;property&gt;标签中的value相当于@Value * value的参数可以是字面量、${key}从环境变量或配置文件获取值、#{SpEL} */ @Value(\"${person.name}\") private String name; @Value(\"#{11*2}\") private Integer age; private Date birth; private Map&lt;String, Object&gt; map; private List&lt;Object&gt; list; private Pet pet; // getter() and setter() @Override public String toString() {...}} 2.4 @Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个一个指定 松散绑定（松散语法） 支持 不支持 SpEL（例：#{}） 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装（例：Map） 支持 不支持 属性名匹配规则（Relaxed binding，松散绑定） person.firstName：使用标准方式 person.first-name：大写用- person.first_name：大写用_ PERSON_FIRST_NAEM： 推荐系统属性使用这种写法 配置文件（yml和properties）都能获取值 如果说我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@value 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties 2.5 配置文件注入值校验123456789101112131415161718@Component@ConfigurationProperties(prefix = \"person\")@Validated // JSR303数据校验public class Person { @Email // @value不支持 private String name; private Integer age; private Date birth; private Map&lt;String, Object&gt; map; private List&lt;Object&gt; list; private Pet pet; // getter() and setter() @Override public String toString() {...}} 3、@PropertySource和@ImportResource@PropertySource用来加载指定的配置文件 1234@PropertySource(value = {\"classpath:person.properties\"})@Component@ConfigurationProperties(prefix = \"person\")public class Person {...} @ImportResource导入Spring的配置文件，让配置文件里面的内容生效 Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别 想让Spring的配置文件生效，加载进来，@ImportResource标注在一个配置类上 1@ImportResource(locations = {\"classpath:beans.xml\"}) 3.1 Spring Boot推荐给容器中添加组件的方式不来编写Spring的配置文件 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"helloService\" class=\"com.initializr.service.HelloService\"&gt;&lt;/bean&gt;&lt;/beans&gt; @Bean既可以标记在类上，也可以作为元注解 推荐使用全注解的方式 配置类———-Spring配置文件 使用@Bean给容器中添加组件 1234567891011121314/** * @Configuration指明当前类是一个配置类，就是来替代之前的Spring配置文件 * * 以前在配置文件中用&lt;bean&gt;&lt;/bean&gt;标签添加组件 */@Configurationpublic class MyAppConfig { @Bean // 将方法的返回值添加到容器中，容器中这个组件默认的id就是方法名 public HelloService helloService() { System.out.println(\"配置类给容器中添加组件了...\"); return new HelloService(); }} 4、配置文件占位符4.1 随机数12${random.uuid} ${random.int} ${random.long}${random.int(10)} ${random.int[1024,65536]} 4.2 占位符获取之前配置的值，如果之前没有配置值，可以使用默认值123456789person.name=MysticalGuest${random.uuid}person.age=${random.int}person.birth=1999/01/09person.map.k1=v1person.map.k2=v2person.list=[a, b, c]person.pet.name=${person.hello:hello}${person.name}'s dog# 如果文件中没有定义person.hello，那么取后面的hello值person.pet.age=6 5、ProfileProfile是Spring对不同环境提供不同配置功能的支持，可以通过激活、指定参数等方式快速切换环境 5.1 多Profile文件我们在主配置文件编写的时候，文件名可以是application-{profile}.properties/yml 默认使用application.properties/yml的配置 5.2 yml支持多文档块方式123456789101112131415server: port: 8081spring: profiles: active: dev---server: port: 8084spring: profiles: dev---server: port: 8085 spring: profiles: prod 5.3 激活指定profile 指定激活开发环境配置 1spring.profiles.active=dev 编辑运行配置参数 --spring.profiles.active=dev 命令行 打包后运行项目，切换端口，配置传入命令行参数 1$ java -jar target/myproject-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev 虚拟机参数 -Dspring.profiles.active=dev 6、配置文件加载位置Spring Boot启动会扫描以下位置的application.properties或者application.yml文件作为 Spring Boot的默认配置文件 file: ./config/ file为当前项目目录 file: ./ classpath: /config/ classpath: / 以上是按照优先级从高到低的顺序，所有位置的文件都会被加载，高优先级配置内容会覆盖低优先级配置内容；Spring Boot会从这4个位置全部加载主配置文件，互补配置 我们也可以通过配置spring.config.location来改变默认配置 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置，指定配置文件和默认加载的主配置文件 1$ java -jar target/myproject-0.0.1-SNAPSHOT.jar --spring.config.location=D:/application.properties 以便运维的时候修改某些配置 7、外部配置加载顺序Spring Boot支持多种外部配置方式，也可以从以下位置加载配置，优先级从高到底，高优先级的配置覆盖第优先级的配置，所有的配置会形成互补配置 这些方式优先级如下，可以参阅官方文档 命令行参数 1$ java -jar target/myproject-0.0.1-SNAPSHOT.jar --server.port=8089 --server.context-path=/initcmd 来自 java: comp/env的JNDI属性 Java系统属性( System getProperties() ) 操作系统环境变量 RandomValuePropertySource配置的Random.*属性值 jar包外部的application-{profile}.properties或application.yml（带spring.profile）配置文件 由jar包外向jar包内进行寻找，优先加载带profile jar包内部的application-{profile}-properties或application.yml（spring profile)配置文件 jar包外部的application.properties或applcation.yml（不带spring.profile）配置文件 jar包内部的application.properties或application.yml（不带spring.profile）配置文件 @Configuration注解类上的@PropertySource 通过SpringApplication.setDefaultProperties指定的默认属性 8、自动配置原理配置依据官方文档 Spring Boot启动的时候加载主配置类，开启了自动配置功能@EnableAuto Configuratio @EnableAutoConfiguration作用 利用EnableAutoConfigurationlmportSelector给容器中导入一些组件?可以查看selectImports()方法的内容 List configurations = getCandidateConfigurations(annotation Metadata, attributes)获取候选的配置 SpringFactorfesLoader.loadFactoryNames()扫描所有jar包类路径下 META-INF/ spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoconfiguration.class类（类名）对应的值，然后把他们添加在器中 将类路径下 META-INF/spring.factories里面配置的所有 EnableAutoConfiguration的值加入到了容器中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\...org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中，用他们来做自动配置 每一个自动配置类进行自动配置功能 8.1 以HttpEncodingAutoConfiguration为例解释自动配置原理12345678910111213141516171819202122232425262728@Configuration@EnableConfigurationProperties({HttpEncodingProperties.class})@ConditionalOnWebApplication@ConditionalOnClass({CharacterEncodingFilter.class})@ConditionalOnProperty( prefix = \"spring.http.encoding\", value = {\"enabled\"}, matchIfMissing = true)public class HttpEncodingAutoConfiguration { // 已经和Spring Boot的配置文件映射了 private final HttpEncodingProperties properties; // 只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) { this.properties = properties; } @Bean // 给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean({CharacterEncodingFilter.class}) public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; } ...} @Configuration表示这是一个配置类，和之前编写的配置文件一样，也可以给容器中添加组件 @EnableConfigurationProperties启用指定类ConfigurationProperties功能，将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中，就可以用了 所有在配置文件中能配置的属性都是在xxxxProperties类中封装着，配置文件能配置什么可以参照某个功能对应的这个属性类 1234567@ConfigurationProperties( prefix = \"spring.http.encoding\")public class HttpEncodingProperties { public static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\"); ...} @ConfigurationProperties(prefix = &quot;spring.http.encoding&quot;)从配置文件中获取指定的值和bean的属性进行绑定 @ConditionalOnWebApplication是Spring底层@Conditional注解，根据不同条件，如果满足指定的条件，整个配置类里面的配置就会生效； 这个注解是判断当前应用是否是web应用，如果是，当前配置类生效 @ConditionalOnClass判断当前项目有没有指定类CharacterEncodingFilter.class CharacterEncodingFilter.class是SpringMVC中进行乱码解决的过滤器，以前都是配置在web.xml中的 @ConditionalOnProperty判断配置文件中是否存在某个配置spring.http.encoding.enabled，如果不存在，判断也是成立的 即使我们配置文件中不配置spring.http.encoding.enabled=true，也是默认生效的 一句话解释这个配置类，根据当前不同的条件，决定这个配置类是否生效？ 一旦这个配置类生效，这个配置类就会给容器中添加各种组件，这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的 8.2 Spring Boot精髓 SpringBoot启动会加载大量的自动配置类 我们看我们需要的功能有没有Spring Boot默认写好的自动配置类 我们再来看这个自动配置类中到底配置了哪些组件（只要有我们要用的组件，我们就不需要再来配置了，否则，自己配置添加，不满意也可以改） 给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值 xxxAutoConfiguration：自动配置类，给容器中添加组件 xxxproperties：封装配置文件中相关属性 8.3 细节在HttpEncodingAutoConfiguration配置里中 123456789@Bean // 给容器中添加一个组件，这个组件的某些值需要从properties中获取@ConditionalOnMissingBean({CharacterEncodingFilter.class})public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter;} 方法上也有一个注解，判断容器中是否配置了这个组件，如果没有则生效，进行配置 @Conditional派生注解 作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置文件里面的所有内容才生效 Conditional扩属注解 作用(判断是否满足当前指定条件) @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean @ConditionalOnMissingBean 容器中不存在指定Bean @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 Conditionalon NotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 虽然自动配置类很多，但大多都需要一定条件才会生效 之前解析过程中，虽然加载了很多自动配置类，但不是所有的都生效 现在重要的是我们怎么知道哪些配置类生效了 我们可以启用debug属性 12# 开启Spring的debug，默认falsedebug=true 运行后观察控制台输出 1234567891011121314151617181920212223242526272829=========================AUTO-CONFIGURATION REPORT=========================Positive matches:----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) ...Negative matches:----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) ...Unconditional classes:---------------------- org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration ... Positive matches：自动配置类启用的Negative matches：没有启动，没有匹配成功的自动配置类","link":"/2020/08/07/Spring/SpringBootConfig/"},{"title":"高级操作系统","text":"课程目标 1、了解高级系统相关内容（主要包括网络OS与分布式系统的概念、特点、应用额体系结构与软硬件组成等）； 2、掌握单机操作系统设计实现原理（特别是常见的操作系统习题、试题的了理解和解答方法）。 1 Distributed Systems1.1 Definition一个分布式系统是：独立计算机的集合，对用户而言，它们看起来像是一个统一的系统。 尚不存在一致性的定义，普遍接受的定义是： 分布式系统是若干台独立计算机的一种联合体，对用户而言，这个联合体就是一台单独的计算机。 在这个定义中，前半句说明是对计算机硬件的要求，后半句是对计算机软件的要求，这两项都是对分布式系统的基本的要求。 另一个角度： 分布式系统是这样一个系统，它运行在不具有共享内存的多台计算机上，但在用户眼里它却像是一台计算机。 实质思想：用户不必去关心系统中的多台计算机的存在。 尽管目前不存在完全满足该条件的系统，但已经有一些原型出现。 1234567891011Machine A Machine B Machine C---------- ---------- ----------| | | | | || Distributed Application 分布式应用程序 || | | | | || Middleware Service 中间件服务 || | | | | ||Local OS| |Local OS| |Local OS|---------- ---------- ---------- | | |-----------------------------------------------------------Network 中间件是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的。 组织为中间件的分布式系统。请注意，中间件层覆盖了多台计算机。 1.2 分布式系统的特点1.2.1 资源共享 Resource Sharing 硬件资源共享：专用设备共享 =》 处理资源共享 =》 负载共享与负载均衡 信息资源共享：如：电子商务应用共享同一数据对象，协同工作组共享同一数据空间 软件资源共享：软件开发组共享同一开发工具，同一类应用任务调用同一处理软件 资源异构、分布 =》 资源命名方案、分布资源管理模型、策略与机制是要解决的重点 互联网络环境 =》 计算机资源共享和多媒体信息资源共享成为研究和开发的热点 1.2.2 透明性 Transparency 透明性的基本概念和内容 机器边界、网络细节和系统状态对用户和应用程序员呈不可见性。多计算机环境 =》 单机环境。例如用户不必知道数据存在何处，进程在何处运行。 优点 软件易于研制；资源变动，软件影响小； 易于实现资源冗余；有利于资源操作移动 实现难点 大多数分布计算机系统固有的异构性增加了透明性实现的难度。 硬件异构性：指令系统不同、数据表示不同。系统配置不同 软件异构性：操作系统不同、网络协议不同 局部自治性限制全局透明性 Transparency Description Access 访问 隐藏数据表示形式和资源访问方式的差异 Location 隐藏资源所在的位置 Migration 转移 隐藏资源可能会移动到另一个位置 Relocation 重定位 隐藏资源在使用中可能会移动到另一个位置 Replication 复写 隐瞒资源可以通过多个副本进行部署和分发 Concurrency 隐瞒资源可能会由几个竞争用户共享 Failure 隐藏资源的故障和恢复 Persistence 隐藏（软件）资源是在内存中还是在磁盘上 分布式系统透明性的不同形式。 1.3 开放性 Openess 是指系统以各种方式进行扩展的能力。核心是要求不同厂家的系统（软硬件）具有互操作性（Interoperability）和可移植性（Portability） 互操作性：不同厂家的系统可有效地相互交换信息 可移植性：在较大范围的平台上运行同一软件的功能 UNIX是一个优秀的开放式软件系统：开放式结构、源代码可用、硬件无关性；TCP/IP协议是另一个开放式系统的例子 标准化是实现开放性的基本保证 标准是已被广泛接受的一种特定实现方法或功能集（接口）。 开房放概念是一种思想、设计观点、系统特征。因此，标准并不意味着是最好的、并不总是绝对需要的（尤其是在早期）、不是一成不变的。 国际标准化组织ISO。 1.4 延展性 Scalability延展性的制约： Concept Example Centralized services 集中服务 一台适用于所有用户的服务器 Centralized data 集中数据 一本在线电话簿 Centralized algorithms 集中式算法 根据完整信息进行路由 Scaling Techniques 1.5 容错性 Fault Tolerance基本概念 系统部分失效是能继续发挥作用的能力。如某个网络节点故障而不影响网络系统正常行为。 分布计算系统的资源多重性为实现容错创造条件：硬件资源冗余、数据多副本、动态切换。 系统容错是提高系统可靠性的重要途径。可靠性描述了系统成功运行的寿命特性。 容错性是分布计算应用的强烈需求：国防应用系统，电子商务应用的电子支付系统。","link":"/2020/06/30/OS/DistributedSystem/"},{"title":"Spring Boot与Docker","text":"1、Docker简介类似于虚拟机技术，但不是一个虚拟机，却实现了虚拟机技术里的资源隔离，性能远远高于虚拟机。 Docker是一个开源的应用容器引擎；是一个轻量级容器技术； 如图，将用一个实例来讲述Docker的来源： 用户A使用的电脑是Windows原生系统，需要自己安装驱动和软件等，但如果用户B也使用同样方法，就也得自己再装一遍，其他人也一样，过于麻烦。 那么就有了Windows镜像系统，用户A把系统装好后，包括安装好的驱动和软件等，打包成镜像，其他用户也就有了。 Docker就类似于这种镜像机制。 Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像； 运行中的这个镜像称为容器，容器启动是非常快速的。 2、核心概念 docker主机(Host)：安装了d ocker程序的机器（Docker直接安装在操作系统之上） docker客户端(Client)：连接docker主机进行操作 docker仓库(Registry)：用来保存各种打包好的软件镜像；公共、私人仓库 docker镜像(Images)：软件打包好的镜像；放在docker仓库中 docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 使用Docker的步骤： 安装Docker 去Docker仓库找到这个软件对应的镜像 使用Docker运行这个镜像，这个镜像就会生成一个Docker容器 对容器的启动停止就是对软件的启动停止 3、安装Docker3.1 安装linux虚拟机 VMWare、VirtualBox 创建新虚拟机或打开已创建的虚拟机，这里选择CentOS 3.2 在linux虚拟机上安装docker，步骤 检查内核版本，必须是3.10及以上 1$ uname -r 不是3.10及以上的，使用 1$ yum update 安装依赖 1$ yum install -y yum-utils device-mapper-persistent-data lvm2 添加软件源（设置yum源） 1$ yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 可以查看所有仓库中所有docker版本，并选择特定版本安装 1$ yum list docker-ce --showduplicates | sort -r 安装docker 1$ sudo yum install &lt;FQPN&gt; # 例如：sudo yum install docker-ce-18.03.1.ce 启动docker 1$ systemctl start docker 验证安装是否成功（有client和service两部分表示docker安装启动都成功了） 1$ docker version 停止docker 1$ systemctl stop docker 开机启动docker 1$ systemctl enable docker 更换docker的镜像源 修改或创建daemon.json文件：vi /etc/docker/daemon.json将以下配置写入到文件中，保存并退出（不会操作的百度下vi命令吧）： Docker中国官方镜像加速 123{ \"registry-mirrors\": [\"https://registry.docker-cn.com\"]} 中科大镜像加速 123{ \"registry-mirrors\": [\"https://docker.mirrors.ustc.edu.cn\"]} 网易163镜像加速 123{ \"registry-mirrors\": [\"http://hub-mirror.c.163.com\"]} 阿里云跟daocloud镜像加速需要注册账号，阿里云官网，登录之后选择控制台，找到容器镜像服务，在镜像加速器下有个加速地址，复制添加上即可 123{ \"registry-mirrors\": [\"https://xxxxxxxx.mirror.aliyuncs.com\"]} 重启docker：systemctl restart docker 4、Docker常用命令&amp;操作4.1 镜像操作 操作 命令 说明 检索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。 拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest 列表 docker images 查看所有本地镜像 删除 docker rmi image-id 删除指定的本地镜像 Docker Hub仓库 4.2 容器操作软件镜像（例：QQ安装程序）——运行镜像——产生一个容器（正在运行的软件，运行的QQ） 步骤： 搜索镜像 1$ docker search tomcat 拉取镜像 1$ docker pull tomcat 根据镜像启动容器 12// --name给容器起名$ docker run --name mytomcat -d tomcat:latest 查看运行中的容器 1$ docker ps 停止运行中的容器 1$ docker stop &lt;容器的id&gt;/&lt;容器的name&gt; 查看所有的容器（包括运行中和已停止的） 1$ docker ps -a 启动容器 1$ docker start &lt;容器id&gt; 删除一个容器（注意和删除镜像的区别） 1$ docker rm 容器id 启动一个做了端口映射的tomcat（可以不用起名），一个镜像可以做 1$ docker run -d -p 8888:8080 tomcat -d：后台运行-p：将主机的端口映射到容器的一个端口 主机端口:容器内部的端口 查看容器的日志 1$ docker logs &lt;container-name&gt;/&lt;container-id&gt; 更多命令，可以参考每一个镜像的文档 5、安装MySQL示例1$ docker pull mysql 错误的启动 1$ docker run --name mysql01 -d mysql 用docker ps观察到，mysql退出了；为什么呢？使用docker logs &lt;mysql的id&gt;，得到错误日志：三个参数必须指定一个 123error: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD 正确的启动 1$ docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql 还应做端口映射 1$ docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysql 几个其他的高级操作 -v：把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面 改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql） 12$ docker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag 不用配置文件，指定mysql的一些配置参数 12$ docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character -set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci","link":"/2020/08/18/Spring/SpringBootDocker/"},{"title":"Spring Boot启动配置原理","text":"1、启动配置原理1.1 几个重要的事件回调机制 配置在META-INF/spring.factories ApplicationContextInitializer SpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner CommandLineRunner 在主程序类中打上断点，Debug，进行研究。 1.2 启动流程： 创建SpringApplication对象 12345678// SpringApplication.classpublic static ConfigurableApplicationContext run(Object source, String... args) { return run(new Object[]{source}, args);}public static ConfigurableApplicationContext run(Object[] sources, String[] args) { return (new SpringApplication(sources)).run(args);} 调用initialize(sources);方法 12345678910111213141516private void initialize(Object[] sources) { // 保存主配置类 if (sources != null &amp;&amp; sources.length &gt; 0) { this.sources.addAll(Arrays.asList(sources)); } // 判断当前是否一个web应用, 即是否导入web模块 this.webEnvironment = deduceWebEnvironment(); // 从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer // 然后保存起来, 不着急用 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); // 从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); // 从多个配置类中找到有main方法的主配置类 this.mainApplicationClass = deduceMainApplicationClass();} 找到ApplicationContextInitializer： 找到的Listener： 运行run方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); //获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories SpringApplicationRunListeners listeners = getRunListeners(args); //回调所有的获取SpringApplicationRunListener.starting()方法 listeners.starting(); try { //封装命令行参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); //准备环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); //创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成 Banner printedBanner = printBanner(environment); //创建ApplicationContext；决定创建web的ioc还是普通的ioc context = createApplicationContext(); analyzers = new FailureAnalyzers(context); //准备上下文环境;将environment保存到ioc中；而且applyInitializers()； //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法 //回调所有的SpringApplicationRunListener的contextPrepared()； prepareContext(context, environment, listeners, applicationArguments, printedBanner); //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded()； //s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版 //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置） refreshContext(context); //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 //ApplicationRunner先回调，CommandLineRunner再回调 afterRefresh(context, applicationArguments); //所有的SpringApplicationRunListener回调finished方法 listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); } //整个SpringBoot应用启动完成以后返回启动的ioc容器； return context; } catch (Throwable ex) { handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); }} 2、事件监听机制来实现一下1.1节中提到的4个组件； 2.1 实现自定义ApplicationContextInitializerCtrl+n搜索ApplicationContextInitializer，选择ApplicationContextInitializer，Ctrl+h查看SpringBoot已经实现的所有Initializer： 12345678910// HelloApplicationContextInitializer.javapublic class HelloApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; { // 来监听ioc容器的启动 @Override public void initialize(ConfigurableApplicationContext applicationContext) { System.out.println(\"ApplicationContextInitializer...initialize...\"+applicationContext); }} 2. 2 实现自定义SpringApplicationRunListener1234567891011121314151617181920212223242526272829303132333435363738// HelloSpringApplicationRunListener.javapublic class HelloSpringApplicationRunListener implements SpringApplicationRunListener { //必须有的构造器, 传过来Spring应用和命令行参数 public HelloSpringApplicationRunListener(SpringApplication application, String[] args){ } // 监听容器开始 @Override public void starting() { System.out.println(\"SpringApplicationRunListener...starting...\"); } @Override public void environmentPrepared(ConfigurableEnvironment configurableEnvironment) { Object o = configurableEnvironment.getSystemProperties().get(\"os.name\"); System.out.println(\"SpringApplicationRunListener...environmentPrepared..\"+o); } @Override public void contextPrepared(ConfigurableApplicationContext configurableApplicationContext) { System.out.println(\"SpringApplicationRunListener...contextPrepared...\"); } // 容器环境加载完成 @Override public void contextLoaded(ConfigurableApplicationContext configurableApplicationContext) { System.out.println(\"SpringApplicationRunListener...contextLoaded...\"); } @Override public void finished(ConfigurableApplicationContext configurableApplicationContext, Throwable throwable) { System.out.println(\"SpringApplicationRunListener...finished...\"); }} 以上两个组件想要起作用，必须配置（META-INF/spring.factories）；在我们引入的每个Jar包里，点开其目录结构中都有META-INF文件夹，里面有个spring.factories文件； 我们就要在resources文件夹下创建META-INF/spring.factories，并写入： 123456// copy Referenceorg.springframework.context.ApplicationContextInitializer=\\com.initializr.initializer.HelloApplicationContextInitializerorg.springframework.boot.SpringApplicationRunListener=\\com.initializr.listener.HelloSpringApplicationRunListener 2.3 实现自定义ApplicationRunner12345678// 需要放在容器中的@Componentpublic class HelloApplicationRunner implements ApplicationRunner { @Override public void run(ApplicationArguments applicationArguments) throws Exception { System.out.println(\"ApplicationRunner...run....\"); }} 2.4 实现自定义CommandLineRunner12345678// 需要放在容器中的@Componentpublic class HelloCommandLineRunner implements CommandLineRunner { @Override public void run(String... strings) throws Exception { System.out.println(\"CommandLineRunner...run...\"+ Arrays.asList(strings)); }} 运行查看控制台有定义输出即可：","link":"/2020/08/27/Spring/SpringBootStartupConfigPrinciple/"},{"title":"Spring Boot错误机制","text":"1、错误处理机制1.1 SpringBoot默认的错误处理机制 默认效果： 浏览器，返回一个默认的错误页面 浏览器发送请求的请求头： 如果是其他客户端，默认响应一个json数据 客户端的请求头： 1.2 原理： 可以参照ErrorMvcAutoConfiguration；错误处理的自动配置；查看这个类的源码 这个配置类给容器中添加了以下组件： DefaultErrorAttributes： 123456789101112// 帮我们在页面共享信息@Overridepublic Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) { Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;(); errorAttributes.put(\"timestamp\", new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes;} BasicErrorController： 12345678910111213141516171819202122232425262728293031@Controller@RequestMapping(\"${server.error.path:${error.path:/error}}\")public class BasicErrorController extends AbstractErrorController { ... // 产生html类型的数据；浏览器发送的请求来到这个方法处理 @RequestMapping(produces = \"text/html\") public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) { HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); // 去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView(\"error\", model) : modelAndView); } // 产生json数据，其他客户端来到这个方法处理 @RequestMapping @ResponseBody public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) { Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); } ...} ErrorPageCustomizer： 12345public class ErrorProperties { @Value(\"${error.path:/error}\") private String path = \"/error\"; ...} DefaultErrorViewResolver 12345678910111213141516171819202122232425@Overridepublic ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) { ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) { modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); } return modelAndView;}private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) { //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = \"error/\" + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders.getProvider(errorViewName, this.applicationContext); if (provider != null) { //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); } //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model);} 1.3 步骤一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被BasicErrorController处理； 响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的 123456789101112131415protected ModelAndView resolveErrorView( HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) { //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) { ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) { return modelAndView; } } return null;} 2、如何定制错误响应：2.1 如何定制错误的页面 有模板引擎的情况下； error/状态码; 将错误页面命名为错误状态码.html放在模板引擎文件夹里面的error文件夹下，发生此状态码的错误就会来到 对应的页面； 我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）； 页面能获取的信息； 123456timestamp：时间戳status：状态码error：错误提示exception：异常对象message：异常消息errors：JSR303数据校验的错误都在这里 没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找； 以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面 2.2 如何定制错误的json数据 自定义异常处理&amp;返回定制json数据： 12345678910111213@ControllerAdvicepublic class CustomExceptionHandler { // 只要出现异常，SpringMVC就会调用这个方法，把异常对象传进来 @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String, Object&gt; handleException(Exception e){ Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"code\", \"user not exist\"); map.put(\"message\", e.getMessage()); return map; }} 用以上方法没有自适应效果，浏览器和客户端返回都是JSON数据 我们可以看到源码中，BasicErrorController类是用来处理自适应的 转发到/error进行自适应响应效果处理 12345678910111213141516171819@ControllerAdvicepublic class CustomExceptionHandler { @ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request){ Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * AbstractErrorController.class中 * Integer statusCode = (Integer) request .getAttribute(\"javax.servlet.error.status_code\"); */ request.setAttribute(\"javax.servlet.error.status_code\", 500); map.put(\"code\", \"user not exist\"); map.put(\"message\", e.getMessage()); // 转发到/error return \"forward:/error\"; }} 将我们的定制数据携带出去； 出现错误以后，会来到/error请求，会被BasicErrorController.class处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController.class（ErrorController）规定的方法）； 完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中； 页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到； 自定义： 12345678910111213// 给容器中加入我们自己定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes { @Override public Map&lt;String, Object&gt; getErrorAttributes( RequestAttributes requestAttributes, boolean includeStackTrace) { Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put(\"company\", \"MysteryGuest\"); return map; }} 最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容","link":"/2020/08/15/Spring/SpringBootError/"},{"title":"Spring Boot与Servlet","text":"1、配置嵌入式Servlet容器SpringBoot默认使用Tomcat作为嵌入式的Servlet容器； 问题？ 1.1 如何定制和修改Servlet容器的相关配置； 修改和server有关的配置（ServerProperties{也是EmbeddedServletContainerCustomizer}）； 123456789server.port=8088server.context-path=/server.tomcat.uri-encoding=UTF-8//通用的Servlet容器设置server.xxx//Tomcat的设置server.tomcat.xxx 编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置 123456789101112@Bean //一定要将这个定制器加入到容器中public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer(){ return new EmbeddedServletContainerCustomizer() { //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableEmbeddedServletContainer container) { container.setPort(8083); } };} 1.2 注册Servlet三大组件（Servlet、Filter、Listener）由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。 注册三大组件用以下方式 ServletRegistrationBean 1234567891011//注册三大组件@Beanpublic ServletRegistrationBean myServlet(){ ServletRegistrationBean registrationBean = new ServletRegistrationBean( new CustomServlet(), \"/myServlet\" ); return registrationBean;} FilterRegistrationBean 1234567@Beanpublic FilterRegistrationBean myFilter(){ FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new CustomFilter()); registrationBean.setUrlPatterns(Arrays.asList(\"/hello\",\"/myServlet\")); return registrationBean;} ServletListenerRegistrationBean 123456@Beanpublic ServletListenerRegistrationBean myListener(){ ServletListenerRegistrationBean&lt;CustomListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new CustomListener()); return registrationBean;} SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet； DispatcherServletAutoConfiguration中： 12345678910111213141516171819202122232425@Bean( name = {\"dispatcherServletRegistration\"})@ConditionalOnBean( value = {DispatcherServlet.class}, name = {\"dispatcherServlet\"})public ServletRegistrationBean dispatcherServletRegistration(DispatcherServlet dispatcherServlet) { ServletRegistrationBean registration = new ServletRegistrationBean( dispatcherServlet, new String[]{this.serverProperties.getServletMapping()} ); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(\"dispatcherServlet\"); registration.setLoadOnStartup(this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) { registration.setMultipartConfig(this.multipartConfig); } return registration;} 2、SpringBoot能不能支持其他的Servlet容器？在之前写定制嵌入式的Servlet容器相关的规则配置类的时候 在ServletConfig.class中用的ConfigurableEmbeddedServletContainer声明的变量，选中，点击Ctrl+h，会在右侧显示它的继承树： 可配置的嵌入式容器工程 3、替换为其他嵌入式Servlet容器默认支持： 3.1 Tomcat（默认使用）12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!--引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器--&gt;&lt;/dependency&gt; 3.2 Jetty（长链接，例如聊天）12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- 引入除Tomcat外的其他Servlet: jetty --&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; 3.3 Undertow（不支持JSP）12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- 引入除Tomcat外的其他Servlet: undertow --&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; 3.4 嵌入式Servlet容器自动配置原理在自动配置包里的EmbeddedServletContainerAutoConfiguration.class：嵌入式的Servlet容器自动配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@AutoConfigureOrder(-2147483648)@Configuration@ConditionalOnWebApplication@Import({EmbeddedServletContainerAutoConfiguration.BeanPostProcessorsRegistrar.class})// 导入BeanPostProcessorsRegistrar; 给容器中导入一些组件// 导入了EmbeddedServletContainerCustomizerBeanPostProcessor// 后置处理器: bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作public class EmbeddedServletContainerAutoConfiguration { ... @Configuration @ConditionalOnClass({Servlet.class, Undertow.class, SslClientAuthMode.class}) @ConditionalOnMissingBean( value = {EmbeddedServletContainerFactory.class}, search = SearchStrategy.CURRENT ) public static class EmbeddedUndertow { public EmbeddedUndertow() { } @Bean public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory(){ return new UndertowEmbeddedServletContainerFactory(); } } @Configuration @ConditionalOnClass({Servlet.class, Server.class, Loader.class, WebAppContext.class}) @ConditionalOnMissingBean( value = {EmbeddedServletContainerFactory.class}, search = SearchStrategy.CURRENT ) public static class EmbeddedJetty { public EmbeddedJetty() { } @Bean public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() { return new JettyEmbeddedServletContainerFactory(); } } @Configuration // 判断当前是否引入了Tomcat依赖 @ConditionalOnClass({Servlet.class, Tomcat.class}) // 判断当前容器没有用户自己定义EmbeddedServletContainerFactory: 嵌入式的Servlet容器工厂 // 作用: 创建嵌入式的Servlet容器 @ConditionalOnMissingBean( value = {EmbeddedServletContainerFactory.class}, search = SearchStrategy.CURRENT ) public static class EmbeddedTomcat { public EmbeddedTomcat() { } @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() { return new TomcatEmbeddedServletContainerFactory(); } }} EmbeddedServletContainerFactory（嵌入式Servlet容器工厂） 1234public interface EmbeddedServletContainerFactory { // 获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer(ServletContextInitializer... var1);} EmbeddedServletContainer（嵌入式的Servlet容器） 以TomcatEmbeddedServletContainerFactory为例 1234567891011121314151617181920212223242526public EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers) { // 创建一个Tomcat Tomcat tomcat = new Tomcat(); // 配置Tomcat的基本环镜 File baseDir = this.baseDirectory != null ? this.baseDirectory : this.createTempDir(\"tomcat\"); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); this.customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); this.configureEngine(tomcat.getEngine()); Iterator var5 = this.additionalTomcatConnectors.iterator(); while(var5.hasNext()) { Connector additionalConnector = (Connector)var5.next(); tomcat.getService().addConnector(additionalConnector); } this.prepareContext(tomcat.getHost(), initializers); // 将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器 return this.getTomcatEmbeddedServletContainer(tomcat);} 我们对嵌入式容器的配置修改是怎么生效？ 12# 配置文件ServerProperties 或 12// 配置类EmbeddedServletContainerCustomizer() EmbeddedServletContainerCustomizer：定制器帮我们修改了Servlet容器的配置？ 怎么修改的原理？ 容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor 1234567891011121314151617181920212223242526272829303132333435363738394041// 初始化之前public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { // 如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件 if (bean instanceof ConfigurableEmbeddedServletContainer) { this.postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer)bean); } return bean;}...private void postProcessBeforeInitialization(ConfigurableEmbeddedServletContainer bean) { Iterator var2 = this.getCustomizers().iterator(); //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值 while(var2.hasNext()) { EmbeddedServletContainerCustomizer customizer = (EmbeddedServletContainerCustomizer)var2.next(); customizer.customize(bean); } private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() { if (this.customizers == null) { // 从容器中获取所有这葛类型的组件: EmbeddedServletContainerCustomizer // 定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件 this.customizers = new ArrayList( this.beanFactory.getBeansOfType( EmbeddedServletContainerCustomizer.class, false, false).values() ); Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); } return this.customizers; }} ServerProperties也是定制器，步骤： SpringBoot根据导入的依赖情况，给容器中添加相应的嵌入式容器工厂，EmbeddedServletContainerFactory[TomcatEmbeddedServletContainerFactory] 容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor；只要是嵌入式的Servlet容器工厂，后置处理器就工作； 后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法 4、嵌入式Servlet容器启动原理什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat？ 获取嵌入式的Servlet容器工厂： SpringBoot应用启动运行run方法 refreshContext(context)；SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext refresh(context)，刷新刚才创建好的ioc容器；查看AbstractApplicationContext.class源码： 1234567891011121314151617181920212223242526272829303132public void refresh() throws BeansException, IllegalStateException { synchronized(this.startupShutdownMonitor) { this.prepareRefresh(); ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory(); this.prepareBeanFactory(beanFactory); try { this.postProcessBeanFactory(beanFactory); this.invokeBeanFactoryPostProcessors(beanFactory); this.registerBeanPostProcessors(beanFactory); this.initMessageSource(); this.initApplicationEventMulticaster(); this.onRefresh(); this.registerListeners(); this.finishBeanFactoryInitialization(beanFactory); this.finishRefresh(); } catch (BeansException var9) { if (this.logger.isWarnEnabled()) { this.logger.warn( \"Exception encountered during context initialization - cancelling refresh attempt: \" + var9 ); } this.destroyBeans(); this.cancelRefresh(var9); throw var9; } finally { this.resetCommonCaches(); } }} onRefresh()，web的ioc容器重写了onRefresh方法 webioc容器会创建嵌入式的Servlet容器；createEmbeddedServletContainer(); 获取嵌入式的Servlet容器工厂：** 1EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory(); 从ioc容器中获取EmbeddedServletContainerFactory 组件；TomcatEmbeddedServletContainerFactory创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置； 使用容器工厂获取嵌入式的Servlet容器： 12this.embeddedServletContainer = containerFactory.getEmbeddedServletContainer(getSelfInitializer()); 嵌入式的Servlet容器创建对象并启动Servlet容器； 先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来； IOC容器启动创建嵌入式的Servlet容器 5、使用外置的Servlet容器嵌入式Servlet容器：应用打成可执行的jar 优点：简单、便携； 缺点：默认不支持JSP、优化定制比较复杂（使用定制器{ServerProperties、自定义EmbeddedServletContainerCustomizer}，自己编写嵌入式Servlet容器的创建工厂{EmbeddedServletContainerFactory}）； 外置的Servlet容器：外面安装Tomcat—-应用war包的方式打包； 5.1 创建JSPweb项目教程： 使用Spring Initializr新建项目： 剩下都是Next，得到项目结构： 生成webapp文件夹（可手动创建，也可用以下方法）： 点击编译器右上的Project Structure按钮—&gt;Modules—&gt;项目展开—&gt;Web—&gt;Web Resource Directories 双击Web Resource Directory下的路径，弹出对话框： 点击OK，然后在弹出对话框点Yes即可； 部署描述图生成XML文件： 将默认的路径...\\WEB-INF\\web.xml改为...\\src\\main\\webapp\\WEB-INF\\web.xml，点击OK即可，最后Apply—&gt;OK 如何启动？ 服务器整合进IDEA 编译器上方Edit Configurations… 添加本地Tomcat配置即可： 配置完后添加部署项目： 出现对话框，选择第二个暴露的就行 最后Apply—&gt;OK。运行Tomcat即可 5.2 步骤 必须创建一个war项目；（利用IDEA创建好目录结构） 将嵌入式的Tomcat指定为provided； 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 必须编写一个SpringBootServletInitializer的子类，并调用configure方法 123456789public class ServletInitializer extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) { // 传入SpringBoot应用的主程序 return application.sources(SpringBootWebJspApplication.class); }} 启动服务器就可以使用。 5.3 原理 jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器； war包：启动服务器，服务器启动SpringBoot应用{SpringBootServletInitializer}，启动ioc容器； servlet3.0（规范文档） 5.4 查看8.2.4 Shared libraries / runtimes pluggability条内容：规则： 服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例； ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名 还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类 5.5 流程 启动Tomcat org\\springframework\\spring-web\\4.3.14.RELEASE\\spring-web-4.3.14.RELEASE.jar!\\META-INF\\services\\javax.servlet.ServletContainerInitializer： Spring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set","link":"/2020/08/16/Spring/SpringBootServlet/"},{"title":"Spring Boot入门，源码解析","text":"1、Spring Boot简介简化Spring应用开发的一个框架 整个Spring技术栈的一个大整合 J2EE开发的一站式解决方案 2、微服务2014，Martin Fowler微服务论文 微服务：架构风格（服务微化） 每一个功能元素最终都是一个可独立替换和独立升级的软件单元 一个应用应该是一组小型服务：可以通过HTTP的方式进行互通 通常跟微服务相对的是单体应用，即将所有功能都打包成在一个独立单元的应用程序。 环境约束（我的开发环境）： JDK8：java version “1.8.0_131” Maven3.x：Apache Maven 3.6.3 IntelliJ IDEA2019.2 SpringBoot 1.5.9.RELEASE 3、Spring Boot HelloWorld一个功能：浏览器发送请求，服务器接收请求并处理，响应”Hello World”字符串 3.1 创建一个Maven工程3.2 导入依赖Spring Boot相关的依赖1234567891011121314&lt;!-- Inherit defaults from Spring Boot --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;!-- Add typical dependencies for a web application --&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.3 编写一个主程序启动Spring Boot应用 123456789101112@SpringBootApplication@RestControllerpublic class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } @GetMapping(\"/hello\") public String hello(@RequestParam(value = \"name\", defaultValue = \"World\") String name) { return String.format(\"Hello %s!\", name); } } 3.4 编写相关的Controller、Service层3.5 运行主程序测试3.6 简化部署Spring官方部署文档 123456789&lt;!-- 这个插件可以将应用打包成一个可执行的jar包 --&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 要运行该应用程序，请使用java -jar命令： 12345678910111213$ java -jar target/myproject-0.0.1-SNAPSHOT.jar . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.9.RELEASE)....... . . ........ . . . (log output here)....... . . ......... Started Example in 2.536 seconds (JVM running for 2.864) 4、Hello World探究4.1 POM文件父项目 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt; Ctrl+鼠标左键查看底层源码，上面这个父项目还依赖于 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt; 实现真正管理Spring Boot应用里面的所有依赖版本 Spring Boot的版本仲裁中心 12345678&lt;properties&gt; &lt;!-- Dependency versions --&gt; &lt;activemq.version&gt;5.14.5&lt;/activemq.version&gt; &lt;antlr2.version&gt;2.7.7&lt;/antlr2.version&gt; ... &lt;maven-war-plugin.version&gt;2.6&lt;/maven-war-plugin.version&gt; &lt;versions-maven-plugin.version&gt;2.2&lt;/versions-maven-plugin.version&gt;&lt;/properties&gt; 以后我们导入依赖默认是不需要写版本（没有在dependencies里面管理的依赖自然需要声明版本号） 4.2 导入的依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-web spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件 更多启动器 Spring Boot将所有的功能场景都抽取出来，做成一个个的starter（启动器），只需要在项目里引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 4.3 主程序类，主入口类1@SpringBootApplication Spring Boot应用标注在某个类上说明这个类是Spring Boot的主配置类，Spring Boot就应该运行这个类的main方法来启动Spring Boot应用 点击这个注解（annotation）查看源码 12345678910111213141516171819202122232425262728293031323334353637383940@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class}), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class})})public @interface SpringBootApplication { @AliasFor( annotation = EnableAutoConfiguration.class, attribute = \"exclude\" ) Class&lt;?&gt;[] exclude() default {}; @AliasFor( annotation = EnableAutoConfiguration.class, attribute = \"excludeName\" ) String[] excludeName() default {}; @AliasFor( annotation = ComponentScan.class, attribute = \"basePackages\" ) String[] scanBasePackages() default {}; @AliasFor( annotation = ComponentScan.class, attribute = \"basePackageClasses\" ) Class&lt;?&gt;[] scanBasePackageClasses() default {};} 解析 1@SpringBootConfiguration // spring boot定义的注解 Spring Boot的配置类，标注在某个类上，表示这是一个Spring Boot的配置类 点击这个注解（annotation）查看源码 123456@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Configurationpublic @interface SpringBootConfiguration {} 解析 1@Configuration // spring定义的注解 配置类上来标注这个注解 配置类—-配置文件：配置类也是容器中的一个组件：@Commponent 1@EnableAutoConfiguration 开启自动配置功能 以前我们需要配置的东西，Spring Boot帮我们自动配置，这个注解告诉Spring Boot开启自动配置功能，这样自动配置才能生效 点击这个注解（annotation）查看源码 12345678910111213@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import({EnableAutoConfigurationImportSelector.class})public @interface EnableAutoConfiguration { String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\"; Class&lt;?&gt;[] exclude() default {}; String[] excludeName() default {};} 解析 1@AutoConfigurationPackage 自动配置包 点击这个注解（annotation）查看源码 1234567@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import({Registrar.class})public @interface AutoConfigurationPackage {} 解析 1@Import({Registrar.class}) Spring的底层注解@import，给容器中导入一个组件 导入的组件由Registrar.class 1234567891011121314static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports { ... // metadata是注解的原信息 public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) { AutoConfigurationPackages.register( registry, (new AutoConfigurationPackages.PackageImport(metadata)).getPackageName() ); } ...} 将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器 1@Import({EnableAutoConfigurationImportSelector.class}) 给容器中导入组件，这是导入那些组件的选择器 点击这个注解（annotation）查看源码 1234567891011121314151617/** @deprecated */@Deprecatedpublic class EnableAutoConfigurationImportSelector extends AutoConfigurationImportSelector { public EnableAutoConfigurationImportSelector() { } protected boolean isEnabled(AnnotationMetadata metadata) { return this.getClass().equals( EnableAutoConfigurationImportSelector.class ) ? (Boolean)this.getEnvironment().getProperty( \"spring.boot.enableautoconfiguration\", Boolean.class, true) : true; }} 然后再查看其父类的源码 里面有一个selectImports方法，将所有需要导入的组件以全类名的方式返回，这些组件就会被添加到容器中 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）：就是给容器中这个场景所需要的所有组件，并配置好这些组件 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作 selectImports会调用该类里的getCandidateConfigurations方法 getCandidateConfigurations又调用了SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class, classLoader) Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作 以前我们需要自己配置的东西，自动配置类帮我们 J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar 5、使用Spring Initializer快速创建Spring Boot项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块，向导会联网创建Spring Boot项目； 默认生成的Spring Boot项目： 主程序已经生成好了，我们只需要添加自己的逻辑即可 resources文件夹中的目录结构 static：保存所有的静态资源：js, css, images templates：保存所以的模板页面：（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面），可以使用官方推荐模板引擎（Freemarker, Thymeleaf） application.properties：Spring Boot应用的配置文件，虽然Spring Boot有默认配置，但我们可以修改一些默认配置","link":"/2020/08/07/Spring/SpringBootStart/"},{"title":"Spring Boot Web开发","text":"1、使用Spring Boot： 创建Spring Boot应用，选中我们需要的模块 Spring Boot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 自己编写业务代码 回顾自动配置原理 这个场景Spring Boot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？等等 xxxxAutoConfiguration：帮我们给容器中自动配置组件 xxxxProperties：配置类来封装配置文件的内容 2、Spring Boot对静态资源的映射规则12345678@ConfigurationProperties( prefix = \"spring.resources\", ignoreUnknownFields = false)public class ResourceProperties implements ResourceLoaderAware { // 可以设置和静态资源有关的参数，比如缓存时间 ...} 2.1 依赖的方式12345678910111213141516171819202122232425// WebMvcAutoConfiguration.class文件public void addResourceHandlers(ResourceHandlerRegistry registry) { if (!this.resourceProperties.isAddMappings()) { logger.debug(\"Default resource handling disabled\"); } else { Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern(\"/webjars/**\")) { this.customizeResourceHandlerRegistration(registry.addResourceHandler( new String[]{\"/webjars/**\"}).addResourceLocations( new String[]{\"classpath:/META-INF/resources/webjars/\"} ).setCachePeriod(cachePeriod) ); } String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) { this.customizeResourceHandlerRegistration(registry.addResourceHandler( new String[]{staticPathPattern}).addResourceLocations( this.resourceProperties.getStaticLocations() ).setCachePeriod(cachePeriod) ); } }} 所有/webjars/**，都去classpath:/META-INF/resources/webjars/找资源 webjars：以jar包的方式引入静态资源 webjars官网 访问方式：http://localhost:8088/webjars/jquery/3.5.1/jquery.js 123456&lt;!-- 引入jquery-webjars --&gt;&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt; 2.2 “/**”访问当前项目的任何资源（静态资源的文件夹）继续读addResourceHandlers方法，如果处理不了，就去静态staticPathPattern路径去找 12345678910111213public WebMvcProperties() { this.localeResolver = WebMvcProperties.LocaleResolver.ACCEPT_HEADER; this.dispatchTraceRequest = false; this.dispatchOptionsRequest = true; this.ignoreDefaultModelOnRedirect = true; this.throwExceptionIfNoHandlerFound = false; this.logResolvedException = false; this.mediaTypes = new LinkedHashMap(); this.staticPathPattern = \"/**\"; this.async = new WebMvcProperties.Async(); this.servlet = new WebMvcProperties.Servlet(); this.view = new WebMvcProperties.View();} 它添加了个位置addResourceLocations，这个里面的resourceProperties有个getStaticLocations()方法，点进去，有个常量RESOURCE_LOCATIONS 12345678static { RESOURCE_LOCATIONS = new String[CLASSPATH_RESOURCE_LOCATIONS.length + SERVLET_RESOURCE_LOCATIONS.length]; System.arraycopy(SERVLET_RESOURCE_LOCATIONS, 0, RESOURCE_LOCATIONS, 0, SERVLET_RESOURCE_LOCATIONS.length); System.arraycopy(CLASSPATH_RESOURCE_LOCATIONS, 0, RESOURCE_LOCATIONS, SERVLET_RESOURCE_LOCATIONS.length, CLASSPATH_RESOURCE_LOCATIONS.length);} 就找到了以下文件夹 12345678private static final String[] SERVLET_RESOURCE_LOCATIONS = new String[]{\"/\"}; // 当前项目的根路径// 和private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]{ \"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\"}; src/mian/java和src/main/resources都是类路径 如果要访问localhost:8088/*.js资源，没有人为处理，那么会自动去上面这些路径，静态资源文件夹里找这些文件 访问方式：http://localhost:8088/asserts/img/childhood_dreams.jpg 2.3 欢迎页设置，静态资源文件夹下的所有index.html页面12345678910111213141516// WebMvcAutoConfiguration.class文件// 配置欢迎页映射@Beanpublic WebMvcAutoConfiguration.WelcomePageHandlerMapping welcomePageHandlerMapping (ResourceProperties resourceProperties) { return new WebMvcAutoConfiguration.WelcomePageHandlerMapping( resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern() );}private void customizeResourceHandlerRegistration(ResourceHandlerRegistration registration) { if (this.resourceHandlerRegistrationCustomizer != null) { this.resourceHandlerRegistrationCustomizer.customize(registration); }} Spring最顶层的组件，保存每个请求谁来处理 点进getWelcomePage()方法 this.mvcProperties.getStaticPathPattern()还被谁映射，点进去看源码就是/** 12345678910111213141516171819public Resource getWelcomePage() { String[] var1 = this.getStaticWelcomePageLocations(); int var2 = var1.length; for(int var3 = 0; var3 &lt; var2; ++var3) { String location = var1[var3]; Resource resource = this.resourceLoader.getResource(location); try { if (resource.exists()) { resource.getURL(); return resource; } } catch (Exception var7) { } } return null;} 需要遍历，说明欢迎页还挺多的 点进getStaticWelcomePageLocations()方法 1234567891011121314private String[] getStaticWelcomePageLocations() { String[] result = new String[this.staticLocations.length]; for(int i = 0; i &lt; result.length; ++i) { String location = this.staticLocations[i]; if (!location.endsWith(\"/\")) { location = location + \"/\"; } result[i] = location + \"index.html\"; } return result;} 还是这个staticLocations静态文件夹 静态文件夹路径都拼接上index.html 访问方式：http://localhost:8088/ 就会找index页面 2.4 网站图标123456789101112131415161718192021222324252627282930// WebMvcAutoConfiguration.class文件// 配置喜欢的图标@Configuration@ConditionalOnProperty( value = {\"spring.mvc.favicon.enabled\"}, matchIfMissing = true)public static class FaviconConfiguration { private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) { this.resourceProperties = resourceProperties; } @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() { SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(-2147483647); mapping.setUrlMap(Collections.singletonMap(\"**/favicon.ico\", this.faviconRequestHandler())); return mapping; } @Bean public ResourceHttpRequestHandler faviconRequestHandler() { ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler.setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; }} 所有的**/favicon.ico都是在静态文件夹下找 2.5 自定义路径1spring.resources.static-locations=classpath:/hello/,classpath:initializr/ 多路径用都好隔开，一旦启用自定义路径，那么默认的静态资源路径就不能使用了 3、模板引擎JSP、Velocity、Freemarker、Thymeleaf Spring Boot推荐的Thymeleaf：语法更简单，功能更强大 3.1 引入Thymeleaf，引入starter：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 查看引入的库，发现引入的2.1.6版本的，太低了 Thymeleaf的版本发布 Spring官网Thymeleaf 3的使用 切换版本： 12345678&lt;properties&gt; ... &lt;!-- Thymeleaf主程序 --&gt; &lt;thymeleaf.version&gt;3.0.2.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- Thymeleaf布局支持程序 Thymeleaf3要求layout2以上版本 --&gt; &lt;thymeleaf-layout-dialect.version&gt;2.1.1&lt;/thymeleaf-layout-dialect.version&gt; &lt;!-- Thymeleaf2和layout1适配 --&gt;&lt;/properties&gt; properties里面的会属性覆盖Spring Boot默认的版本号 thymeleaf-layout-dialect的版本发布 3.2 Thymeleaf使用及语法还是在spring-boot-autoconfigure自动配置包里：添加组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374@Configuration@ConditionalOnClass( name = {\"org.thymeleaf.templatemode.TemplateMode\"})static class Thymeleaf3Configuration { Thymeleaf3Configuration() { } @Configuration @ConditionalOnClass({Servlet.class}) @ConditionalOnWebApplication static class Thymeleaf3ViewResolverConfiguration extends AbstractThymeleafViewResolverConfiguration { Thymeleaf3ViewResolverConfiguration(ThymeleafProperties properties, SpringTemplateEngine templateEngine) { super(properties, templateEngine); } protected void configureTemplateEngine(ThymeleafViewResolver resolver, SpringTemplateEngine templateEngine) { Method setTemplateEngine; try { setTemplateEngine = ReflectionUtils.findMethod( resolver.getClass(), \"setTemplateEngine\", new Class[]{Class.forName( \"org.thymeleaf.ITemplateEngine\", true, resolver.getClass().getClassLoader() )} ); } catch (ClassNotFoundException var5) { throw new IllegalStateException(var5); } ReflectionUtils.invokeMethod(setTemplateEngine, resolver, new Object[]{templateEngine}); } } @Configuration @ConditionalOnMissingBean( name = {\"defaultTemplateResolver\"} ) static class DefaultTemplateResolverConfiguration extends AbstractTemplateResolverConfiguration { DefaultTemplateResolverConfiguration(ThymeleafProperties properties, ApplicationContext applicationContext) { super(properties, applicationContext); } @Bean public SpringResourceTemplateResolver defaultTemplateResolver() { SpringResourceTemplateResolver resolver = super.defaultTemplateResolver(); Method setCheckExistence = ReflectionUtils.findMethod( resolver.getClass(), \"setCheckExistence\", new Class[]{Boolean.TYPE} ); ReflectionUtils.invokeMethod( setCheckExistence, resolver, new Object[]{this.getProperties().isCheckTemplate()} ); return resolver; } }} 因为我们引入的是3+版本，所以只有3+版本生效； 配置了哪些属性？在文件ThymeleafProperties中： 123456789101112131415161718192021@ConfigurationProperties( prefix = \"spring.thymeleaf\")public class ThymeleafProperties { private static final Charset DEFAULT_ENCODING = Charset.forName(\"UTF-8\"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(\"text/html\"); public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; private boolean checkTemplate = true; private boolean checkTemplateLocation = true; private String prefix = \"classpath:/templates/\"; private String suffix = \".html\"; private String mode = \"HTML5\"; private Charset encoding; private MimeType contentType; private boolean cache; private Integer templateResolverOrder; private String[] viewNames; private String[] excludedViewNames; private boolean enabled;} 只要我们把HTML页面放在classpath:/templates/，Thymeleaf就能自动渲染 Thymeleaf语法还是参照官方网的官方文档 3.3 代码示例 导入Thymeleaf的名称空间 1&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; 使用Thymeleaf语法 1&lt;div th:text=\"${text}\"&gt;这里是div信息&lt;/div&gt; 3.4 语法规则th:text：改变当前元素里面的文本内容； th：任意html属性；替换原生属性的值，例：th:class覆盖class Feature Detail Attribute Fragment inclusion 片段包含：jsp:include th:insertth:replace Fragment iteration 遍历：c:forEach th:each Conditional evaluation 条件判断：c:if th:ifth:unlessth:switchth:case Local variable definition 声明变量：c:set th:objectth:with General attribute modification 任意属性修改支持prepend, append th:attrth:attrprependth:attrappend Specific attribute modification 修改制定属性默认值 th:valueth:hrefth:src… Text (tag body modification) 修改标签体内容 th:text(转义特殊字符)th:utext(不转义特殊字符) Fragment specification 声明片段 th:fragment Fragment removal th:remove 3.5 表达式 Simple expressions: (表达式语法) Variable Expressions: ${…}: 获取变量值; OGNL; 12345678910111213141516171819202122232425262728293031 1) 获取对象的属性、调用方法 2) 使用内置的基本对象 #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. ${session.foo} // Retrieves the session atttribute 'foo' # 附录都有演示 3) 内置的一些工具对象 #execInfo : information about the template being processed. #messages : methods for obtaining externalized messages inside variables expressions, # in the same way as they would be obtained using #{…} syntax. #uris : methods for escaping parts of URLs/URIs #conversions : methods for executing the configured conversion service (if any). #dates : methods for java.util.Date objects: formatting, component extraction, etc. #calendars : analogous to #dates , but for java.util.Calendar objects. #numbers : methods for formatting numeric objects. #strings : methods for String objects: contains, startsWith, prepending/appending, etc. #objects : methods for objects in general. #bools : methods for boolean evaluation. #arrays : methods for arrays. #lists : methods for lists. #sets : methods for sets. #maps : methods for maps. #aggregates : methods for creating aggregates on arrays or collections. #ids : methods for dealing with id attributes that might be repeated # (for example, as a result of an iteration). Selection Variable Expressions: *{…}: 选择表达式, 和${}在功能上是一样的 123456补充: 配合th:object=\"${session.user}\"进行使用&lt;div th:object=\"${session.user}\"&gt; &lt;p&gt;Name: &lt;span th:text=\"*{firstName}\"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=\"*{lastName}\"&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=\"*{nationality}\"&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt; Message Expressions: #{…}: 获取国际化内容 Link URL Expressions: @{…}: 定义URL 1@{/order/process(execId=${execId},execType='FAST')} Fragment Expressions: ~{…}: 片段引用表达式 12# 插入片段文档&lt;div th:insert=\"~{commons :: main}\"&gt;...&lt;/div&gt; Literals(字面量) 12345Text literals: 'one text' , 'Another one!' ,…Number literals: 0 , 34 , 3.0 , 12.3 ,…Boolean literals: true , falseNull literal: nullLiteral tokens: one , sometext , main ,… Text operations:(文本操作) 12String concatenation: +Literal substitutions: |The name is ${name}| Arithmetic operations:(数学运算) 12Binary operators: + , - , * , / , %Minus sign (unary operator): - Boolean operations:(布尔运算) 12Binary operators: and , orBoolean negation (unary operator): ! , not Comparisons and equality:(比较运算) 12Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )Equality operators: == , != ( eq , ne ) Conditional operators:(条件运算, 也支持3元运算符) 123If-then: (if) ? (then)If-then-else: (if) ? (then) : (else)Default: (value) ?: (defaultvalue) Special tokens:(特殊符号) 1No-Operation: _ 4、SpringMVC自动配置可以参阅官方文档Developing web applications 4.1 Spring Boot为Spring MVC提供了自动配置，可与大多数应用程序完美配合。自动配置会在Spring的默认设置之上添加以下功能： 包含ContentNegotiatingViewResolver和BeanNameViewResolver Bean。 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（就是View对象），视图对象决定如何渲染（转发？重定向？等）） ContentNegotiatingViewResolver：组合所有的视图解析器的 如何定制：我们可以自己给容器中添加一个视图解析器，自动将其组合进来 Ctrl+N输入DispatchServlet.class在它的doDispatch方法前面设置断点，Debug运行，浏览器访问页面，查看控制台。看DispatchServlet里用到的视图解析器是什么？得到如图： 支持提供静态资源，包括对WebJars的支持（请参见下文）。 自动注册Converter，GenericConverter，Formatter bean。 Converter：转换器，类型转换使用。例如前端文本转后台Integer Formatter：格式化器，2020.08.13===Date 123456789// 配置文件中配置日期格式化的规则@Bean@ConditionalOnProperty( prefix = \"spring.mvc\", name = {\"date-format\"})public Formatter&lt;Date&gt; dateFormatter() { return new DateFormatter(this.mvcProperties.getDateFormat()); // 日期格式化组件} 自己添加的格式化器，我们只需要放在容器中即可 支持HttpMessageConverters（请参见下文）。 HttpMessageConverter：SpringMVC中用来转换HTTP请求和响应的；例：User对象以JSON形式写出 HttpMessageConverters是从容器中确定的，获取所有的HttpMessageConverter 自己给容器中添加HttpMessageConverter，只需将自己的组件注册在容器中（@Bean, @Component） 自动注册MessageCodesResolver（请参见下文）。 定义错误代码生成规则（例：JSR303校验时） 静态index.html支持。 自定义Favicon支持（请参阅下文）。 自动使用ConfigurableWebBindingInitializer bean（请参见下文）。 我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器中） 初始化WebDataBinder（web数据绑定器）； web数据绑定器的功能：请求数据=====绑定到JavaBean中 org.springframework.boot.autoconfigure.web：web的所有自动配置场景。 如果您想保留Spring Boot MVC功能，而只想添加其他MVC配置（拦截器，格式化程序，视图控制器等），则可以添加自己的类型为WebMvcConfigurerAdapter的@Configuration类，但无需@EnableWebMvc。如果希望提供RequestMappingHandlerMapping，RequestMappingHandlerAdapter或ExceptionHandlerExceptionResolver的自定义实例，则可以声明一个提供此类组件的WebMvcRegistrationsAdapter实例。 如果要完全控制Spring MVC，则可以添加用@EnableWebMvc注释的自己的@Configuration。 4.2 扩展SpringMVC1234567&lt;mvc:view-controller path=\"/hello\" view-name=\"success\"/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/hello\"/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 要实现以上Spring配置文件的内容，编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc 1234567891011// 使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@Configurationpublic class SpringMVCConfig extends WebMvcConfigurerAdapter { @Override public void addViewControllers(ViewControllerRegistry registry) { // super.addViewControllers(registry); //浏览器发送 /addViewController 请求来到 thymeleaf registry.addViewController(\"/addViewController\").setViewName(\"thymeleaf\"); }} 既保留了所有的自动配置，也能用我们扩展的配置； 原理： WebMvcAutoConfiguration是SpringMVC的自动配置类 在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class) 1234@Configurationpublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration { ...} 点进其父类DelegatingWebMvcConfiguration查看源码： 123456789101112131415161718public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); public DelegatingWebMvcConfiguration() { } //自动装配, 从容器中获取所有的WebMvcConfigurer @Autowired( required = false ) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) { if (!CollectionUtils.isEmpty(configurers)) { this.configurers.addWebMvcConfigurers(configurers); // 一个参考实现; 将所有的WebMvcConfigurer相关配置都来一起调用; } }} WebMvcConfigurerComposite类中的一个实现 123456789public void addViewControllers(ViewControllerRegistry registry) { Iterator var2 = this.delegates.iterator(); while(var2.hasNext()) { WebMvcConfigurer delegate = (WebMvcConfigurer)var2.next(); delegate.addViewControllers(registry); }} 容器中所有的WebMvcConfigurer都会一起起作用（包括我们自己写的）； 我们的配置类也会被调用； 效果：SpringMVC的自动配置和我们的扩展配置都会起作用； 4.3 全面接管SpringMVCSpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了（静态资源也不能访问了） 我们需要在配置类中添加@EnableWebMvc即可； 原理：为什么@EnableWebMvc自动配置就失效了？ @EnableWebMvc的核心 123456@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.TYPE})@Documented@Import({DelegatingWebMvcConfiguration.class})public @interface EnableWebMvc {} 查看DelegatingWebMvcConfiguration类的源码 1234@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { ...} 在找到WebMvcAutoConfiguration类，查看签名 12345678910@Configuration@ConditionalOnWebApplication@ConditionalOnClass({Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class})@ConditionalOnMissingBean({WebMvcConfigurationSupport.class})@AutoConfigureOrder(-2147483638)@AutoConfigureAfter({DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class})public class WebMvcAutoConfiguration { ...} @ConditionalOnMissingBean()：容器中没有这个组件的时候，这个自动配置类才生效 @EnableWebMvc将WebMvcConfigurationSupport组件导入进来； 导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能。 5、如何修改Spring Boot的默认配置模式： Spring Boot在自动配置很多组件时，先看容器中有没有用户自己配置的（@Bean, @Component）,如果有就用用户配置的，如果没有才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来； 在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置 在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置","link":"/2020/08/09/Spring/SpringBootWeb/"},{"title":"Spring Boot与日志","text":"1、日志框架故事：有一个开发人员，开发一个大型系统； 遇到重要数据，喜欢System.out.println(&quot;&quot;)，将关键数据打印在控制台 去掉？写在一个文件？方便？ 框架来记录系统的一些运行时信息，日志框架：first.jar 高大上的几个功能？异步模式？自动规定？等等？：second.jar 将以前的框架卸下来？换上新的框架，更新修改之前相关API：third.jar JDBC—-数据库驱动： 写了一个统一的接口层：暂时叫做日志门面（日志的一个抽象层）：fourth.jar 给项目中导入具体的日志实现就行了，我们之前的日志框架都是实现的抽象层 2、市面上的日志框架JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j… 2.1 下表行间无任何对应关系 日志门面 日志实现 JCL( Jakarta Commons Logging) Log4j SLF4j( Simple Logging Facade for Java) JUL( java. util.logging) jboss-logging Log4j2 Logback 左边选一个门面（抽象层）、右边选一个实现 选哪个呢？排除法 2.2 日志门面：slf4jJboss-logging：普通程序员用不了 JCL：最后一次更新是在2014年，廉颇老矣，尚能饭否？ 剩下slf4j理所应当 2.3 日志实现：logbacklog4j、logback和slf4j都是一个人写的，适配性好，log4j不错但有性能问题，但升级消耗太大，就重写了logback 所有log4j没有logback先进，JUL是Java自带的，怕日志市场被占，比较简略 log4j2是借log4j之名，由Apache公司重新做的框架，设计地非常好，由于太好还没适配 2.4 Spring Boot怎么做的呢？Spring框架默认是用JCL日志框架 Spring Boot选用slf4j和logback 3、slf4j的使用如何在系统中使用slf4j？官方文档 以后开发的时候，日志记录方法得调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法 参见用户手册SLF4J user manual给系统中导入slf4j的jar和logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld { public static void main(String[] args) { Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(\"Hello World\"); }} 虽然默认用的是logback的实现，如果想要其他实现也可以，毕竟slf4j是抽象层，实现用什么都行 图解 如果系统中只导入了slf4j，我们要进行日志记录，就会返回空值，因为没有任何实现 正确用法：我的应用程序面向slf4j编程，调用它的方法进行日志记录，在程序中也导入日志实现，虽然调用slf4j接口，但logback会实现，记录到文件或控制台 如果slf4j要绑定log4j，log4j出现比较早，没想到要适配slf4j，所以两者绑定要有一个适配层（slf4j实现的），适配层相当于上面实现了slf4j的具体方法，而在方法里面要进行真正日志记录的时候，又调了log4j的API，要用log4j还要导入适配层即可JUL同理 slf4j也有简单日志实现也能用，或者slf4j没有什么操作的实现包，也是输出空值 每一个日志的实现框架都有自己的配置文件，使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件 slf4j只提供抽象层，用哪个实现就写那个的配置文件 4、遗留问题开发某个系统时：使用{slf4j+logback}，依赖Spring框架（commons-logging），依赖Hibernate框架（Jboss-logging），依赖MyBatis框架等等可能一大堆 出现什么问题，系统中日志杂交？ 现在就要做同一日志记录，即使是别的框架和我一起使用slf4j进行输出？ 进入slf4j官方文档的legacy APIs 统一slf4j，使用其他包替换原有日志框架，替换的意思就是，例如要把原框架里面对Commons-logging的依赖排除掉 但如果我现在用的Spring框架缺少Commons-logging就运行不起来了，Spring底层记录日志就需要Commons-logging，那怎么办呢？就用jcl-over-slf4j.jar替换这个包，Spring要用的类这个替换包例还是有的，就不会报错了 但新的包实现怎么办呢？新的包调入slf4j，而slf4j又调到真正的实现中，其他框架不同日志框架同理替换 其他组合方式也是如此 如何让系统中所有的日志都统一到slf4j： 将系统中其他日志框架先排除去 用中间包来替换原有的日志框架 我们导入slf4j其他的实现 5、Spring Boot日志关系每个启动器（场景）都要依赖的 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; Spring Boot使用它来做日志功能 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;&lt;/dependency&gt; 依赖图示： 总结： Spring Boot底层也是使用slf4j+logback的方式进行日志记录 Spring Boot也是把其他的日志都替换成了slf4j 中间替换包，以jcl-over-slf4j.jar为例： 在项目的依赖包中找到其对应jar包：（中间转换包） 从图中看出，虽然包名用的Apache的，但实现却是使用的SLF4JLogFactory()的日志工厂 123456789@SuppressWarnings(\"rawtypes\")public abstract class LogFactory { static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = \"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j\"; static LogFactory logFactory = new SLF4JLogFactory(); ...} 如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉！ Spring框架用的是commons-logging： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; Spring Boot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，我们唯一需要做的是，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉。 6、日志使用6.1 默认配置当我们初始化项目运行后，自己没有配置日志，但控制台是由输出信息的 Spring Boot默认帮我们配置好了日志，直接使用就可以了 12345678910111213141516171819202122// LoggerFactory是记录器工厂，记录器Logger logger = LoggerFactory.getLogger(getClass());@Testpublic void testLog() { /** * 日志的级别 * 由低到高：trace&lt;debug&lt;info&lt;waring&lt;error * 可以调整输出的日志级别 * 只打印高级别即以后（更高级别）的信息 */ logger.trace(\"这是跟踪轨迹日志...trace...\"); logger.debug(\"这是调试日志...debug\"); /** * Spring Boot默认使用的是info级别的，输出info级别即以后的内容 * 没有指定级别的就用Spring Boot默认规定的级别（root级别） */ logger.info(\"这是信息日志...info...\"); logger.warn(\"这是警告信息...warning...\"); logger.error(\"这是错误信息日志，异常捕获...error...\"); // 也可以通过配置文件修改级别} 日志的输出格式 %d：表示时间 %thread：表示线程名 %-5level：级别从左显示5个字符宽度 %logger{50}：表示logger名字最长50个字符，否则按照句点分割 %msg：日志消息 %n：换行 12345678910111213141516# trace及以后的级别生效logging.level.com.initializr=trace# 生成springboot日志文件# 可以用决定路径# 如果不指定路径，就在当前项目下生成logging.file=springboot.log# 使用logging.path可以不使用logging.file，使用spring.log默认文件# 在当前磁盘的根路径下创建文件夹，并生成日志文件#logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n# 指定文件中输出的日志的格式logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss} === [%thread] === %-5level %logger{50} === %msg%n 6.2 自定义日志、指定配置可从官方文档-日志参见第26.5条Custom log configuration 给类路径下放上每个日志框架自己的配置文件即可，Spring Boot就不使用默认配置了 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接就被日志框架识别了 logback-spring.xml：日志框架就不直接加载日志的配置项，由Spring Boot解析日志配置，可以使用Spring Boot的高级Profile功能 1234567891011&lt;springProfile name=\"staging\"&gt; &lt;!-- configuration to be enabled when the \"staging\" profile is active --&gt;&lt;/springProfile&gt;&lt;springProfile name=\"dev, staging\"&gt; &lt;!-- configuration to be enabled when the \"dev\" or \"staging\" profiles are active --&gt;&lt;/springProfile&gt;&lt;springProfile name=\"!production\"&gt; &lt;!-- configuration to be enabled when the \"production\" profile is not active --&gt;&lt;/springProfile&gt; 可以指定某段配置只在某个环境下生效 否则就会报错 123java.lang.IllegalStateException: Logback configuration error detected: ERROR in ch.qos.logback.core.joran.spi.Interpreter@23:39 - no applicable action for [springProfile]... 使用logback-spring.xml配置文件时： 1234567891011&lt;!-- 控制台打印 --&gt;&lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder charset=\"utf-8\"&gt; &lt;springProfile name=\"dev\"&gt; &lt;pattern&gt;${CONSOLE_LOG_PATTERN}&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=\"!dev\"&gt; &lt;pattern&gt;${FILE_LOG_PATTERN}&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/encoder&gt;&lt;/appender&gt; 7、切换日志框架7.1 现在我们想用log4j实现根据之前的原理，就要除去有关log4j的转换包，用原始包；还要导出logback的jar包 IDEA-&gt;在pom.xml文件中鼠标右键-&gt;Diagrams-&gt;Show Dependencies-&gt;选择要除去的jar包-&gt;鼠标右键-&gt;Exclude 其他的JCL和JCL有的框架还要用，所有转换包要留着 但log4j-over-slf4j.jar要去掉，这是个替换包，里面的log4j都用处slf4j了，但现在我们要用log4j了，而不是替换，所以也将其排除 最终： 面向slf4j编程，用log4j实现 导入一个适配层的包 1234&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 查看其源码，自动导入了log4j的框架 123456...&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt;&lt;/dependency&gt;... 可以按照slf4j的日志适配图，进行相关的切换 得到最终的pom.xml文件配置为： 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 7.2 切换至log4j2参阅官方文档表13.3. Spring Boot technical starters 按照之前的操作将spring-boot-start-logging.jar除去 在pom.xml文件中导入： 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt;","link":"/2020/08/08/Spring/SpringBootLog/"},{"title":"Vue整合Element-UI","text":"安装Element-UI Element-UI官方中文网 1 安装命令 在项目中打开终端，执行下面命令： 1$ cnpm i element-ui -S CDN 1234&lt;!-- 引入样式 --&gt;&lt;link rel=\"stylesheet\" href=\"https://unpkg.com/element-ui/lib/theme-chalk/index.css\"&gt;&lt;!-- 引入组件库 --&gt;&lt;script src=\"https://unpkg.com/element-ui/lib/index.js\"&gt;&lt;/script&gt; 官方教程 2 引入在项目的src/mian.js中引用element-ui： 12345678910111213141516import Vue from 'vue'import App from './App.vue'import router from './router'import store from './store'// 引入Element-UIimport ElementUI from 'element-ui';import 'element-ui/lib/theme-chalk/index.css';Vue.config.productionTip = falseVue.use(ElementUI);new Vue({ router, store, render: h =&gt; h(App)}).$mount('#app') 3 使用上述配置完成就可以使用Element-UI了，直接在组件中使用EL标签即可。","link":"/2020/06/29/Vue/Vue%E5%BC%95%E5%85%A5Element-UI/"},{"title":"Electron+vue-cli3开发跨平台桌面应用","text":"一步一步搭建Electron+vue-cli3开发平台（亲测有效） Electron是一个基于Chromium和 Node.js，可以使用 HTML、CSS和JavaScript构建跨平台应用的技术框架，兼容 Mac、Windows 和 Linux。虽然B/S是目前开发的主流，但是C/S仍然有很大的市场需求。受限于浏览器的沙盒限制沙盒（英语：sandbox，又译为沙箱），计算机专业术语，在计算机安全领域中是一种安全机制，为运行中的程序提供的隔离环境。通常是作为一些来源不可信、具破坏力或无法判定程序意图的程序提供实验之用。网页应用无法满足某些场景下的使用需求，而桌面应用可以读写本地文件、调用更多系统资源，再加上Web开发的低成本、高效率的优势，这种方式越来越受到开发者的喜爱。 这篇博客一步一步教你如何使用Electron和vue-cli3，在完全保留vue开发web应用的习惯下，搭建桌面应用。 这篇博客不涉及Electron和vue的开发教程，仅以实现两者结合为目的，若要深入学习Electron和vue，请访问官方： Electron Vue Vue-cli Stylus 学习该框架之前，希望读者需要提前掌握以下技能： HTML、CSS、JavaScript Vue2.x Stylus 1.创建项目1.1 安装NodejsNode.js 中文网下载安装 1.2 使用cnpm加速下载npm有时下载速度很慢，可以安装cnpm，从国内淘宝镜像下载，执行以下命令： 1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 之后所有的npm命令都可以直接替换成cnpm使用了。 1.3 为什么不使用electron-vue搭建呢Electron-vue官方中文文档 由于SimulatedGREG/electron-vue已经很久没有更新了，而且其生成的工程结构并不是vue-cli3。所以放弃使用。 1.4 安装/升级vue-cli3 先执行以下命令，确认下本地安装的vue-cli版本（如果自己的电脑没有安装过vue，跳过前两步到第三步吧！）： $ vue -V或$ vue --version 在写本篇博客时，我的vue是2.9.6版本。 如果本地使用的是vue-cli2.x或者更早版本，可先执行下面命令全局卸载： $ cnpm uninstall vue-cli -g （1）vue-cli3使用了新的npm包名，与旧版本不一样。 （2）在vue2.9.6下执行上面命令，控制台输入vue -V仍然有输出，解决方法： ​ a. 当然, 卸载命令还是要执行的: 全局卸载：npm uninstall vue-cli -g; ​ b. npmrc文件删除掉 ​ c. 检索删除vue-cli文件夹 ​ 再试试: vue -V，就不显示版本号了。 （3）可以忽略上述问题，直接安装最新版本的vue-cli3即可（亲测有效）。 执行以下命令全局安装vue-cli3： $ cnpm install @vue/cli -g 执行以下命令升级vue-cli3： $ cnpm update @vue/cli -g 1.5 创建vue项目 在指定目录下，打开终端，执行以下命令，创建vue项目： $ vue create electron-vue-demo 这里的项目名称为electron-vue-demo（不能出现大写字母），可根据自己的具体项目改变。 创建命令执行后，在完成创建之前，会出现以下选项（如果熟悉此步骤可跳过本节内容）： 1234Vue CLI v4.4.6? Please pick a preset: (Use arrow keys) default (babel, eslint) &gt; Manually select features 选择 Manually select features （自定义安装）。 1234567891011? Check the features needed for your project: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)&gt;(*) Babel ( ) TypeScript ( ) Progressive Web App (PWA) Support (*) Router (*) Vuex (*) CSS Pre-processors (*) Linter / Formatter ( ) Unit Testing ( ) E2E Testing 这里选择了常用的模块，请根据实际需求进行选择。 12? Use history mode for router? (Requires proper server setup for index fallback in production) (Y/n)n 如果选择了router，这里会询问是否使用history模式。 vue-router 默认使用hash模式（即通过url#hash来跳转页面），使用URL的hash来模拟一个完整的 URL，当URL改变时，页面不会重新加载。 如果使用history模式，URL就像正常的url，例如 http://yoursite.com/page，比较好看。但是还需要后台配置支持。 这里我们选择n。 123456? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): (Use arrow keys) Sass/SCSS (with dart-sass) Sass/SCSS (with node-sass) Less &gt; Stylus 选择CSS预处理模块，这里我们使用Stylus。 12345? Pick a linter / formatter config: (Use arrow keys) ESLint with error prevention only ESLint + Airbnb config &gt; ESLint + Standard config ESLint + Prettier 选择ESLint代码格式检查工具的配置，选择ESLint + Standard config，标准配置。 1234? Pick additional lint features: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)&gt;(*) Lint on save ( ) Lint and fix on commit Line on save表示在保存代码的时候，进行格式检查。 Lint and fix on commit表示在$ git commit的时候自动纠正格式。 这里只选择Lint on save。 123? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? In dedicated config files &gt; In package.json 这里问把 babel，postcss，eslint 这些配置文件放哪？ In dedicated config files表示独立文件。 In package.json表示放在package.json里。 这里选择In package.json。 1? Save this as a preset for future projects? (y/N) N 是否为以后的项目保留这些设置？选择N。 然后耐心等待项目安装完成。 1.6 自动安装Electron 执行以下命令，进入项目目录： $ cd electron-vue-demo 然后执行以下命令： $ vue add electron-builder electron-builder是一个简单又强大的库。解决了打包这个棘手的问题，而且可以应对大部分的打包需求。 接下来出现配置选项： 1234? Choose Electron Version (Use arrow keys) ^7.0.0 ^8.0.0 &gt; ^9.0.0 选择Electron版本，我写这篇博客的时候，选项是上面3个版本，选择最新的即可。 然后耐心等待安装完成。 1.7 手动安装Electron 修改package.json，添加以下7行： 1234567891011121314151617181920212223242526272829303132333435363738...\"scripts\": { \"serve\": \"vue-cli-service serve\", \"build\": \"vue-cli-service build\", \"lint\": \"vue-cli-service lint\", \"electron:build\": \"vue-cli-service electron:build\", // add \"electron:serve\": \"vue-cli-service electron:serve\", // add \"postinstall\": \"electron-builder install-app-deps\", // add \"postuninstall\": \"electron-builder install-app-deps\" // add},\"main\": \"background.js\", // add\"dependencies\": { \"core-js\": \"^3.6.5\", \"vue\": \"^2.6.11\", \"vue-router\": \"^3.2.0\", \"vuex\": \"^3.4.0\"},\"devDependencies\": { \"@vue/cli-plugin-babel\": \"~4.4.0\", \"@vue/cli-plugin-eslint\": \"~4.4.0\", \"@vue/cli-plugin-router\": \"~4.4.0\", \"@vue/cli-plugin-vuex\": \"~4.4.0\", \"@vue/cli-service\": \"~4.4.0\", \"@vue/eslint-config-standard\": \"^5.1.2\", \"babel-eslint\": \"^10.1.0\", \"electron\": \"^9.0.5\", // add \"eslint\": \"^6.7.2\", \"eslint-plugin-import\": \"^2.20.2\", \"eslint-plugin-node\": \"^11.1.0\", \"eslint-plugin-promise\": \"^4.2.1\", \"eslint-plugin-standard\": \"^4.0.0\", \"eslint-plugin-vue\": \"^6.2.2\", \"stylus\": \"^0.54.7\", \"stylus-loader\": \"^3.0.2\", \"vue-cli-plugin-electron-builder\": \"~2.0.0-rc.3\", // add \"vue-template-compiler\": \"^2.6.11\"},... 新建src/background.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495'use strict'import { app, protocol, BrowserWindow } from 'electron'import { createProtocol, installVueDevtools} from 'vue-cli-plugin-electron-builder/lib'const isDevelopment = process.env.NODE_ENV !== 'production'// Keep a global reference of the window object, if you don't, the window will// be closed automatically when the JavaScript object is garbage collected.let win// Scheme must be registered before the app is readyprotocol.registerSchemesAsPrivileged([ { scheme: 'app', privileges: { secure: true, standard: true } }])function createWindow() { // Create the browser window. win = new BrowserWindow({ width: 1000, height: 600, webPreferences: { /* Use pluginOptions.nodeIntegration, leave this alone See nklayman.github.io/vue-cli-plugin-electron-builder/guide/security.html#node-integration for more info nodeIntegration: process.env.ELECTRON_NODE_INTEGRATION */ webSecurity: false, nodeIntegration: true } }) if (process.env.WEBPACK_DEV_SERVER_URL) { // Load the url of the dev server if in development mode win.loadURL(process.env.WEBPACK_DEV_SERVER_URL) if (!process.env.IS_TEST) win.webContents.openDevTools() } else { createProtocol('app') // Load the index.html when not in development win.loadURL('app://./index.html') } win.on('closed', () =&gt; { win = null })}// Quit when all windows are closed.app.on('window-all-closed', () =&gt; { // On macOS it is common for applications and their menu bar // to stay active until the user quits explicitly with Cmd + Q if (process.platform !== 'darwin') { app.quit() }})app.on('activate', () =&gt; { // On macOS it's common to re-create a window in the app when the // dock icon is clicked and there are no other windows open. if (win === null) { createWindow() }})// This method will be called when Electron has finished// initialization and is ready to create browser windows.// Some APIs can only be used after this event occurs.app.on('ready', async () =&gt; { if (isDevelopment &amp;&amp; !process.env.IS_TEST) { // Install Vue Devtools try { await installVueDevtools() } catch (e) { console.error('Vue Devtools failed to install:', e.toString()) } } createWindow()})// Exit cleanly on request from parent process in development mode.if (isDevelopment) { if (process.platform === 'win32') { process.on('message', (data) =&gt; { if (data === 'graceful-exit') { app.quit() } }) } else { process.on('SIGTERM', () =&gt; { app.quit() }) }} 以上代码是1.6小节使用自动化方式安装后生成的。 安装依赖包 在项目目录下执行以下命令，安装全部依赖包： $ cnpm install 1.8 编译并启动APP 执行以下命令，开始编译APP，并启动开发环境APP： $ npm run electron:serve或$ yarn electron:serve 首次启动可能会等待很久，加载完后会自动打开APP，等待即可。 编译成功后，就会出现开发环境的APP了，如下图（Win10启动界面）： 当回到控制台，发现控制台的信息： 1234567INFO Launching Electron...Failed to fetch extension, trying 4 more timesFailed to fetch extension, trying 3 more timesFailed to fetch extension, trying 2 more timesFailed to fetch extension, trying 1 more timesFailed to fetch extension, trying 0 more timesVue Devtools failed to install: Error: net::ERR_CONNECTION_TIMED_OUT 这是因为在请求安装vuejs devtools插件。需要翻墙才能安装成功。可以忽略上面的问题，耐心等待5次请求失败后会自动跳过，上面的成功界面即证实跳过依然编译成功。 依然有解决方案： 注释掉src/background.js中的以下代码就行了： 12345678910/* if (isDevelopment &amp;&amp; !process.env.IS_TEST) { // Install Vue Devtools try { await installVueDevtools(); } catch (e) { console.error(\"Vue Devtools failed to install:\", e.toString()); } }*/ 2.配置项目2.1 配置ESLint代码格式检查工具ESlint可以高效的检查代码格式，让参与项目的所有工程师都能保持统一的代码风格。其检测精度甚至可以精确到是否多一个空格或者少一个空格。代码格式的统一对提高团队的协同开发效率有很大的帮助，特别是对有代码洁癖的工程师。 在项目根目录下创建.eslintrc.js （注意文件名前面有个.） 请粘贴以下代码： 123456789101112131415161718192021222324module.exports = { root: true, env: { node: true }, 'extends': [ 'plugin:vue/essential', '@vue/standard' ], rules: { 'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off', // 不检测语句末尾的分号 'semi': ['off', 'always'], // 强制缩进为2个空格 'indent': ['error', 2], // 关闭函数名称跟括号之间的空格检测 'space-before-function-paren': 0, // 忽略大括号内的空格 'object-curly-spacing': 0 }, parserOptions: { parser: 'babel-eslint' }} 这里说明下关于indent缩进的配置，要配合项目根目录下的.editorconfig 12345[*.{js,jsx,ts,tsx,vue}]indent_style = space &lt;--这里定义缩进类型是空格还是tabindent_size = 2 &lt;--这里需要与.eslintrc.js的indent对应trim_trailing_whitespace = trueinsert_final_newline = true .editorconfig 用于IDE自动格式化代码.eslintrc.js 用于ESlint检测 更多配置可参阅 ESLint教程。 2.2 配置vue在项目目录下创建vue.config.js，粘贴以下代码： 123456789101112131415161718192021const path = require('path');function resolve (dir) { return path.join(__dirname, dir);}module.exports = { publicPath: './', devServer: { // can be overwritten by process.env.HOST host: '0.0.0.0', port: 8080 }, chainWebpack: config =&gt; { config.resolve.alias .set('@', resolve('src')) .set('src', resolve('src')) .set('common', resolve('src/common')) .set('components', resolve('src/components')); }}; devServer 用于设置开发环境的服务，这里表示在本地8080端口启动web服务。 chainWebpack 我们给项目目录起了”别名(alias)”，在代码中，我们可以直接用“别名”访问资源，省去了每次输入完整相对路径的麻烦。 在js代码中可直接使用别名，例如： @/common/js/xxx.js 等价于 src/common/js/xxx.js common/js/xxx.js 等价于 src/common/js/xxx.js 在css或者html中使用别名，需要在别名前加“~”，例如： @import &quot;~common/stylus/font.styl&quot; 3.项目基本设定3.1 主进程和渲染进程简介在开始下面的步骤之前，很有必要简单了解下Electron的应用架构。 主进程 Electron 运行 package.json 的 main 脚本（background.js）的进程被称为主进程。 在主进程中运行的脚本通过创建web页面来展示用户界面。 一个 Electron 应用总是有且只有一个主进程。 渲染进程 由于 Electron 使用了 Chromium 来展示 web 页面，所以 Chromium 的多进程架构也被使用到。 每个 Electron 中的 web 页面运行在它自己的渲染进程中。 在普通的浏览器中，web页面通常在一个沙盒环境中运行，不被允许去接触原生的资源。 然而 Electron 的用户在 Node.js 的 API 支持下可以在页面中和操作系统进行一些底层交互。 主进程和渲染进程的关系 主进程使用 BrowserWindow 实例创建页面。 每个 BrowserWindow 实例都在自己的渲染进程里运行页面。 当一个 BrowserWindow 实例被销毁后，相应的渲染进程也会被终止。 主进程管理所有的web页面和它们对应的渲染进程。 每个渲染进程都是独立的，它只关心它所运行的 web 页面。 具体可参阅官方文档。 3.2 APP窗口大小修改background.js： 1234567891011win = new BrowserWindow({ width: 1000, height: 600, webPreferences: { /* Use pluginOptions.nodeIntegration, leave this alone See nklayman.github.io/vue-cli-plugin-electron-builder/guide/security.html#node-integration for more info */ nodeIntegration: process.env.ELECTRON_NODE_INTEGRATION }}) 3.3 取消跨域限制修改background.js： 12345678910111213win = new BrowserWindow({ width: 1000, height: 600, webPreferences: { /* Use pluginOptions.nodeIntegration, leave this alone See nklayman.github.io/vue-cli-plugin-electron-builder/guide/security.html#node-integration for more info nodeIntegration: process.env.ELECTRON_NODE_INTEGRATION */ webSecurity: false, nodeIntegration: true }}) 3.4 取消菜单栏在我们生成的桌面APP中，我们可以看到默认的菜单栏。 在windows中，菜单栏在APP窗口内的顶部；在macOS中，菜单栏位于电脑屏幕顶部。 为了方便项目将来也能直接生成纯web应用，尽量把APP的全部功能都做到渲染进程里，这里我们取消菜单栏。 由于macOS的特殊性，顶部菜单栏无法删除，所以我们针对macOS特殊处理，把菜单栏只保留“关于”和“退出”。 修改background.js： 12345678910111213141516171819202122232425262728293031323334'use strict'// 添加Menu组件import { app, protocol, BrowserWindow, Menu } from 'electron'...function createWindow() { // Create the browser window. ... win.on('closed', () =&gt; { win = null }) createMenu()}// 设置菜单栏function createMenu() { // darwin表示macOS，针对macOS的设置 if (process.platform === 'darwin') { const template = [{ label: 'App Demo', submenu: [ {role: 'about'}, { role: 'quit' }] }] const menu = Menu.buildFromTemplate(template) Menu.setApplicationMenu(menu) } else { // windows及linux系统 Menu.setApplicationMenu(null) }} 改变后的APP界面样式： 更多关于菜单栏设置，请参阅：Electron官方API 3.5 设置APP窗口图标准备windows和macOS两版图标： Platform File Type Specification Windows app.ico 最小尺寸：256x256 MacOS app.png或app.icns 最小尺寸：512x512 把图标文件放到public/目录下，项目结构如下： 1234567891011121314151617|- /dist_electron |...|- /public |- app.icns |- app.ico |- app.png |- favicon.ico |- index.html|- /src |...|- .editorconfig |- .eslintrc.js|- .gitignore|- babel.config.js|- package.json|- package-lock.json|- README.md 可以顺便把favicon.ico也修改一下，但是在桌面版APP上是用不到的。如果以后生成纯web项目才会用到。 修改background.js，让APP窗口应用图标： 1234567891011function createWindow() { // Create the browser window. win = new BrowserWindow({ ... // eslint-disable-next-line no-undef icon: `${__static}/app.ico` }) ...} 这里的${__static}对应的是public目录 现在，Windows系统上可以看到开发环境的APP窗口图标已经生效了。 MacOS图标请参照4.1章节，并且需要在build后才能生效。 3.6 设置APP窗口标题栏名称修改public/index.html， 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt; &lt;link rel=\"icon\" href=\"&lt;%= BASE_URL %&gt;favicon.ico\"&gt; &lt;!-- 把'&lt;%= htmlWebpackPlugin.options.title %&gt;'改为App Demo --&gt; &lt;title&gt;My App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ... &lt;/body&gt;&lt;/html&gt; 4.打包这里我们已经集成了electron-builder工具，可以参阅官方文档。","link":"/2020/06/28/Vue/Electron+vue-cli3/"},{"title":"Vue整合Axios","text":"Vue整合Axios，封装API Axios官方API 1.安装axios npm管理： 1$ cnpm i axios -S CDN： 1&lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; 2.封装axios在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json、客户端防御cSRF等。所以官方也是果断放弃了对其官方库vue-resource的维护，直接推荐我们使用axios库。如果还对axios不了解的，可以移步Axios官方API。 2.2 引入在项目的src目录中，新建一个request文件夹，然后在里面新建一个http.js；新建一个apis文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。 http.js文件： 123456789/* eslint-disable no-lone-blocks */// axios package// 引入axios，并加到原型链中import Vue from 'vue'import axios from 'axios'Vue.prototype.$axios = axios;Vue.prototype.$store = store;axios.defaults.baseURL = '/' // 关键代码 2.3 设置请求时间http.js文件： 1234...// 设置默认的请求超时时间。超过了10s，告知用户当前请求超时，请刷新等。axios.defaults.timeout = 10000; 2.4 post请求头设置post请求的时候，我们需要加上一个请求头，所以可以在这里进行一个默认的设置，即设置post的请求头为application/x-www-form-urlencoded;charset=UTF-8 http.js文件： 1axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8'; 2.5 请求拦截器在发送请求前可以进行一个请求的拦截，为什么要拦截呢？拦截请求是用来做什么的呢？ 比如，有些请求是需要用户登录之后才能访问的，或者post请求的时候，需要序列化我们提交的数据。这时候，我们可以在请求被发送之前进行一个拦截，从而进行我们想要的操作。 http.js文件： 12345678910111213141516171819202122232425262728293031...import store from '@/store/index' //@ 等价于/src这个目录.../* ============================== 拦截器 ============================== */// 请求拦截器axios.interceptors.request.use( config =&gt; { // 每次发送请求之前判断vuex中是否存在token // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况 // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断 console.log('请求拦截器config' + config.headers.Authorization); const token = store.state.token; console.log('store.state' + store.state); console.log('token:' + token); token &amp;&amp; (config.headers.Authorization = token); // 每次发送请求之前判断是否存在token // 如果存在，则统一在http请求的header都加上token，不用每次请求都手动添加了 // if (token) { // config.headers.Authorization = token; // } return config; }, error =&gt; { console.log('error:' + error); return Promise.error(error); }) token：一般是在登录完成之后，将用户的token通过localStorage或者cookie存在本地，然后用户每次在进入页面的时候（即在main.js中），会首先从本地存储中读取token，如果token存在说明用户已经登陆过，则更新vuex中的token状态。然后，在每次请求接口的时候，都会在请求的header中携带token，后台人员就可以根据你携带的token来判断你的登录是否过期，如果没有携带，则说明没有登录过。 那么每个请求都携带token，那么如果一个页面不需要用户登录就可以访问的怎么办呢？其实，前端的请求可以携带token，但是后台可以选择不接收的。 2.6 响应拦截器http.js文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677...// 响应拦截器axios.interceptors.response.use( // 请求成功 response =&gt; { // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据 // 否则的话抛出错误 console.log('响应拦截器' + response.status); if (response.status === 200) { console.log('响应拦截器' + response.status); return Promise.resolve(response); } else { return Promise.reject(response); } }, // 服务器状态码不是2开头的的情况 // 这里可以跟你们的后台开发人员协商好统一的错误状态码 // 然后根据返回的状态码进行一些操作，例如登录过期提示，错误提示等等 // 下面列举几个常见的操作，其他需求可自行扩展 // 请求失败 error =&gt; { console.log('响应拦截器error::' + error); console.log('响应拦截器码: ' + error.response.status); if (error.response.status) { switch (error.response.status) { // 401: 未登录 // 未登录则跳转登录页面，并携带当前页面的路径 // 在登录成功后返回当前页面，这一步需要在登录页操作。 case 401: { console.log('响应拦截器error::401'); console.log('401::' + router); console.log('401::' + router.currentRoute.fullPath); router.replace({ path: '/login', query: { redirect: router.currentRoute.fullPath } }); } break; // 403 token过期 // 登录过期对用户进行提示 // 清除本地token和清空vuex中token对象 // 跳转登录页面 case 403: // 清除token localStorage.removeItem('token'); store.commit('loginSuccess', null); // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面 setTimeout(() =&gt; { router.replace({ path: '/login', query: { redirect: router.currentRoute.fullPath } }); }, 1000); break; // 404请求不存在 case 404: router.replace({ path: '/login', query: { redirect: router.currentRoute.fullPath } }); break; // 其他错误，直接抛出错误提示 default: } return Promise.reject(error.response); } }) 响应拦截器很好理解，就是服务器返回给我们的数据，我们在拿到之前可以对他进行一些处理。 例如上面的思想：如果后台返回的状态码是200，则正常返回数据，否则的根据错误的状态码类型进行一些我们需要的错误，其实这里主要就是进行了错误的统一处理和没登录或登录过期后调整登录页的一个操作。 2.7 封装get方法和post方法常用的ajax请求方法有get、post、put等方法，axios对应的也有很多类似的方法。为了简化代码，还是要对其进行一个简单的封装。下面主要封装两个方法：get和post。 get方法 通过定义一个get函数，get函数有两个参数，第一个参数表示我们要请求的url地址，第二个参数是我们要携带的请求参数。get函数返回一个promise对象，当axios其请求成功时resolve服务器返回 值，请求失败时reject错误值。最后通过export抛出get函数。 http.js文件： 12345678910111213141516171819202122232425.../* ============================== 封装get方法和post方法 ============================== */// const Domain = \"http://255.255.255.0:8000\"; // 定义根域名const Domain = '';/** * get方法，对应get请求 * @param {String} url [请求的url地址] * @param {Object} params [请求时携带的参数] */export function get(action, params) { return new Promise((resolve, reject) =&gt; { // url 判断是测试环境 就要拿 测试环境的域名， 正式环境的就要用 正式域名 const url = Domain + action; axios.get(url, { params: params }).then(res =&gt; { resolve(res.data); }).catch(err =&gt; { reject(err.data) }) });} post方法 原理同get基本一样，但是要注意的是，post方法必须要使用对提交从参数对象进行序列化的操作，所以我们可以通过node的qs模块来序列化我们的参数。这个很重要，如果没有序列化操作，后台是拿不到提交的数据的。 可以通过import QS from 'qs'引入qs模块。 12345678910111213141516171819.../** * post方法，对应post请求 * @param {String} url [请求的url地址] * @param {Object} params [请求时携带的参数] */export function post(action, params) { return new Promise((resolve, reject) =&gt; { const url = Domain + action; axios.post(url, params) .then(res =&gt; { resolve(res.data); }) .catch(err =&gt; { reject(err.data) }) });} axios.get()方法和axios.post()在提交数据时参数的书写方式还是有区别的。区别就是，get的第二个参数是一个{}，然后这个对象的params属性值是一个参数对象的。而post的第二个参数就是一个参数对象。两者略微的区别要留意哦！ 封装完成啦！ 3.接口统一管理整齐的api就像电路板一样，即使再复杂也能很清晰整个线路。文件中存放所有的api接口。 在api.js中引入封装的get和post方法。 api.js文件： 12345678910111213/** * api接口统一管理 */import { get, post } from '@/request/http'export default { postData(action, params){ return post(action, params) }, getData(action, params){ return get(action, params) }} 在组件中使用： 任意vue文件： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div id=&quot;#&quot;&gt;&lt;/template&gt;&lt;script&gt; import Vue from 'vue'; import api from '@/api/api.js'; Vue.prototype.$api = api; export default { name:&quot;#&quot;, data(){ return { value1:'', value2:'' } }, methods:{ functiondemo(arg){ // 序列化数据 let param = new URLSearchParams(); param.append(&quot;key1&quot;, this.value1); param.append(&quot;key2&quot;, this.value2); this.$api.postData('/url', param) .then(response =&gt; { ... }) .catch(err =&gt; { console.log(err); }); } } }&lt;/script&gt;&lt;style&gt; ...&lt;/style&gt; 其他的api接口，就在api.js中继续往下面扩展就可以了！ 并为每个接口写好注释！ api接口管理的一个好处就是，我们把api统一集中起来，如果后期需要修改接口，我们就直接在api.js中找到对应的修改就好了，而不用去每一个页面查找我们的接口然后再修改会很麻烦。关键是，万一修改的量比较大，就会很麻烦。还有就是如果直接在我们的业务代码修改接口，一不小心还容易动到我们的业务代码造成不必要的麻烦。","link":"/2020/06/29/Vue/Vue%E5%BC%95%E5%85%A5Axios/"},{"title":"TypeScript入门","text":"TypeScript教程 TypeScript官网 1 安装1.1 NPM安装 在项目中打开终端，执行下面命令： 1$ cnpm install -g typescript 菜鸟教程 1.2 测试安装完成后我们可以使用 tsc 命令来执行 TypeScript 的相关代码，以下是查看版本号： 12$ tsc -vVersion 3.9.5 1.3 Hello World 然后我们新建一个 test.ts 的文件，代码如下： 12var message:string = \"Hello World\" console.log(message) .ts 为 TypeScript 代码文件的扩展名。 然后执行以下命令将 TypeScript 转换为 JavaScript 代码： 1$ tsc test.ts 这时候再当前目录下（与 test.ts 同一目录）就会生成一个 test.js 文件，代码如下： 12var message = \"Hello World\";console.log(message); 使用 node 命令来执行 test.js 文件： 12$ node test.jsHello World","link":"/2020/06/30/ts/TypeScript/"},{"title":"SpringBoot与数据访问","text":"1、整合基本JDBC与数据源1.1 Spring官网查看各种场景JDBC有关的场景启动器。 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 配置文件： 123456spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.15.22:3306/jdbc driver-class-name: com.mysql.jdbc.Driver 效果： 默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源 数据源的相关配置都在DataSourceProperties里面 1.2 自动配置原理org.springframework.boot.autoconfigure.jdbc 参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型； SpringBoot默认可以支持以下数据源： 123org.apache.tomcat.jdbc.pool.DataSourceHikariDataSourceBasicDataSource 自定义数据源类型 1234567891011121314@ConditionalOnMissingBean({DataSource.class})@ConditionalOnProperty( name = {\"spring.datasource.type\"})static class Generic { Generic() { } @Bean public DataSource dataSource(DataSourceProperties properties) { // 使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性 return properties.initializeDataSourceBuilder().build(); }} 在DataSourceAutoConfiguration.class中，有DataSourceInitializer继承自ApplicationListener 作用： runSchemaScripts()；运行建表语句 runDataScripts()；运行插入数据的sql语句 默认只需要将文件命名为： 12schema-*.sql、data-*.sql默认规则：必须命名schema.sql，schema-all.sql； 可以使用配置文件指定位置 12345678spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.15.22:3306/jdbc driver-class-name: com.mysql.jdbc.Driver schema: - classpath:department.sql 操作数据库：自动配置了JdbcTemplate操作数据库 2、整合Druid数据源在Maven公共库中搜索Druid，找到其Maven依赖： 123456&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.23&lt;/version&gt;&lt;/dependency&gt; 在配置文件中加入配置： 12345678910111213141516171819202122232425262728293031spring: # 数据源基本配置 datasource: # 与DataSourceProperties.class下的属性一一对应 username: root password: 123456 url: jdbc:mysql://192.168.8.156:3306/jdbc driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource# schema:# - classpath:department.sql # 数据源其他配置, 底部这种颜色是因为DataSourceProperties.class下没有这些属性, # 并不能绑定到数据库的配置里 # 但DruidDataSource.java中有这些属性 # 想要生效, 自己配置, config.DruidConfig initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 想要配置生效，导入druid数据源 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Configurationpublic class DruidConfig { @ConfigurationProperties(prefix = \"spring.datasource\") @Bean public DataSource druid(){ return new DruidDataSource(); } // 配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet(){ ServletRegistrationBean bean = new ServletRegistrationBean( new StatViewServlet(), \"/druid/*\" ); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"loginUsername\",\"admin\"); initParams.put(\"loginPassword\",\"123456\"); initParams.put(\"allow\",\"\");// 默认就是允许所有访问 initParams.put(\"deny\",\"192.168.15.21\"); bean.setInitParameters(initParams); return bean; } // 2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter(){ FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"exclusions\",\"*.js,*.css,/druid/*\"); // 排除拦截 bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(\"/*\")); return bean; }} 在之前写的SpringinitializrApplicationTests类的testJDBC()方法中 1System.out.println(dataSource.getClass()); 语句打上断点，debug测试方法，查看控制台： 3、整合MyBatis同样在Maven公共库中搜索MyBatis Spring Boot Starter，找到其Maven依赖 123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt;&lt;/dependency&gt; 3.1 MyBatis-Spring-Boot-Starter 简介MyBatis-Spring-Boot-Starter类似一个中间件，链接Spring Boot和MyBatis，构建基于Spring Boot的MyBatis应用程序。 MyBatis-Spring-Boot-Starter 当前版本是 2.1.3，发布于2020年6月 MyBatis-Spring-Boot-Starter是个集成包，因此对MyBatis、MyBatis-Spring和SpringBoot的jar包都存在依赖，如下所示： MyBatis-Spring-Boot-Starter MyBatis-Spring Spring Boot Java 2.1 2.0 (need 2.0.2+ for enable all features) 2.1 or higher 8 or higher 1.3 1.3 1.5 6 or higher 3.2 分析依赖 依赖会引入spring-boot-starter-jdbc，mybatis的jar包，mybatis-spring中间整合包以及mybatis-spring-boot-autoconfigure自动配置包。 3.3 使用步骤 配置数据源相关属性 给数据库建表 创建JavaBean 注解版 3.4 注解版123456789101112131415161718192021222324// DepartmentMapper.java// 指定这是一个操作数据库的mapper@Mapperpublic interface DepartmentMapper { @Select(\"select * from department where id=#{id}\") public Department getDeptById(Integer id); @Delete(\"delete from department where id=#{id}\") public int deleteDeptById(Integer id); /* useGeneratedKeys = true: 使用自动生成的主键 keyProperty = \"id\": 指明主键字段, id属性式用来封装主键的 插入的department后, 主键会重新封装进来, 才会有值 */ @Options(useGeneratedKeys = true, keyProperty = \"id\") @Insert(\"insert into department(departmentName) values(#{departmentName})\") public int insertDept(Department department); @Update(\"update department set departmentName=#{departmentName} where id=#{id}\") public int updateDept(Department department);} 访问方式： 插入：http://localhost:8088/dept?departmentName=AA 查询：http://localhost:8088/dept/1 问题：自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer； 123456789101112131415161718192021// MyBatisConfig.java// 由于上面的org.apache.ibatis.session.Configuration, 所以这里使用全类名@org.springframework.context.annotation.Configurationpublic class MyBatisConfig { /* 使用注解版MyBatis时, 本来数据库department表中字段是departmentName, 如果将其改为department_name后, 就取不到值了, 如果不使用注解版, 可以直接在配置文件中配置驼峰命名规则, 但现在只能使用配置类了 */ @Bean public ConfigurationCustomizer configurationCustomizer(){ return new ConfigurationCustomizer(){ @Override public void customize(Configuration configuration) { // 开启驼峰命名法规则 configuration.setMapUnderscoreToCamelCase(true); } }; }} 还有，当我们实体类增多，每个映射文件都需要@Mapper注解？可以在启动类中使用MapperScan批量扫描所有的Mapper接口； 点击MapperScan查看源码： 1234567891011121314151617181920212223@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.TYPE})@Documented@Import({MapperScannerRegistrar.class})public @interface MapperScan { String[] value() default {}; String[] basePackages() default {}; Class&lt;?&gt;[] basePackageClasses() default {}; Class&lt;? extends BeanNameGenerator&gt; nameGenerator() default BeanNameGenerator.class; Class&lt;? extends Annotation&gt; annotationClass() default Annotation.class; Class&lt;?&gt; markerInterface() default Class.class; String sqlSessionTemplateRef() default \"\"; String sqlSessionFactoryRef() default \"\"; Class&lt;? extends MapperFactoryBean&gt; factoryBean() default MapperFactoryBean.class;} 里面可以配置basePackages()参数： 1234567891011@MapperScan(\"com.initializr.mapper\")@SpringBootApplicationpublic class SpringinitializrApplication { public static void main(String[] args) { System.out.println(\"Start...\"); SpringApplication.run(SpringinitializrApplication.class, args); System.out.println(\"Success...\"); } ...} 3.5 配置文件版MyBatis代码都托管到了GitHub，去GitHub查看配置文件写法，官方文档 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;/settings&gt;&lt;/configuration&gt; 使配置文件生效： 123456# application.ymlmybatis: # 指定全局配置文件的位置 config-location: classpath:mybatis/mybatis-config.xml # 指定sql映射文件的位置 mapper-locations: classpath:mybatis/mapper/*.xml 更多使用参照官方文档 4、整合SpringData的JPA模块4.1 SpringData简介SpringData官方文档 Spring Data项目的目的是为了简化构建基于Spring框架应用的数据访问技术，包括非关系数据库、Map-Reduce框架、云数据服务等等；另外一位包含对关系数据库的访问支持。 Spring Data包含多个子项目： Spring Data Commons Spring Data JDBC Spring Data JDBC Ext Spring Data JPA Spring Data KeyValue Spring Data LDAP Spring Data MongoDB Spring Data Redis Spring Data REST …… Spring Data for Apache Solr Spring Data Neo4j Spring Data特点 SpringData为我们提供使用统一的API来对数据访问层进行操作；这主要是 Spring Data Commons项目来实现的。Spring Data Commons让我们在使用关系型或者非关系型数据访问技术时都基于Spring提供的统一标准，标准包含了CRUD(创建、获取、更新、删除)、査询、排序和分页的相关操作。 统一的Repository接口 Repository&lt;T, ID extends Serializable&gt;：统一接口 RevisionRepository&lt;T, ID extends Serializable, N extends Number&amp; Comparable&lt;N&gt;&gt;：基于乐观锁机制 CrudRepository&lt;T, ID extends Serializable&gt;：基本CRUD操作 PagingAndSortingRepository&lt;T, ID extends Serializable&gt;：基本CRUD及分页 提供数据访问模板类xxxTemplate 如：MongoTemplate、RedisTemplate等 JPA (Java Persistence API，Java持久层API) 与Spring Data JpaRepository基本功能 定义符合规范的方法命名 @Query自定义查询，定制查询SQL Specification查询（Spring Data JPA支持JPA2.0的Criteria查询） 应用面向Spring Data编程，使用其提供模板。 4.2 整合SpringData JPA引入启动器： 12345&lt;!-- 引入JPA --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 查看视图： 可以看出，其导入了很多Spring业务功能模块，比如AOP和事务（Spring-tx）等； 还可以看出其底层是用hibernate实现的，其中使用hibernate-entitymanager管理hibernate-jpa-*-ap，进行操作。 依然需要配置数据源，用JPA操作数据库。 JPA：ORM（Object Relational Mapping）； 编写一个实体类（bean）和数据表进行映射，并且配置好映射关系； 12345678910111213141516//使用JPA注解配置映射关系@Entity //告诉JPA这是一个实体类（和数据表映射的类）@Table(name = \"tbl_user\") //@Table来指定和哪个数据表对应;如果省略默认表名就是user；public class User { @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键 private Integer id; @Column(name = \"last_name\",length = 50) //这是和数据表对应的一个列 private String lastName; @Column //省略默认列名就是属性名 private String email; // getter and setter} 编写一个Dao接口来操作实体类对应的数据表（称为Repository） 123//继承JpaRepository来完成对数据库的操作public interface UserRepository extends JpaRepository&lt;User,Integer&gt; {} 基本的配置JpaProperties 1234567spring: jpa: hibernate: # 更新或者创建数据表结构 ddl-auto: update # 控制台显示SQL show-sql: true 编写controller类 1234567891011121314151617181920// UserController.java@RestControllerpublic class UserController { @Autowired UserRepository userRepository; @GetMapping(\"/user/{id}\") public User getUser(@PathVariable(\"id\") Integer id){ User user = userRepository.findOne(id); return user; } @GetMapping(\"/user\") public User insertUser(User user){ // 有自增组件 User save = userRepository.save(user); return save; }} 写了两个简单的方法用来做测验 启动主程序查看控制台： 可以看出，我们的配置ddl-auto: update生效了，当我们第一次启动项目，数据库中没有user表时，项目会自动为我们创建的。 然后依次访问：http://localhost:8088/user/1 和http://localhost:8088/user?lastName=Tom&amp;email=tom@vip.com 查看控制台： 最后返回数据库是由数据的。 测试成功啦！","link":"/2020/08/18/Spring/SpringBootDataAccess/"},{"title":"Java及JVM简介","text":"1、前言1.1 你是否也遇到过这些问题? 运行着的线上系统突然卡死，系统无法访问，甚至直接OOM（Out Of Memory）! 想解决线上 JVM GC（ JVM垃圾回收 ）问题，但却无从下手。 新项目上线，对各种JVM参数设置一脸茫然，直接默认吧，然后就错了。 每次面试之前都要重新背一遍J的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优JVM参数，如何解决GC、OOM等问题，一脸懵逼。 我们通常都是学习基础的技能，在此基础上学习更复杂的功能。 1.2 开发人员如何看待上层框架 一些有一定工作经验的开发人员，打心眼儿里觉得SSM、微服务等上层技术才是重点，基础技术并不重要，这其实是一种本末倒置的“病态“。 如果我们把核心类库的 API 比做数学公式的话，那么 Java 虚拟机的知识就好比公式的推导过程 计算机系统体系对我们来说越来越远，在不了解底层实现方式的前提下，通过高级语言很容易编写程序代码。但事实上计算机并不认识高级语言。 1.3 架构师每天都在思考什么? 应该如何让我的系统更快? 如何避免系统出现瓶颈? 1.4 知乎上有条帖子：应该如何看招聘信息，直通年薪50万+? 参与现有系统的性能优化，重构，保证平台性能和稳定性 根据业务场景和需求，决定技术方向，做技术选型 能够独立架构和设计海量数据下高并发分布式解决方案，满足功能和非功能需求 解决各类潜在系统风险，核心功能的架构与代码编写 分析系统瓶颈，解决各种疑难杂症,性能调优等 1.5 为什么要学JVM？ 面试的需要：入职BATJ（京东）、T（头条）MD（滴滴）、P（拼多多）K（快手）Q（趣头条）等一线大厂不光关注技术的广度，更关注技术的深度，JVM技术是大厂面试的必备技能，掌握越深越好 中高级程序员、架构师必备技能：架构师每天都在思考如何让我的系统更快，如何避免系统出现性能瓶颈。单纯的依靠物理机不足以解决问题，分析系统性能、调优系统瓶颈离不了对JVM中内存、垃圾回收、字节码指令、性能监控工具、调优参数的熟练掌握。 精进技术、极客（好奇与行动）追求：JVM是Java生态的核心价值的体现，垃圾回收算法、JIT（ just in time 的缩写，也就是即时编译编译器，AOT：提前编译器）、底层原理值得每个程序员去探索。同时，JVM作为跨语言的平台，对于深入理解Scala、Kotlin、JavaScript、Jython、Groovy也很有帮助。Java最前沿最成熟垃圾回收算法。 1.6 Java vs C++以C语言代表的语言是高级语言的开端了，Java借鉴了C和C++的有点，并摈弃其缺点；缺点主要就是内存动态分配和垃圾收集技术。 分配内存想要再次使用就要垃圾回收，否则就成一次性内存了。对于C语言来说，就需要程序员自己分配内存自己回收；Java是自动管理内存的。对于自动管理内存的弊端就是不了解Java内部的内存结构和工作机制，对于项目调优就没办法了，理解为黑盒？心中胆怯，没底？ 垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是Java工程师进阶的必备能力。 2、Java及JVM简介栈管运行，堆管存储？Java半解释型，半编译型语言？ Java虚拟机官方文档下载 TIOBE语言热度排行榜 2.1 Java生态圈Java是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大，Java也早已不再是简简单单的一门计算机语言了,它更是一个平台、一种文化、一个社区。 作为一个平台，Java虚拟机扮演着举足轻重的作用。 Groovy、 Scala、 JRuby、Kot]in等都是Java平台的一部分 作为一种文化，Java几乎成为了“开源”的代名词 第三方开源软件和框架。如 Tomcat、 struts, My Batis, Spring等。 就连UDK和JM自身也有不少开源的实现,如 OpenJDK、 Harmony（开源的JVM） 作为一个社区，Java拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到Java的身影。其应用形式之复杂、参与人数之众多也令人咋舌 2.2 Java：跨平台的语言 2.3 JVM虚拟机规范The Java Virtual Machine Specification, Java SE 8 Edition Java虚拟机是Java平台的基石。 它是技术的组成部分，负责硬件和操作系统的独立性，编译代码的小巧大小以及保护用户免受恶意程序攻击的能力。 编译代码的小巧（小尺寸）：在一个程序中用到了基本数据类型和类，在编译字节码文件时对应一个常量池，运行的时候对应运行常量池，通过常量指向，避免去字节码文件加载大量数据和类，以保证字节码文件的小尺寸， 2.4 JVM：跨语言的平台Java：跨平台的语言 不仅可以执行Java程序，其他语言也是可以的。只需保证各自的编译器编译出的字节码文件遵循Java虚拟机规范即可。在Java虚拟机的编译器中运行。 三大并行难题：CPU、OS、编译器。 随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序。 Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。 The Java Virtual Machine Specification, Java SE 8 Edition 为了安全起见，Java虚拟机对类文件中的代码施加了严格的语法和结构约束。 但是，Java虚拟机可以托管任何具有可用有效类文件表示的功能的语言。 受通用的独立于机器的平台的吸引，其他语言的实现者可以将Java虚拟机作为其语言的交付工具。 Java不是最强大的语言，但是JVM是最强大的虚拟机。 2.5 字节码 我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在JVM平台上执行的字节码格式都是一样的。所以应该统称为JVM字节码。 不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。 Java 虚拟机与Java 语言并没有必然的联系，它只与特定的二进制文件格式——Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、 Bytecodes）和符号表，还有一些其他辅助信息。 2.6 多语言混合编程 Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件干发应对日趋复杂的项目需求的一个方向。 试想一下，在一个项目之中，并行处理用Clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上。 对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如Da Vinci machine项目、 Nashorn引擎、 Invoke Dynamic指令、java.lang.invoke包等），推动Java虚拟机从“Java语言的虚拟机”向“多语言虚拟机”的方向发展。 3、Java发展的重大事件 1990年，在Sun计算机公司中，由 Patrick Naughton、 Mikesheridan及James Gosling领导的小组 Green Team，开发出的新的程序语言，命名为oak，后期命名为Java 1995年，Sun正式发布Java和 HotJava产品，Java首次公开亮相。 1996年1月23日 Sun Microsystems发布了JDK1.0。 1998年，JDK1.2版木发布。同时，sun发布了JSP/ Servlet、EJB规范，以及将Java分成了J2EE（企业级应用）、J2SE（桌面级应用）和J2ME（移动端）。这表明了Java开始向企业、桌面应用和移动设备应用3大领域挺进。 2000年，JDK1.3发布， Java Hotspot Virtual Machine正式发布，成为Java的默认虚拟机。 2002年，JDK1.4发布，古老的 Classic虚拟机退出历史舞台，同期微软.NET发布 2003年年底，Java平台的 Scala正式发布，同年 Groovy也加入了Java阵营。 2004年，JDK1.5发布。同时JDK1.5改名为 JavaSE5.0。 2006年，JDK6发布。同年，Java开源并建立了 OpenJDK。顺理成章，Hotspot虚拟机也成为了 OpenJDK中的默认虚拟机。 2007年，Java平台迎来了新伙伴Clojure。 2008年，Oracle收购了BEA，得到了JRockit虚拟机。 2009年，Twitter宣布把后台大部分程序从Ruby迁移到 Scala，这是Java平台的又一次大规模应用。 2010年，Oracle收购了Sun，获得Java商标和最具价值的 Hotspot虚拟机，JCP组织管理Java语言，但Oracle话语权比较重。此时，Oracle拥有市场占用率最高的两款虚拟机Hot Spot和 JRockit，并计划在未来对它们进行整合：Hotrockit 2011年，JDK7发布。在JDK1.7u4中，正式启用了新的垃圾回收器G1。 2014年，算是整合了上述两款虚拟机Hotrockit，从JavaSE8.0后 2017年，JDK9发布。将G1设置为默认GC，替代CMS。同年，IBM的J9开源，形成了现在的 Open J9社区 2018年，Android的Java侵权案判决，Google赔偿Oracle计88亿美元。同年，OracLe宣告 JavaEE成为历史名词，JDBC、JMS、servlet赠予Eclipse基金会。同年，JDK11发布，LTS版本的JDK，发布革命性的ZGC，调整JDK授权许可 2019年，JDK12发布，加入RedHat领导开发的 Shenandoah GC 在JDK11之前，OracleJDK中还会存在一些 OpenJDK中没有的、闭源的功能。但在JDK11中，我们可以认为 OpenJDK和 oracleJDK代码实质上已经完全一致的程度。主要是基于的协议不同，OpenJDK基于OPL协议，OracleJDK基于OPN协议。OpenJDK维护期半年，过了就更新下一版本，OracleJDK持续维护3年 4、虚拟机与Java虚拟机4.1 虚拟机 所谓虚拟机( Virtual Machine)，就是一台虚拟的计算机它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。 大名鼎鼎的 Visual Box，VMware就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。 程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。 无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。 4.2 Java虚拟机 Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。 JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回收器，以及可靠的即时编译器。 Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine）因为所有的Java程序都运行在Java虚拟机内部。 作用： Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。 特点 一次编译，到处运行 自动内存管理 自动垃圾回收功能 5、JVM的位置 JⅥM是运行在操作系统之上的，它与硬件没有直接的交互。不同操作系统的JVM是有区别的。 6、JVM的整体结构 HotSpot VM是目前市面上高性能虚拟机的代表作之一。 它采用解释器与即时编译器并存的架构。 在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。 将图示结构分为上中下层： 上层：入口是字节码文件，通过装载器加载到内存中，生成class对象； 中层：有对应class的实例了；多线程共享方法区和堆，虚拟机栈（Java栈），本地方法栈和程序计数器是每个线程独有的。 下层：有“后端编译器”，将高级语言翻译为机器语言 7、Java代码执行流程 关于上图中Java编译器（“前端”编译器）的细节不用过多关注，除非涉及开发一门语言；在这个过程中任何一个过程失败，都不能正确生成字节码文件。字节码文件也是跨平台的 “解析执行”和“编译执行“模块相当于执行引擎，”解析执行“保证响应时间，逐行对字节码解释执行，反复执行的代码称为”热点代码“，“编译执行”有个二次编译，第一编译为字节码的热点代码，将其缓存起来，下次直接调用，转换为机器指令。 8、JVM的架构模型Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。HotSpot是基于栈的架构。 8.1 具体来说：这两种架构之间的区别： 基于栈式架构的特点 设计和实现更简单，适用于资源受限的系统；（方法，入栈出栈？实现简单） 避开了寄存器的分配难题：使用零地址（无地址，只有操作数）指令方式分配。（栈的结构？栈顶元素？不需要知道地址？不麻烦） 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。 不需要硬件支持，可移植性更好，更好实现跨平台。（栈与内存交互） 基于寄存器架构的特点 典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。 指令集架构则完全依赖硬件，可移植性差 性能优秀和执行更高效 花费更少的指令去完成一项操作。 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主方水洋 8.2 示例123456789public class StackStructureTest { public static void main(String[] args) { // int i = 1+2; int i = 3; int j = 4; int k = i+j; }} 编译运行后，会在项目的out文件夹下生成字节码文件： 在“chapter01”下打开cmd执行下面语句进行反编译： 1$ javap -v StackStructureTest.class 输出：（基于栈的计算流程（以Java虚拟机为例）） 1234567891011121314151617181920212223242526272829303132333435363738394041424344... #23 = Utf8 java/lang/Object{ public com.chapter01.StackStructureTest(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return LineNumberTable: line 3: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/chapter01/StackStructureTest; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=4, args_size=1 0: iconst_3 // 定义常量3 1: istore_1 // 1是操作数栈的索引位置，将上面常量保存到索引为1的操作数栈中 2: iconst_4 3: istore_2 4: iload_1 // 将索引1加载进来 5: iload_2 // 加载索引2 6: iadd // 求和操作 7: istore_3 // 将结果存到索引为3的操作数栈中 8: return // 8行，寄存器的话 LineNumberTable: line 7: 0 line 8: 2 line 9: 4 line 10: 8 LocalVariableTable: Start Length Slot Name Signature 0 9 0 args [Ljava/lang/String; 2 7 1 i I 4 5 2 j I 8 1 3 k I}SourceFile: \"StackStructureTest.java\" 而基于寄存器的计算流程： 12mov eax,2 //将eax寄存器的值设为1add eax,3 //使eax寄存器的值加3 8.3 总结由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。 时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpot VM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？ 栈：跨平台性、指令集小、指令多；执行性能比寄存器差 9、JVM的生命周期9.1 虚拟机的启动Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。 自定义的类通过系统类加载器加载，继承自Object，Object需要被引导类加载器加载，Object并不是初始类，一个简单类的执行就需要加载很多类，此时JVM启动 9.2 虚拟机的执行 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。 程序开始执行时他才运行，程序结束时他就停止。 1234567891011121314151617public class StackStructureTest { public static void main(String[] args) { // int i = 1+2; int i = 3; int j = 4; int k = i+j; try { Thread.sleep(6000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"hello\"); }} 运行，趁还没有结束，在cmd中输入： 1234567891011$ jps // 打印当前执行程序中的进程22272 StackStructureTest // 22272端口号2254824164 RemoteMavenServer3622024 Launcher21388 Jps // JVM就退出了$ jps // 结束后2254824164 RemoteMavenServer363188 Jps22024 Launcher 执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。 9.3 虚拟机的退出有如下的几种情况： 程序正常执行结束 程序在执行过程中遇到了异常（没有处理的异常）或错误而异常终止 由于操作系统用现错误而导致Java虚拟机进程终止 某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。 第6节运行时数据区，就是运行时环境，对应的类就是java.lang.Runtime，这个类是单例的 除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。 10、JVM发展历程10.1 Sun Classic VM 早在1996年Java1.0版本的时候，Sun公司发布了一款名为sun classic VM的Java虚拟机，它同时也是世界上第一款商用Java虚拟机，JDK1.4时完全被淘汰。 这款虚拟机内部只提供解释器。 现在还有及时编译器，因此效率比较低，而及时编译器会把热点代码缓存起来，那么以后使用热点代码的时候，效率就比较高。提升效率就要用JIT编译器。 如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。 解释器响应快，编译器寻找热点代码，不用解释器逐行编译。如果只使用高性能编译器，响应时间慢，加上逐行编译指令，就会使程序启动时响应时间过长（卡顿）。其实现今的Java虚拟机的执行速度以不亚于C，更形象地例子，解释器相当于步行，命令响即出发，编译器相当于坐公交车，命令响等公交或转车，两者配合更优。 现在hotspot内置了此虚拟机。 10.2 Exact VM 为了解决上一个虚拟机问题，jdk1.2时，sun提供了此虚拟机。 Exact Memory Management：准确式内存管理 也可以叫Non-Conservative/Accurate Memory Management 虚拟机可以知道内存中某个位置的数据具体是什么类型。| 具备现代高性能虚拟机的维形 热点探测（寻找出热点代码进行缓存） 编译器与解释器混合工作模式 只在solaris平台短暂使用，其他平台上还是classic vm，英雄气短，终被Hotspot虚拟机替换 10.3 HotSpot VM HotSpot历史 最初由一家名为“Longview Technologies”的小公司设计 1997年，此公司被sun收购；2009年，Sun公司被甲骨文收购。 JDK1.3时，HotSpot VM成为默认虚拟机 目前Hotspot占有绝对的市场地位，称霸武林。 不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot Sun/oracle JDK和openJDK的默认虚拟机 因此本课程中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的Gc机制。（比如其他两个商用虚机都没有方法区的概念） 从服务器、桌面到移动端、嵌入式都有应用。 名称中的HotSpot指的就是它的热点代码探测技术。 通过计数器找到最具编译价值代码，触发即时编译或栈上替换 通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡 10.4 JRockit 专注于服务器端应用 它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。 大量的行业基准测试显示，JRockit JVM是世界上最快的JVM。 使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。 优势：全面的Java运行时解决方案组合 JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要 MissionControl服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。 官网JMC，监控内存泄露。 原属BEA公司，2008年，JRockit被oracle收购。 oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。 高斯林（Java之父）：目前就职于谷歌，研究人工智能和水下机器人 10.5 IBM的J9 全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9 市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM广泛用于IBM的各种Java产品。 目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机。 2017年左右，IBM发布了开源J9VM，命名为openJ9，交给EClipse基金会管理，也称为Eclipse OpenJ9 10.6 KVM和CDC / CLDC Hotspot oracle在Java ME产品线上的两款虚拟机为：CDC/CLDC HotSpot Implementation VM KVM（Kilobyte）是CLDC-HI早期产品目前移动领域地位尴尬，智能机被Android和ioS二分天下。 KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场 智能控制器、传感器 老人手机、经济欠发达地区的功能手机 所有的虚拟机的原则：一次编译，到处运行。 10.7 Azul VM 前面三大“高性能Java虚拟机”使用在通用硬件平台上 这里Azul VW和BEA Liquid VM是与特定硬件平台绑定、软硬件配合的专有虚拟机 高性能Java虚拟机中的战斗机。 Azul VM是Azul Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的ava虚拟机。 每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。 2010年，Azul Systems公司开始从硬件转向软件，发布了自己的Zing JVM，可以在通用x86平台上提供接近于Vega系统的特性。 10.8 Liquid VM 高性能Java虚拟机中的战斗机。 BEA公司开发的，直接运行在自家Hypervisor系统上Liquid VM即是现在的JRockit VE（Virtual Edition）， Liquid VM即是现在的 JRockit VE（Virtual Edition）。Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。 随着JRockit虚拟机终止开发，Liquid vM项目也停止了。 10. 9Apache Marmony Apache也曾经推出过与JDK1.5和JDK1.6兼容的Java运行平台Apache Harmony。 它是IBM和Intel联合开发的开源JVM，受到同样开源的OpenJDK的压制，Sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK 虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。 10.10 Micorsoft JVM 微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。 只能在window平台下运行。但确是当时Windows下性能最好的Java VM。 1997年，sun以侵犯商标、不正当竞争罪名指控微软成功，赔了sun很多钱。微软windowsXP SP3中抹掉了其VM。现在windows上安装的jdk都是HotSpot。 10.11 Taobao JVM 由Ali JVM团队发布。阿里，国内使用Java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。 基于OpenJDK开发了自己的定制版本AlibabaJDK，简称AJDK。是整个阿里Java体系的基石。 基于OpenJDK Hotspot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。 创新的GCIH（GC invisible heap）技术实现了off-heap，即将生命周期较长的Java对象从heap中移到heap之外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。 GCIH中的对象还能够在多个Java虚拟机进程中实现共享 使用crc32指令实现JVM intrinsic降低JNI的调用开销 PMU hardware的Java profiling tool和诊断协助功能 针对大数据场景的ZenGc taobao vm应用在阿里产品上性能高，硬件严重依赖intel的cpu，损失了兼容性，但提高了性能 目前已经在淘宝、天猫上线，把Oracle官方JVM版本全部替换了。 10.12 Dalvik VM 谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。 Dalvik VM只能称作虚拟机，而不能称作“Java虚拟机”，它没有遵循 Java虚拟机规范 不能直接执行Java的Class文件 基于寄存器架构，不是jvm的栈架构。 执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。 它执行的dex（Dalvik Executable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。 Android 5.0使用支持提前编译（Ahead of Time Compilation，AOT）的ART VM替换Dalvik VM。 10.13 Graal VM 2018年4月，Oracle Labs公开了Graal VM，号称 “Run Programs Faster Anywhere“，勃勃野心。与1995年java的”write once，run anywhere”遥相呼应。 Graa VM在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言” 的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等 支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件 工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。 如果说HotSpot有一天真的被取代，Graal VM希望最大。但是Java的软件生态没有丝毫变化。 10.14 总结具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以oracle HotSpot VM为默认虚拟机。","link":"/2020/08/28/Java/JVM%E7%AE%80%E4%BB%8B/"},{"title":"ElasticSearch入门","text":"1、ElasticSearch介绍 1.1 引言 在海量数据中执行搜索功能时，如果使用MSQL，效率太低。 如果关键字输入的不准确一样可以搜索到想要的数据。 将搜索关键字，以高亮字体展示（购物网站）。 1.2 ES的介绍ES是一个使用Java语言并且基于lucence编写的搜索引擎框架，他提供了分布式的全文搜索功能，提供了一个统一的基于RESTful风格的WEB接口。官方文档 lucence：一个搜索引擎底层，官方网站，apache旗下的顶级项目，直接使用成本太高，所以采用ES实现功能。 分布式：突出ES的横向扩展能力。 全文检索：将一段词语进行分词，并将分出的单个词语统一的放在一个分词库中，在搜索时，根据关键字取分词库中检索，找到匹配的内容（倒排索引）。 比如：淘宝搜索“壳手机”，将其分解为“壳”、“手机”、“手”等；将目标“…苹果手机壳…”也这样分解。（全文检索） RESTful风格的WEB接口：操作ES，只需要发送一个http请求，并且根据请求方式的不同，携带参数的不同，执行相应的功能。 应用广泛：WIKI，Github，Gold Man用ES每天维护将近10TB数据。 1.3 ES的由来你知道的, 为了搜索… 回忆时光 许多年前，一个刚结婚的名叫 Shay Banon 的失业开发者，跟着他的妻子去了伦敦，他的妻子在那里学习厨师。 在寻找一个赚钱的工作的时候，为了给他的妻子做一个食谱搜索引擎，他开始使用 Lucene 的一个早期版本。 直接使用 Lucene 是很难的，因此 Shay 开始做一个抽象层，Java 开发者使用它可以很简单的给他们的程序添加搜索功能。 他发布了他的第一个开源项目 Compass。 后来 Shay 获得了一份工作，主要是高性能，分布式环境下的内存数据网格。这个对于高性能，实时，分布式搜索引擎的需求尤为突出， 他决定重写 Compass，把它变为一个独立的服务并取名 Elasticsearch。 第一个公开版本在2010年2月发布，从此以后，Elasticsearch 已经成为了 Github 上最活跃的项目之一，他拥有超过300名 contributors(目前736名 contributors )。 一家公司已经开始围绕 Elasticsearch 提供商业服务，并开发新的特性，但是，Elasticsearch 将永远开源并对所有人可用。 据说，Shay 的妻子还在等着她的食谱搜索引擎… 1.4 ES和Slor Solr在查询死数据时，速度比ES快。但是数据如果是改变的，Solr查询速度会降低很多，ES的查询速度没有变化。 Solr搭建集群依赖ZooKeeper来帮助管理，ES本身就支持集群的搭建，不需要第三方的介入。 Solr出现早，最开始Solr的社区很火爆，针对国内文档少；ES出现后，国内社区火爆程度 上升，ES的文档非常健全。 ES对云计算和大数据支持很好 1.5 倒排索引 拿到数据的过程分两步：（关键字：“好编程“，分词为”好“和”编程“） query：根据输入的关键字，去分词库中检索内容；结果：1,2,3 fetch：根据在分词库中检索到的id，直接拉取指定数据；结果：“1：你好”，“2：编程”和“3：你好编程” 将存放的数据以一定的方式进行分词，并将分词的内容存放到一个单独的分词库中。 当用户取查询数据时，会将用户的查询关键字进行分词。 然后去分词库中匹配内容，最终得到数据的id标识 根据id标识去存放数据的位置拉去指定数据 2、安装2.1 安装docker-composeDocker安装方法 2.2.1 安装方法1，使用pip 安装pip需要先安装epel-release包 1$ yum -y install -y epel-release 安装pip 1$ yum install -y python-pip 检查python和pip版本 12$ python -V # 3+$ pip -V # 20+ 若不满足上述条件 pip升级 1$ pip install --upgrade pip -ihttp://pypi.douban.com/simple --trusted-host pypi.douban.com 升级python2到python3 1234567891011# 下载$ wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz# 解压源码包$ tar -zxvf Python-3.7.0.tgz# 创建安装目录$ mkdir /usr/local/python3$ cd Python-3.7.0/# 安装到指定目录$ ./configure --prefix=/usr/local/python3# 编译$ make &amp;&amp; make install 设置软链接全局使用python3 1234$ cd /usr/local/python3$ ln -s /usr/local/python3/bin/python3 /usr/local/bin/python3$ ln -s /usr/local/python3/bin/pip3 /usr/local/bin/pip3$ ln -s /usr/local/bin/pip3 /usr/bin/pip 验证版本 1234$ python3 -VPython 3.7.0$ pip -vpip 20.2.2 from /usr/local/python3/lib/python3.7/site-packages/pip (python 3.7) 可以使用下述命令来查看软链接设置 1$ ls -al /usr/bin | grep python 升级 Python 之后，由于将默认的 python 指向了 python3，yum 不能正常使用，需要编辑 yum 的配置文件： 1234$ vi /usr/bin/yum将 #!/usr/bin/python 改为 #!/usr/bin/python2.7$ vi /usr/libexec/urlgrabber-ext-down将 #!/usr/bin/python 改为 #!/usr/bin/python2.7 指定安装源，安装docker-compose 1$ pip install -i https://pypi.tuna.tsinghua.edu.cn/simple docker-compose 查看docker-compose的版本 12$ docker-compose -vdocker-compose version 1.24.0, build 0aa5906 2.1.2 安装方法2，离线安装（推荐）Github发行版本，下载docker-compose-Linux-x86_64，推荐一个软件Motrix，加快下载速度，将下载文件命名为docker-compose。 上传到服务器并移动到/usr/local/bin/： 1$ mv docker-compose /usr/local/bin/ 添加可执行权限 1$ chmod +x /usr/local/bin/docker-compose 查看docker-compose版本 12$ docker-compose -vdocker-compose version 1.26.2, build eefe0d31 2.2 安装ElasticSearch&amp;KibanaDocker镜像工厂，分别搜索“elasticsearch”和“kibana”，选取“社区镜像”作为来源，找到“library/elasticsearch”和“library/kibana”，版本同一。 Kibana是为Elasticsearch设计的开源分析和可视化平台。 在指定文件夹下： 1$ vi docker-compose.yml 并复制下面内容到docker-compose.yml文件 123456789101112131415161718version: \"3.1\"services: elasticsearch: image: daocloud.io/library/elasticsearch:6.5.4 restart: always container_name: elasticsearch ports: - 9200:9200 kibana: image: daocloud.io/library/kibana:6.5.4 restart: always container_name: kibana ports: - 5601:5601 environment: - elasticsearch_url=ip:9200 # 此处ip为自己对应主机地址 depends_on: - elasticsearch 运行 1$ docker-compose up -d 查看日志 1$ docker-compose logs -f 浏览器查看，成功 浏览http://192.168.6.33:9200/： 浏览http://192.168.6.33:5601 2.3 安装IK分词器Es默认的分词器对中文的支持是不友好的，Github下载地址，版本还是要统一。 还是使用docker安装： 查看es容器的CONTAINER ID，进入es容器内部： 12[root@localhost docker_elasticsearch]# docker exec -it &lt;CONTAINER ID&gt; bash[root@fddcec4fe9e7 elasticsearch]# 进入bin目录，执行bin目录下的脚本文件： 1$ cd bin IK分词器对于es来说就是一个插件： 123$ ./elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.5.4/ elasticsearch-analysis-ik-6.5.4.zip 由于在容器内安装IK分词器，如果把容器down掉，这个IK分词器就没了，重启就可以了 记得重启es容器，分词器才会生效，重启es就可以了： 1$ docker restart &lt;CONTAINER ID&gt; 在Kibana中测试，使用GitHub推荐方法；在Dev Tool中： 12345POST _analyze{ \"analyzer\": \"ik_max_word\", \"text\":\"我是Java工程师.你呢?\"} 得到输出“ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960{ \"tokens\" : [ { \"token\" : \"我\", \"start_offset\" : 0, \"end_offset\" : 1, \"type\" : \"CN_CHAR\", \"position\" : 0 }, { \"token\" : \"是\", \"start_offset\" : 1, \"end_offset\" : 2, \"type\" : \"CN_CHAR\", \"position\" : 1 }, { \"token\" : \"java\", \"start_offset\" : 2, \"end_offset\" : 6, \"type\" : \"ENGLISH\", \"position\" : 2 }, { \"token\" : \"工程师\", \"start_offset\" : 6, \"end_offset\" : 9, \"type\" : \"CN_WORD\", \"position\" : 3 }, { \"token\" : \"工程\", \"start_offset\" : 6, \"end_offset\" : 8, \"type\" : \"CN_WORD\", \"position\" : 4 }, { \"token\" : \"师\", \"start_offset\" : 8, \"end_offset\" : 9, \"type\" : \"CN_CHAR\", \"position\" : 5 }, { \"token\" : \"你\", \"start_offset\" : 10, \"end_offset\" : 11, \"type\" : \"CN_CHAR\", \"position\" : 6 }, { \"token\" : \"呢\", \"start_offset\" : 11, \"end_offset\" : 12, \"type\" : \"CN_CHAR\", \"position\" : 7 } ]}","link":"/2020/08/29/ES/ElasticSearchStart/"},{"title":"Redis入门","text":"1、NoSQL概述1.1 为什么要用NoSQL 大数据时代，分布式集群，单机—&gt;分布式 单机MySQL的时代 应用不是直接访问MySQL，会通过一些方法，DAL（数据访问层，Data Access Layer）去访问MySQL实例。以前不同SQL对应不同语法，麻烦，出现了框架Hibernate和MyBatis等框架，开发变得简单，框架底层值得学习。 90年代，一个基本的的网站访问量不会太大，单个数据库完全足够！ 那个时候更多的去使用静态网页Html，服务器根本没有太大压力！ 思考一下，这种情况下：整个网站的瓶颈是什么？ 数据量太大，一个机器放不下！ 数据的索引，比如如果MySQL的数据超300万，不建立索引太慢！MySQL使用B+Tree，索引机器也放不下！ 访问量（读写混合），一个服务器承受不来！ 只要出现以上3种情况之一，就要晋级！ Memcached（缓存）+MySQL+垂直拆分（读写分离） 网站80%的情况都在读，每次都要去查询数据库的话时分麻烦，所以说我们希望减轻服务器压力，可以使用缓存来保持效率！ 发展过程：优化数据结构和索引-&gt;文件索引（IO）-&gt;Memcached（当时最热门的技术） 分库分表+水平拆分+MySQL集群 技术和业务在发展的同时，对人的要求也越来越高了！ 数据库本质：读写 早些年MyISAM（默认存储引擎）：表锁，十分影响效率！高并发下就会出现严重的锁问题； 转战Innodb：行锁 慢慢的开始使用分库分表来解决写的压力！多服务多表MySQL在那个年代推出了表分区！但并没有多少公司使用。MySQL的集群，很好满足那个年代需求。","link":"/2020/09/02/Redis/NoSQL/"},{"title":"Java多线程","text":"创建线程的主要方式 继承Thread类创建线程类（重点） 实现Runnable接口创建线程类（重点） 实现Callable接口或Future接口创建线程（了解） 1、前言关于学习Java多线程，其中程序，进程和线程等重要概念及其关系在这里就不多赘述，之前操作系统也详细讲过，我就不再详细扩展，直接进入Java线程的学习吧！ 此处分享一下Java1.8帮助文档（中文版），提取码: k26d 2、Thread类2.1 Thread类实现Runnable接口源码： 1234567891011121314151617publicclass Thread implements Runnable { /* Make sure registerNatives is the first thing &lt;clinit&gt; does. */ private static native void registerNatives(); static { registerNatives(); } private volatile String name; private int priority; private Thread threadQ; private long eetop; /* Whether or not to single_step this thread. */ private boolean single_step; ...} 2.2 创建步骤：将一个类声明为Thread的子类。 这个子类应该重写Thread类的run方法 。 然后可以分配并启动子类的实例 自定义线程类继承Thread类 重写run()方法，编写线程执行体 创建线程对象，调用start()方法启动线程 2.2.1 测试123456789101112131415161718192021222324public class Thread1 extends Thread { @Override public void run() { // run方法线程体 for (int i = 0; i &lt; 20; i++) { System.out.print(String.format(\"%-3d\", i) + \"Hello \"); } } public static void main(String[] args) { // main方法主线程 // 创建一个线程对象 Thread1 thread1 = new Thread1(); // 调用start方法开启线程 thread1.start(); for (int i = 0; i &lt; 800; i++) { System.err.print(String.format(\"%-3d\", i) + \"World \"); } }} 查看控制台输出： 注意：线程开启不一定立即执行，由CPU调度执行 调用start方法，是线程同时执行，交替执行。如果调用run方法，就是顺序执行。 2.2.2 案例：实现多线程同步下载图片APACHE官网下载commons-io，导入项目Library 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Thread2 extends Thread { private String url; // Picture url private String path; private String name; // Saved file name public Thread2(String url, String path, String name) { super(); this.url = url; this.path = path; this.name = name; } @Override public void run() { WebDownloader webDownloader = new WebDownloader(); webDownloader.downloader(url, path, name); System.out.println(\"Downloaded the file which name is \" + name); } public static void main(String[] args) { String path = \"src/com/newthread/img/\"; Thread2 t1 = new Thread2( \"https://wx1.sinaimg.cn/orj360/67e231a6ly1geq8okovekj21hc0u0e42.jpg\", path, \"tower.jpg\"); Thread2 t2 = new Thread2( \"https://wx1.sinaimg.cn/orj360/67e231a6ly1geq8oq8jx1j21hc0u0qse.jpg\", path, \"bike.jpg\"); Thread2 t3 = new Thread2( \"https://wx1.sinaimg.cn/orj360/67e231a6ly1geq8on2u4gj21hc0u0ngj.jpg\", path, \"bridge.jpg\"); // simultaneous execution t1.start(); t2.start(); t3.start(); }}// downloaderclass WebDownloader{ // download function public void downloader(String url, String path,String name) { try { FileUtils.copyURLToFile(new URL(url), new File(path + name)); } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); System.err.println(\"IO Exception...downloader function has a problem!\"); } }} 结果： 3、Runnable接口3.1 Runnable接口声明实现类Runnable接口。 那个类然后实现了run方法。 然后可以分配类的实例，在创建Thread时作为参数传递，并启动。 源码： 123456789101112131415publicclass Thread implements Runnable { /* Make sure registerNatives is the first thing &lt;clinit&gt; does. */ private static native void registerNatives(); static { registerNatives(); } ... public Thread(Runnable target) { init(null, target, \"Thread-\" + nextThreadNum(), 0); } ...} 实现Runnable接口创建的线程，不能通过run或start方法来启动。在Thread类中有一个构造器，这个构造器接收一个Runnable接口的实现类对象，构造Thread线程类对象，然后使用这个线程类对象调用start方法启动我们的线程。 3.2 创建步骤 自定义线程类实现Runnable接口 实现run()方法，编写线程执行体 创建线程对象，调用start()方法启动线程 推荐使用Runnable对象，因为Java单继承的局限性 12345678910111213141516171819202122232425public class Thread3 implements Runnable { @Override public void run() { // run方法线程体 for (int i = 0; i &lt; 20; i++) { System.out.print(String.format(\"%-3d\", i) + \"Hello \"); } } public static void main(String[] args) { // main方法主线程 // 创建Runnable接口的实现类对象 Thread3 thread3 = new Thread3(); // Thread thread = new Thread(thread3);// thread.start(); new Thread(thread3).start(); for (int i = 0; i &lt; 800; i++) { System.err.print(String.format(\"%-3d\", i) + \"World \"); } }} 3.3 对比 继承Thread类 子类继承Thread类具有多线程能力 启动线程：子类对象.start() 不建议使用：避免OOP单继承局限 实现Runnable接口 子类实现Runnable接口具有多线程能力 启动线程：传入目标对象+Thread对象.start() 推荐使用：避免单继承局限性，灵活方便，方便同一对象被多个线程使用 4、Callable接口（了解即可）4.1 源码：12345678910@FunctionalInterfacepublic interface Callable&lt;V&gt; { /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;} 从源码可以看出，Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。 这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务。 4.2 创建步骤 实现Callable接口，需要返回值类型 重写call方法，需要抛出异常 创建目标对象 创建执行服务：ExecutorService ser = Executors.newFixedThreadPool(1); 提交执行：Future&lt; Boolean&gt; result1 = ser.submit(1); 获取结果：boolean r1= result1.get(); 关闭服务：ser.shutdownNow(); 123456789101112131415161718192021222324252627282930313233343536public class Callable1 implements Callable&lt;Boolean&gt;{ @Override public Boolean call() throws Exception { for (int i = 0; i &lt; 20; i++) { System.out.println(String.format(\"%-3d\", i) + Thread.currentThread().getName()); } return true; } public static void main(String[] args) throws InterruptedException, ExecutionException { Callable1 callable1 = new Callable1(); Callable1 callable2 = new Callable1(); Callable1 callable3 = new Callable1(); // 创建执行服务 ExecutorService ser = Executors.newFixedThreadPool(3); // 提交执行 Future&lt;Boolean&gt; result1 = ser.submit(callable1); Future&lt;Boolean&gt; result2 = ser.submit(callable2); Future&lt;Boolean&gt; result3 = ser.submit(callable3); // 获取结果 boolean r1= result1.get(); boolean r2= result2.get(); boolean r3= result3.get(); System.out.println(r1 + \" \"+ r2 + \" \" + r3); // 关闭服务 ser.shutdownNow(); }} 5、静态代理模式5.1 内容真实角色，代理角色；真实角色和代理角色要实现同一个接口，代理角色要持有真实角色的引用。 在Java中线程的设计使用了静态代理设计模式，其中自定义线程类实现Runable接口，Thread类也实现了Runalbe接口，在创建子线程的时候，传入了自定义线程类的引用，再通过调用start()方法，调用自定义线程对象的run()方法。实现了线程的并发执行。 Thread对象调用线程的start()方法，在内部调用了真实角色的run()方法。 5.2 设计代码结构由三部分组成 接口：主题 代理类 被代理类 实现方式：代理类和被代理类要实现同一个主题接口，而且代理类中要有一个被代理类的属性（target），这样才能把核心业务逻辑交还给被代理类完成；而一些与核心业务逻辑无关的逻辑，并且需求是多变的，那么这些逻辑就可以交给代理类来完成。 代理对象可以做很多真实对象做不了的事情，真实对象专注做自己的事情 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class StaticProxy { public static void main(String[] args) { SpringPioneer springPioneer = new SpringPioneer(new Programmer()); springPioneer.Deploy(); }}interface SpringBootFrame { // 接口主题：框架整合部署 void Deploy();}// 真实角色，程序员class Programmer implements SpringBootFrame{ @Override public void Deploy() { System.out.println(\"Programmer SpringBoot deployed successfully!\"); }}// 代理角色，SpringBoot的作者，帮我们简化开发class SpringPioneer implements SpringBootFrame{ // 代理谁--&gt;真实目标角色 private SpringBootFrame target; public SpringPioneer(SpringBootFrame target) { this.target = target; } @Override public void Deploy() { before(); this.target.Deploy(); // 这就是真实对象 after(); } private void before() { System.out.println(\"研发出这个SpringBoot框架，并开源。\"); } private void after() { System.out.println(\"不断推出新的特性。\"); }} 6、Lambda表达式函数式编程的概念 6.1 为什么要使用lambda表达式？避免匿名内部类定义过多，代码简洁，去掉无意义代码，核心逻辑。 理解Functional Interface（函数式接口）是学习Java8 lambda表达式的关键。 函数式接口的定义：任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口。 123public interface Runnable { public abstract void run();} 对于函数式接口，我们可以通过lambda表达式来创建接口的对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class lambda1 { // 3.静态内部类 static class StaticEntityLike implements Like { @Override public void lambda() { System.out.println(\"Static likes lambda!\"); } } public static void main(String[] args) { Like entityLike = new EntityLike(); entityLike.lambda(); Like staticEntityLike = new StaticEntityLike(); staticEntityLike.lambda(); // 4.局部内部类 class InternalEntityLike implements Like { @Override public void lambda() { System.out.println(\"Internal likes lambda!\"); } } Like internalEntityLike = new InternalEntityLike(); internalEntityLike.lambda(); // 5.匿名内部类，没有类的名称，必须借助接口或者父类 Like anonymousEntityLike = new Like() { @Override public void lambda() { System.out.println(\"Anonymous likes lambda!\"); } }; anonymousEntityLike.lambda(); // 6.用lambda简化 Like lambdaLike = () -&gt; { System.out.println(\"Lambda likes lambda!\"); }; lambdaLike.lambda();// new Like(()-&gt;System.out.println(\"Lambda likes lambda!\")).lambda(); // 7.带参数的 Love lambdaLove = (int t) -&gt; { System.out.println(\"Lambda loves you \" + t + \" times!\"); }; lambdaLove.time(520); // 7.1简化去掉参数类型 Love love1 = (t) -&gt; { System.out.println(\"Lambda loves you \" + t + \" times!\"); }; love1.time(521); // 7.2简化去掉括号 Love love2 = t -&gt; { System.out.println(\"Lambda loves you \" + t + \" times!\"); }; love2.time(522); // 7.3简化去掉花括号 // lambda表达式只能有一行代码的情况下才能简化成为一行，如果有多行，那么就用代码块包裹 Love love3 = t -&gt; System.out.println(\"Lambda loves you \" + t + \" times!\"); love3.time(523); }}// 1.定义一个函数式接口interface Like { void lambda();}// 2.实现类class EntityLike implements Like { @Override public void lambda() { System.out.println(\"I like lambda!\"); }}// 带参数的interface Love { void time(int t);} 多个参数可以去掉参数类型，再简化就必须加上括号(a, b)-&gt;{}; 7、线程7.1 线程状态 创建状态（new）：Thread t = new Thread();，线程对象一旦创建，就进入到了新生状态。 就绪状态：当调用start()方法，线程立即进入就绪状态，但不意味着立即调度执行。 运行状态：CPU调度进入运行状态线程才真正执行线程体的代码块。 阻塞状态：当调用sleep()，wait()或同步锁定时，线程进入阻塞状态就是代码不往下执行，阻塞事件解除后，重新进入就绪状态，等待cpu调度执行。 死亡状态（dead）：线程中断或者结束，一旦进入死亡状态，就不能再次启动。 7.2 线程方法 方法 说明 setPriority(int newPriority) 设置当前线程的优先级 static void sleep(long millis) 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）。休眠的线程进入阻塞状态。 void join() 调用join方法的线程强制执行，其他线程处于阻塞状态，等该线程执行完后，其他线程再执行。有可能被外界中断产生InterruptedException中断异常。 static void yield() 调用yield方法的线程，（暂停当前执行的线程对象）会礼让其他线程先运行。（大概率其他线程先运行，小概率自己还会运行） void interrupt() 中断线程，不建议使用 boolean isAlive() 判断线程是否处于活动状态 （线程调用start后，即处于活动状态） 7.3 停止线程 不推荐使用JDK提供的stop()和destroy()方法。（已废弃） 12345678910111213141516171819202122232425262728publicclass Thread implements Runnable { ... @Deprecated public final void stop() { SecurityManager security = System.getSecurityManager(); if (security != null) { checkAccess(); if (this != Thread.currentThread()) { security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION); } } // A zero status value corresponds to \"NEW\", it can't change to // not-NEW because we hold the lock. if (threadStatus != 0) { resume(); // Wake up thread if it was suspended; no-op otherwise } // The VM can handle all thread states stop0(new ThreadDeath()); } ... @Deprecated public void destroy() { throw new NoSuchMethodError(); } ...} 推荐线程自己停止下来，建议使用一个标志位进行终止变量当flag=false，则终止线程运行。 12345678910111213141516171819202122232425262728293031public class TestStop implements Runnable { // 1.设置一个标志位 private boolean flag = true; @Override public void run() { int i=0; while (flag) { System.out.println(\"run...Thread...\"+i++); } } // 2.设置一个公开的方法停止线程，转换标志位 public void stop() { this.flag = false; } public static void main(String[] args) { TestStop testStop = new TestStop(); new Thread(testStop).start(); for (int i = 0; i &lt; 200; i++) { System.out.println(\"main...Thread...\"+i); if(i==100) { // 调用stop方法停止线程 testStop.stop(); System.out.println(\"run...Thread...stoped...\"); } } }} 结果：线程停止，main线程继续执行到结束 7.4 线程休眠 sleep(时间)指定当前线程阻塞的毫秒数；sleep存在异常Interrupted Exception；sleep时间达到后线程进入就绪状态；sleep可以模拟网络延时，倒计时等；每一个对象都有一个锁，sleep不会释放锁。 示例： 123456789101112131415161718192021222324252627282930313233343536// 模拟倒计时public class TestSleep2 { public static void main(String[] args) { try { tenDown(); } catch (InterruptedException e) { e.printStackTrace(); } // 打印当前系统时间 Date startTime = new Date(System.currentTimeMillis()); // 获取当前系统时间 System.out.println(\"Start printing system time...\"); while (true) { try { Thread.sleep(1000); System.out.println(new SimpleDateFormat(\"HH:mm:ss\").format(startTime)); startTime = new Date(System.currentTimeMillis()); // 更新时间 } catch (InterruptedException e) { e.printStackTrace(); } } } public static void tenDown() throws InterruptedException { int num=10; while (true) { Thread.sleep(1000); System.out.println(num--); if (num&lt;=0) { break; } } }} 7.4 线程礼让礼让线程，让当前正在执行的线程暂停，但不阻塞；将线程从运行状态转为就绪状态；让cpu重新调度，礼让不一定成功！看CPU心情。 示例： 1234567891011121314151617public class TestYield { public static void main(String[] args) { MyYield myYield = new MyYield(); new Thread(myYield, \"a\").start(); new Thread(myYield, \"b\").start(); }}class MyYield implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()+\"Thread starts...\"); Thread.yield(); // 礼让 System.out.println(Thread.currentThread().getName()+\"Thread ends...\"); }} 7.5 线程强制执行 join()合并程序，待此线程执行完成后，再执行其他线程，其他线程阻塞。可以想象为插队。 示例： 1234567891011121314151617181920212223242526public class TestJoin implements Runnable { @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(\"VIP thread comes...\"+i); } } public static void main(String[] args) { TestJoin testJoin = new TestJoin(); Thread thisThread = new Thread(testJoin); thisThread.start(); for (int i = 0; i &lt; 200; i++) { if (i==90) { try { thisThread.join(); // 插队 } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"main Thread...\"+i); } }} 取一个运行结果： 12345678910111213141516171819202122232425main Thread...0VIP thread comes...0main Thread...1VIP thread comes...1VIP thread comes...2VIP thread comes...3VIP thread comes...4VIP thread comes...5...main Thread...87main Thread...88main Thread...89VIP thread comes...19VIP thread comes...20VIP thread comes...21VIP thread comes...22VIP thread comes...23VIP thread comes...24...VIP thread comes...98VIP thread comes...99main Thread...90main Thread...91main Thread...92main Thread...93 在插队之前，2线程并行，当调用join()后，这个线程即成为VIP，只能等VIP线程执行结束，其他线程才能继续执行。 7.6 线程状态线程状态State是枚举类型，有5个状态，在中文帮助文档中有声明。 Thread.java源码： 12345678910111213141516171819202122publicclass Thread implements Runnable { ... public enum State { NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED; } public State getState() { return sun.misc.VM.toThreadState(threadStatus); } ...} 示例： 123456789101112131415161718192021222324252627282930public class TestState { public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(()-&gt;{ for (int i = 0; i &lt; 5; i++) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"\\\\\\\\\\\\\"); }); // 观察状态 Thread.State state = thread.getState(); System.out.println(state); // NEW // 启动 thread.start(); state = thread.getState(); System.out.println(state); // RUN while (state != Thread.State.TERMINATED) { // 只要线程不终止就一直输出状态 Thread.sleep(100); state = thread.getState(); // 更新状态 System.out.println(state); } }} 7.7 线程优先级 Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行；线程的优先级用数字表示，范围从1-10。 Thread.java源码： 123456789101112131415161718192021222324publicclass Thread implements Runnable { ... public final static int MIN_PRIORITY = 1; public final static int NORM_PRIORITY = 5; public final static int MAX_PRIORITY = 10; ... public final void setPriority(int newPriority) { ThreadGroup g; checkAccess(); if (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) { throw new IllegalArgumentException(); } if((g = getThreadGroup()) != null) { if (newPriority &gt; g.getMaxPriority()) { newPriority = g.getMaxPriority(); } setPriority0(priority = newPriority); } } ...} 优先级低只是意味着获得调度的概率低，并不是优先级低就不会被调用了，这都是看CPU的调度。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class TestPriority { public static void main(String[] args) { // 主线程默认优先级 System.out.println( Thread.currentThread().getName() + \"--&gt;\"+Thread.currentThread().getPriority() ); MyPriority myPriority = new MyPriority(); Thread t1 = new Thread(myPriority); Thread t2 = new Thread(myPriority); Thread t3 = new Thread(myPriority); Thread t4 = new Thread(myPriority); Thread t5 = new Thread(myPriority); t1.start(); t2.setPriority(2); // 先设置优先级再启动 t2.start(); t3.setPriority(Thread.MAX_PRIORITY); t3.start(); try { t4.setPriority(-1); t4.start(); t5.setPriority(11); t5.start(); } catch (Exception e) { System.err.println(e); } }}class MyPriority implements Runnable { @Override public void run() { System.out.println( Thread.currentThread().getName()+\"--&gt;\" + Thread.currentThread().getPriority() ); }} 取一个运行结果： 12345main--&gt;5java.lang.IllegalArgumentExceptionThread-0--&gt;5Thread-2--&gt;10Thread-1--&gt;2 总是主线程mian限制性，优先级低的也可能比高的优先执行。 7.8 守护（daemon）线程 线程分为用户线程和守护线程；虚拟机必须确保用户线程（main线程）执行完毕；虚拟机不用等待守护线程执行完毕；如后台记录操作日志，监控内存垃圾回收等。 示例： 1234567891011121314151617181920212223242526272829303132public class TestDaemon { public static void main(String[] args) { God god = new God(); Man man = new Man(); Thread thread = new Thread(god); thread.setDaemon(true); // 默认false表示用户线程，正常的线程都是用户线程 thread.start(); // 守护线程启动 new Thread(man).start(); // 用户线程挺停止 }}class God implements Runnable { @Override public void run() { while (true) { System.out.println(\"God bless you!\"); } }}class Man implements Runnable { @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(\"Hello World!\"); } System.err.println(\"Goodbye World!\"); }} 看似god线程会一直循环执行下去，但它是守护线程，man线程执行结束后，守护线程等一会也会结束，因为虚拟机还会运行一会儿。 8、线程同步多个线程操作同一个资源。 并发：同一个对象被多个线程同时操作。 处理多线程问题时，多个线程访问同—个对象，并且某些线程还想修改这个对象，这时候我们就需要线程同步。线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程再使用。 8.1 队列和锁由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制synchronized，当一个线程获得对象的排它锁（锁是对象的），将会独占资源。其他线程必须等待这个线程使用后释放锁即可。存在以下问题： 一个线程持有锁会导致其他所有需要此锁的线程挂起 在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能问题 8.2 同步方法 由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是synchronized关键字，它包括两种用法synchronized方法和synchronized块 同步方法: public synchronized void method(int args) synchronized方法控制对“对象“的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行 缺陷：若将一个大的方法申明为 synchronized将会影响效率 弊端：需要锁太多，浪费资源 8.3 同步块 同步块：synchronized(obj){} obj称之为同步监视器 obj可以是任何对象，但是推荐使用共享资源作为同步监视器 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class[反射中讲解] 同步监视器的执行过程 第一个线程访问，锁定同步监视器，执行其中代码 第二个线程访问，发现同步监视器被锁定，无法访问 第一个线程访问完毕，解锁同步监视器 第二个线程访问，发现同步监视器没有锁，然后锁定并访问 案例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class Bank { public static void main(String[] args) { Account account = new Account(100, \"Deposit\"); Drawing husband = new Drawing(account, 50, \"husband\"); Drawing wife = new Drawing(account, 100, \"wife\"); husband.start(); wife.start(); }}class Account { int money; String name; public Account(int money, String name) { this.money = money; this.name = name; }}class Drawing extends Thread { Account account; int drawingMoney; int nowMoney; public Drawing(Account account, int drawingMoney, String name) { super(name); this.account = account; this.drawingMoney = drawingMoney; } // @Override // public synchronized void run() { // if(account.money-drawingMoney&lt;0) { // System.out.println(Thread.currentThread().getName()+\" Money is not enough!\"); // return; // } // try { // Thread.sleep(1000); // } catch (InterruptedException e) { // e.printStackTrace(); // } // // 卡内余额 // account.money = account.money - drawingMoney; // // 手里的现金 // nowMoney = nowMoney + drawingMoney; // System.out.println(account.name + \" balance is \"+account.money); // System.out.println(this.getName()+\"'s cash now is \"+nowMoney); // } @Override public void run() { synchronized (account) { if(account.money-drawingMoney&lt;0) { System.out.println(Thread.currentThread().getName()+\" Money is not enough!\"); return; } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } account.money = account.money - drawingMoney; nowMoney = nowMoney + drawingMoney; System.out.println(account.name + \" balance is \"+account.money); System.out.println(this.getName()+\"'s cash now is \"+nowMoney); } }} 这里要注意了：同步块指定锁住的对象，可以锁住任何对象。如果用上面的方法将run方法上锁，锁住的是husband和wife对象，也就是有两把锁了（2个线程2把锁）。只能用下面的方法锁住变化的量，才有用。 List等常见数据集合是非安全的，JUC(java.util.concurrent包)中提供了CopyOnWriteArrayList等安全类型的集合。 9、锁9.1 死锁 多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。某一个同步块同时拥有“两个以上对象的锁”时，就可能会发生“死锁”的问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class DeadLock { public static void main(String[] args) { Makeup girl1 = new Makeup(0, \"Marry\"); Makeup girl2 = new Makeup(1, \"Lisa\"); girl1.start(); girl2.start(); }}class Lipstick{}class Mirror {}class Makeup extends Thread { // 用static保证资源只有一份儿 private static Lipstick lipstick = new Lipstick(); private static Mirror mirror = new Mirror(); int choice; String name; // 化妆的人 public Makeup(int choice, String name) { this.choice = choice; this.name = name; } @Override public void run() { try { startMakeup(); } catch (InterruptedException e) { e.printStackTrace(); } } // 化妆，互相持有对方的锁，就是需要拿到对方的资源 // private void startMakeup() throws InterruptedException { // if (choice==0) { // synchronized (lipstick) { // 获得口红的锁 // System.out.println(this.name+\" got the lipstick!\"); // Thread.sleep(1000); // synchronized (mirror) { // 1秒钟后向获得镜子 // System.out.println(this.name+\" got the mirror!\"); // } // } // } else { // synchronized (mirror) { // System.out.println(this.name+\" got the mirror!\"); // Thread.sleep(1000); // synchronized (lipstick) { // System.out.println(this.name+\" got the lipstick!\"); // } // } // } // // 比如选择0时，只有当得到镜子后才会释放口红的锁，就会死锁 // } private void startMakeup() throws InterruptedException { if (choice==0) { synchronized (lipstick) { // 获得口红的锁 System.out.println(this.name+\" got the lipstick!\"); Thread.sleep(1000); } synchronized (mirror) { // 1秒钟后向获得镜子 System.out.println(this.name+\" got the mirror!\"); } } else { synchronized (mirror) { System.out.println(this.name+\" got the mirror!\"); Thread.sleep(1000); } synchronized (lipstick) { System.out.println(this.name+\" got the lipstick!\"); } } // 这样做就是当口红用完口红的锁就释放 }} 结合操作系统死锁产生的条件和避免死锁的方式。 9.2 Lock（锁） 从JDK5.0开始，Java提供了更强大的线程同步机制：通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当 java.utll.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问,毎次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象 ReentrantLock（可重入锁）类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是Reentrantlock，可以显式加锁、释放锁。 9.3 synchronized和Lock的对比 Lock是显式锁（手动开启和关闭锁，别忘记关闭锁）synchronized是隐式锁，出了作用域自动释放 Lock只有代码块锁，synchronized有代码块锁和方法锁 使用Lock锁，JwM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类） 优先使用顺序：Lock &gt; 同步代码块（已经进入了方法体，分配了相应资源） &gt; 同步方法（在方法体之外） 10、线程协作（线程通信） 在生产者消费者问题中，仅有synchronized是不够的 synchronized可阻止并发更新同一个共享资源，实现了同步 synchronized不能用来实现不同线程之间的消息传递（通信） Java提供了几个方法解决线程之间的通信问题 方法名 作用 wait() 表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁 wait(long timeout) 指定等待的毫秒数 notify() 唤醒一个处于等待状态的线程 notifyAll() 唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度 注意：均是Object类的方法，都只能在同步方法或者同步代码块中使用否则会抛出异常IlegalMonitorState Exception 10.1 解决方式1：管程法并发协作模型“生产者/消费者模式”—&gt;管程法 生产者：负责生产数据的模块(可能是方法，对象，线程，进程) 消费者：负责处理数据的模块(可能是方法，对象，线程，进程) 缓冲区：消费者不能直接使用生产者的数据，他们之间有个“缓冲区“ 生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public class TestProductorCustomer { public static void main(String[] args) { Buffer buffer = new Buffer(); new Productor(buffer).start(); new Customer(buffer).start(); }}// 生产者class Productor extends Thread { // 需要一个容器 Buffer buffer; public Productor(Buffer buffer) { this.buffer = buffer; } // 生产 @Override public void run() { for (int i = 1; i &lt; 100; i++) { buffer.push(new Goods(i)); System.out.println(\"生产了第\"+i+\"个商品！\"); } }}// 消费者class Customer extends Thread { Buffer buffer; public Customer(Buffer buffer) { this.buffer = buffer; } // 消费 @Override public void run() { for (int i = 1; i &lt; 100; i++) { System.out.println(\"消费了第\" + buffer.pop().getID() + \"个商品！\"); } }}// 产品class Goods extends Thread { private int ID; public Goods(int id) { this.ID = id; } public int getID() { return ID; }}// 缓冲区class Buffer extends Thread { // 需要一个容器大小 Goods[] goods = new Goods[10]; int count=0; // 生产者放入产品 public synchronized void push(Goods good) { // 如果容器满了，就需要等待消费者消费 if(count==goods.length) { // 通知消费者消费，生产等待 try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } // 如果没有满就需要放入产品 goods[count] = good; count++; // 可以通知消费者消费了 this.notifyAll(); } // 消费者消费产品 public synchronized Goods pop() { // 如果容器是否为空 if(count==0) { // 通知生产者生产，消费等待 try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } // 如果可以消费 count--; Goods good = goods[count]; // 可以通知生产者生产了 this.notifyAll(); return good; }} 10.2 解决方式2：信号灯法就是长度为1的管程法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class ProductorCustomerUsingSignal { public static void main(String[] args) { Show show = new Show(); new Actor(show).start(); new Audience(show).start(); }}// 生产者演员class Actor extends Thread { private Show show; public Actor(Show show) { this.show = show; } @Override public void run() { for (int i = 0; i &lt; 20; i++) { if (i%2==0) { this.show.play(\"Happy Camp!\"); } else { this.show.play(\"TikTok!\"); } } }}// 消费者观众class Audience extends Thread { private Show show; public Audience(Show show) { this.show = show; } @Override public void run() { for (int i = 0; i &lt; 20; i++) { this.show.watch(); } }}// 资源节目class Show { // 演员表演，观众等待 T // 观众观看，演员等待 F private boolean flag = true; String display; // 表演的节目 // 表演 public synchronized void play(String display) { if (!flag) { try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"Actors show the \"+display); // 通知观众观看 this.notifyAll(); this.display = display; this.flag = !this.flag; } // 表演 public synchronized void watch() { if (flag) { try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"Audience watch the \"+display); // 通知演员表演 this.notifyAll(); this.flag = !this.flag; }} 11、线程池 背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具（共享单车）。 优势： 提高响应速度（减少了创建新线程的时间） 降低资源消耗（重复利用线程池中线程，不需要每次都创建） 便于线程管理（…） core Poolsize：核心池的大小 maximumPoolsize：最大线程数 keepAlive Time：线程没有任务时最多保持多长时间后会终止 123456789101112131415161718192021public class TestPool { public static void main(String[] args) { // 1.创建服务，创建线程池 ExecutorService executorService = Executors.newFixedThreadPool(10); executorService.execute(new PoolThread()); executorService.execute(new PoolThread()); executorService.execute(new PoolThread()); executorService.execute(new PoolThread()); // 2.关闭连接 executorService.shutdown(); }}class PoolThread implements Runnable { @Override public void run() { System.out.println(Thread.currentThread().getName()); }} JDK5.0起提供了线程池相关API：Executor Service和Executors Executor Service：真正的线程池接口。常见子类 ThreadPoolExecutor void execute( Runnable command)：执行任务命令，没有返回值，一般用来执行 Runnable &lt;T&gt; Future&lt;T&gt; submit( Callable&lt;T&gt;task)：执行任务，有返回值，一般又来执行Callable（上面我们介绍Callable接口时测试过） void shutdown()：关闭连接池 Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池","link":"/2020/09/05/Java/Thread/"},{"title":"管理GitHub个人资料README","text":"管理您的个人资料README 最近看到一个Github主页添加个人资料，觉得挺不错，就想着也弄一个，就像下图一样，其实并不麻烦。 GitHub提供了这样的服务，官方文档，我也是在官方文档找到的详细教程。以下大多都是翻译版，还有一些个人建议和踩坑经验，我挑出其中最重要的部分分享。 关于您的个人资料README您可以将自述文件添加到您的GitHub个人资料中，以向其他人介绍您自己。 您可以通过创建个人资料README与GitHub社区上有关您自己的信息。 GitHub在个人资料页面顶部显示您的个人资料README。 您可以决定在个人资料README中包含哪些信息，因此可以完全控制自己在GitHub上的展示方式。以下是一些访问者在您的个人资料README中可能发现有趣，有趣或有用的信息示例。 “关于我”部分描述了您的工作和兴趣 您引以为豪的贡献以及这些贡献的背景 在您所参与的社区中获得帮助的指南 您可以使用GitHub Flavored Markdown设置文本格式，并在个人资料README中包含表情符号，图像和GIF。有关更多信息，请参阅“在GitHub上编写和格式化入门”。 先决条件如果满足以下所有条件，则GitHub将在您的个人资料页面上显示您的个人资料README。 您已经创建了一个名称与您的GitHub用户名相匹配的存储库。 该存储库是公共（Public）的。 存储库的根目录中包含一个名为README.md的文件（初始化创建即可，不需要克隆到本地）。 README.md文件包含任何内容。 当你创建仓库的时候，将仓库名命名为mysticalguest，下面就会出现提示： 您发现了一个秘密！ MysticalGuest / MysticalGuest是一个“特殊”存储库，可用于将README.md添加到您的GitHub个人资料中。确保它是公开的，并使用自述文件对其进行初始化以开始使用。 其他仓库不会出现这样的提示。说明是成功的。 注意：如果您在2020年7月之前创建了一个与用户名相同名称的公共存储库，则GitHub不会在您的个人资料上自动显示该存储库的自述文件。您可以通过转到GitHub.com上的存储库并单击“共享到配置文件”，手动将存储库的自述文件共享到您的配置文件。（这个不用管了，因为7月之后很方便，一旦仓库创建成功，GitHub个人主页就会显示了！） 下面就开始在线编辑这个仓库下的README.md文件即可： 编辑GitHub提供了强大的在线编辑器，还可以预览。我的编辑： 12345678910111213141516171819202122232425### Welcome！👋 + **My Github Blog.[https://mysticalguest.github.io](https://mysticalguest.github.io/)**+ **My Gitee Blog.[https://mysteryguest.gitee.io](https://mysteryguest.gitee.io/)**+ **My CSDN Blog.[https://blog.csdn.net/etherealsymbol](https://blog.csdn.net/etherealsymbol/)**+ **My CNBlogs Blog.[https://www.cnblogs.com/mysteryguest](https://www.cnblogs.com/mysteryguest/)**- 🔭 I’m currently working on java source code...- 🌱 I’m currently learning Java, MySQL, Spring, Redis, Elasticsearch...- 📫 How to reach me: mysticalguest@163.com&lt;!--**MysticalGuest/mysticalguest** is a ✨ _special_ ✨ repository because its `README.md` (this file) appears on your GitHub profile.Here are some ideas to get you started:- 🔭 I’m currently working on ...- 🌱 I’m currently learning ...- 👯 I’m looking to collaborate on ...- 🤔 I’m looking for help with ...- 💬 Ask me about ...- 📫 How to reach me: ...- 😄 Pronouns: ...- ⚡ Fun fact: ...--&gt; 编辑完成Commit Changes即可，刷新主页。 成功，就是这么简单！ 删除个人资料README如果满足以下任何条件，则从您的GitHub个人资料中删除个人资料README： 自述文件为空或不存在。 该存储库是私有的。 存储库名称不再与您的用户名匹配。 选择的方法取决于您的需求，但是如果不确定，我们建议将存储库设为私有。 有关如何将存储库设为私有的步骤，请参阅“更改存储库的可见性”。","link":"/2020/09/13/Github/Profile/"},{"title":"华为面经","text":"收到面试邀约后该怎么做？我参考了尚硅谷雷老师的博客，他的B站ID是“黎曼的猜想”。通过他的经验的指导，并结合我的面试实际情况，为面试准备了许多说辞。 面试前准备当收到面试通知后，通过如下准备可以大大提升面试成功率。 知己知彼，百战不殆。即使侥幸面试成，亦可防止压工资。 其实公司肯花时间让你去面试，前提条件一定是通过了你的简历，一定发现你和公司的匹配点，也就是说，一定是有录用意向的。 在技术面试的时间段里（最长1个小时，并且可能有多伦技面），尽可能地展现优势。 至于通过技术面试后，业务主管、项目经理或人事的面试一般是过滤特别差的，比如考察团队协作能力和沟通表达能力等，这对大家来说应该都不是问题。 敲重点！ 至少定出2天的准备时间 一定要再次阅读公司的职位要求 就类似于考试，一定是先审题嘛，然后再做相应的准备。 比如，我报的西安华为21届秋季校招，第一意向部门传送与接入产品线，第二意向部门云核心网产品线，领域都是通用软件开发工程师。 岗位职责 在这里，你将从事IT应用层软件、分布式云化软件、互联网软件等的设计开发，可以采用敏捷、Devops、开源等先进的软件设计开发模式，接触最前沿的产品和软件技术，成为大容量高并发技术的专家；你将参与华为产品的软件研发工作，包括但不限于：（1）完成从客户需求到软件产品定义、架构设计、开发实现、再到上线运营维护等产品生命周期中的各个环节；（2）创造性解决产品在实现过程中的技术难题，应用前沿技术提升产品的核心竞争力，如分布式系统、性能调优、可靠性、数据库等；（3）有机会参与业界前沿技术研究和规划，参与开源社区运作，与全球专家一起工作、交流，构建华为在业界影响力。 岗位要求 1、计算机、软件、通信等相关专业本科及以上学历；2、热爱编程，基础扎实，熟悉掌握但不限于JAVA/C++/C/Python/JS/HTML/GO等编程语言中的一种或数种，有良好的编程习惯；3、具备独立工作能力和解决问题的能力、善于沟通，乐于合作，热衷新技术，善于总结分享，喜欢动手实践；4、对数据结构、算法有一定了解；5、优选条件：（1）熟悉TCP/IP协议及互联网常见应用和协议的原理；（2）有IT应用软件、互联网软件、IOS/安卓等相关产品开发经验，不满足于课堂所学，在校期间积极参加校内外软件编程大赛或积极参于编程开源社区组织；（3）熟悉JS/AS/AJAX/HTML5/CSS等前端开发技术。 能从中挖掘出如下的技能需求点： 专业性要求： 基础扎实 熟悉TCP/IP协议及互联网常见应用和协议的原理 编程大赛 其实在投简历前，就可以根据不同公司的不同要求对简历进行微调，这样获得该岗位的面试机会更大。 准备项目描述的说辞面试环节中的项目介绍必要环节 这里介绍些项目描述的要点： 业务需求一笔带过，项目背景，工期人数等寥寥几句，面试官不关心的。就可以这样介绍： 大二在软通动力实训的过程中接触了SpringBoot，由于我家有个亲戚开了个私人宾馆，就萌生了开发一个宾馆的Web应用的想法。然后我一个人在大二暑假花了3个月的时间用SpringBoot做一个宾馆信息管理系统，面向的用户就是宾馆的前台，可以简化管理宾馆的业务过程。 结合项目实际需求，介绍项目用到的技术，比如上面“岗位要求”描述中，要求有“开发经验，熟悉一些前端知识等”，可以这样介绍： 在这个项目里，开发用户界面要到模板引擎，比如JSP和Thymeleaf，就必须了解前端知识嘛，所以我还学习并用到了许多前端框架，比如EasyUI、Bootstrap、Ajax和axios等，甚至还接触过Vue。 注意：这里仅仅是介绍项目，结合功能点说出技术即可，一定要思路清晰。 再结合项目，说些招聘方需要的非技术的要求 在这个项目中，我用到了MVC设计模式，在项目的开发过程中去学习，遇到问题我首先会在网络上寻找解决方案，然后再去和同学商量，或是我在Java学习的微信群里，不乏工作经验丰富的人，我也会去问他们解决方案。过一定时间我也会再回顾代码，优化代码逻辑，减少代码量等。 如果有，说下项目中的亮点，比如用到了一些比较好的技术。 官方推荐模板渲染引擎Thymeleaf，语法更灵活 MyBatis框架，SQL语句更灵活，实现更简单 缓存 String对象的优化 这个项目对数据库性能和内存性能要求比较高，所以我用到了Oracle调优技术和JVM内存优化技术，此外，我们还用到了大数据分析工具对计费模式做了优化。 准备好说辞，能给面试官留下思路清晰，技术匹配的印象。 如果运用到项目的技术和要求不匹配，但可以在了解的基础上说出来，整理一下说辞即可。但通过后面的问题，面试官发现你根本不了解，性质就变了。 在准备项目说辞的时候，可以尽量和职位要求靠，但你说的每个技术点，稍后面试官都会问的。如果某个技术点没有掌握，其实问题不大，面试官不会要求十全十美。 一定得准备项目描述里提到的技术在介绍项目时，吸引面试官把注意力集中到你提到的技术点上。这些技术大多也是岗位要求的技术。 结合项目点明技术。 准备亮点话题亮点话题多多益善 对于Java高级开发而言，可以准备以下话题： 虚拟内存优化 数据库性能优化 分布式高并发架构 一些热门组件，比如redis、nginx等 大数据方向的用法？ Java core（比如集合或多线程）方面的底层实现代码 Spring系列（比如IOC、AOP、MVC、SpringBoot、SpringCloud）方面的底层实现代码 要准备到什么程度： 最好结合项目实际说出真的用过这些技术 最好往性能调优方面靠 通过准备，大家可以主导面试官提问，否则面试官开始天马行空地问问题，大家薄弱点被暴露的机会就有可能大大增加。 刷题手撕代码啊，远程的话，就是用本地IDE，然后共享屏幕，不要紧张对自己代码不自信。 面试中的表现软实力面试官只有当确认候选人在责任心和团队协作能力方面没问题，才会把你招进公司。面试官会通过（1）问问题的方式；（2）通过回答问题的方式和说话的语气；来确认。 所以大家面试的过程中： 交流时尽量目视面试官，谈吐清晰，语速不急不缓，说话果断，语气不卑不亢，别太僵硬 适当微笑，点头互动 积极回答问题，如果没听清问题，及时主动询问 不急不燥，从容应对“压力测试” 放松心态 当觉得自己不行的时候，就走在这个斑马线上，你就是一个行人。 上面这些都是我二面之前做的准备。 二面完后总结一面自我介绍嘛，基本信息，实习实践经历比赛，虽然简历上有。 开始看机试的题 我是没有想到的，依次回顾当时的机试题，我当时是8月12号参加的华为西北校招机试，距离面试这天已经1个月了吧，有些没有印象，只说出了一题的大概思路，觉得自己没有表现好。当时的题及我写的代码都以放在我的GitHub上，大家可以参考，并不都是AC。 项目 问我做过的项目给他展示，我是直接共享屏幕展示，他会问我如何实现，他也会指出我项目里出现的问题。和我讨论，大家把握说话方式，不要太拘束即可。还会展示数据库，问数据库中各个表的实现和意义，问我了为什么密码是明文没有加密，这是我第二个感觉表现不好的地方。 然后就手撕代码 当时机试，有两题没写出来，他就从里面挑了一道题让我写，当时没有思路，最后又写出来了，觉得挺幸运，不过写代码过程中出现了写小插曲，这是我第三个感觉表现不好的地方。 结束 大概聊得就这么多，最后问我有什么问题想问他，我也没有问题。 二面一面结束10分钟后就会出结果，前2面安排挺紧凑的相隔30分钟吧，会换面试官的。轮到我就比较凑巧，刚好到饭点，我一面面完群里就通知大家可以去吃饭了。 吃完饭会来，等了一会儿，1点30分开始。还是自我介绍，基本信息，实习实践经历比赛，虽然简历上有。 项目 然后他提了个功能，问我实现思路，感觉也没有达到他的要求 结合项目，给出场景 问我有没有什么想法？我说出了大概思路，感觉也没有达到他的要求 B树系列问题 B树，B+树为什么比二叉树等效率高？特点是什么？我之前通过MySQL了解的B+树，现在已经没啥印象了，就也没有回答的很顺利。 数据结构，排序 问快速排序、归并排序和堆排序的时间复杂度，有没有了解比这些排序更快的，还有他们的稳定性。 结束 大概聊得就这么多，最后问我有什么问题想问他，我也没有问题。 专业主管面试职业规划（人生规划）：最重要的就是找对职业方向 1、自我分析阶段 兴趣分析： 我应聘的岗位是通用软件开发，我也向HR了解过情况，我的意向工作就是Java开发。我热爱Java，我从大二接触到这门语言就开始了，Java是我接触到的第二门编程语言，第一门面向对象的编程语言，我喜欢他的规范和严谨。所以我会主动努力地去学习Java及其相关的框架，比如Spring。 性格分析： 大学期间我参与过比较多的项目，做过开发，也做过项目组长，做过项目汇报，我都可以适应这些角色，开发不用说我是喜欢的，项目组长的话，主要负责协调组内成员，规划好项目进度，也会帮助和鼓励组员开发。我觉得我的性格比较活泼比较负责，我每次参与开发完成项目都很有成就感和满足感，会有冲动向同学们汇报展示。 优缺点分析： 优点：做事比较负责，认真，有上进心，肯吃苦 缺点：比较在意他人的看法 2、职业分析规划 毕业之后找到自己心仪的工作，认真完成工作，抽时间学习专业知识技能，向前辈和同事学习经验。因为自己要学的东西还很多，积淀一段时间后，想着在工作中职位向上晋升，不断积累经验。 网上翻到一篇博客【面试经验】三轮面试拿到华为Offer 问我为什么选择华为，我说我想去大城市闯荡，华为有很大的平台可以供我们年轻人发挥。然后主管问有没有人推荐你选华为，或者你是怎么了解华为的。这些问题我都是心里面有答案的，因为我邻居就有在华为工作的，所以我稍微了解华为，也有人力挺我要去华为发展，这些都是这个问题的答案。 接下来就是压力面试，问我如果你和你同学一起进入华为，发现你的工资比同学低个几千元，你该怎么办，你会不会心理不平衡？我说我会弄明白我为什么会比别人低，然后努力工作，改正一些缺点，争取在业务上超过他们。业务主管说在华为刚进去不要在乎你比别人少几千，以后都是年薪几十万，几百万的，那几千元算什么，刚进去的两个人，几年以后可能待遇截然不同。 接着又问我如果你有一项技术只有你一个人会，是你的独门秘诀，现在又需要，你会不会把他教给其他人。我直接说不会，因为这是吃饭的家伙。业务主管笑了笑说虽然这是我不想得到的答案，但是你诚实，在华为大家都是有技术互相交流的，大家都倾其所有的完成项目，这样项目就能轻松的完成，然后一些奖励大家一起分，这样多开心。接着又问我，如果我是业务主管，给5个不同方向的人打等级，打绩效成绩该怎么打。这个我答的比较好，因为要看团队合作能力，看他在完成工作的同时还为团队带来了哪些利益，因为华为是狼道盛行的团队，特别讲究团队合作。 聊完这些压力面以后，面试官问我有没有问题要问他。我就顺便问了一个我这个方向的进入华为能不能直接上手，对不对口。你进来以后也会跟着师傅学习，慢慢上手项目，开始融入团队完成项目，到后来一个人负责一个项目。三轮面试差不多就结束了，第三轮面试大概35分钟左右，这个还是比较轻松的。 这里要注意的是，三轮面试的时候，如果业务主管问你地点的问题，那你就要小心了，如果说给你深圳你去不去，你说不去的话，可能第三轮你就会倒下。当然了很多同学没有被问到这个问题，关于地点问题倒在三轮的，我们学院大概两个人。（当你面试完华为以后，恭喜你，你的面试经验已经非常成熟了。你再去面试其他公司，你就会发现很轻松，基本都不需要准备，级别绝对不是一个level，因为华为的面试官带你把项目都仔仔细细的过了一遍，华为三轮面试的那两个小时绝对成为你人生中宝贵的财富） 面试完三轮以后等通知，说一个星期后给结果。19号面试的同学，有大部分都撑完了三轮面试，20号面试的同学最后只有2个撑到了第三轮。然后面试完以后，第二天就有三轮面试的结果了，我是录用排序中，有的同学倒下了，显示面试不通过。苦苦等了一个星期，然后HR说可能国庆之后给结果。在家里过了一个国庆后。大概11号的时候，有人收到签约短信了，那波人是第一批被捞上来了，网络能源产品线电源岗只有我同门被捞了，因为他研究方向就是逆变器，十分对口，面试也很顺利，薪资待遇开的20k。我们专业，面试其他部门的第一批被捞的都是开的20k，价格都一样。过了几天，华为第二批开始捞人，我被捞出来了，16号南研所签约，签两方（华为的两方可以毁约，没有违约金），第二批的待遇稍微差一点只有19k，计算方法就是19*（14-16），签完两方，拿到了华为的聘书，我就回学校了。后来听说第三批只有18k了。 最后再说一下我去了哪里吧，最后我选择了江苏电网（某市供电公司）。主要原因是签了承诺书，不允许毁约电网，再加上家里人不同意我去华为，怕我身体吃不消。签完电网刚开始三天我还状态良好，后来慢慢的有些后悔，觉得我这性格的更适合华为，我喜欢奋斗干出一番事业，年轻人不能怕吃苦。然后同学对我进行了一波开导，再加上家里人不同意去华为，最后我还是坚定的选择了国家电网。其实选择哪有什么后悔不后悔，你进去以后踏实干活，干出成绩来，有所成就，你就会觉得当初的选择多么的对。如果你整天浑水摸鱼，一事无成，这样你就会觉得当初为什么选择了它，而没选择另一者。所以为了以后不留遗憾，今后也会努力工作，带着华为那种拼搏的精神进入电网，踏实干活。最后我们学院大概4个签约了华为公司，都选择了上海。最后衷心的祝愿在华为拼搏的这些同学，你们带着东大电气人的梦想，勇敢新世界，拖着世界往前走，虽然在华为拼搏的路上没有我，但梦想与你们跟随。 三面依然是自我介绍，充分准备一下。 专业：软件工程 对软件工程的理解，工程化开发软件项目…自我感觉还行 软件工程中最重要的是什么？为什么？ 需求分析，软件开发的开端 最有成就感的事 最遗憾的事 未来规划 了解华为的企业文化吗 总体觉得面试华为收获不少，拿不拿得到Offer另说。前两面挺虚的，但三面还好，等待通知吧！","link":"/2020/09/16/Interview/Huawei/"},{"title":"计算机网络课程复习","text":"考查目标： 掌握计算机网络的基本概念、基本原理和基本方法。 掌握计算机网络的体系结构和典型网络协议，了解典型网络设备的组成和特点，理解典型网络设备的工作原理。 能够运用计算机网络基本概念、基本原理和基本方法进行网络系统分析、设计和应用。 以西北工业大学801计算机专业基础为考纲 一、计算机网络体系结构1.1 计算机网络概述1.1.1 计算机网络的概念、组成与功能 计算机网络是“以相互共享资源的方式互联起来的自治计算机系统的集合”。 计算机网络通常由3个部分组成，分别是资源子网、通信子网和通信协议。 组成 资源子网 通信子网 通信协议 包括 主机与终端、终端控制器、联网外设、各种网络软件与数据资源 路由器、各种互联设备与通信线路 通信双方必须共同遵守的规则和约定就称为通信协议 作用 负责全网的数据处理业务，向网络用户提供各种网络资源与网络服务 负责完成网络数据传输、路由与分组转发等信息处理任务 等 计算机网络的功能 主要功能 详细 作用 数据通信 依照一定的通信协议，利用数据传输技术在两个终端之间传递数据信息的一种通信方式和通信业务 实现计算机和计算机、计算机和终端以及终端与终端之间的数据信息传递，是继电报、电话业务之后的第三种最大的通信业务 资源共享 资源共享是人们建立计算机网络的主要目的之一。计算机资源包括硬件资源、软件资源和数据资源 硬件资源的共享可以提高设备的利用率，避免设备的重复投资，如利用计算机网络建立网络打印机；软件资源和数据资源的共享可以充分利用已有的信息资源，减少软件开发过程中的劳动，避免大型数据库的重复建设 集中管理 计算机网络技术的发展和应用，已使得现代的办公手段、经营管理等发生了变化 管理信息系统、办公自动化系统等，通过这些系统可以实现日常工作的集中管理，提高工作效率，增加经济效益 实现分布式处理 网络技术的发展，使得分布式计算成为可能 对于大型的课题，可以分为许许多多小题目，由不同的计算机分别完成，然后再集中起来，解决问题 负荷均衡 负荷均衡是指工作被均匀的分配给网络上的各台计算机系统 网络控制中心负责分配和检测，当某台计算机负荷过重时，系统会自动转移负荷到较轻的计算机系统去处理 1.1.2 计算机网络的分类 计算机网络的分类方法有多种，其中最主要的方法是根据覆盖范围进行分类的方法。 分类 覆盖范围(Reference) 详细 特点 种类 广域网(Wide Area Network; WAN) &gt;100km 也称为远程网。一般是在不同城市之间的LAN或者MAN网络互联 距离较远，信息衰减比较严重，所以这种网络一般是要租用专线，通过IMP（接口信息处理）协议和线路连接起来，构成网状结构，解决循径问题 邮电部的CHINANET，CHINAPAC，和CHINADDN网 城域网(Metropolitan Area Network; MAN) 10~100km 早期以光纤为传输介质。宽带城域网以IP为基础，通过计算机网络、广播电视网、电信网三网融合 完善的光纤传输网是基础。传统电信、有线电视与IP业务的融合成为宽带城域网的核心业务。高端路由器和多层交换机是核心设备。扩大宽带接入规模与服务质量是应用关键 提供普通家庭用户和集团用户高速接入因特网、局域网互连以及VPN/VPDN等业务 局域网(Local Area Network; LAN) 10m~10km 局部地区范围内的网络。局域网一般位于一个建筑物或一个单位内，不存在寻径问题，不包括网络层的应用 连接范围窄、用户数少、配置容易、连接速率高 以太网（Ethernet）、令牌环网（Token Ring）、光纤分布式接口网络（FDDI）、异步传输模式网（ATM）以及最新的无线局域网（WLAN） 个人区域网(Personal Area Network; PAN) &lt;10m 个人操作空间(Personal Operating Space; POS)。无线个人区域网络(WPAN)。近距离不同移动办公设备之间低速互联 蓝牙：开放的规范，近距离无线通信，语音和数据传输，世界任何地方通信ZigBee：低功耗、低速率、低成本 蓝牙技术与ZigBee技术（近距离无线通信） 1.1.3 计算机网络与互联网的发展历史 第一阶段：计算机网络技术与理论准备阶段（20世纪50年代） 数据通信技术日趋成熟，为计算机网络的形成奠定技术基础 分组交换概念的提出为计算机网络的研究奠定了理论基础 第二阶段：计算机网络的形成（20世纪60年代） ARPANET的成功运行证明了分组交换理论的正确性 TCP/IP协议的广泛应用为更大规模的网络互联奠定了坚实的基础 E-mail、FTP、TELNET、BBS等应用展现出网络技术广阔的应用前景 第三阶段：网络体系结构的研究（20世纪70年代中期） 网络体系结构与协议的标准化研究，对更大规模的网络互联起到推动作用 国际标准化组织(ISO)在推动“开放系统互连(Open System Interconnection, OSI)参考模型”与网络协议标准化研究方面做了大量工作 OSI参考模型的研究对网络理论体系的形成与发展，以及在网络协议标准化研究方面起到了重要的推动作用 TCP/IP经受了市场和用户的检验，吸引了大量的投资，推动了Internet应用的发展，成为业界标准 第四阶段：Internet应用、无线网络与网络安全技术研究的发展 Internet作为全球性的国际网与大型信息系统 Internet大规模接入推动了接入技术的发展 对等(Peer-to-Peer, P2P)网络技术的研究，使得“即时通信”等新的网络应用不断涌现 WPAN、WLAN与WMAN技术日益成熟，并应用阶段。无线自组网、无线传感器网络受到高度重视 物联网技术形成与发展 网络安全技术快速发展 1.2计算机网络的标准化工作及相关组织。1.2.1 网络协议标准化组织 国际电信联盟（International Telecommunications Union, ITU） 负责电信方面的标准制定。 国际标准化组织（International Organization for Standardization, ISO） 组织制定国际标准。ISO中负责数据通信标准的是ISO第97技术委员会（TC97）。OSI参考模型就是由ISO的TC97组织制定的。 电子工业协会（Electronic Industries Association, EIA） 制定的RS-232接口标准在通信中应用广泛。 电气电子工程师协会（Institute of Electrical and Electronics Engineers, IEEE） 组织制定了局域网中最重要的802系列标准。 1.3 计算机网络体系结构与参考模型1.3.1 计算机网络分层结构 OSI体系结构：应用层，表示层，会话层，运输层，网络层，数据链路层，物理层 TCP/IP体系结构：应用层，运输层（TCP或UDP），网际层（IP），网络接口层 五层协议体系结构：应用层，运输层，网络层，数据链路层，物理层 1.3.2 计算机网络协议、接口、服务等概念 协议就是一组控制数据交互过程的通信规则，这些为网络数据交换制定的通信规则、约定与标准被称为“网络协议” 网络协议三要素： （1）语义：解释控制信息每个部分的意义 （2）语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序 （3）时序：是对事件发生顺序地详细说明 层次结构是处理计算机网络问题最基本的方法。对于一些难以处理的复杂问题，通常采用分解为若干个容易处理的、小一些的问题，“化整为零，分而治之”的方法去解决 在邮政系统中，邮箱就是发信人、收信人与邮递员之间交互的接口。接口是同一主机内相邻层之间交换信息的连接点 实体：任何可发送或接受信息的硬件或软件进程，通常是个特定的软件模块。 第n层的活动元素称为n层实体 不同机器上同一层称为对等层，同一层的实体叫做对等实体 服务：下层为相邻上层提供的功能调用，垂直的。对等实体在协议的控制下使得本层能为上一层提供服务。 1.3.3 ISO/OSI参考模型和TCP/IP模型 二、物理层2.1 通信基础2.1.1 信道、信号、宽带、码元、波特、速率、信源与信宿等基本概念 信道：通信的通道，是信号传输的媒介 信号：在通信系统中，二进制代码0、1比特序列必须变换成不同的电平或频率变化的信号之后，才能通过传输介质进行传输 带宽：网络的通信线路传送数据的能力。即：在单位时间内从网络中的某一个点到另一点所能通过的“最高数据率” 码元：在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为(二进制）码元 一个数字脉冲就是一个码元 波特：调制速率描述通过模拟线路传输模拟数据信号的过程中，从调制解调器输出的调制信号每秒钟载波调制状态改变的数值，单位是1/s，称为波特 1波特表示数字通信系统每秒传输1个码元，单位时间内数字通信系统所传输的码元个数 速率：连接在计算机网络上的主机在数字信道上传送数据的速率，也称为数据率或比特率。 信源：发送数据的一方 信宿：接收数据的一方 2.1.2 奈奎斯特定理与香农定理 Nyquist准则 2.1.3 编码与调制 编码：把数字信号转换为另一种形式的数字信号 常用编码方式：不归零制，归零制（正脉冲代表1，负脉冲代表0），曼彻斯特编码（位周期中心的向上跳变代表0，向下代表1，反之亦可），差分曼彻斯特编码（每一位的中心处始终有跳变。位开始边界有跳变为0，位开始边界无跳变为1）。 调制：将发送端的数字信号变换成模拟信号的过程。实现调制功能的设备称为“调制器” 2.1.4 电路交换、报文交换与分组交换 分类 详细 特点 电路交换（线路交换，Circuit Switching） 两台计算机通过通信子网进行数据交换之前，首先从信源到信宿建立一条实际的物理连接通道 在保持连接期间双方独占信道（没有冲突，浪费信道资源）。信道资源的利用效率较低。适用于交互式会话类通信 报文交换 以报文为数据交换的单位，整块数据从源到宿由交换结点逐一中转 整块数据逐站存储转发。对报文的长度没有限制，对于大块数据（占用存储空间大，占用信道时间长）。延迟较大，不能实现交互式通信 分组交换 将数据拆分成分组，依次从源到宿经交换结点转发 分组的长度有上限控制，各自独立传输（占用信道时间短，占用缓存空间小）。信道共享（可充分利用信道资源，有可能发生资源(信道和结点）占用冲突） 分组交换的优点 比报文交换的延迟小 比电路交换的效率高 适于计算机网络通信 分组交换的缺点 仍然有延迟，不能满足实时多媒体通信的服务质量 需要解决冲突检测、拥塞控制和纠错重发等问题 2.1.5 数据报与虚电路分组交换技术可以分为2类：数据报（Data Gram, DG）与虚电路（Virtual Circuit, VC）。 数据报方式 虚电路方式 2.2 传输介质 双绞线、同轴电缆、光纤与无线传输介质 物理层接口的特性 2.3 物理层设备 中继器 集线器。 三、数据链路层3.1 数据链路层的功能采取差错检测、差错控制与流量控制等方法，将有差错的物理线路改进成无差错的数据链路，向网络层提供高质量的数据传输服务。 3.2 组帧3.3 差错控制在计算机通信中，研究检测与纠正比特流传输错误的方法称为“差错控制”。差错控制的目的是减少物理线路的传输错误。在设计差错控制方法时提出以下2种策略： 3.3.1 检错编码检错码为每个传输单元加上一定的冗余信息，接收端可以根据这些冗余信息发现传输差错，但是不能确定是哪一位或哪些位出错，并且自己不能够自动纠正传输错误。 常用的检错码有奇偶校验码（垂直、水平、垂直水平奇偶校验）和循环冗余码（CRC）。 3.3.2 纠错编码纠错码为每个传输单元加上足够多的冗余信息，以便接收端能够发现，并能够自动纠正传输差错。 检错码需要通过重传机制达到纠错目的，但工作原理简单，实现起来容易，广泛使用。 纠错码有优越之处，但实现起来困难，在一般的通信场所不易采用。 3.4 流量控制与可靠传输机制3.4.1 流量控制、可靠传输与滑动窗口机制 流量控制 发送端发送数据超过物理线路的传输能力或超过接收端的帧接收能力时，就会造成链路拥塞。为了防止链路拥塞，数据链路层必须具有流量控制功能。（避免淹没物理线路和接收端） 停止-等待协议; 后退N帧协议(GBN); 选择重传协议(SR)。 3.5 介质访问控制 信道划分介质访问控制：频分多路复用、时分多路复用、波分多路复用、码分多路复用的概念和基本原理; 随即访问介质访问控制：ALOHA协议，CSMA协议，CSMA/CD协议，CSMA/CA协议; 轮询访问介质访问控制：令牌传递协议。 3.6 局域网 局域网的基本概念与体系结构; 以太网与IEEE 802.3; IEEE 802.11; 令牌环网的基本原理。 3.7 广域网3.7.1 广域网的基本概念;3.7.2 PPP协议;3.7.3 HDLC协议 背景 ISO将SDLC协议（面向比特型）修改后的高级数据链路控制（HDLC）协议作为国际标准（ISO 3309）。目前很多流行的数据链路层协议，如Ethernet帧结构与PPP协议，都是在HDLC基础上修改，或是取其子集形成的。 数据链路的配置方式和数据传送方式 HDLC数据链路有2种基本配置方式：非平衡配置与平衡配置 非平衡配置 一组主机根据在通信过程中的地位分为主站与从站，由主站来控制数据链路的工作过程。 3.8 数据链路层设备 网桥的概念及其基本原理; 局域网交换机及其工作原理。 四、网络层4.1 网络层的功能 异构网络互联; 路由与转发; 拥塞控制。 4.2 路由算法 静态路由与动态路由; 距离-向量路由算法; 链路状态路由算法; 层次路由。 4.3 IPv4 IP协议的主要特点： IP协议是一种无连接、不可靠的分组传送服务的协议 IP协议是点-点网络层通信协议 IP协议屏蔽了互联的网络在数据链路层、物理层协议与实现技术上的差异 4.3.1 IPv4分组分组由2部分组成：分组头（首部）和数据 图中分组头的每行宽度（0~31）共32位，4字节。前5行是分组头中必有字段，第6行开始是选项字段，因此IPv4分组头的基本长度（$4(字节)*5(行)$）20字节，最大长度（$20+40(字节的选项)$）60字节。 4.3.2 IPv4地址与NAT连接到每个局域网的计算机都有一块网卡，就有一个MAC地址（物理地址）。IP地址（逻辑地址）是网络层的地址，主要用于路由器的寻址，因此IP地址采用层次结构。 4.3.3 子网划分与子网掩码、CIDR4.3.4 ARP协议、DHCP协议与ICMP协议4.4 IPv6 IPv6的主要特点; IPv6地址 4.5 路由协议 自治系统; 域内路由与域间路由; RIP路由协议; OSPF路由协议; BGP路由协议。 4.6 IP组播 组播的概念; IP组播地址。 4.7 移动IP 移动IP的概念; 移动IP的通信过程。 4.8 网络层设备 路由器的组成和功能; 路由表与路由转发。 五、传输层5.1 传输层提供的服务 传输层的功能：实现分布式进程通信。 5.1.1 传输层寻址与端口5.1.2 无连接服务与面向连接服务 区别 无连接服务 面向连接服务 概念 不需要建立连接直接进行数据的传输，报文之间相互独立 通信双方在通信时，要事先建立一条通信线路，其过程有建立连接、使用连接和释放连接3个过程 特点 动态地分配资源，每个带有目的地址的包（报文分组）送到线路上，由系统选定路线进行传输，适用于发送少量报文的情况 静态地分配资源，传输前需要建立连接，适用于在一段时间内向一个目的地址发送大量的数据 参考模型 IP、UDP协议（无连接协议），邮件系统（无连接的模式） TCP（面向连接的协议），电话系统（面向连接的模式） 优点 不占用通信信道 实时通信 / 可靠信息流 / 信息回复确认 缺点 非实时通信 / 信息流可能丢失 / 信息无回复确认 占用通信道 5.2 UDP协议User Datagram Protocol（用户数据报协议） 5.2.1 UDP数据报 UDP协议是一种无连接、不可靠的传输层协议。 UDP协议是一种面向报文的传输层协议。 5.2.2 UDP校验5.3 TCP协议Transmission Control Protocol（传输控制协议） 5.3.1 TCP段（报文段，TCP报文）5.3.2 TCP连接管理 TCP连接建立（3次握手） TCP连接释放（4次握手） 5.3.3 TCP可靠传输可靠：保证接收方进程从缓存区读出的字节流与发送方发出的字节流是完全一样的。 TCP实现可靠传输的4个机制 校验 与UDP校验一样，发送方和接收方增加伪首部，然后通过二进制反码求和的计算方法来判断有没有发生错误 序号 TCP是面向字节流的，但在发送的时候会把一些字节放在一起组成一个报文段然后把报文段发送出去；报文段的大小是不定的（可以是2个、十个、百个等），报文段的大小取决于链路层的MTU（最大传输单元） 就是TCP根据下方数据链路层的MTU（最大传输单元）来随即将数据切割成好几段并且进行编号 确认 发送方每一次发送数据之后都需要接收方进行确认。 TCP使用的是累计确认机制，就是从第一个丢失的字节开始请求丢失的报文段。如由于网络状况原因，456丢失，78到达，但接收端仍然请求发送的数据序号是4，等到456出现在缓存中，78早已在，那么接下来接收端应该请求发送的数据序号是9。 重传 为什么要使用自适应算法？网络环境太复杂，路径又长又短，RTT设置短了可能会引起长报文段不必要的重传，RTT设置长了又导致网络利用率降低，所以使用RTTs 5.3.4 TCP流量控制与拥塞控制六、应用层6.1 网络应用模型 客户/服务器模型; P2P模型、。 6.2 DNS系统 层次域名空间; 域名服务器; 域名解析过程。 6.3 FTP FTP协议的工作原理; 控制连接与数据连接。 6.4 电子邮件 电子邮件系统的组成结构; 电子邮件格式与MIME; SMTP协议与POP3协议。 6.5 WWW WWW的概念与组成结构; HTTP协议。","link":"/2021/01/08/Postgraduate/computerNetwork/"},{"title":"数据结构课程复习","text":"考查目标： 理解数椐结构的基本概念、掌握数椐的逻辑结构、存储结构及其差异，以及各种基本操作的实现。 掌握基本的数据处理原理和方法，在此基础上能够对算法进行设计与分析。 能够选择合适的数椐结构和方法进行问题求解。 以西北工业大学801计算机专业基础为考纲 一、线性表1.1 线性表的定义和基本操作 线性表（Linear List）描述：线性表是n个类型相同数据元素的有限序列，对n&gt;0，除第一个元素无直接前驱、最后一个元素无直接后继外，其余的每个元素只有一个直接前驱和一个直接后继，元素之间具有一对一的关系。 1.2线性表的实现1.2.1 顺序存储结构1.2.2 链式存储结构1.3 线性表的应用二、栈、队列和数组2.1 栈和队列的基本概念2.2 栈和队列的顺序存储结构2.3 栈和队列的链式存储结构2.4 栈和队列的应用2.5 特殊矩阵的压缩存储三、树与二叉树3.1 树的概念3.2 二叉树3.2.1 二叉树的定义及其主要特征3.2.2 二叉树的顺序存储结构3.2.3 二叉树的链式存储结构3.2.4 二叉树的遍历3.2.5 线索二叉树的基本概念和构造3.3 二叉排序树3.4 平衡二叉树四、树、森林4.1 树的存储结构4.2 森林与二叉树的转换4.3 树与森林的遍历4.4 树的应用4.5 等价类问题4.6 哈夫曼树和哈夫曼编码五、图5.1 图的概念5.2 图的存储及基本操作5.2.1邻接矩阵法5.2.1 邻接表法5.3 图的遍历5.3.1深度优先搜索5.3.2 广度优先搜索5.4 图的基本应用及其复杂度分析5.4.1 最小（代价生成树）5.4.2 最短路径5.4.3 拓扑排序5.4.4 关键路径六、查找6.1 查找的基本概念6.2 顺序查找法6.3 折半查找法6.4 B-树6.5 散列表（Hash）表及其查找6.6 查找算法的分析及应用七、内部排序7.1 排序的基本概念7.2 插入排序7.2.1 直接插入排除7.2.2 折半插入排除7.2.3 希尔（shell）排序7.3 交换排序7.3.1 冒泡排序7.3.2 快速排序7.3.3 选择排序7.3.4 简单选择排序7.4 堆排序7.5 归并排序7.6 二路归并排序7.7 基数排序7.8 各种内部排序算法的比较7.9 内部排序算法的应用","link":"/2021/01/08/Postgraduate/dataStructure/"},{"title":"英语积累","text":"考查目标： 考研时期真题词汇和作文积累。 并且以后的英语积累也会记到这里。 以我考的英语二为基础 积累1.词汇量 真题词汇集锦 2020年 （完形）tedious 单调乏味的 instructive 增长知识的，富有教益的 harsh 严厉的，残酷的 vague 含糊的，粗略的 fatigue 疲乏，疲劳 confront 面对遭遇 trying 令人厌烦的 （Text1）asocial 不合群的 trait 特点 认为，感觉 reciprocal 互惠的，相应的 乐意 （Text2）rigorous 谨慎的，严格的 justified 有充分理由的，合理地 （Text3）yet 用于否定 Its fate is yet to be decided. 它的命运尚未确定。 deem 认为，视为 vulunerable 易受攻击的 2019年 （完形）obsess 使痴迷 solely 仅仅，只 v.描写 depiction n.描写 aside from 除…以外 rigid 严格死板的，（人）不通融的 conceal 隐藏 hold onto 抓紧，保存 account for 解释，了解，查明 confirm 证实，确认 triumph 战胜，获胜 fluctuation 波动，起伏 zeal 热情 （Text1）appease 安抚 guilt still gets a bad rap 内疚感可不是件好事 deceptive 欺骗性的 addictive 使人上瘾的 不可原谅的 rein 控制 极差的 nastier impulses 恶意冲动 vice versa 反之亦然 rate v.评估 n.速率 （Text2）count on 依赖，指望 soak up 吸收 消耗，烧毁 be accustomed to sth 习惯于 （Text3）obstruct 阻碍 no numerical cap 没有数量限制 implausible 不合理的 plausible 可信的 cumbersome 缓慢冗长的 slow granting procedures 签发过程缓慢 curb 抑制 aggressive 激进的 2018年 utterly 完全的，绝对的 insidious 潜伏的 inferiority 劣势，低等 evaporate 蒸发，消失 asset 资产 physical assets 有形资产 astonishing 令人惊讶 intricate 错综复杂 2017年 bidder 投标者 dual 双重的 wordy 话多的，冗长的 tricky 狡猾的，棘手的 compensation 补偿 scarce 不足的，稀少的 2.句子 小作文集锦 Forbidden City is a great magnet for foreign tourists. The hope of living a better life is his impetus to study. I’ve come to the conclusion that … take the initiative to do 积极主动做某事 of even greater concern is the fact that … 更加需要关注的是 It is far better to do 远不如做某事，最好做某事？ In short 简言之 As sb notes, … 正如某人所指出 exert onself to do sth 努力做某事 图表作文 address 处理，应对 supply 供应 pose 引起，产生 decelerate 减速 1234图表作文:This argument has attracted a lot of attention. 这一观点已受到广泛关注。This phenomenon can be attributed to the following reasons. 之所以出现这种现象，原因可能有以下几点。However, this encouraging sign also presents challenges, like how to address the supply **deficientcy** posed by decelerated growth of **museum**s and people's increasingly diverse need for exhibitions. 如何应对博物馆增长放缓带来的供不应求问题以及人们日益多样化的观展需求问题等。 小作文范文1.范文一12345Dear Li Ming, I'd like to congratulate you for winning the fierce competition for admission to a prestigious university. This success means that you have acquired extraoridinary learning capacity and if this capacity can be further developed in university, you will be competent to build your career. However, I must also warn you that the approaching university life is different to you previous school life. You should make adjustment for it. That is, you should mentally and practically prepare to be indepent and learn not for examination but for your life purpose. I wish you could learn to manage life and study by yourself in the following four years. Sincerely yours, Zhang Wei 范文赏析： 短语部分 fierce competition 激烈竞争 admission 入场费 prestigious university 名校 prestigious 声誉高的，有威望的 extraordinary learning capacity 卓越的学习能力 previous school life be competent to build your career 有能力创造一番事业 mentally 心理方面 make adjustment for it 做出调整 practically 实际层面 12长句部分：learn not for examination but for your life purpose 不是为考试学习，而是为自己的人生目标学习。 2.范文二（2020小作文）123456Dear Friends, I'm so delighted that you trust me to arrange your trip. I'm writing to inform you of the historical attraction to visit the Terracotta. Army, one of the greastest archaeological discoveries of all time and share some travel trips. Located to the east of downtown Xi'an, the Terracotta Army is a massive collection of life-size clay warriors and horses buried in the tomb of China's First Emperor. It offers a fascinating glimpse into the country's glorious past. To get a better view of these breathtaking sculpture, you may consider avoiding public holidays in China or setting out early if you have to visit the mesume on those days. In addition, it's also advisable to rent a multilingual audio guide at the ticket office, which will certainly make your trip informative. Hope this trip suits your taste and that you all enjoy it. Yours sincerely, Li Ming 范文赏析： 短语部分 be so delighted that … arrange your trip Terracotta 兵马俑 the greatest archaeological discoveries 最伟大的考古发现 大作文范文1.范文一123China's auto market was still dominated by Japanese, Chinese and American brands. American cars remained the third most popular int the market with a slight increase in market share. A noticeable change occurred concerning Japanese and Chinese brands. With its market share slipping by almost 10%, Japanese brands were displaced from their leading position by Chinese brands which expanded their share by around 10%.The performance of American brand cars is to be expexted, given their worldwide fame and reliable quality. The big change in the performance of Japanese and Chinese brands seems sudden but is not unexpected. Chinese auto producers had narrowed the technology gap between themselves and foreign competitors, and cleverly switched their promotion strategies to satisfy Chinese customers' appetite for a bargin. While Chinese brands were growing, Japanese brands were hit by a reputation crisis caused by frequent quality compliants.The plight of Japanese brands is a reminder that quality is the soul of products. Hopefully, Chinese automakers will consistently guarantee high quality, thereby protecting their own reputation so as to maintain market popularity. 范文赏析： 短语部分 auto 汽车 was still dominated by Japanese 被控制，被占据 remained the third most popular a slight increase share 股份，份额 noticeable 显著的 slipping 下降 but is not unexpected 也在预料之中 expanded 扩大，增加 narrowed the technology gap 缩小了技术差距 plight 困境，苦难 thereby 从而 12345678910111213长句部分：were displaced from their leading position 主导地位被取代The performance of American brand cars is to be expexted, given their worldwide fame and reliable quality. 鉴于美国品牌汽车的世界声誉和可信赖的质量，其表现预料之中。and cleverly switched their promotion strategies to satisfy Chinese customers' appetite for a bargin. 并聪明地改变了其推广策略一满足中国消费者对便宜商品的喜好。Japanese brands were hit by a reputation crisis caused by frequent quality compliants. 日本品牌因频繁的质量投诉遭到信誉危机的打击。The plight of Japanese brands is a reminder that quality is the soul of products. 日本品牌的困境提醒一个事实，质量是产品的灵魂。Chinese automakers will consistently guarantee high quality, 希望中国汽车制造商能一贯保证好的质量 2.范文二123Employees aged above 50 years were most likely to report satisfaction, with 40% of them indicating they were content. Employees aged 40 years or younger were less willing to declare satisfaction. Employees aged between 41 and 50 were surely the unhappiest; none of them felt satisfied and the proportion of respondents reporting dissatisfaction was as high as 64%.The significant different in job satisfaction relates to employees' career situation. Employees aged between 41 and 50, less energetic than younger crowd and less competent than older professionals, reach a career plateau, showing deep job dissatisfaction. In contrast, younger colleages, in spite of occasional confusion, are mostly in an upward spiral, and understandably feel happier. As for older colleagues, many of them have achieved career maturity and their careers are going to be crowned with a relaxing retirement life. Not surprisingly, they are the happiest.Career trouble may afflict people at all ages. For lasting happiness with our jobs, positive attitude is necessary. 范文赏析： 短语部分 aged above 50 years 定语 they were content proportion 比例 as high as as…as 句型 significant difference In contrast 比较而言 inspite of occasional confusion 不管（除了）偶尔感到困惑 in an upward spiral understandably 正常地 career maturity 职业成熟 be crowned with 获得，被冠以 Not surprisinly afflict 困扰，困惑 123456789长句部分：were less willing to declare satisfaction 更不愿意宣称对工作满意were surely the unhappiestless competent than older professionalsreach a career plateau 进入职场高原（停滞不前的局面）","link":"/2021/01/08/Postgraduate/English/"}],"tags":[{"name":"C","slug":"C","link":"/tags/C/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"OS","slug":"OS","link":"/tags/OS/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"Element-UI","slug":"Element-UI","link":"/tags/Element-UI/"},{"name":"Electron-Vue","slug":"Electron-Vue","link":"/tags/Electron-Vue/"},{"name":"Axios","slug":"Axios","link":"/tags/Axios/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"ElasticSearch","slug":"ElasticSearch","link":"/tags/ElasticSearch/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"Theory","slug":"Theory","link":"/tags/Theory/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"Huawei","slug":"Huawei","link":"/tags/Huawei/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"配置","slug":"配置","link":"/categories/%E9%85%8D%E7%BD%AE/"},{"name":"主题","slug":"主题","link":"/categories/%E4%B8%BB%E9%A2%98/"},{"name":"课程","slug":"课程","link":"/categories/%E8%AF%BE%E7%A8%8B/"},{"name":"框架","slug":"框架","link":"/categories/%E6%A1%86%E6%9E%B6/"},{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"},{"name":"搜索引擎","slug":"搜索引擎","link":"/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"积累","slug":"积累","link":"/categories/%E7%A7%AF%E7%B4%AF/"},{"name":"原理","slug":"原理","link":"/categories/%E5%8E%9F%E7%90%86/"},{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}