{"pages":[],"posts":[{"title":"Java编译原理","text":"Java development notes document Source Code 解决的问题1在CMD上运行java文件时出现错误：找不到或者无法加载主类的问题。 解决方案 1. 首先写一个测试文件 12345public class TestDemo { public static void main(String args[]) { System.out.println(\"Run successfully!\"); }} 2. 通过cmd编译如下 2.1 通过命令：javac TestDemo.java将其编译成字节码文件。要运行一段Java源码，必须先将源码转换为class文件，class文件就是编译器编译之后供虚拟机解释执行的二进制字节码文件。 2.2 通过命令：java TestDemo将其运行，并打印输出结果。 从图中可以看出，在这种情况下编译是正常的。 3. 那么，我们修改刚开始的代码 在首行加入在java中最常见的package关键字。如下： 1234567package CourseExercise;public class TestDemo { public static void main(String args[]) { System.out.println(\"Run successfully!\"); }} 3.1 通过命令：javac TestDemo.java将其编译成字节码文件 在编译成字节码文件时，是没有问题的。也就是说，在当前文件目录下，可以成class文件。好的，继续往下进行。 3.2 通过命令： `java TestDemo` 尝试将其运行，并打印输出结果。 这个时候就会报错了。提示错误：找不到或无法加载主类。很明显，这个错误是由于在代码首行加入了package CourseExercise;造成的。 4. 那么，遇到这种问题该怎么解决呢 方法如下： 4.1 通过命令： `javac -d . TestDemo.java` 将目标文件编译成class文件。 说明： -d ：表示生成目录，设置编译生成的class文件保存路径，路径与定义的包名和层次相关。 . ：表示在当前目录中生成。 4.2 通过命令： `java CourseExercise/TestDemo` 或者 `java CourseExercise.TestDemo` 来运行程序。 4.3 通过命令： `javap -verbose TestDemo.class` 将class文件中的字节码转换为字节码指令。","link":"/2020/06/21/Java%E7%AC%94%E8%AE%B0%E6%96%87%E6%A1%A31/"},{"title":"高级操作系统","text":"课程目标 1、了解高级系统相关内容（主要包括网络OS与分布式系统的概念、特点、应用额体系结构与软硬件组成等）； 2、掌握单机操作系统设计实现原理（特别是常见的操作系统习题、试题的了理解和解答方法）。 1 Distributed Systems1.1 Definition一个分布式系统是：独立计算机的集合，对用户而言，它们看起来像是一个统一的系统。 尚不存在一致性的定义，普遍接受的定义是： 分布式系统是若干台独立计算机的一种联合体，对用户而言，这个联合体就是一台单独的计算机。 在这个定义中，前半句说明是对计算机硬件的要求，后半句是对计算机软件的要求，这两项都是对分布式系统的基本的要求。 另一个角度： 分布式系统是这样一个系统，它运行在不具有共享内存的多台计算机上，但在用户眼里它却像是一台计算机。 实质思想：用户不必去关心系统中的多台计算机的存在。 尽管目前不存在完全满足该条件的系统，但已经有一些原型出现。 1234567891011Machine A Machine B Machine C---------- ---------- ----------| | | | | || Distributed Application 分布式应用程序 || | | | | || Middleware Service 中间件服务 || | | | | ||Local OS| |Local OS| |Local OS|---------- ---------- ---------- | | |-----------------------------------------------------------Network 中间件是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的。 组织为中间件的分布式系统。请注意，中间件层覆盖了多台计算机。 1.2 分布式系统的特点1.2.1 资源共享 Resource Sharing 硬件资源共享：专用设备共享 =》 处理资源共享 =》 负载共享与负载均衡 信息资源共享：如：电子商务应用共享同一数据对象，协同工作组共享同一数据空间 软件资源共享：软件开发组共享同一开发工具，同一类应用任务调用同一处理软件 资源异构、分布 =》 资源命名方案、分布资源管理模型、策略与机制是要解决的重点 互联网络环境 =》 计算机资源共享和多媒体信息资源共享成为研究和开发的热点 1.2.2 透明性 Transparency 透明性的基本概念和内容 机器边界、网络细节和系统状态对用户和应用程序员呈不可见性。多计算机环境 =》 单机环境。例如用户不必知道数据存在何处，进程在何处运行。 优点 软件易于研制；资源变动，软件影响小； 易于实现资源冗余；有利于资源操作移动 实现难点 大多数分布计算机系统固有的异构性增加了透明性实现的难度。 硬件异构性：指令系统不同、数据表示不同。系统配置不同 软件异构性：操作系统不同、网络协议不同 局部自治性限制全局透明性 Transparency Description Access 访问 隐藏数据表示形式和资源访问方式的差异 Location 隐藏资源所在的位置 Migration 转移 隐藏资源可能会移动到另一个位置 Relocation 重定位 隐藏资源在使用中可能会移动到另一个位置 Replication 复写 隐瞒资源可以通过多个副本进行部署和分发 Concurrency 隐瞒资源可能会由几个竞争用户共享 Failure 隐藏资源的故障和恢复 Persistence 隐藏（软件）资源是在内存中还是在磁盘上 分布式系统透明性的不同形式。 1.3 开放性 Openess 是指系统以各种方式进行扩展的能力。核心是要求不同厂家的系统（软硬件）具有互操作性（Interoperability）和可移植性（Portability） 互操作性：不同厂家的系统可有效地相互交换信息 可移植性：在较大范围的平台上运行同一软件的功能 UNIX是一个优秀的开放式软件系统：开放式结构、源代码可用、硬件无关性；TCP/IP协议是另一个开放式系统的例子 标准化是实现开放性的基本保证 标准是已被广泛接受的一种特定实现方法或功能集（接口）。 开房放概念是一种思想、设计观点、系统特征。因此，标准并不意味着是最好的、并不总是绝对需要的（尤其是在早期）、不是一成不变的。 国际标准化组织ISO。 1.4 延展性 Scalability延展性的制约： Concept Example Centralized services 集中服务 一台适用于所有用户的服务器 Centralized data 集中数据 一本在线电话簿 Centralized algorithms 集中式算法 根据完整信息进行路由 Scaling Techniques 1.5 容错性 Fault Tolerance基本概念 系统部分失效是能继续发挥作用的能力。如某个网络节点故障而不影响网络系统正常行为。 分布计算系统的资源多重性为实现容错创造条件：硬件资源冗余、数据多副本、动态切换。 系统容错是提高系统可靠性的重要途径。可靠性描述了系统成功运行的寿命特性。 容错性是分布计算应用的强烈需求：国防应用系统，电子商务应用的电子支付系统。","link":"/2020/06/30/AdvancedOS/"},{"title":"Java中main方法参数String[] args的使用","text":"Java development notes document Source Code Java规定12main方法参数必须为字符串数组(String [ ])，变量名可以随意，通常使用args即是arguments（”参数”的复数形式）的缩写。 Main方法12345public static void main(String[] args) {}public static void main(String args[]) {} 两种写法都是一样的，都表示字符串数组args，其中args只是普通变量名，可以随意定义（前提是符合变量名规则） 思考讨论 1. 不按Java规定 123456public class TestDemo { public static void main(String args) { // 将 String[] 改为 String System.out.println(\"Test!\"); }} 如果按照上面代码进行编码，那就不能被系统识别为主方法；系统就会提示类似如下错误：Error: Main method not found in the file, please define the main method as: public static void main(String[] args) 2. 同名main方法 如果已经有正确main方法，再有同名的main方法就是方法重载了。 1234567public static void main(String[] args){ // 正确标准完美的main方法}public static void main(String args){ // 方法重载} 3. 回归正题：参数String[] args的作用 参数String[] args的作用就是可以在main方法运行前将参数传入main方法中。 3.1 从控制台，输入编译执行命令时传参数。例如下面代码： 123456public class TestMain { public static void main(String[] args) { for(int i=0; i&lt;args.length; i++) System.out.println(args[i]); }}3.2 但是此时args[]并没有赋值，我们需要从控制台命令行进行赋值，就像这样： 所以在命令行中使用String[] args即传入参数的使用为： 1$ java java_file_name arg1 arg2 arg3 ... 4. eclipse举例 在Eclipse使用String[] args4.1 4.2 最后点击Run运行即可。","link":"/2020/06/21/Java%E7%AC%94%E8%AE%B0%E6%96%87%E6%A1%A32/"},{"title":"TypeScript入门","text":"TypeScript教程 TypeScript官网 1 安装1.1 NPM安装 在项目中打开终端，执行下面命令： $ cnpm install -g typescript 菜鸟教程 1.2 测试安装完成后我们可以使用 tsc 命令来执行 TypeScript 的相关代码，以下是查看版本号： 12$ tsc -vVersion 3.9.5 1.3 Hello World 然后我们新建一个 test.ts 的文件，代码如下： 12var message:string = \"Hello World\" console.log(message) .ts 为 TypeScript 代码文件的扩展名。 然后执行以下命令将 TypeScript 转换为 JavaScript 代码： 1$ tsc test.ts 这时候再当前目录下（与 test.ts 同一目录）就会生成一个 test.js 文件，代码如下： 12var message = \"Hello World\";console.log(message); 使用 node 命令来执行 test.js 文件： 12$ node test.jsHello World","link":"/2020/06/30/TypeScript/"},{"title":"Icarus主题美化","text":"Icarus用户指南 - 主题美化Icarus的主题样式编码文件为themes/icarus/layout/layout.jsx。此文件定义了站点全局的样式设置。本文详细介绍了本主题针对文章分类的详细配置说明。 自定义 Icarus 主题 主题默认是三列排列，第一列是个人信息，第二列是文章的简介或者内容，第三列是标签云等组件。 在首页的时候阅读体验也很好，但是在文章页面查看全文的时候就感觉文章内容显示有些太少。 于是打算在文章页面隐藏掉右边的侧边栏。 我想应该是我用的icarus主题版本是3+，网上都是2+版本的教程，没有找到对应教程。 于是就自己阅读源码自己解决了问题。 默认配置也基本能用了，但是有一个痛点就是，阅读模式文章宽度太短了，还是根据个人习惯做下配置。 解决方案 1. 首先找到了控制侧边栏的代码文件在 ../themes/icarus/layout/layout.jsx 源码为(版本差别，大同小异)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445const { Component } = require('inferno');const classname = require('hexo-component-inferno/lib/util/classname');const Head = require('./common/head');const Navbar = require('./common/navbar');const Widgets = require('./common/widgets');const Footer = require('./common/footer');const Scripts = require('./common/scripts');const Search = require('./common/search');module.exports = class extends Component { render() { const { env, site, config, page, helper, body } = this.props; const language = page.lang || page.language || config.language; const columnCount = Widgets.getColumnCount(config.widgets); return &lt;html lang={language ? language.substr(0, 2) : ''}&gt; &lt;Head env={env} site={site} config={config} helper={helper} page={page} /&gt; &lt;body class={`is-${columnCount}-column`}&gt; &lt;Navbar config={config} helper={helper} page={page} /&gt; &lt;section class=\"section\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"columns\"&gt; &lt;div class={classname({ column: true, 'order-2': true, 'column-main': true, 'is-12': columnCount === 1, 'is-8-tablet is-8-desktop is-8-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3 })} dangerouslySetInnerHTML={{ __html: body }}&gt;&lt;/div&gt; &lt;Widgets site={site} config={config} helper={helper} page={page} position={'left'} /&gt; &lt;Widgets site={site} config={config} helper={helper} page={page} position={'right'} /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;Footer config={config} helper={helper} /&gt; &lt;Scripts site={site} config={config} helper={helper} page={page} /&gt; &lt;Search config={config} helper={helper} /&gt; &lt;/body&gt; &lt;/html&gt;; }}; 三栏分别为：（从第24行开始） 12345678&lt;div class={classname({ column: true, 'order-2': true, 'column-main': true, 'is-12': columnCount === 1, 'is-8-tablet is-8-desktop is-8-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3 })} dangerouslySetInnerHTML={{ __html: body }}&gt;&lt;/div&gt; // 中 1&lt;Widgets site={site} config={config} helper={helper} page={page} position={'left'} /&gt; // 左 1&lt;Widgets site={site} config={config} helper={helper} page={page} position={'right'} /&gt; //右 2. 那能不能逻辑改为只有主页才显示右边侧栏呢？ 我从源码中分析到，函数返回return的就是样式页面。既然找到了这3栏，我可以通过改变返回值，就可以达到控制主体样式的目的。 所以加一个判断语句即可： 12345678if(page.path==='index.html'){ // index.html即主页面 // 返回3栏 return '...';}else{ // 返回2栏，改变宽度即可 return '...';} 上面代码只会在主页面显示3栏，后续博主我在使用的过程中发现有且只有主页面是3栏；换页、分类页等页面就会变成2栏！ 因为我们的代码只为主页面返回3栏！ 后来在读源码后，找到了解决方法：在 ../themes/icarus/layout/layout.jsx 文件中第16行添加如下代码：12console.log(\"Page\", page);console.log(\"Page.path: \", page.path);这样就可以查看页面具体信息；控制台执行hexo g -d后，会出现以下信息；由于每个page信息可能会很多，尤其是博客文章内容过多，就会使page包含的信息过多，会使控制台信息溢出；所以我只选择其中一个较短的信息展示如下： 2.1 page信息12345678910111213Page: { base: 'tags/Hexo/', total: 1, current: 1, current_url: 'tags/Hexo/', posts: _Query { data: [ [_Document], [_Document] ], length: 2 }, prev: 0, prev_link: '', next: 0, next_link: '', tag: 'Hexo', path: 'tags/Hexo/index.html', lang: 'en', canonical_path: 'tags/Hexo/index.html' } 2.2 page.path信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354ubuntu~/github/mysticalguest.github.io$ hexo g -dInferno is in development mode.INFO ======================================= ██╗ ██████╗ █████╗ ██████╗ ██╗ ██╗███████╗ ██║██╔════╝██╔══██╗██╔══██╗██║ ██║██╔════╝ ██║██║ ███████║██████╔╝██║ ██║███████╗ ██║██║ ██╔══██║██╔══██╗██║ ██║╚════██║ ██║╚██████╗██║ ██║██║ ██║╚██████╔╝███████║ ╚═╝ ╚═════╝╚═╝ ╚═╝╚═╝ ╚═╝ ╚═════╝ ╚══════╝=============================================INFO === Checking package dependencies ===INFO === Checking the configuration file ===INFO === Registering Hexo extensions ===INFO Start processingINFO Files loaded in 6.76 sPage.path: 2020/06/18/ICARUS主题美化/Page.path: 2020/06/17/数据结构进阶实训八/Page.path: 2020/06/17/数据结构进阶实训五/Page.path: 2020/06/17/数据结构进阶实训二/Page.path: 2020/06/17/数据结构进阶实训一/Page.path: 2020/06/17/数据结构进阶实训六/Page.path: 2020/06/17/数据结构进阶实训七/Page.path: 2020/06/16/Java笔记文档2/Page.path: 2020/06/16/Java笔记文档1/Page.path: 2020/06/15/数据结构进阶实训三/Page.path: 2020/06/15/数据结构进阶实训四/Page.path: 2020/06/14/hello-world/Page.path: archives/index.htmlPage.path: archives/page/2/index.htmlPage.path: archives/2020/index.htmlPage.path: archives/2020/page/2/index.htmlPage.path: archives/2020/06/index.htmlPage.path: archives/2020/06/page/2/index.htmlPage.path: categories/配置/index.htmlPage.path: categories/Document-Compile/index.htmlPage.path: categories/主题/index.htmlPage.path: categories/算法/index.htmlPage.path: index.htmlPage.path: page/2/index.htmlPage.path: tags/Hexo/index.htmlPage.path: tags/Java/index.htmlPage.path: tags/C/index.htmlPage.path: categories/index.htmlPage.path: tags/index.htmlINFO 0 files generated in 3.37 sINFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder...INFO Copying files from extend dirs...位于分支 master无文件要提交，干净的工作区分支 'master' 设置为跟踪来自 'git@github.com:*/*.git' 的远程分支 'master'。Everything up-to-dateINFO Deploy done: git 从控制台打印出的信息，可以明显看出每个页面的详细路径信息；所以我们想要那些页面3栏都可以；12345678910var path = /\\Sindex.html/; if(page.path==='index.html' || path.test(page.path)){ // 返回3栏 return '...';}else{ // 返回2栏，改变宽度即可 return '...';} 这里我利用正则表达式，将非博客文章页面都设为3栏显示，大家可根据自己喜好自行对想要的页面设置指定栏数。 3. 其他修改逻辑 +表示添加代码，没有标记表示代码不做修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 从16行开始修改代码+ if(page.path==='index.html'){ return &lt;html lang={language ? language.substr(0, 2) : ''}&gt; &lt;Head env={env} site={site} config={config} helper={helper} page={page} /&gt; &lt;body class={`is-${columnCount}-column`}&gt; &lt;Navbar config={config} helper={helper} page={page} /&gt; &lt;section class=\"section\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"columns\"&gt; &lt;div class={classname({ column: true, 'order-2': true, 'column-main': true, 'is-12': columnCount === 1, 'is-8-tablet is-8-desktop is-8-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3 })} dangerouslySetInnerHTML={{ __html: body }}&gt;&lt;/div&gt; &lt;Widgets site={site} config={config} helper={helper} page={page} position={'left'} /&gt; &lt;Widgets site={site} config={config} helper={helper} page={page} position={'right'} /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;Footer config={config} helper={helper} /&gt; &lt;Scripts site={site} config={config} helper={helper} page={page} /&gt; &lt;Search config={config} helper={helper} /&gt; &lt;/body&gt; &lt;/html&gt;;+ }+ else{+ return &lt;html lang={language ? language.substr(0, 2) : ''}&gt;+ &lt;Head env={env} site={site} config={config} helper={helper} page={page} /&gt;+ &lt;body class={`is-${columnCount}-column`}&gt;+ &lt;Navbar config={config} helper={helper} page={page} /&gt;+ &lt;section class=\"section\"&gt;+ &lt;div class=\"container\"&gt;+ &lt;div class=\"columns\"&gt;+ &lt;div class={classname({+ column: true,+ 'order-2': true,+ 'column-main': true,+ 'is-12': columnCount === 1,+ 'is-8-tablet is-8-desktop is-10-widescreen': columnCount === 2+ })} dangerouslySetInnerHTML={{ __html: body }}&gt;&lt;/div&gt;+ &lt;Widgets site={site} config={config}helper={helper} page={page} position={'left'}/&gt;+ &lt;/div&gt;+ &lt;/div&gt;+ &lt;/section&gt;+ &lt;Footer config={config} helper={helper} /&gt;+ &lt;Scripts site={site} config={config} helper={helper} page={page} /&gt;+ &lt;Search config={config} helper={helper} /&gt;+ &lt;/body&gt;+ &lt;/html&gt;;+ } 好啦，大工告成！ 其中只有两处代码改动较大，让我们来看看吧！ 我们只是修改了栏数，但每一栏的宽度没有改变，这里更关注的是文章栏的宽度。具体修改代码下： 1234// 渲染相应栏的标签，只添加‘中’和‘左’// 根据自己的喜好可以选择任意组合，‘中’和‘右’也可以// 第45行'is-8-tablet is-8-desktop is-10-widescreen': columnCount === 2 即将原来的 is-8-widescreen修改为is-10-widescreen。 4. 下面详细解释一下代码 icarus 可以设置资料、toc、归档等等插件在文章的左侧或者右侧。也就是说，包括插件和文章在内，列数在1~3列不等： 无插件的时候，为1列；插件统一在左侧或右侧时，为2列；插件左、右侧都有时，为3列。Bulma 引擎将屏幕横向分为12份，所有元素按照自己的需求使用即可。 通过 layout或widget.jsx 文件，我们可以看到，对于插件而言： 如果屏幕分为2列，则插件的宽度为 is-4-widescreen，也即是4/12=33.33%的宽度；如果屏幕分为3列，则插件的宽度为 is-3-widescreen，也即是3/12=25%的宽度，两列插件占了50%宽。同样的，layout.jsx 文件针对文章也做了宽度限制： 如果屏幕分为1列，则文章的宽度为 is-12，也即是12/12=100%的宽度；如果屏幕分为2列，则文章的宽度为 is-8-widescreen，也即是8/12=66.66%的宽度；如果屏幕分为3列，则文章的宽度为 is-6-widescreen，也即是6/12=50%的宽度。 那么调整插件宽度的方法也就差不多想出来啦！","link":"/2020/06/21/ICARUS%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"},{"title":"高级操作系统","text":"文件系统 课堂笔记 1.文件与文件系统文件：具有符号名的一组相关元素的集合。 通常，文件由记录组成，记录用于描述对象的属性，记录又可包含若干个数据项。 文件系统是OS中管理文件的子系统，它实现文件的存储、检索、更新、共享和保护等，并为用户提供方便有效的文件使用和操作方法。 1.1 文件系统的功能 文件的按名存取 文件目录建立和维护 实现逻辑文件到物理文件的转换 文件存储空间的分配和管理 提供合适的文件存取方法 实现文件的共享、保护和保密 提供一组可供用户使用的文件操作 1.2 文件系统的优点使用方便：由于文件系统实现了案名存取，因而用户无需关心文件存放的物理位置数据安全：文件系统可以提供各种保护措施，防止用户对文件有意或无意的破坏接口统一：用户可以使用统一的接口来操作各种介质上的文件 1.3 文件系统的分层结构 文件管理—实现文件的逻辑结构，为用户提供各种文件系统调用，及种文件系统调用，及文件访问权限的设置等工作； 目录管理—负责查找文件描述符，进而找到需要访问的文件，及进行访问权限检查等工作; 外存映射管理—将文件的逻辑地址转换成磁盘的物理地址，即由逻辑块号找到柱面号、磁道号和扇区号，具体的数据传输操作由设备管理实现。 2 文件的存取存取方法是操作系统为用户程序提供的使用文件的技术和手段。 存取方法（决定和影响着文件的物理结构） ​ -顺序存取：若当前存取的记录是Ri，则下次必存取Ri+1 ​ -直接（随机）存取 ​ -索引存取 ​ -按（键）值存取 2.1 文件的操作对记录的操作：检索、插入、删除、修改 对文件的操作：创建文件、删除文件、打开文件、关闭文件、读文件、写文件 3 文件目录与文件检索 通过文件目录实现文件的“按名存取”； 文件系统基本功能之一是负责文件目录的建立、维护和检索。 存放管理文件所需信息的数据结构即文件目录，一个文件的文件目录即其目录项又称文件控制块FCB（File Control Block）： -文件和文件控制块是一一对应的； -FCB通常包括：文件名、用户名、类型、文件结构、建立日期、存取权限、物理地址等 3.1 文件目录与目录项目录文件：把FCB集中起来，组成文件，保存于外存，这个文件称作目录文件 文件检索：给定一个文件名，查找相应的目录文件找到该文件所对应的目录项 3.1.1 单级目录整个系统只有一张目录表，所有文件均登记在该表中，每个文件占有一项。 目录表存放在存储设备的固定地方，系统启动时调用内存。 单级目录的优点是非常简单，但： ​ -不允许重名 ​ -查找速度慢 3.1.2 二级目录 系统设置唯一一个主文件目录MFD（Master File Directiry）。 每个用户设立一个用户文件目录UFD（User）。UFD由该用户所有文件的FCB构成。 每个UFD在MFD中占有一个目录项，其中包括用户名和指向该用户文件的指针。 优点： ​ -提高了查找速度​ -解决了重名问题 3.1.3 多级目录 树形目录结构，最高层是根目录，最低层是数据文件，其他是目录文件。 3.1.4 层级目录结构 每一级目录即可以包含下一级目录(即目录文件的目录项)，也可以包含具体文件(即具体文件的目录项)，形成层次关系。 多级目录结构采用树形结构，是一棵倒向有根树，树根是根目录；从根向下，每个树枝是一个子目录；而树叶是文件。 树型多级目录优点：组织灵活、便于命名、检索高效。 3.1.5 UNIX/Linux目录项文件名 inode节点号14字节 2字节0号目录项和索引节点 思考：UNIX使用i-node的好处是什么? ➢因为按文件名检索目录文件时，只用到了文件名。当找到该文件名时，才需要它的其它描述信息。所以在把存放该目录文件的盘块从外存调入内存进行比较时，应使一个盘块中包含尽量多的文件名，以减少访问磁盘次数，加快文件检索速度。 例:设物理块大小为512B,某目录下有128个文件。 原来的FCB占64B，则每物理块能容纳512/64=8个FCB，则该目录文件需占128/8= 16块，查找一个文件的平均访盘次数为:(1+16) /2= 8.5次。 采用i-node后:文件名部分有16B，i-node部 分有64B，每物理块能容纳512/16=32个文件名部分或512/64=8个i-node，则该目录的文件名部分需占128/32=4块，i-node部分需占128/8=16块。查找一个文件的平均访盘次数为:(1+4) /2+1=3.5次。 4 文件逻辑结构与数据存储 文件的逻辑结构：用户所看到的文件结构 -记录式文件，文件由若干记录所构成 -流式文件，文件由若干字符（字节）序列构成 文件的物理结构：文件在外存的存放形式 -顺序文件:逻辑文件中的信息顺序地存放在相邻的物理块中 -链接文件:文件中的信息不是顺序排列的，它们可以存放在不相邻的物理块中，通过指针连接成链表索引文件:为每一文件建立一个索引表，用以实现逻辑记录和物理块号之间的映射 4.1 文件结构与文件存储物理块是存储介质上连续信息所组成的一个区域。 块是主存储器和辅助存储设备信息交换的物理单位，每次交换一块或整块数。 决定块的大小要考虑到用户使用方式、数据传输效率和存储设备类型等多种因素。 不同类型的存储介质，块的大小常常各不相同；同一类型的存储介质，块的大小也可以不同。 间隙是块之间不记录用户代码信息的空闲区城。 4.2 文件的逻辑结构文件的逻辑结构是用户所见的信息组织方式。 文件的逻辑结构分为：流式文件，记录式文件。 流式文件指文件内的数据不再组成记录，只是依次的一串信息(字节)集合。 流式文件常按字节数来读取所需信息，也可用插入特殊字符作为分界。 记录式文件由逻辑记录组成，逻辑记录具有特定的逻辑含意。 4.3 记录组块和分解逻辑记录和块的关系： 逻辑记录是按信息的逻辑含义所划分的单位，块是存储介质上连续的存储区域。 逻辑记录存放到文件存储器上时，一个记录可能占用一块或多块，也可能多个存放到一个物理块中。 记录组块—将多个记录置于一个存储块中。 记录分解—从存储块中分解出逻辑记录。 块因子—一个存储块中包含多少个记录。 4.4 记录组块4.4.1 需考虑的问题： 块的长度是固定的还是可变的? ​ -大多数系统中，块的固定长度的的。 与记录的平均大小相比，块的相对大小是多少？ ​ -综合考虑顺序访问的频率和访问的局部性潜能，倾向于用大的块，以减少I/O传送时间。 4.4.2 记录组块的方法固定组块 可变长度跨越式组块 可变长度非跨越式组块 5.文件存储器管理5.1 空闲盘块管理-》磁盘分配表 -》常用的空闲空间管理技术 ​ -位示图 ​ -空闲块列表 ​ -空闲区链表 ​ -空闲块索引 -》文件卷 ​ -一组在辅助存储上可寻址的扇区的集合，操作系统或应用程序用卷来存储数据。一个卷中的扇区在物理上并不需要是连续的，只需要对操作系统或应用程序来讲是连续的。一个卷可能是更小的卷合并或组合后的结果。 5.2文件存储空间管理5.2.1 预分配与动态分配 预分配策略要求在发出创建文件的请求时，声明该文件的最大大小。 ​ -若不能可靠地估计文件可能的最大大小，通常会多估计一些，以避免分配的空间不够。—浪费 动态分配只有在需要时才给文件分配空间。 ​ -当创建一个新文件时，是否一次性地分配所需要的最大空间？ 预分配与动态分配 ​ -在分配时，采用什么分配策略? ​ a.可变大小的连续分区(类似分区式) ​ b.大小相等但不连续的块(类似页式) ​ c.采用什么数据结构记录分配给文件的空间?—文件分配表 5.2.2 分配策略 文件分配时，需要综合考虑单个文件的效率和整个系统的效率 ​ -连续空间可以提高磁盘访问性能； ​ -使用可变大小的分区，可以减少由于超额分配而产生的未使用存储空间的派费； ​ -使用固定大小的分区可以简化空间的再分配； ​ -数目较多的小分区会增加用于管理分配信息表的大小。 综合考虑的两种选择: ​ -可变大小的连续分区 ​ a.大小可变避免了浪費，文件分配表比较小 ​ b.空间很难再次利用 ​ -大小相等但不连续的块 ​ a.小的固定分区提供了更多的灵活性 ​ b.可能需要较大的文件分配表或更复杂的结构 6.文件的物理结构文件的物理结构是指文件在物理存储空间中存放(分配)的形式，亦称为文件的物理组织。 文件的物理结构涉及：块的划分、记录的排列索引的组织、信息的搜索，其优劣直接影响文件系统的性能。 文件的物理结构：顺序文件、链式文件、索引文件、直接文件 6.1 顺序文件（连续文件） 将一个文件存放到文件存储器连续的物理块中，便形成了顺序文件。 顺序文件中逻辑记录和物理记录顺序完全一致。通常记录按次序被读出或修改。 顺序文件的优点/缺点：读写高效/改变大小困难，磁盘碎片问题。File Allocation Table 6.2 链式文件（串联文件） 链式文件通过链指针将存放文件内容的各物理块联系起来 连接结构的优/缺点：文件读写效率低/易于扩展，不存在磁盘碎片问题 6.3 直接文件（哈希文件） 通过hash函数在记录的关键字与其存储地址之间建立关系，据此实现存取即称为直接文件。 文件控制块 6.4 索引文件（链式文件的高效实现，现在几乎都采用）索引结构是实现非连续存储的另一种方法，适用于数据记录保存有随机存取存储设备上的文件。 使用索引表，其中登记了存放文件的物理块。 如果块长4KB (即索引块和数据块长4K)，每个指针(盘块号) 4B，则采用这种索引分配时，允许的文件最大尺寸是多少? 直接地址: 10X 4KB= 40KB 一级索引: 4KBX (4KB/4B)= 4MB 二级索引: 4KBX (4KB/4B)2= 4GB 三级索引: 4KB X (4KB/4B)3= 4TB 合计大小: 40KB+4MB+4GB+4TB 6.文件共享与保护 访问权限 ​ -无 ​ -知道 ​ -执行 ​ -读 ​ -追加 ​ -更新 ​ -改变保护 ​ -删除 同时访问 ​ -加锁 ​ -互斥和死锁问题 6.1 文件共享6.1.1 基于目录指针实现文件共享允许一个文件可以有多个父目录，即有多个属于不同用户的目录，同时指向同一个文件，即可实现文件共享(但这会破坏树的特性一多个父节点! ) 6.1.2 利用索引节点利用索引结点，存放文件的物理地址、文件属性和文件共享与保护相关信息，而不同用户在其文件目录中设置共性文件的别名及指向相应索引结点的指针。 6.1.3 利用符号链实现共享由操作系统为被共享文件的创建一个LINK类型的文件(即该共享文件的路径名，称为符号链)，用户通过在自己的文件目录中包含指向该符号链文件的方法实现文件共享。 6.2 文件保护利用符号链实现共享的优缺点 优点：只有文件主才拥有指向其索引结点的指针，而其他共享用户则只有该文件的路径名，因此不会因文件主删除一个共享 文件后留下悬空指针的问题。共享者通过符号链访问一个已被删除的共享文件将会访问失败时，则删除符号链。 缺点：用户访问共享文件时，系统是根据给定的文件路径名逐个分量(名)去查找目录，直至找到该文件的索引结点。因此，可能要多次读盘，开销大。此外，要为每个共享用户建立一条符号链，而由于链本身实际上是一个文件，也要为它分配索引结点，这也要耗费磁盘空间。 文件保护用于防止文件被破坏。包括两个方面: ​ 一是防止系统崩溃所造成的文件破坏; ​ 二是防止文件主和其他用户有意或无意的非法操作所造成的文件不安全性。 防止系统崩溃造成文件破坏的方法: ​ ➢定时转储 ​ ➢多副本 防止非法操作的方法:基本思想是建立三元组: (用户、 对象、存取权限)—访问控制 访问矩阵 ​ -主体 ​ -对象 访问权限 6.3 UNIX文件保护 UNIX/Linux把用户分为3类：文件主、同组用户、其他用户 定义3种存取权限：可读r、可写w、可执行x。文件属性共有10位： ​ -rwxrwxrwx","link":"/2020/07/01/OS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"title":"Electron+vue-cli3开发跨平台桌面应用","text":"一步一步搭建Electron+vue-cli3开发平台（亲测有效） Electron是一个基于Chromium和 Node.js，可以使用 HTML、CSS和JavaScript构建跨平台应用的技术框架，兼容 Mac、Windows 和 Linux。虽然B/S是目前开发的主流，但是C/S仍然有很大的市场需求。受限于浏览器的沙盒限制沙盒（英语：sandbox，又译为沙箱），计算机专业术语，在计算机安全领域中是一种安全机制，为运行中的程序提供的隔离环境。通常是作为一些来源不可信、具破坏力或无法判定程序意图的程序提供实验之用。网页应用无法满足某些场景下的使用需求，而桌面应用可以读写本地文件、调用更多系统资源，再加上Web开发的低成本、高效率的优势，这种方式越来越受到开发者的喜爱。 这篇博客一步一步教你如何使用Electron和vue-cli3，在完全保留vue开发web应用的习惯下，搭建桌面应用。 这篇博客不涉及Electron和vue的开发教程，仅以实现两者结合为目的，若要深入学习Electron和vue，请访问官方： Electron Vue Vue-cli Stylus 学习该框架之前，希望读者需要提前掌握以下技能： HTML、CSS、JavaScript Vue2.x Stylus 1.创建项目1.1 安装NodejsNode.js 中文网下载安装 1.2 使用cnpm加速下载npm有时下载速度很慢，可以安装cnpm，从国内淘宝镜像下载，执行以下命令： $ npm install -g cnpm --registry=https://registry.npm.taobao.org 之后所有的npm命令都可以直接替换成cnpm使用了。 1.3 为什么不使用electron-vue搭建呢Electron-vue官方中文文档 由于SimulatedGREG/electron-vue已经很久没有更新了，而且其生成的工程结构并不是vue-cli3。所以放弃使用。 1.4 安装/升级vue-cli3 先执行以下命令，确认下本地安装的vue-cli版本（如果自己的电脑没有安装过vue，跳过前两步到第三步吧！）： $ vue -V或$ vue --version 在写本篇博客时，我的vue是2.9.6版本。 如果本地使用的是vue-cli2.x或者更早版本，可先执行下面命令全局卸载： $ cnpm uninstall vue-cli -g （1）vue-cli3使用了新的npm包名，与旧版本不一样。 （2）在vue2.9.6下执行上面命令，控制台输入vue -V仍然有输出，解决方法： ​ a. 当然, 卸载命令还是要执行的: 全局卸载：npm uninstall vue-cli -g; ​ b. npmrc文件删除掉 ​ c. 检索删除vue-cli文件夹 ​ 再试试: vue -V，就不显示版本号了。 （3）可以忽略上述问题，直接安装最新版本的vue-cli3即可（亲测有效）。 执行以下命令全局安装vue-cli3： $ cnpm install @vue/cli -g 执行以下命令升级vue-cli3： $ cnpm update @vue/cli -g 1.5 创建vue项目 在指定目录下，打开终端，执行以下命令，创建vue项目： $ vue create electron-vue-demo 这里的项目名称为electron-vue-demo（不能出现大写字母），可根据自己的具体项目改变。 创建命令执行后，在完成创建之前，会出现以下选项（如果熟悉此步骤可跳过本节内容）： 1234Vue CLI v4.4.6? Please pick a preset: (Use arrow keys) default (babel, eslint) &gt; Manually select features 选择 Manually select features （自定义安装）。 1234567891011? Check the features needed for your project: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)&gt;(*) Babel ( ) TypeScript ( ) Progressive Web App (PWA) Support (*) Router (*) Vuex (*) CSS Pre-processors (*) Linter / Formatter ( ) Unit Testing ( ) E2E Testing 这里选择了常用的模块，请根据实际需求进行选择。 12? Use history mode for router? (Requires proper server setup for index fallback in production) (Y/n)n 如果选择了router，这里会询问是否使用history模式。 vue-router 默认使用hash模式（即通过url#hash来跳转页面），使用URL的hash来模拟一个完整的 URL，当URL改变时，页面不会重新加载。 如果使用history模式，URL就像正常的url，例如 http://yoursite.com/page，比较好看。但是还需要后台配置支持。 这里我们选择n。 123456? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): (Use arrow keys) Sass/SCSS (with dart-sass) Sass/SCSS (with node-sass) Less &gt; Stylus 选择CSS预处理模块，这里我们使用Stylus。 12345? Pick a linter / formatter config: (Use arrow keys) ESLint with error prevention only ESLint + Airbnb config &gt; ESLint + Standard config ESLint + Prettier 选择ESLint代码格式检查工具的配置，选择ESLint + Standard config，标准配置。 123? Pick additional lint features: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)&gt;(*) Lint on save ( ) Lint and fix on commit Line on save表示在保存代码的时候，进行格式检查。 Lint and fix on commit表示在$ git commit的时候自动纠正格式。 这里只选择Lint on save。 123? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? In dedicated config files &gt; In package.json 这里问把 babel，postcss，eslint 这些配置文件放哪？ In dedicated config files表示独立文件。 In package.json表示放在package.json里。 这里选择In package.json。 1? Save this as a preset for future projects? (y/N) N 是否为以后的项目保留这些设置？选择N。 然后耐心等待项目安装完成。 1.6 自动安装Electron 执行以下命令，进入项目目录： $ cd electron-vue-demo 然后执行以下命令： $ vue add electron-builder electron-builder是一个简单又强大的库。解决了打包这个棘手的问题，而且可以应对大部分的打包需求。 接下来出现配置选项： 1234? Choose Electron Version (Use arrow keys) ^7.0.0 ^8.0.0 &gt; ^9.0.0 选择Electron版本，我写这篇博客的时候，选项是上面3个版本，选择最新的即可。 然后耐心等待安装完成。 1.7 手动安装Electron 修改package.json，添加以下7行： 1234567891011121314151617181920212223242526272829303132333435363738...\"scripts\": { \"serve\": \"vue-cli-service serve\", \"build\": \"vue-cli-service build\", \"lint\": \"vue-cli-service lint\", \"electron:build\": \"vue-cli-service electron:build\", // add \"electron:serve\": \"vue-cli-service electron:serve\", // add \"postinstall\": \"electron-builder install-app-deps\", // add \"postuninstall\": \"electron-builder install-app-deps\" // add},\"main\": \"background.js\", // add\"dependencies\": { \"core-js\": \"^3.6.5\", \"vue\": \"^2.6.11\", \"vue-router\": \"^3.2.0\", \"vuex\": \"^3.4.0\"},\"devDependencies\": { \"@vue/cli-plugin-babel\": \"~4.4.0\", \"@vue/cli-plugin-eslint\": \"~4.4.0\", \"@vue/cli-plugin-router\": \"~4.4.0\", \"@vue/cli-plugin-vuex\": \"~4.4.0\", \"@vue/cli-service\": \"~4.4.0\", \"@vue/eslint-config-standard\": \"^5.1.2\", \"babel-eslint\": \"^10.1.0\", \"electron\": \"^9.0.5\", // add \"eslint\": \"^6.7.2\", \"eslint-plugin-import\": \"^2.20.2\", \"eslint-plugin-node\": \"^11.1.0\", \"eslint-plugin-promise\": \"^4.2.1\", \"eslint-plugin-standard\": \"^4.0.0\", \"eslint-plugin-vue\": \"^6.2.2\", \"stylus\": \"^0.54.7\", \"stylus-loader\": \"^3.0.2\", \"vue-cli-plugin-electron-builder\": \"~2.0.0-rc.3\", // add \"vue-template-compiler\": \"^2.6.11\"},... 新建src/background.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394'use strict'import { app, protocol, BrowserWindow } from 'electron'import { createProtocol, installVueDevtools} from 'vue-cli-plugin-electron-builder/lib'const isDevelopment = process.env.NODE_ENV !== 'production'// Keep a global reference of the window object, if you don't, the window will// be closed automatically when the JavaScript object is garbage collected.let win// Scheme must be registered before the app is readyprotocol.registerSchemesAsPrivileged([ { scheme: 'app', privileges: { secure: true, standard: true } }])function createWindow() { // Create the browser window. win = new BrowserWindow({ width: 1000, height: 600, webPreferences: { // Use pluginOptions.nodeIntegration, leave this alone // See nklayman.github.io/vue-cli-plugin-electron-builder/guide/security.html#node-integration // for more info // nodeIntegration: process.env.ELECTRON_NODE_INTEGRATION webSecurity: false, nodeIntegration: true } }) if (process.env.WEBPACK_DEV_SERVER_URL) { // Load the url of the dev server if in development mode win.loadURL(process.env.WEBPACK_DEV_SERVER_URL) if (!process.env.IS_TEST) win.webContents.openDevTools() } else { createProtocol('app') // Load the index.html when not in development win.loadURL('app://./index.html') } win.on('closed', () =&gt; { win = null })}// Quit when all windows are closed.app.on('window-all-closed', () =&gt; { // On macOS it is common for applications and their menu bar // to stay active until the user quits explicitly with Cmd + Q if (process.platform !== 'darwin') { app.quit() }})app.on('activate', () =&gt; { // On macOS it's common to re-create a window in the app when the // dock icon is clicked and there are no other windows open. if (win === null) { createWindow() }})// This method will be called when Electron has finished// initialization and is ready to create browser windows.// Some APIs can only be used after this event occurs.app.on('ready', async () =&gt; { if (isDevelopment &amp;&amp; !process.env.IS_TEST) { // Install Vue Devtools try { await installVueDevtools() } catch (e) { console.error('Vue Devtools failed to install:', e.toString()) } } createWindow()})// Exit cleanly on request from parent process in development mode.if (isDevelopment) { if (process.platform === 'win32') { process.on('message', (data) =&gt; { if (data === 'graceful-exit') { app.quit() } }) } else { process.on('SIGTERM', () =&gt; { app.quit() }) }} 以上代码是1.6小节使用自动化方式安装后生成的。 安装依赖包 在项目目录下执行以下命令，安装全部依赖包： $ cnpm install 1.8 编译并启动APP 执行以下命令，开始编译APP，并启动开发环境APP： $ npm run electron:serve或$ yarn electron:serve 首次启动可能会等待很久，加载完后会自动打开APP，等待即可。 编译成功后，就会出现开发环境的APP了，如下图（Win10启动界面）： 当回到控制台，发现控制台的信息： 1234567INFO Launching Electron...Failed to fetch extension, trying 4 more timesFailed to fetch extension, trying 3 more timesFailed to fetch extension, trying 2 more timesFailed to fetch extension, trying 1 more timesFailed to fetch extension, trying 0 more timesVue Devtools failed to install: Error: net::ERR_CONNECTION_TIMED_OUT 这是因为在请求安装vuejs devtools插件。需要翻墙才能安装成功。可以忽略上面的问题，耐心等待5次请求失败后会自动跳过，上面的成功界面即证实跳过依然编译成功。 依然有解决方案： 注释掉src/background.js中的以下代码就行了： 12345678910/* if (isDevelopment &amp;&amp; !process.env.IS_TEST) { // Install Vue Devtools try { await installVueDevtools(); } catch (e) { console.error(\"Vue Devtools failed to install:\", e.toString()); } }*/ 2.配置项目2.1 配置ESLint代码格式检查工具ESlint可以高效的检查代码格式，让参与项目的所有工程师都能保持统一的代码风格。其检测精度甚至可以精确到是否多一个空格或者少一个空格。代码格式的统一对提高团队的协同开发效率有很大的帮助，特别是对有代码洁癖的工程师。 在项目根目录下创建.eslintrc.js （注意文件名前面有个.） 请粘贴以下代码： 123456789101112131415161718192021222324module.exports = { root: true, env: { node: true }, 'extends': [ 'plugin:vue/essential', '@vue/standard' ], rules: { 'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off', // 不检测语句末尾的分号 'semi': ['off', 'always'], // 强制缩进为2个空格 'indent': ['error', 2], // 关闭函数名称跟括号之间的空格检测 'space-before-function-paren': 0, // 忽略大括号内的空格 'object-curly-spacing': 0 }, parserOptions: { parser: 'babel-eslint' }} 这里说明下关于indent缩进的配置，要配合项目根目录下的.editorconfig 12345[*.{js,jsx,ts,tsx,vue}]indent_style = space &lt;--这里定义缩进类型是空格还是tabindent_size = 2 &lt;--这里需要与.eslintrc.js的indent对应trim_trailing_whitespace = trueinsert_final_newline = true .editorconfig 用于IDE自动格式化代码.eslintrc.js 用于ESlint检测 更多配置可参阅 ESLint教程。 2.2 配置vue在项目目录下创建vue.config.js，粘贴以下代码： 123456789101112131415161718192021const path = require('path');function resolve (dir) { return path.join(__dirname, dir);}module.exports = { publicPath: './', devServer: { // can be overwritten by process.env.HOST host: '0.0.0.0', port: 8080 }, chainWebpack: config =&gt; { config.resolve.alias .set('@', resolve('src')) .set('src', resolve('src')) .set('common', resolve('src/common')) .set('components', resolve('src/components')); }}; devServer 用于设置开发环境的服务，这里表示在本地8080端口启动web服务。 chainWebpack 我们给项目目录起了”别名(alias)”，在代码中，我们可以直接用“别名”访问资源，省去了每次输入完整相对路径的麻烦。 在js代码中可直接使用别名，例如： @/common/js/xxx.js 等价于 src/common/js/xxx.js common/js/xxx.js 等价于 src/common/js/xxx.js 在css或者html中使用别名，需要在别名前加“~”，例如： @import &quot;~common/stylus/font.styl&quot; 3.项目基本设定3.1 主进程和渲染进程简介在开始下面的步骤之前，很有必要简单了解下Electron的应用架构。 主进程 Electron 运行 package.json 的 main 脚本（background.js）的进程被称为主进程。 在主进程中运行的脚本通过创建web页面来展示用户界面。 一个 Electron 应用总是有且只有一个主进程。 渲染进程 由于 Electron 使用了 Chromium 来展示 web 页面，所以 Chromium 的多进程架构也被使用到。 每个 Electron 中的 web 页面运行在它自己的渲染进程中。 在普通的浏览器中，web页面通常在一个沙盒环境中运行，不被允许去接触原生的资源。 然而 Electron 的用户在 Node.js 的 API 支持下可以在页面中和操作系统进行一些底层交互。 主进程和渲染进程的关系 主进程使用 BrowserWindow 实例创建页面。 每个 BrowserWindow 实例都在自己的渲染进程里运行页面。 当一个 BrowserWindow 实例被销毁后，相应的渲染进程也会被终止。 主进程管理所有的web页面和它们对应的渲染进程。 每个渲染进程都是独立的，它只关心它所运行的 web 页面。 具体可参阅官方文档。 3.2 APP窗口大小修改background.js： 12345678910win = new BrowserWindow({ width: 1000, height: 600, webPreferences: { // Use pluginOptions.nodeIntegration, leave this alone // See nklayman.github.io/vue-cli-plugin-electron-builder/guide/security.html#node-integration // for more info nodeIntegration: process.env.ELECTRON_NODE_INTEGRATION } }) 3.3 取消跨域限制修改background.js： 123456789101112win = new BrowserWindow({ width: 1000, height: 600, webPreferences: { // Use pluginOptions.nodeIntegration, leave this alone // See nklayman.github.io/vue-cli-plugin-electron-builder/guide/security.html#node-integration // for more info // nodeIntegration: process.env.ELECTRON_NODE_INTEGRATION webSecurity: false, nodeIntegration: true } }) 3.4 取消菜单栏在我们生成的桌面APP中，我们可以看到默认的菜单栏。 在windows中，菜单栏在APP窗口内的顶部；在macOS中，菜单栏位于电脑屏幕顶部。 为了方便项目将来也能直接生成纯web应用，尽量把APP的全部功能都做到渲染进程里，这里我们取消菜单栏。 由于macOS的特殊性，顶部菜单栏无法删除，所以我们针对macOS特殊处理，把菜单栏只保留“关于”和“退出”。 修改background.js： 12345678910111213141516171819202122232425262728293031323334'use strict'// 添加Menu组件import { app, protocol, BrowserWindow, Menu } from 'electron'...function createWindow() { // Create the browser window. ... win.on('closed', () =&gt; { win = null }) createMenu()}// 设置菜单栏function createMenu() { // darwin表示macOS，针对macOS的设置 if (process.platform === 'darwin') { const template = [{ label: 'App Demo', submenu: [ {role: 'about'}, { role: 'quit' }] }] const menu = Menu.buildFromTemplate(template) Menu.setApplicationMenu(menu) } else { // windows及linux系统 Menu.setApplicationMenu(null) }} 改变后的APP界面样式： 更多关于菜单栏设置，请参阅：Electron官方API 3.5 设置APP窗口图标准备windows和macOS两版图标： Platform File Type Specification Windows app.ico 最小尺寸：256x256 MacOS app.png或app.icns 最小尺寸：512x512 把图标文件放到public/目录下，项目结构如下： 1234567891011121314151617|- /dist_electron |...|- /public |- app.icns |- app.ico |- app.png |- favicon.ico |- index.html|- /src |...|- .editorconfig |- .eslintrc.js|- .gitignore|- babel.config.js|- package.json|- package-lock.json|- README.md 可以顺便把favicon.ico也修改一下，但是在桌面版APP上是用不到的。如果以后生成纯web项目才会用到。 修改background.js，让APP窗口应用图标： 1234567891011function createWindow() { // Create the browser window. win = new BrowserWindow({ ... // eslint-disable-next-line no-undef icon: `${__static}/app.ico` }) ...} 这里的${__static}对应的是public目录 现在，Windows系统上可以看到开发环境的APP窗口图标已经生效了。 MacOS图标请参照4.1章节，并且需要在build后才能生效。 3.6 设置APP窗口标题栏名称修改public/index.html， 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt; &lt;link rel=\"icon\" href=\"&lt;%= BASE_URL %&gt;favicon.ico\"&gt; &lt;!-- 把'&lt;%= htmlWebpackPlugin.options.title %&gt;'改为App Demo --&gt; &lt;title&gt;My App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ... &lt;/body&gt;&lt;/html&gt; 4.打包这里我们已经集成了electron-builder工具，可以参阅官方文档。","link":"/2020/06/28/Electron+vue-cli3/"},{"title":"Vue整合Element-UI","text":"安装Element-UI Element-UI官方中文网 1 安装命令 在项目中打开终端，执行下面命令： $ cnpm i element-ui -S CDN 1234&lt;!-- 引入样式 --&gt;&lt;link rel=\"stylesheet\" href=\"https://unpkg.com/element-ui/lib/theme-chalk/index.css\"&gt;&lt;!-- 引入组件库 --&gt;&lt;script src=\"https://unpkg.com/element-ui/lib/index.js\"&gt;&lt;/script&gt; 官方教程 2 引入在项目的src/mian.js中引用element-ui： 12345678910111213141516import Vue from 'vue'import App from './App.vue'import router from './router'import store from './store'// 引入Element-UIimport ElementUI from 'element-ui';import 'element-ui/lib/theme-chalk/index.css';Vue.config.productionTip = falseVue.use(ElementUI);new Vue({ router, store, render: h =&gt; h(App)}).$mount('#app') 3 使用上述配置完成就可以使用Element-UI了，直接在组件中使用EL标签即可。","link":"/2020/06/29/Vue%E5%BC%95%E5%85%A5Element-UI/"},{"title":"Vue整合Axios","text":"Vue整合Axios，封装API Axios官方API 1.安装axios npm管理： $ cnpm i axios -S CDN：&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 2.封装axios在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json、客户端防御cSRF等。所以官方也是果断放弃了对其官方库vue-resource的维护，直接推荐我们使用axios库。如果还对axios不了解的，可以移步Axios官方API。 2.2 引入在项目的src目录中，新建一个request文件夹，然后在里面新建一个http.js；新建一个apis文件夹，然后在里面新建一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。 http.js文件： 123456789/* eslint-disable no-lone-blocks */// axios package// 引入axios，并加到原型链中import Vue from 'vue'import axios from 'axios'Vue.prototype.$axios = axios;Vue.prototype.$store = store;axios.defaults.baseURL = '/' // 关键代码 2.3 设置请求时间http.js文件： 1234...// 设置默认的请求超时时间。超过了10s，告知用户当前请求超时，请刷新等。axios.defaults.timeout = 10000; 2.4 post请求头设置post请求的时候，我们需要加上一个请求头，所以可以在这里进行一个默认的设置，即设置post的请求头为application/x-www-form-urlencoded;charset=UTF-8 http.js文件： 1axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8'; 2.5 请求拦截器在发送请求前可以进行一个请求的拦截，为什么要拦截呢？拦截请求是用来做什么的呢？ 比如，有些请求是需要用户登录之后才能访问的，或者post请求的时候，需要序列化我们提交的数据。这时候，我们可以在请求被发送之前进行一个拦截，从而进行我们想要的操作。 http.js文件： 12345678910111213141516171819202122232425262728293031...import store from '@/store/index' //@ 等价于/src这个目录.../* ============================== 拦截器 ============================== */// 请求拦截器axios.interceptors.request.use( config =&gt; { // 每次发送请求之前判断vuex中是否存在token // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况 // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断 console.log('请求拦截器config' + config.headers.Authorization); const token = store.state.token; console.log('store.state' + store.state); console.log('token:' + token); token &amp;&amp; (config.headers.Authorization = token); // 每次发送请求之前判断是否存在token // 如果存在，则统一在http请求的header都加上token，不用每次请求都手动添加了 // if (token) { // config.headers.Authorization = token; // } return config; }, error =&gt; { console.log('error:' + error); return Promise.error(error); }) token：一般是在登录完成之后，将用户的token通过localStorage或者cookie存在本地，然后用户每次在进入页面的时候（即在main.js中），会首先从本地存储中读取token，如果token存在说明用户已经登陆过，则更新vuex中的token状态。然后，在每次请求接口的时候，都会在请求的header中携带token，后台人员就可以根据你携带的token来判断你的登录是否过期，如果没有携带，则说明没有登录过。 那么每个请求都携带token，那么如果一个页面不需要用户登录就可以访问的怎么办呢？其实，前端的请求可以携带token，但是后台可以选择不接收的。 2.6 响应拦截器http.js文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677...// 响应拦截器axios.interceptors.response.use( // 请求成功 response =&gt; { // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据 // 否则的话抛出错误 console.log('响应拦截器' + response.status); if (response.status === 200) { console.log('响应拦截器' + response.status); return Promise.resolve(response); } else { return Promise.reject(response); } }, // 服务器状态码不是2开头的的情况 // 这里可以跟你们的后台开发人员协商好统一的错误状态码 // 然后根据返回的状态码进行一些操作，例如登录过期提示，错误提示等等 // 下面列举几个常见的操作，其他需求可自行扩展 // 请求失败 error =&gt; { console.log('响应拦截器error::' + error); console.log('响应拦截器码: ' + error.response.status); if (error.response.status) { switch (error.response.status) { // 401: 未登录 // 未登录则跳转登录页面，并携带当前页面的路径 // 在登录成功后返回当前页面，这一步需要在登录页操作。 case 401: { console.log('响应拦截器error::401'); console.log('401::' + router); console.log('401::' + router.currentRoute.fullPath); router.replace({ path: '/login', query: { redirect: router.currentRoute.fullPath } }); } break; // 403 token过期 // 登录过期对用户进行提示 // 清除本地token和清空vuex中token对象 // 跳转登录页面 case 403: // 清除token localStorage.removeItem('token'); store.commit('loginSuccess', null); // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面 setTimeout(() =&gt; { router.replace({ path: '/login', query: { redirect: router.currentRoute.fullPath } }); }, 1000); break; // 404请求不存在 case 404: router.replace({ path: '/login', query: { redirect: router.currentRoute.fullPath } }); break; // 其他错误，直接抛出错误提示 default: } return Promise.reject(error.response); } }) 响应拦截器很好理解，就是服务器返回给我们的数据，我们在拿到之前可以对他进行一些处理。 例如上面的思想：如果后台返回的状态码是200，则正常返回数据，否则的根据错误的状态码类型进行一些我们需要的错误，其实这里主要就是进行了错误的统一处理和没登录或登录过期后调整登录页的一个操作。 2.7 封装get方法和post方法常用的ajax请求方法有get、post、put等方法，axios对应的也有很多类似的方法。为了简化代码，还是要对其进行一个简单的封装。下面主要封装两个方法：get和post。 get方法 通过定义一个get函数，get函数有两个参数，第一个参数表示我们要请求的url地址，第二个参数是我们要携带的请求参数。get函数返回一个promise对象，当axios其请求成功时resolve服务器返回 值，请求失败时reject错误值。最后通过export抛出get函数。 http.js文件： 12345678910111213141516171819202122232425.../* ============================== 封装get方法和post方法 ============================== */// const Domain = \"http://255.255.255.0:8000\"; // 定义根域名const Domain = '';/** * get方法，对应get请求 * @param {String} url [请求的url地址] * @param {Object} params [请求时携带的参数] */export function get(action, params) { return new Promise((resolve, reject) =&gt; { // url 判断是测试环境 就要拿 测试环境的域名， 正式环境的就要用 正式域名 const url = Domain + action; axios.get(url, { params: params }).then(res =&gt; { resolve(res.data); }).catch(err =&gt; { reject(err.data) }) });} post方法 原理同get基本一样，但是要注意的是，post方法必须要使用对提交从参数对象进行序列化的操作，所以我们可以通过node的qs模块来序列化我们的参数。这个很重要，如果没有序列化操作，后台是拿不到提交的数据的。 可以通过import QS from 'qs'引入qs模块。 12345678910111213141516171819.../** * post方法，对应post请求 * @param {String} url [请求的url地址] * @param {Object} params [请求时携带的参数] */export function post(action, params) { return new Promise((resolve, reject) =&gt; { const url = Domain + action; axios.post(url, params) .then(res =&gt; { resolve(res.data); }) .catch(err =&gt; { reject(err.data) }) });} axios.get()方法和axios.post()在提交数据时参数的书写方式还是有区别的。区别就是，get的第二个参数是一个{}，然后这个对象的params属性值是一个参数对象的。而post的第二个参数就是一个参数对象。两者略微的区别要留意哦！ 封装完成啦！ 3.接口统一管理整齐的api就像电路板一样，即使再复杂也能很清晰整个线路。文件中存放所有的api接口。 在api.js中引入封装的get和post方法。 api.js文件： 12345678910111213/** * api接口统一管理 */import { get, post } from '@/request/http'export default { postData(action, params){ return post(action, params) }, getData(action, params){ return get(action, params) }} 在组件中使用： 任意vue文件： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div id=&quot;#&quot;&gt;&lt;/template&gt;&lt;script&gt; import Vue from 'vue'; import api from '@/api/api.js'; Vue.prototype.$api = api; export default { name:&quot;#&quot;, data(){ return { value1:'', value2:'' } }, methods:{ functiondemo(arg){ // 序列化数据 let param = new URLSearchParams(); param.append(&quot;key1&quot;, this.value1); param.append(&quot;key2&quot;, this.value2); this.$api.postData('/url', param) .then(response =&gt; { ... }) .catch(err =&gt; { console.log(err); }); } } }&lt;/script&gt;&lt;style&gt; ...&lt;/style&gt; 其他的api接口，就在api.js中继续往下面扩展就可以了！ 并为每个接口写好注释！ api接口管理的一个好处就是，我们把api统一集中起来，如果后期需要修改接口，我们就直接在api.js中找到对应的修改就好了，而不用去每一个页面查找我们的接口然后再修改会很麻烦。关键是，万一修改的量比较大，就会很麻烦。还有就是如果直接在我们的业务代码修改接口，一不小心还容易动到我们的业务代码造成不必要的麻烦。","link":"/2020/06/29/Vue%E5%BC%95%E5%85%A5Axios/"},{"title":"数据结构进阶实训七 链表，数组","text":"Data structure advanced training course notes and algorithm exercises Source Code: https://github.com/MysticalGuest/DataStructure/tree/master/AdvancedJuniorTraining 题目1123判断两个链表是否相交？ - 给定两个单链表，判断两个单链表是否相交？ - 假设两个单链表均没有环 1.1 算法设计思想 如果链表有交点，那么他们一定有共同后缀，转化为共同后缀问题 1.2 源代码 12345678910111213141516171819202122LinkList commonSuffix(LinkList L1, LinkList L2){ Node *p, *q; int len1, len2; len1=listlen(L1); len2=listlen(L2); if(lastChar(L1) != lastChar(L2)){ return NULL; } else{ for(p=L1; len1&gt;len2; len1--){ p=p-&gt;next; } for(q=L2; len2&gt;len1; len2--){ q=q-&gt;next; } while(p-&gt;next != NULL &amp;&amp; p-&gt;next != q-&gt;next){ p=p-&gt;next; q=q-&gt;next; } return p-&gt;next; }} 1.3 运行情况截图 题目2123456连续子数组的最大和。输入一个整形数组，数组里有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O（n） - 例如输入数组为（1、-2、3、10、-4、7、2、-5） - 和最大的子数组为（ 3、10、-4、7、2 ） - 该子数组的和为18 2.1 算法设计思想 将第一个元素默认最大值，往后遍历，并相加；如果此时和sum小于当前元素，就舍弃之前的元素；如果当前sum大于记录的max值，将max值改为sum；直到遍历结束数组所有元素 2.2 源代码 1234567891011121314151617181920212223242526int MaxSum(int a[], int size, int *s, int *e){ if(a == NULL || size == 0){ //非法输入 return -1; } int sum = 0;//初始和为0 int i = 0; int max = a[i];//最大值最初必为数组第一个元素 for(i; i &lt; size; i++){ sum = sum + a[i];//遍历一个元素，累加一次 if(sum &lt; a[i]){//如果加上当前元素之后的和比当前元素还小，则舍弃之前的元素，从当前元素开始累加 *s = i; sum = a[i]; } //如果加上当前元素之后的和比当前元素大 //说明可以继续累加 //如果当前和比最大值大，则更新最大值为当前和 //否则，不做更新 if(sum &gt; max){ *e = i; max = sum; } } return max;} 2.3 运行情况截图 题目31234数组中的逆序对。在数组中的两个数字，如果前面的数字大于后面的数字，则这两个数字组成一个逆序对。 - 输入一个数组，输出逆序对、并求出这个数组中出现的逆序对的总数 - 例如：数组中元素{7，5，6，4}，一共有5个逆序对分别是（7,6）、（7,5）（7,4）、（6,4）、（5,4） 3.1 算法设计思想 利用归并的思想；在排序交换元素的时候就输出这两数，就是逆序对，并用计数器记录 3.2 源代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#define MAX 32767int merge(int *array, int p,int q,int r) { //归并array[p...q] 与 array[q+1...r] int tempSum=0; int n1 = q-p+1; int n2 = r-q; int* left = NULL; int* right = NULL; int i, j, k, l; left = ( int *)malloc(sizeof(int) * (n1+1)); right = ( int *)malloc(sizeof(int) * (n2+1)); for(i=0; i&lt;n1; i++) left[i] = array[p+i]; for(j=0; j&lt;n2; j++) right[j] = array[q+1+j]; left[n1] = MAX; //哨兵，避免检查每一部分是否为空 right[n2] = MAX; i=0; j=0; for(k=p; k&lt;=r; k++) { if(left[i] &lt;= right[j]) { array[k] = left[i]; i++; } else { if(array[k]&gt;right[j]){ l=k+1; for(l; l&lt;n1; l++) printf(\"(%d, %d)\\t\", array[l], right[j]); } printf(\"(%d, %d)\\t\", left[i], right[j]); array[k] = right[j]; j++; tempSum += n1 - i; } } return tempSum;}int mergeSort(int *array, int start, int end ) { int sum=0; if(start &lt; end) { int mid = (start + end) /2; sum += mergeSort(array, start, mid); sum += mergeSort(array, mid+1, end); sum += merge(array,start,mid,end); } return sum;} 3.3 运行情况截图","link":"/2020/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E4%B8%83/"},{"title":"数据结构进阶实训一 位运算，优化算法","text":"Data structure advanced training course notes and algorithm exercises 数据结构进阶实训课程笔记和算法练习 Source Code: https://github.com/MysticalGuest/DataStructure/tree/master/AdvancedJuniorTraining 题目112对于一个字节（8bit)的无符号整型变量求其二进制表示中“1”的个数。要求算法的执行效率尽可能高。 1.1 算法设计思想 用户直接输入一个8位无符号整型常数，并进行用户输入的校验，如果不满足条件，提示用户重新输入，直到输入正确； 将十进制转换为二进制； 持续下面循环8次： 将二进制数模2，结果为1，计数器加1，然后二进制数右移一位； 循环结束，1的个数为计数器值。 1.2 源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;conio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;void main(){ printf(\"Please enter an 8-bit unsigned integer constant:\"); char array[8]; scanf(\"%s\", array); int len = strlen(array); // 判断用户输入是否是8位无符号整型常量 // 并判断用户输入是否为二进制 // 如果长度不为8,或不是二进制数,则重新输入 while(len!=8 || strspn(array, \"01\")!=len){ printf(\"Your input does not meet the conditions!\\n \\ Please enter an 8-bit unsigned integer constant as required:\"); scanf(\"%s\", array); len = strlen(array); } int arrayToInt = strtol(array, NULL, 2); //十进制转二进制函数的声明 int transfer(int x); int i=0, num=0; for(i; i&lt;len; i++){ if(transfer(arrayToInt)%2 == 1) num++; arrayToInt=arrayToInt&gt;&gt;1; } printf(\"The number of \\\"1\\\" in its binary representation is: %d.\\n\", num); printf(\"The program will continue to run, press any key to close it.\"); getch();}int transfer(int x){ int i=0; int binary = 0b0; for(i ; i&lt;x ; i++){ binary++; } return binary;} 1.3 运行情况截图 题目21给定一个整数N，N！末尾会有多少个0呢？编写算法计算给定的N！末尾有多少个0？ 2.1 算法设计思想 一个数的阶乘末尾有多少0，即判断这个数除以10的余数是否为0，如果为0，则末尾是0。 2.2 源代码 1234567while(factorial&gt;0){ if(factorial%10==0) numOfZero++; else break; factorial = factorial / 10;} 2.3 运行情况截图 题目31求N!的二进制表示中最低位的1的位置。 3.1 算法设计思想 初始化计数器为0； 先把n!化为二进制表示的形式，再把其二进制形式模2，如果结果为0，将其二进制形式右移一位，并且计数器加1； 循环上面的操作，直到模2结果为1，结束循环，计数器即为最后结果。 3.2 源代码 1234567891011121314151617181920212223242526int convert(int x){ // 十进制转二进制 int binary=0b0, i=0; for(i; i&lt;x; i++){ binary++; } return binary;}void main(){ int n,factorial=1, i=1, numOfZero=0; printf(\"Please enter an integer and the program will calculate its factorial:\"); scanf(\"%d\", &amp;n); for(i ; i&lt;=n; i++){ // 求阶乘 factorial *= i; } printf(\"The factorial of n is %d\\n\", factorial); int binary = convert(factorial); while(1){ // 求位置 numOfZero++; if(binary%2==1) break; binary = binary&gt;&gt;1; } printf(\"When representing n! In binary, \\ the position of the lowest bit 1 is (from right to left): %d\\n\", numOfZero);} 3.3 运行情况截图 题目41对于一个由N个整数组成的数组，设计算法（程序），求出该数组中的最大值和最小值。 4.1 算法设计思想 先判断数组的前两个值，将小的赋给min，将大的赋给max； 循环从数组的下标2开始，将数组下标为2的值记为num，如果num小于min，则将num赋值给min，反之则不变； 如果num大于max，则将num赋值给max，反之则不变； 直到循环结束，max则为最大值，min为最小值。 4.2 源代码 123456789101112131415161718192021222324252627void main(){ int random, num[20], i=0, max, min; printf(\"Give an array of 20 integers:\\n\"); for(i; i&lt;20; i++){ // 使用随机数初始化数组 random = rand()%100; num[i] = random; printf(\"%d \", num[i]); } if(num[0]&lt;num[1]){ max=num[1]; min=num[0]; } else{ max=num[0]; min=num[1]; } i=2; // 从2开始比较 for(i; i&lt;20; i++){ if(num[i]&gt;max) max=num[i]; if(num[i]&lt;min) min=num[i]; } printf(\"\\nThe maximum value of the array is: %d\", max); printf(\"\\nThe minimum value of the array is: %d\\n\", min); system(\"pause\");} 4.3 运行情况截图 题目51快速找出一个数组中所有满足条件的的两个数。（条件：这两个数的和等于一个给定的值sum.）。 5.1 算法设计思想 从第1个数开始循环与后面的数相加，判断结果如果等于给定值sum就输出这两个值； 然后从第2个数开始循环与后面的数相加，以此循环直到把数组遍历完。 5.2 源代码 123456789101112131415161718192021void main(){ int sum=100 int num[20]={41, 67, 34, 0, 69, 24, 78, 58, 62, 64, 5, 45, 81, 27, 61, 91, 95, 42, 27, 36}; printf(\"Give an array of 20 integers:\\n\"); int i=0, j; for(i; i&lt;20; i++){ printf(\"%d \", num[i]); } printf(\"\\n\"); i=0; for(i; i&lt;20; i++){ int add=num[i]; j= i+1; for(j; j&lt;20; j++){ if(add+num[j]==sum){ printf(\"The sum of the two numbers found is 100, which are: %d and %d.\\n\", add, num[j]); } } } system(\"pause\");} 5.3 运行情况截图","link":"/2020/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E4%B8%80/"},{"title":"数据结构进阶实训三 字符串，数组","text":"Data structure advanced training course notes and algorithm exercises 数据结构进阶实训课程笔记和算法练习 Source Code: https://github.com/MysticalGuest/DataStructure/tree/master/AdvancedJuniorTraining 题目11234实现将一个字符串中的每个空格字符换成“%20”。 - 例如：输入“We are happy.”, 则输出: - “We%20are%happy.”要求在时间复杂度O（n）,空间复杂度O（1）下完成。假设存放字符串的数组空间足够大。 1.1 算法设计思想 前提假设存放字符串的数组空间足够大； 第一次，遍历，计算出字符串长度，和替换后字符串长度； i从原字符串末尾出发，j从新字符串末尾出发，遇到空格就替换为“%20”。 1.2 源代码 12345678910111213141516171819202122232425char str[100] = \"We are happy.\"; // 假设空间足够大int length=0, blank=0, i, j;while(str[length]!='\\0'){ printf(\"%c\", str[length]); if(str[length]==' '){ blank++; } length++;}length += 2 * blank;i=length-2*blank;j=length;while(i&gt;=0 &amp;&amp; j&gt;i){ if(str[i]==' '){ str[j--]='0'; str[j--]='2'; str[j--]='%'; } else{ str[j--]=str[i]; } i--;} 1.3 运行情况截图 题目21234数组中出现次数超过一半的数字已知数组中有一个数字其出现的次数超过了数组长度的一半，请找出这个数组。要求： - 高效 - 分析时空效率 2.1 算法设计思想 一个数字出现的次数超过了数组的一半，那么将其排序后，称为有序数列，中间的元素即为所求。 2.2 源代码 1234567891011121314151617void sort(int a[], int length){ int i, j, min, temp; for(i=0; i&lt;length; i++){ min=i; for(j=i; j&lt;length; j++){ if(a[min]&gt;a[j]) min=j; } if(min!=i){ temp=a[min]; a[min]=a[i]; a[i]=temp; } }}printf(\"%d\\n\", array[length/2]); 2.3 运行情况截图 题目31234已知数组中的n个正数，找出其中最小的k个数。要求： - 高效 - 分析时空效率 3.1 算法设计思想 先将数组从小到大排序； 即可顺序打印出前k个数，即为数组中最小的k个数。 时间复杂度为O(n)，空间复杂度为O(1)。 3.2 源代码 12345678910111213141516171819202122void sort(int a[], int length){ int i, j, min, temp; for(i=0; i&lt;length; i++){ min=i; for(j=i; j&lt;length; j++){ if(a[min]&gt;a[j]) min=j; } if(min!=i){ temp=a[min]; a[min]=a[i]; a[i]=temp; } }}printf(\"\\nEnter the value k and output the smallest k number among them, k = \");scanf(\"%d\", &amp;k);printf(\"The smallest %d number in the array is: \\n\", k);for(i=0; i&lt;k; i++){ printf(\"%d\\t\", array[i]);} 3.3 运行情况截图","link":"/2020/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E4%B8%89/"},{"title":"数据结构进阶实训二 顺序表","text":"Data structure advanced training course notes and algorithm exercises 数据结构进阶实训课程笔记和算法练习 Source Code: https://github.com/MysticalGuest/DataStructure/tree/master/AdvancedJuniorTraining 题目11234输入数字n,按顺序打印输出从1到最大的n位十进制数。比如输入3，则打印出1,2,3，一直到最大的3位数999。 - 要考虑若n很大，我们求最大的n位数用int 或long long 也可能会溢出； - 考虑大数问题； - 提示：关于大数的表示和存储：用字符数组(取值为数字型字符)来表达大数 1.1 算法设计思想 这题主要解决大数问题。我用字符串来解决大数问题。那么字符串中所有字符都是数字；首先动态分配字符串空间为（n+1）*char，字符串最后要有一个结束符’\\0’，初始化其他位为0；然后每一次为字符串表示的数字加1，再打印出来；方法print()会遍历字符串，直到遇到第一个非0字符后，打印后面的字符；关键方法printRecursively()，每10个数，对具体位数加1，然后进位，递归。 1.2 源代码 1234567891011121314151617181920212223void printRecursively(char *number, int n, int index){ int i; if(index == n){ print(number, n); return; } for(i = 0; i&lt;10; i++){ number[index] = i + '0'; // printf(\"NUMBER: %s\\n\", number); printRecursively(number, n, index + 1); }}void printToMaxOfNDigits(int n){ if (n &lt;= 0) return; char *number = (char *)malloc((n+1)*sizeof(char)); memset(number, '0', (n+1)*sizeof(char)); // 在一段内存块中填充某个给定的值,初始化为0 number[n] = '\\0'; printRecursively(number, n, 0); free(number);} 1.3 运行情况截图 题目2123456已知一个顺序表L（整数）实现一个函数将调整顺序表中的数字顺序，使得所有奇数位于表L的前半部分，所有偶数位于数组的后半部分。 - 如果把题目改成把顺序表中的数按照大小分为两部分，负数都在非负数的前面，该怎么做？再定义一个函数？？ - 或者再改为：把顺序表中的数分为两部分， 能被3整除的数放在前面，不能被3整除的数放在后面；再定义一个函数？？ - 是否有更好的办法？增加代码的可扩展性。 2.1 算法设计思想 定义一个规则rule方法，根据用户输入，确定排序规则，增加代码复用性；三种排序规则思想一样：（1）start=0从顺序表头开始往后，end从尾开始往前，start遇到偶数停止，end遇到奇数停止，交换下标为start和下标为end的元素，然后继续前进；（2）start=0从顺序表头开始往后，end从尾开始往前，start遇到正数停止，end遇到负数停止，交换下标为start和下标为end的元素，然后继续前进；（3）start=0从顺序表头开始往后，end从尾开始往前，start遇到不能被3整除的数停止，end遇到能被3整除的数停止，交换下标为start和下标为end的元素，然后继续前进。 2.2 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/*宏定义*/#define MAXSIZE 30//宏定义布尔类型#define BOOL int#define TRUE 1#define FALSE 0typedef int ElemType; /*顺序表中存放整型元素*/typedef struct{ ElemType elem[MAXSIZE]; int last;}SeqList;/*函数声明*/void initList(SeqList *L);void printList(SeqList L);BOOL rule(int elem, int select);void sortList(SeqList *L, SeqList *L1, int select);void main(){ SeqList La, Lb; Lb.last=-1; // 初始化Lb int select; initList(&amp;La); // 给出一个顺序表La printf(\"Give a sequence table: \\nLa = \"); printList(La); /* 给出下列几种排序规则: 奇数在前，偶数在后; 负数在前，非负数在后; 能被3整除的数在前面，不能被3整除的数在后面. */ printf(\"\\nGive the following sorting rules: \\ \\n1.Odd number first, even number behind;\\ \\n2.Negative numbers first, non-negative numbers last;\\ \\n3.Numbers divisible by 3 are in the front, \\ and numbers that are not divisible by 3 are in the back.\\ \\nPlease select the sorting rule you want and enter the rule number:\"); scanf(\"%d\", &amp;select); while(select != 1 &amp;&amp; select != 2 &amp;&amp; select != 3){ printf(\"Please reselect: \"); scanf(\"%d\", &amp;select); } sortList(&amp;La, &amp;Lb, select); printf(\"The adjusted sequence table is: \\n\"); printList(Lb); system(\"pause\");}/*函数定义*/void initList(SeqList *L){ L-&gt;last=-1; int i=0; for(i; i&lt;MAXSIZE; i++){ L-&gt;elem[i]=rand()%100 - 50; } L-&gt;last=MAXSIZE-1;}void printList(SeqList L){ int i; printf(\"(\"); for(i=0; i&lt;=L.last; i++) printf(\"%d \", L.elem[i]); printf(\")\\n\");}void sortList(SeqList *L, SeqList *L1, int select){ int i=0, end=L-&gt;last, start=0; for(i; i&lt;=L-&gt;last; i++){ if( rule(L-&gt;elem[i], select) == TRUE){ // 偶数尾插法 L1-&gt;elem[end] = L-&gt;elem[i]; end--; } else{ // 奇数前插法 L1-&gt;elem[start] = L-&gt;elem[i]; start++; } } L1-&gt;last=L-&gt;last;}BOOL rule(int elem, int select){ switch (select) { case 1: if(elem%2==0) return TRUE; return FALSE; break; case 2: if(elem&gt;=0) return TRUE; return FALSE; break; case 3: if(elem%3!=0) return TRUE; return FALSE; break; default: return FALSE; break; }} 2.3 运行情况截图 题目31给定一个整数数组，删除相邻的重复数字，结果数组中不能存在任何相邻的重复数字。 3.1 算法设计思想 将数组存入顺序表；遍历顺序表，将下标为i和下标i+1的元素比较如果相等，进行判断：如果下标为i和下标i+2的元素相等，所有元素往前移动1位；如果下标为i和下标i+2的元素不相等，所有元素往前移动2位；持续上述循环，结束的标志是遍历顺序表，没有相邻相同元素就结束循环。 3.2 源代码 123456789101112131415161718192021222324252627282930313233343536373839while(flag==1){ if(L.last==0) // 代表顺序表中只有一个元素 break; if(L.elem[i]==L.elem[j]){ if(L.elem[i]==L.elem[j+1]){ // 判断是否3数相连 for(k=i; k&lt;L.last; k++){ L.elem[k]=L.elem[k+1]; // 所有元素前移1位 } L.last = L.last-1; } else{ // 不是3数相连，那就是2数相连 for(k=i; k&lt;L.last-1; k++){ L.elem[k]=L.elem[k+2]; // 所有元素前移2位 } L.last = L.last-2; if(j&gt;L.last){ i=0; j=1; } } } if(j==L.last){ for(k=0; k&lt;L.last; k++){ if(L.elem[k]==L.elem[k+1]){ flag=1; break; } else flag=0; } i=-1; j=0; } i++; j++;} 3.3 运行情况截图 题目4123已知顺序表L（数组表示即可），编写一个时间复杂度O(n)，空间复杂度为O（1）的算法将表L中所有值为x 的元素删除。 - 表中元素无序。 4.1 算法设计思想 遍历顺序表，将顺序表a的元素赋给顺序表b，遇到要删除的元素就跳过。 4.2 源代码 12345678910111213void deleteList(SeqList *LA, SeqList *LB, int n){ int count=0, i=0, j=0; for(i; i&lt;LA-&gt;last+1; i++){ if(LA-&gt;elem[i]==n){ count++; // 记录删除元素的个数 } else{ LB-&gt;elem[j] = LA-&gt;elem[i]; j++; } } LB-&gt;last = LA-&gt;last-count;} 4.3 运行情况截图 题目51234567将n 个整数存入顺序表L，实现将L中的整数序列循环左移p(0&lt;p&lt;n)个位置，即将L中的数据序列(x0, x1, ... , xp-1, xp, xp+1, ... , xn-1)变换为(xp, xp+1, ... , xn-1, x0, x1, ... , xp-1) - 类似的实现循环右移K位； - 要求：时间复杂度为O(n)。空间复杂度为S(1)。 5.1 算法设计思想 将下标0到p的元素逆置；将下标p+1到n 的元素逆置；最后将整个顺序表逆置得到最终结果。 5.2 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960void main(){ SeqList L = {{1,2,3,4,5,6,7,8,9,10},10}; int n; int temp; char direction; printf(\"Give a sequence table: \\n\"); printlist(L); printf(\"Please enter a positive integer n to cycle through the sequence: \"); scanf(\"%d\", &amp;n); getchar(); // 吃掉回车 printf(\"Please select the direction of movement (L for left, R for right): \"); while(direction!='R' &amp;&amp; direction!='L'){ scanf(\"%c\", &amp;direction); getchar(); if(direction=='L'){ n = n%L.last; } else if(direction=='R'){ // 右移n格就是左移L.last-n格 n = L.last - n%L.last; } else{ printf(\"Wrong input, please re-enter: \"); } } int i = 0, j = n-1; //将子表(X0,X1...,Xp-1)逆序为(Xp-1,...,X1,X0) reverse(&amp;L, i, j); //将子表(Xp,Xp+1,...,Xn-1)逆序为(Xn-1,...,Xp+1,Xp) i = n; j = L.last-1; reverse(&amp;L, i, j); //将整张表(Xp-1,...,X1,X0,Xn-1,...,Xp+1,Xp)逆序为(Xp,Xp+1,...,Xn-1,X0,X1...,Xp-1) i = 0; j = L.last-1; reverse(&amp;L, i, j); printf(\"The sequence table after moving is: \\n\"); printlist(L); system(\"pause\");}void reverse(SeqList *L,int i, int j){ int temp; while(i &lt; j){ temp = L-&gt;elem[i]; L-&gt;elem[i] = L-&gt;elem[j]; L-&gt;elem[j] = temp; ++i; --j; }} 5.3 运行情况截图","link":"/2020/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E4%BA%8C/"},{"title":"数据结构进阶实训五 栈与递归","text":"Data structure advanced training course notes and algorithm exercises Source Code: https://github.com/MysticalGuest/DataStructure/tree/master/AdvancedJuniorTraining 题目1123假设算术表达式只包含“+”、“-”、“*”、“/”，正整数和括号的合法数学表达式。根据算符优先关系， - 将算术表达式的中缀表示法转换为后缀表示法。 - 对得到的后缀表达式进行求值 1.1 算法设计思想 1.1.1 转后缀表达式： 从左到右扫描每一个字符。如果扫描到的字符是操作数（如a、b等），就直接输出这些操作数。 如果扫描到的字符是一个操作符，分三种情况：（1）如果堆栈是空的，直接将操作符存储到堆栈中（pushCStack it）（2）如果该操作符的优先级大于堆栈出口的操作符，就直接将操作符存储到堆栈中（pushCStack it）（3）如果该操作符的优先级低于堆栈出口的操作符，就将堆栈出口的操作符导出（popCStack it）,直到该操作符的优先级大于堆栈顶端的操作符。将扫描到的操作符导入到堆栈中（pushCStack） 如果遇到的操作符是左括号”（”，就直接将该操作符输出到堆栈当中。该操作符只有在遇到右括号“ )”的时候移除。这是一个特殊符号该特殊处理。 如果扫描到的操作符是右括号“ ”，将堆栈中的操作符导出（popCStack）到output中输出，直到遇见左括号“（”。将堆栈中的左括号移出堆栈（popCStack ）。继续扫描下一个字符。 如果输入的中缀表达式已经扫描完了，但是堆栈中仍然存在操作符的时候，我们应该讲堆栈中的操作符导出并输入到output 当中。 1.1.3 求值 后缀表达式求值的算法是:遍历后缀表达式，如果遇到运算数，那么运算数入栈如果遇到运算符，那么弹出栈里面两个元素，先弹出的是右运算数，后弹出的是左运算数，计算运算结果，然后将结果入栈最后遍历到后缀表达式末尾，当结果只有一个元素时，就是答案 1.2 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239#define StackSize 50#define INFINITY 32768// 定义运算符栈typedef struct{ char elem[StackSize]; int top;}SeqCStack;void InitCStack(SeqCStack *S){ S-&gt;top=-1;}void pushCStack(SeqCStack *S, char operator){ if(S-&gt;top == StackSize - 1){ // 栈满 return ; } else{ S-&gt;top++; S-&gt;elem[S-&gt;top] = operator; return ; }}void popCStack(SeqCStack *S, char *e){ if(S-&gt;top == -1){ // 栈空 return ; } else{ *e = S-&gt;elem[S-&gt;top]; S-&gt;top--; return ; }}char getCStackTop(SeqCStack S){ if(S.top == -1){ // 栈空 return '#'; } else{ return S.elem[S.top]; }}void traverse(SeqCStack S){ int i=0; while(i &lt;= S.top){ printf(\"%c \", S.elem[i++]); } printf(\"\\n\");}// 定义运算数栈typedef struct{ int data[StackSize]; int top;}SeqNStack;void InitNStack(SeqNStack *S){ S-&gt;top=-1;}void pushNStack(SeqNStack *S, int num){ if(S-&gt;top == StackSize - 1){ // 栈满 return ; } else{ S-&gt;top++; S-&gt;data[S-&gt;top] = num; return ; }}void popNStack(SeqNStack *S, int *e){ if(S-&gt;top == -1){ // 栈空 return ; } else{ *e = S-&gt;data[S-&gt;top]; S-&gt;top--; return ; }}int getNStackTop(SeqNStack S){ if(S.top == -1){ // 栈空 return INFINITY; } else{ return S.data[S.top]; }}char compare(char operator, char top){ if(top == '#') // 空栈，操作符直接进栈 return '&gt;'; else if(operator==')' &amp;&amp; top=='(') return '='; else if(top=='(') return '&gt;'; else if(operator=='+') // 如果操作符是'+', 无论栈顶元素是什么, '+'优先级都小 return '&lt;'; else if(operator=='-') return '&lt;'; else if(operator=='*' &amp;&amp; top=='+') return '&gt;'; else if(operator=='*' &amp;&amp; top=='-') return '&gt;'; else if(operator=='*' &amp;&amp; top=='*') return '&lt;'; else if(operator=='*' &amp;&amp; top=='/') return '&lt;'; else if(operator=='*' &amp;&amp; top=='(') return '&lt;'; else if(operator=='/' &amp;&amp; top=='+') return '&gt;'; else if(operator=='/' &amp;&amp; top=='-') return '&gt;'; else if(operator=='/' &amp;&amp; top=='*') return '&lt;'; else if(operator=='/' &amp;&amp; top=='(') return '&lt;'; else if(operator=='(') return '&gt;'; else if(operator==')') return '&lt;';}int caculate(int left, int right, char c){ int re = 0; switch (c){ case '+': re = left + right; break; case '-': re = left - right; break; case '*': re = left * right; break; case '/': re = left / right; break; default: break; } return re;}void main(){ SeqCStack OS, SuffixExp; SeqNStack NS; /* 初始化运算符栈 */ InitCStack(&amp;OS); /* 初始化运算数栈 */ InitNStack(&amp;NS); /* 初始后缀表达式栈 */ InitCStack(&amp;SuffixExp); char exp[] = {'5', '+', '2', '*', '(', '1', '+', '6', ')', '-', '8', '/', '2', '\\0'}; printf(\"Infix expression is: %s\\n\", exp); char suffixstr[50], temp; int i = 0, tempNum; while (exp[i]!='\\0'){ if(isdigit(exp[i])){ // 如果是数字直接进后缀表达式栈 pushCStack(&amp;SuffixExp, exp[i]); // printf(\"num------%c\\n\", exp[i]); i++; } else{ // printf(\"char------\\n\"); // printf(\"compare----%c\\n\", compare(exp[i], getCStackTop(OS))); switch(compare(exp[i], getCStackTop(OS))){ case '&gt;': pushCStack(&amp;OS, exp[i]); // printf(\"case1 &gt;---%c\\n\", exp[i]); i++; break; case '=': popCStack(&amp;OS, &amp;temp); // 脱括号 // printf(\"case2 =---%c\\n\", temp); i++; break; case '&lt;': while(compare(exp[i], getCStackTop(OS))=='&lt;'){ // printf(\"case3 &lt;---%c\\n\", exp[i]); // printf(\"case3 getCStackTop %c\\n\", getCStackTop(OS)); popCStack(&amp;OS, &amp;temp); // printf(\"case3 after getCStackTop %c\\n\", getCStackTop(OS)); pushCStack(&amp;SuffixExp, temp); } // if(exp[i]!=')'){i++;} break; } } } /* 最后把栈中剩余的运算符依次弹栈打印 */ while(getCStackTop(OS)!='#'){ popCStack(&amp;OS, &amp;temp); pushCStack(&amp;SuffixExp, temp); } traverse(SuffixExp); for(i=SuffixExp.top; i&gt;=0; i--){ popCStack(&amp;SuffixExp, &amp;temp); suffixstr[i] = temp; } printf(\"Infix expression to suffix expression is: %s\\n\", suffixstr); /* 后缀表达式求值的算法是: 遍历后缀表达式， 如果遇到运算数，那么运算数入栈 如果遇到运算符，那么弹出栈里面两个元素，先弹出的是右运算数，后弹出的是左运算数， 计算运算结果，然后将结果入栈。 最后遍历到后缀表达式末尾，当结果只有一个元素时，就是答案 */ char *p=suffixstr; while (*p != '\\0'){ if (isdigit(*p)){ pushNStack(&amp;NS, *p-'0'); } else{ popNStack(&amp;NS, &amp;tempNum); int rightNum = tempNum; // printf(\"rightNum:::%d\\n\", rightNum); // free(temp); popNStack(&amp;NS, &amp;tempNum); int leftNum = tempNum; // free(temp); int result = caculate(leftNum, rightNum, *p); // printf(\"caculate result----%d\\n\", result); pushNStack(&amp;NS, result); } p++; } printf(\"result: %d\\n\", getNStackTop(NS)); system(\"pause\");} 1.3 运行情况截图 题目21设L为带头结点的单链表，实现从尾到头反向输出链表中每个结点的值。（递归思想） 2.1 算法设计思想 递归语句在打印之前就可以了 2.2 源代码 123456void printReversely(LinkList L){ if(L-&gt;next!=NULL){ printReversely(L-&gt;next); printf(\"%c \", L-&gt;next-&gt;data); }} 2.3 运行情况截图 题目312345一只青蛙一次可以跳上1级台阶，也可以跳上2级。编写代码求青蛙跳上一个n级的台阶，总共有多少种跳法？ - 若条件改为： 一只青蛙一次可以跳上1级台阶，也可以跳上2级，也可以跳上3级，...，也可以跳上n级。 编写代码求青蛙跳上一个n级的台阶，总共有多少种跳法？ 3.1 算法设计思想 Q： 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 A： f(n) = f(n-1)+f(n-2)+…+f(1)f(n-1) = f(n-2)+ f(n-3)…+f(1)两式相减，得到f(n) = 2*f(n-1) 3.2 源代码 1234567891011121314151617181920int Jump(int i, int n) { //表示当前台阶数大于总台阶数，很显然这种情况不符合，走不通，记为 0 if (i &gt; n) { return 0; } //表示当前台阶数正好等于总的台阶数，那么这种情况符合，记为 1 if (i == n) { return 1; } return Jump(i + 1, n) + Jump(i + 2, n);}int JumpN(int num){ if (num == 1){ return 1; } else{ return 2*JumpN(num-1); }} 3.3 运行情况截图 题目4123用一个2X1的小矩形横着或竖着去覆盖更大的矩形。如下图 - 具体：用8个2X1小矩形横着或竖着去覆盖2X8的大矩形，覆盖方法有多少种？ - 编写代码求用2X1小矩形横着或竖着去覆盖2Xn的大矩形。输出总共有多少种覆盖方法 4.1 算法设计思想 当n=1时，覆盖方法有1种；当n=2时，覆盖方法有2种；当n=3时，覆盖方法有2+1=3种；当n=4时，覆盖方法有3+2=5种；按照规律就转化成了斐波那契数列问题 4.2 源代码 1234567891011int Cover(int n){ if(n&lt;=0){ return 0; } else if(n==1||n==2){ return n; } else{ return Cover(n-1) + Cover(n-2); }} 4.3 运行情况截图 题目5123借助自定义栈以非递归形式求解汉诺塔问题（n,a,b,c）；即将n个盘子从起始塔座a通过辅助塔座b移动到目标塔座c,并保证每个移动符合汉诺塔问题的要求 5.1 算法设计思想 利用递归的思想，用栈来处理；比如n=3时，转化的问题是：先要移动A塔座上面2个盘子到B塔座，这个操作进栈后续处理；然后移动A塔座上面最后一个大盘子到C塔座，这个操作进栈后续处理；最后再移动B塔座上最后两个盘子到C塔座；一直访问栈，如果栈顶处理的盘子数不是1，就在把操作细分，进栈；直到盘子数为1，移动盘子；直到栈为空 5.2 源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// 定义汉诺塔数据typedef struct{ char A; char B; char C; int n;}HanoiData;// 定义栈typedef struct{ HanoiData elem[StackSize]; int top;}SeqStack;void InitStack(SeqStack *S){ S-&gt;top=-1;}void push(SeqStack *S, HanoiData hd){ if(S-&gt;top == StackSize - 1){ // 栈满 return ; } else{ S-&gt;top++; S-&gt;elem[S-&gt;top] = hd; return ; }}void pop(SeqStack *S, HanoiData *e){ if(S-&gt;top == -1){ // 栈空 return ; } else{ *e = S-&gt;elem[S-&gt;top]; S-&gt;top--; return ; }}// HanoiData getTop(SeqStack S){// if(S.top == -1){ // 栈空// return ;// }// else{// return S.elem[S.top];// }// }void move1(int n,char A,char B,char C){ if(n==1){ printf(\"%c--&gt;%c\\n\",A,C); } else{ move1(n-1,A,C,B); move1(1,A,B,C); move1(n-1,B,A,C); } }void hanoi(int n){ SeqStack S; InitStack(&amp;S); HanoiData h = {'A', 'B', 'C', n}; push(&amp;S,h);//初始栈 // hanoi_data x;//用来保存出栈的n,A,B,C while(S.top!=-1){ pop(&amp;S, &amp;h);//出栈并用x带回 if(h.n==1){ printf(\"%c--&gt;%c\\n\",h.A,h.C);//打印出移动方案 } else{ HanoiData h1 = {h.B, h.A, h.C, h.n-1}; push(&amp;S,h1); HanoiData h2 = {h.A, h.B, h.C, 1}; push(&amp;S,h2); HanoiData h3 = {h.A, h.C, h.B, h.n-1}; push(&amp;S,h3); } }} 5.3 运行情况截图","link":"/2020/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E4%BA%94/"},{"title":"数据结构进阶实训九 二叉树的应用","text":"Data structure advanced training course notes and algorithm exercises Source Code: https://github.com/MysticalGuest/DataStructure/tree/master/AdvancedJuniorTraining 题目112345建二叉树二叉链表存储 - 扩展的先序序列（之前采用的方法） 此次要求：已知两个遍历序列建二叉树（先/中，后/中） - 其先、中序遍历序列分别存放在两个数组pre[]和inorder[]中。 - 其中、后序遍历序列分别存放在两个数组inorder[]和post中。 1.1 算法设计思想 两种建树的思想相同，都是分治的思想；通过前序遍历，第一个元素就是树的根节点；然后在重建左子树，找到左子树的根节点，重建右子树，找到右子树的根节点，递归下去；中序+后续遍历重建树也是如此；后续序列的最后一个元素就是树的根节点。 1.2 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;stdio.h&gt;#include&lt;Windows.h&gt;typedef char ElemType;typedef struct Node{ ElemType elem; struct Node *LChild; struct Node *RChild;}BiTNode, *BiTree;// 前序+中序重建二叉树void ReBuildByPreAndInOrder(char *prelist, char *inlist, int len, BiTree *bt){ if(!prelist || !inlist || len&lt;=0 ) //空树 return; int i; // 找到根结点在中序遍历中的位置 for(i = 0; i &lt; len; i++){ if(inlist[i] == prelist[0]) break; } if(i&gt;=len) return; // 初始化根结点 *bt = (BiTNode*)malloc(sizeof(BiTNode)); if(!bt) // 申请失败 return; (*bt)-&gt;LChild = (*bt)-&gt;RChild = NULL; (*bt)-&gt;elem = prelist[0]; // 重建左子树 ReBuildByPreAndInOrder(prelist+1, inlist, i, &amp;(*bt)-&gt;LChild); // 重建右子树 ReBuildByPreAndInOrder(prelist+i+1, inlist+i+1, len-i-1, &amp;(*bt)-&gt;RChild);}// 中序+后序重建二叉树void ReBuildByInAndPostOrder(char *inlist,char *postlist, int len, BiTree *bt){ if(!inlist || !postlist || len&lt;=0 ) //空树 return; int i; // 找到根结点在中序遍历中的位置 for(i = 0; i &lt; len; i++){ if(inlist[i] == postlist[len-1]) break; } if(i&gt;=len) return; // 初始化根结点 *bt = (BiTNode*)malloc(sizeof(BiTNode)); if(!bt) return; (*bt)-&gt;LChild = (*bt)-&gt;RChild = NULL; (*bt)-&gt;elem = postlist[len-1]; //重建左子树 ReBuildByInAndPostOrder(inlist, postlist, i, &amp;(*bt)-&gt;LChild); //重建右子树 ReBuildByInAndPostOrder(inlist+i+1, postlist+i, len-i-1, &amp;(*bt)-&gt;RChild);}void PrintTree(BiTree bt,int nLayer){ int i; if(bt==NULL) return; PrintTree(bt-&gt;RChild,nLayer+1); for(i=0;i&lt;nLayer;i++) printf(\" \"); printf(\"%c\\n\", bt-&gt;elem); PrintTree(bt-&gt;LChild,nLayer+1);}void main(){ char pre[7]={'A', 'B', 'D', 'E', 'C', 'F', 'G'}, inorder1[7] = {'D', 'B', 'E', 'A', 'F', 'C', 'G'}, inorder2[9] = {'G', 'D', 'H', 'B', 'A', 'E', 'C', 'I', 'F'}, post[9] = {'G', 'H', 'D', 'B', 'E', 'I', 'F', 'C', 'A'}; int i=0; /* 前序+中序重建二叉树 */ printf(\"Give the preorder and midorder traversal of a binary tree: \\nPreorder = \"); for(i=0; i&lt;7; i++){ printf(\"%c \", pre[i]); } printf(\"\\nMidorder = \"); for(i=0; i&lt;7; i++){ printf(\"%c \", inorder1[i]); } BiTree T1=NULL; ReBuildByPreAndInOrder(pre, inorder1, 7, &amp;T1); printf(\"\\nThe binary tree constructed by two traversal sequences is: \\n\"); PrintTree(T1, 1); /* 前序+中序重建二叉树 */ /* 中序+后序重建二叉树 */ printf(\"Give the midorder and postorder traversal of a binary tree: \\nMidorder = \"); for(i=0; i&lt;9; i++){ printf(\"%c \", inorder2[i]); } printf(\"\\nPostorder = \"); for(i=0; i&lt;9; i++){ printf(\"%c \", post[i]); } BiTree T2=NULL; ReBuildByInAndPostOrder(inorder2, post, 9, &amp;T2); printf(\"\\nThe binary tree constructed by two traversal sequences is: \\n\"); PrintTree(T2, 1); /* 中序+后序重建二叉树 */ system(\"pause\");} 1.3 运行情况截图 题目2123求二叉树中值为x的节点所在的层号。二叉树bt采用二叉链表存储；设计一个算法level（bt,x）求二叉树中值为x的节点所在的层号 2.1 算法设计思想 在求二叉树深度算法的基础上改进算法；在含有目标节点的子树上查找，到达目标节点即结束递归 2.2 源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 算法1int layer(BiTree bt, char x){ int cot = 0; if(bt==NULL) return cot; else if(bt-&gt;elem==x){ cot = 1; return cot; } else{ // printf(\"layer(bt-&gt;LChild, x): %d\\n\", layer(bt-&gt;LChild, x)); if(layer(bt-&gt;LChild, x)){ cot = layer(bt-&gt;LChild, x)+1; return cot; } // printf(\"layer(bt-&gt;RChild, x): %d\\n\", layer(bt-&gt;RChild, x)); if(layer(bt-&gt;RChild, x)){ cot = layer(bt-&gt;RChild, x)+1; return cot; } } return cot;}// 算法2int find_node_level(BiTree bt, char x, int h){ if (bt == NULL) return 0; else if (bt-&gt;elem == x) return h; else{ int l = find_node_level(bt-&gt;LChild, x, h+1); if (l != 0) return l; else return find_node_level(bt-&gt;RChild, x, h+1); }}// 算法3void level_in_x(BiTree BT,char x,int level){ if (BT == NULL){ return ; } if(BT-&gt;elem == x){ printf(\"x in %d\",level); } level++; printf(\"1:%d----\\n\", level); level_in_x(BT-&gt;LChild,x,level); printf(\"2:%d----\\n\", level); level_in_x(BT-&gt;RChild,x,level); printf(\"3:%d----\\n\", level); level--;} 2.3 运行情况截图 题目3123求二叉树的宽度。利用二叉树层次遍历求二叉树的宽度；二叉树的宽度即二叉树同层结点数的最大值 3.1 算法设计思想 我利用一个足够大的全局数组来记录遍历过程中的二叉树宽度；利用一个变量max来记录最大宽度，即为所求；求宽度的函数依然采用的是先序遍历递归的思想，加一个形参k，对应width数组下标，记录当前深度，来传给子层信息；如果当前深度k的节点不为空，那么width[k]++，来记录宽度；max为宽度最大值 3.2 源代码 1234567891011121314#define size 100int width[size];int max=0;void MaxWidth(BiTree T,int k){ if(T==NULL) return; width[k]++; if(max&lt;width[k]) max=width[k]; MaxWidth(T-&gt;LChild, k+1); MaxWidth(T-&gt;RChild, k+1);} 3.3 运行情况截图 题目412345678二叉树bt采用二叉链表存储，设计算法实现采用括号表示法输出该二叉树。 A / \\ B C / / \\ D E F \\ G A(B(D(,G)),C(E,F)) 4.1 算法设计思想 把题目中的括号表示法A(B(D(,G)),C(E,F))，去掉括号变为：ABDGCEF这种写法不是我们熟悉的先序遍历吗！所以我就在二叉树先序遍历算法的基础上改进算法； a.在节点的左右子树不为空时输出“（”；b.当节点右子树不为空时输出“，”；c.在节点的左右子树不为空时输出“）” 4.2 源代码 12345678910111213void Brackets(BiTree T){ if (T==NULL) return; printf(\"%c\", T-&gt;elem); if(T-&gt;LChild!=NULL||T-&gt;RChild!=NULL) printf(\"( \"); Brackets(T-&gt;LChild); if(T-&gt;RChild!=NULL) printf(\", \", T-&gt;elem); Brackets(T-&gt;RChild); if(T-&gt;LChild!=NULL||T-&gt;RChild!=NULL) printf(\" )\");} 4.3 运行情况截图 题目51234求二叉树的路径长度。二叉树二叉链表存储二叉树的路径长度即：二叉树中所有结点的路径长度之和。（结点的路径长度即：从根到结点的分支数） 5.1 算法设计思想 路径长度即为分支数之和；根据二叉树的性质；每个节点的头部都有一个分支，除了根节点；所以分支数之和就是二叉树节点数-1；那么采用递归的方法求得节点数，就可以求得路劲长度了 5.2 源代码 123456789int Node(BiTree T){ if (T==NULL) return 0; else{ return 1 + Node(T-&gt;LChild) + Node(T-&gt;RChild); }}printf(\"The path length of this binary tree is: %d\\n\", Node(T)-1); 5.3 运行情况截图","link":"/2020/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E4%B9%9D/"},{"title":"hello-world","text":"title: Hello WorldWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/06/21/hello-world/"},{"title":"数据结构进阶实训十 二叉排序树","text":"Data structure advanced training course notes and algorithm exercises 数据结构进阶实训课程笔记和算法练习 Source Code: https://github.com/MysticalGuest/DataStructure/tree/master/AdvancedJuniorTraining 题目112判断二叉树是否为正则二叉树。 - 正则二叉树的定义：指在二叉树中不存在度为1的分支点。 1.1 算法设计思想 利用二叉树遍历递归的思想；先判断当前节点是否正则；然后递归判断该节点的左右子树。 1.2 源代码 1234567891011// 1代表是正则二叉树，0代表不是int IsRegular(BiTree T){ if(T==NULL) return 1; else if(T-&gt;LChild==NULL ^ T-&gt;RChild==NULL) return 0; else{ IsRegular(T-&gt;LChild); IsRegular(T-&gt;RChild); }} 1.3 运行情况截图 &lt;/p&gt; 题目21判断二叉树是否为完全二叉树？ 2.1 算法设计思想 一个树是否为完全二叉树，每个节点有以下4中情况： 1234情况一： 情况二： 情况三： 情况四： A A A A / \\ / \\ / \\ / \\B C B NULL NULL B NULL NULL 规律是： （1）如果当前访问的节点的左右孩子是情况三，说明不是完全二叉树，直接返回false； （2）如果当前访问的节点的左右孩子是情况1，继续访问其他节点； （3）如果当前访问的节点的左右孩子是情况2或者情况4，那么我们定义一个状态（接下来访问的所有节点必须全部是叶子节点）。只要遇到情况2或者情况4，这个状态就开启了。 算法就是层次遍历所有节点并做判断。 2.2 源代码 1234567891011121314151617181920212223242526BOOL IsCBT(BiTree bt){ if(bt==NULL) // 空树 return TRUE; BOOL leaf = FALSE; SeqQueue Q; BiTree p; InitQueue(&amp;Q); EnterQueue(&amp;Q, bt); while(!IsEmpty(Q)){ DeleteQueue(&amp;Q, &amp;p); if(p-&gt;LChild==NULL &amp;&amp; p-&gt;RChild!=NULL) // 情况3: 当前节点有右孩子，没有左孩子 return FALSE; //上述的状态已经发生，但是当前访问到的节点不是叶节点（有左孩子或者右孩子） if(leaf &amp;&amp; (p-&gt;LChild!=NULL||p-&gt;RChild!=NULL)) return FALSE; if(p-&gt;LChild!=NULL) //左孩子不为空，加入到队列中去 EnterQueue(&amp;Q, p-&gt;LChild); if(p-&gt;RChild!=NULL) //右孩子不为空，加入到队列中去 EnterQueue(&amp;Q, p-&gt;RChild); //这个if语句就是判断状态是否要发生 if((p-&gt;LChild!=NULL &amp;&amp; p-&gt;RChild==NULL)||(p-&gt;LChild==NULL &amp;&amp; p-&gt;RChild==NULL)) leaf=TRUE; } return TRUE;} 2.3 运行情况截图 &lt;/p&gt; 题目3123456二叉树二叉链表存储，结点数据域的值为整数，且取值各不相同。编写代码判断该二叉树是否为二叉排序树。二叉排序树，又称二叉查找树。它或者是一颗空树，或者是具有下列性质的二叉树。 - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； - 它的的左、右子树也分别为二叉排序树。 3.1 算法设计思想 由于二叉排序树的中序遍历得到的是一个单调递增的序列； 所以根据这个想法，我们可以中序遍历这个二叉树，将得到的序列存入temp数组； 通过检验temp数组的单调递增性来判断这个二叉树是否为二叉排序树。 3.2 源代码 123456789101112131415161718192021#define N 100int temp[N];int i = 0;void inorder(BiTree root){ if(root == NULL) return; if(root-&gt;LChild != NULL) inorder(root-&gt;LChild); temp[i++] = root-&gt;data; if(root-&gt;RChild != NULL) inorder(root-&gt;RChild);}int ISBST(int temp[], int k){ int flag=0; for(int i=1; i&lt;k; i++) if(temp[i]&lt;temp[i-1]) return 0; return 1;} 3.3 运行情况截图 &lt;/p&gt; 题目4123二叉树二叉链表存储，结点数据域的值为整数，且取值各不相同。编写代码判断该二叉排序树是否为平衡二叉排序树。 - 平衡二叉树，是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1。 4.1 算法设计思想 通过平衡二叉树的定义可以将判断平衡二叉树的条件分为以下2个： （1）首先是一颗二叉排序树； （2）每个节点的左右子树的高度差至多为1； 基于以上两个条件写两个方法； 第一个条件思想和上一题一样，判断二叉排序树； 第二个条件通过递归判断每个节点的左右子树高度； 将两个条件返回值综合，就可以判断出。 4.2 源代码 12345678910111213141516171819202122232425262728293031323334int Deep(BiTree bt){ int ld=0,rd=0; if(bt){ ld=Deep(bt-&gt;LChild)+1; rd=Deep(bt-&gt;RChild)+1; } return ld &gt;= rd?ld:rd;}BiTree pre=NULL;BOOL ISAVL(BiTree root){ int lcd=0,rcd=0; if(root!=NULL){ int l = ISAVL(root-&gt;LChild); // printf(\"pre: %d\\n\", pre-&gt;data); lcd=Deep(root-&gt;LChild); // 左子树的深度 rcd=Deep(root-&gt;RChild); // 右子树的深度 // printf(\"Deep(root-&gt;LChild): %d\\n\", Deep(root-&gt;LChild)); // printf(\"Deep(root-&gt;RChild): %d\\n\", Deep(root-&gt;RChild)); // printf(\"root: %d\\n\", root-&gt;data); if(abs(lcd-rcd)&gt;1){ // 条件1:每一个节点的左子树和右子树的高度差至多等于1 return FALSE; } if(pre!=NULL){ if(pre-&gt;data &gt; root-&gt;data){ // 条件2:中序遍历的前驱节点大于后面节点的值,就不是平衡二叉树 return FALSE; } } pre=root; int r = ISAVL(root-&gt;RChild); return l &amp;&amp; r; } return TRUE;} 4.3 运行情况截图 &lt;/p&gt; 题目51编写代码完成：输入一棵二叉树，输出它的镜像。 5.1 算法设计思想 利用二叉树遍历递归的思想； 先交换左右子树； 然后分别镜像左右子树。 5.2 源代码 12345678910111213141516void swap(BiTree *node1, BiTree *node2){ BiTree temp; temp = *node1; *node1=*node2; *node2=temp;}void Mirror(BiTree *bt){ if((*bt)==NULL) return; swap(&amp;((*bt)-&gt;LChild), &amp;((*bt)-&gt;RChild)); Mirror(&amp;((*bt)-&gt;LChild)); Mirror(&amp;((*bt)-&gt;RChild));} 5.3 运行情况截图 &lt;/p&gt; 题目6123输入：一个整数和一棵二叉树（树中结点的数据值为int）；输出：二叉树中结点值的和为输入的的整数的所有路径。路径的定义：从树的根结点开始往下一直到叶子结点形成的，称为一条路径。 6.1 算法设计思想 用先序遍历的方式访问节点，使用栈数组ResultStack存储满足条件的路径，使用栈SeqStack存储当前路径节点。 遍历二叉树的过程：按先序遍历顺序访问每一个节点，访问每个结点时，将结点添加到SeqStack中。 如果当前结点是叶子结点，则判断当前路径是否是符合条件的路径，符合条件的路径存入到栈数组ResultStack； 如果当前结点不是叶子结点，则递归当前节点的左右子节点。 6.2 源代码 123456789101112131415161718192021SeqStack ResultStack[10];int i=0;void SumPath(BiTree bt, SeqStack *S, int value){ BiTree p; Push(S, bt); if(bt){ if(!bt-&gt;LChild &amp;&amp; !bt-&gt;LChild){ if(value == bt-&gt;data){ ResultStack[i] = *S; i++; } } else{ SumPath(bt-&gt;LChild, S, value-bt-&gt;data); SumPath(bt-&gt;RChild, S, value-bt-&gt;data); } if(!IsEmpty(*S)) Pop(S, &amp;p); }} 6.3 运行情况截图 &lt;/p&gt; 题目7123输入：一个整数数组，判断该数组是否为某二叉排序树的后序遍历序列；输出：若是，则返回true，若不是，则返回false； 假设该数组中的任何两个数值都互不相同。 7.1 算法设计思想 后续遍历中，最后一个数字是根结点，将数组中的数字分为两部分： 第一部分是左子树的值，它的值都比根结点小； 另一部分是右子树的值，它的值都比根结点大； 后续遍历（5,7,6,9,11,10,8）的最后一个结点是8，所以在这个数组中，5,7,6都比8小时该数的左子树；而9,11,10都比8大，是该树的右子树。 我们以同样的方法来分析其左子树和右子树5,7,6，其中6将左子树分为5和7两部分；10将右子树9和11分为两部分。所以这个序列就是一个后续遍历序列。但是（7,4,5,6）就不是它的一个后续遍历序列。因为6大于7，所以也就是说7,4,5都是其右子树，但是很不幸还有4比6小，所以不可能是一个后续遍历。 7.2 源代码 12345678910111213141516171819202122BOOL VerifySequenceOfBST(int *array,int length){ if(array==NULL || length&lt;=0) return FALSE; int root=array[length-1]; int i=0; //左子树的结点小于根节点； for(;i&lt;length-1;i++){ if(array[i]&gt;root) break; //找完了全部的左子树的序列； } int j=i;//右子树的结点大于根结点； for(;j&lt;length-1;j++){ if(array[j]&lt;root) return FALSE; } BOOL left=TRUE; if(i&gt;0) left=VerifySequenceOfBST(array,i); BOOL right=TRUE; if(j&lt;length-1) right=VerifySequenceOfBST(array+i,length-i-1); return left &amp;&amp; right;} 7.3 运行情况截图 &lt;/p&gt;","link":"/2020/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E5%8D%81/"},{"title":"数据结构进阶实训十一 树","text":"Data structure advanced training course notes and algorithm exercises 数据结构进阶实训课程笔记和算法练习 Source Code C语言中文网 题目11建立树的孩子兄弟表示法存储 1.1 算法设计思想 孩子兄弟表示法：任意一棵树，它的节点的第一个孩子如果存在就是唯一的，它的右兄弟存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟 给定一颗树，可以找到唯一的一颗二叉树与之对应，因此，可以用一颗二叉树来表示一颗树的结构。如图： ​ A A /​ / | B / \\​ B C D E C \\ / | F D /E F G G /​ / | H \\​ H I J I \\​ J 和二叉树建树的方法相同，递归的思想，先建立左子树，左子树建立完（即遇到结束标志字符’#’），退层建立右子树。 所以按照将树转化为二叉树，然后输入先序序列来建这棵树。 1.2 源代码 123456789101112131415161718192021#define ElemType chartypedef struct CSNode{ ElemType data; struct CSNode *firstchild, *nextsibling;}CSNode, *CSTree;// eg. ABE#F##C#DGH#I#J#####void CreatCSTree(CSTree *t){ ElemType ch; scanf(\"%c\", &amp;ch); if(ch=='#') { (*t)=NULL; } else { (*t)=(CSTree)malloc(sizeof(CSNode)); (*t)-&gt;data=ch; CreatCSTree(&amp;((*t)-&gt;firstchild)); CreatCSTree(&amp;((*t)-&gt;nextsibling)); }} 1.3 运行情况截图 题目21在树的孩子兄弟表示法下，求取求取树T的高度。 2.1 算法设计思想 &gt; 2.2 源代码 12 2.3 运行情况截图 题目31树采用孩子兄弟表示法存储。 fch data nsib level 1编写算法，将树中所有结点层次值置入每个结点的level域,并要求由根开始逐层输出树中的各条边，边的输出格式为（ki,kj） 3.1 算法设计思想 &gt; 3.2 源代码 1 3.3 运行情况截图 题目41已知树采用孩子兄弟表示法表示试编写算法按如下的凹入方式打印树。 4.1 算法设计思想 &gt; 4.2 源代码 12 4.3 运行情况截图","link":"/2020/07/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E5%8D%81%E4%B8%80/"},{"title":"数据结构进阶实训六 多维数组","text":"Data structure advanced training course notes and algorithm exercises Source Code: https://github.com/MysticalGuest/DataStructure/tree/master/AdvancedJuniorTraining 题目1123我们把只包含因子2,3,5的数称为丑数。求从小到大的第1500个丑数。 -例如：6,8都是丑数，但14不是丑数，因为它包含因子7.习惯上我们把1当做丑数。 -编写尽可能高效的算法。提示：（可以用空间换时间） 1.1 算法设计思想 准备一个数组，初始化第1个丑数的下标0，值1；然后1X2得到2，就是第2个丑数；然后1X3得到3，就是第3个丑数；不能直接1X5就是第4个丑数，因为还有一个丑数2X2=4；所以难点就是判断中间丑数，然后存储在数组中；往下循环；然后1X5得到5，就是第5个丑数 1.2 源代码 1234567891011121314151617181920212223int min_num(int n1,int n2,int n3){ int min=(n1&lt;n2)?n1:n2; min=(min&lt;n3)?min:n3; return min;}void solution(long int array[]){ int i; int t2=0;//记录M2的下标 int t3=0; int t5=0; for(i=1; i&lt;1500; i++){ while(array[t2]*2&lt;=array[i-1])//查找到新的M2，即乘以2后第一个大于M的数 t2++; while(array[t3]*3&lt;=array[i-1]) t3++; while(array[t5]*5&lt;=array[i-1]) t5++; int min=min_num(array[t2]*2, array[t3]*3, array[t5]*5); array[i]=min; }} 1.3 运行情况截图 题目21顺时针打印矩阵 2.1 算法设计思想 针对一般矩阵，先顺时针打印最外部一圈，那么这个矩阵去掉外部一圈，内部也是一个小矩阵；按照这样的规律，依次打印最外部一圈就可以了 2.2 源代码 1234567891011121314151617181920212223void PrintMatrix(int (*num)[4], int col, int row, int layer){ int i; int new_col = col - layer; int new_row = row - layer; for(i=layer; i&lt;new_col; i++){ // 从左至右打印第一行 printf(\"%d \", num[layer][i]); } if(new_row&gt;layer){ for(i=layer+1; i&lt;new_row; i++){ // 从上至下打印最右一列 printf(\"%d \", num[i][new_row-1]); } } if(new_col-1&gt;layer &amp;&amp; new_row-1&gt;layer){ for(i=new_col-2; i&gt;=layer; i--){ // 从右至左打印最后一行 printf(\"%d \", num[new_col-1][i]); } } if(new_col-1&gt;layer &amp;&amp; new_row-1&gt;layer+1){ for(i=new_row-2; i&gt;layer; i--){ // 从下至上打印最左一列 printf(\"%d \", num[i][layer]); } }} 2.3 运行情况截图 题目3123设二维数组B[0..m-1][0..n-1]的数据在行、列方向上都按从小到大的顺序有序，且x在B中存在。试设计一个算法，找出x在B数组中的位置i,j。要求比较的次数不超过m+n 3.1 算法设计思想 第一个循环（最多4次）： 将要定位的元素与每一行的最后一个元素比较，如果小于等于最后一个元素就结束循环，此时的i值就是元素的行坐标； 第二次循环（最多5次）： 将要定位的元素与每一列的所有元素比较，如果小于等于这个值，就结束循环，此时的j值就是元素的列坐标 3.2 源代码 123456789int matrix[4][5] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20}, i, j;for(i=0; i&lt;4; i++){ // 定位行坐标i if(obj &lt;= matrix[i][4]) break;}for(j=0; j&lt;5; j++){ // 定位列坐标j if(obj &lt;= matrix[i][j]) break;} 3.3 运行情况截图","link":"/2020/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E5%85%AD/"},{"title":"数据结构进阶实训四 链表","text":"Data structure advanced training course notes and algorithm exercises 数据结构进阶实训课程笔记和算法练习 Source Code: https://github.com/MysticalGuest/DataStructure/tree/master/AdvancedJuniorTraining 题目11给定一个单链表L，L为头指针，判断该链表内是否局部存在环？ 1.1 算法设计思想 使用快慢指针判断单链表是否存在环。 使用slow、fast 2个指针，slow慢指针每次向前走1步，fast快指针每次向前走2步，若存在环的话，必定存在某个时候 slow = fast 快慢指针相遇。 返回值为1：存在环 返回值为0：不存在环 1.2 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657typedef struct Node { int data; struct Node *next;}Node, *LinkList;void InitLinkList(LinkList *L) { *L = (LinkList)malloc(sizeof(Node)); (*L)-&gt;next = NULL; Node *r=*L, *s, *temp; int i=0; while(i&lt;10){ s=(Node*)malloc(sizeof(Node)); s-&gt;data=i; r-&gt;next=s; s-&gt;next=NULL; if(i==4){ // 记住一个元素,以助后面成环 temp=r; } r=s; i++; } r-&gt;next=temp; // 成环}int IsLoopLinkList(LinkList list){ //空指针 if(list == NULL){ return 0; } //只有头结点,没有元素 if(list-&gt;next == NULL){ return 0; } Node* slow = list; Node* fast = list; int loc = 0; while (1){ if(fast-&gt;next == NULL){ //快指针 到底链表尾结点说明 没有环，此时slow 指向中间结点 return 0; } else{ if (fast-&gt;next != NULL &amp;&amp; fast-&gt;next-&gt;next != NULL){ fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; } else{ fast = fast-&gt;next; } } //某个时刻 快慢指针相遇，说明此处存在环！ if(slow == fast){ return 1; } } return 0;} 1.3 运行情况截图 题目21234找到单链表中倒数第k个结点。找出解决方法要求：尽可能高效例如：一个链表有6个结点，（1,2,3,4,5,6）这个链表的倒数第3个结点是：值为4的结点 2.1 算法设计思想 先遍历获得链表长度listlen(L)； 然后计算得出倒数第k个节点的正数位置，也就是listlen(L)-k+1； 遍历到listlen(L)-k+1的节点，然后输出 2.2 源代码 12345678910111213141516/* 求链表长度 */int listlen(LinkList L){ int len=0; Node *head=L; while(head-&gt;next!=NULL){ len++; head=head-&gt;next; } return len;}// mainscanf(\"%d\", &amp;k);for(i=0; i&lt;listlen(L)-k+1; i++){ p=p-&gt;next;} 2.3 运行情况截图 题目312在O(1)时间删除单链表结点；给定单链表L及其中一个结点地址p,定义一个函数实现在O(1)时间删除该结点。 3.1 算法设计思想 将节点p的下一个节点的值赋给p；p的后继指向p的后继的后继；然后free掉p的后继 3.2 源代码 12345678910111213141516171819202122232425void InitLinkList(LinkList *L, LinkList *temp) { *L = (LinkList)malloc(sizeof(Node)); (*L)-&gt;next = NULL; Node *r=*L, *s; int i=0; while(i&lt;10){ s=(Node*)malloc(sizeof(Node)); s-&gt;data=i; r-&gt;next=s; s-&gt;next=NULL; if(i==5){ // 记住一个节点地址 *temp=r; } r=s; i++; }}// mainInitLinkList(&amp;L, &amp;p);s=p-&gt;next;p-&gt;data = s-&gt;data;p-&gt;next=s-&gt;next;free(s); 3.3 运行情况截图 题目4123假定用带头结点的单链表保存单词，当两个单词有相同的后缀时，则可共享相同的后缀存储空间，例如：loading和being。 - 设计一个高效的算法，找出str1和str2的共同后缀的起始位置。（可能有也可能没有。） - 分析算法的时空效率 4.1 算法设计思想 分别获得链表str1和str2的长度；移动长度较长的链表的头指针，使得两指针的起始位置相同；然后同时往后移动，遇到相同地址的节点即为共同后缀的起始位置 4.2 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657LinkList reverse(LinkList L){ if(L-&gt;next == NULL || L-&gt;next-&gt;next == NULL) { return L; /*链表为空或只有一个元素则直接返回*/ } Node *r, *p = L-&gt;next, *q = L-&gt;next-&gt;next; while(q != NULL){ r = q-&gt;next; q-&gt;next = p; p = q; q = r; } /*此时q指向原始链表最后一个元素，也是逆转后的链表的表头元素*/ L-&gt;next-&gt;next = NULL; /*设置链表尾*/ L-&gt;next = p; /*调整链表头*/ return L;}LinkList commonSuffix1(LinkList L1, LinkList L2){ Node *p, *q; int len1, len2; len1=listlen(L1); len2=listlen(L2); if(lastNode(L1) != lastNode(L2)){ return NULL; } else{ for(p=L1; len1&gt;len2; len1--){ p=p-&gt;next; } for(q=L2; len2&gt;len1; len2--){ q=q-&gt;next; } while(p-&gt;next != NULL &amp;&amp; p-&gt;next != q-&gt;next){ p=p-&gt;next; q=q-&gt;next; } return p-&gt;next; }}LinkList commonSuffix2(LinkList L1, LinkList L2){ Node *p=L1, *q=L2; if(L1-&gt;next == NULL || L2-&gt;next == NULL){ // 空，直接返回 return NULL; } // else if(L1-&gt;next != L2-&gt;next){ // 这里的第一个元素,是原来的最后一个元素 // return NULL; // 不相等直接返回 // } else{ while(p-&gt;next != NULL &amp;&amp; q-&gt;next != NULL &amp;&amp; p-&gt;next != q-&gt;next){ p=p-&gt;next; q=q-&gt;next; } return p-&gt;next; }} 4.3 运行情况截图","link":"/2020/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E5%9B%9B/"},{"title":"树的要点归纳","text":"数据结构第六章要点归纳 1.树的基础知识点1.1 树的相关概念 结点拥有的子树数称为节点的度（Degree）。 度为0的结点称为叶结点（Leaf）或终端结点；度不为0的结点称为非终端结点或分支节点。 除根节点之外，分支节点也称为内部结点。 树的度是树内部各结点的度的最大值。 如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。 森林是$m(m \\geq 0)$棵互不相交的树的集合。 1.2 树的存储结构 双亲表示法 孩子表示法 孩子兄弟表示法 1.3 二叉树的相关概念 斜树：所有的结点都只有左子树的二叉树叫左斜树。所有结点都只有右子树的二叉树叫右斜树。这二者统称为斜树。 满二叉树：在一颗二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。 完全二叉树：对一棵具有n个结点的二叉树按层序编号，如果编号为$i(1 \\leq i \\leq n)$的节点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。 完全二叉树的特点： ​ （1）叶子结点只能出现在最下两层。 ​ （2）最下层的叶子一定集中在左部连续位置。 ​ （3）倒数二层，若有叶子结点，一定都在右部连续位置。 ​ （4）如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况。 ​ （5）同样结点数的二叉树，完全二叉树的深度最小。 1.4 二叉树的存储结构 顺序存储结构 二叉链表 2.二叉树5个基本性质及灵活应用 二叉树的定义：二叉树(Binary Tree)是n(n≥0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根节点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。 2.1 性质1在二叉树的第i层上至多有$2^{i-1}$个结点（$i \\geq 1$）。 2.2 性质2深度为k的二叉树至多有$2^k-1$个结点（$k \\geq1$）。 2.3 性质3对任何一棵二叉树T，如果其终端结点数为$n_0$，度为2的结点数为$n_2$，则$n_0=n_2+1$。 2.4 性质4具有n个结点的完全二叉树的深度为$\\lfloor log_2{n} \\rfloor +1$ （$\\lfloor x \\rfloor$表示不大于x的最大整数）。 2.5 性质5如果对一棵有$n$个结点的完全二叉树（其深度为$\\lfloor log_2{n} \\rfloor +1$）的结点按层序编号（从第1层到第$\\lfloor log_2{n} \\rfloor+1$层，每层从左到右），对任一结点$i(1 \\leq i \\leq n)$有： 如果$i=1$，则节点$i$是二叉树的根，无双亲；如果$i \\geq 1$，则其双亲是节点$\\lfloor \\frac{i}{2} \\rfloor$。 如果$2i &gt; n$，则结点$i$无左孩子（结点i为叶子节点）；否则其左孩子是结点$2i$。 如果$2i+1 &gt; n$，则结点$i$无右孩子；否则其右孩子是结点$2i+1$。 3.二叉树遍历（基础知识掌握） 二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。 3.1 前、中、后序遍历3.2 二叉树的建立3.3 线索二叉树3.3.1 对于一个有$n$个结点的二叉链表，每个结点有指向左右孩子的两个指针域，所以一共是$2n$个指针域。而$n$个结点的二叉树一共有$n-1$条分支线数，也就是说，其实是存在$2n-(n-1) =n+1$个空指针域。 12345678 A / \\ B C / \\ / \\ D E F G / \\ /H I J 图3-1 3.3.2 如上图，中序遍历得到HDIBJEAFCG这样的字符，可以知道，结点I的前驱是D，后继是B，结点F的前驱是A，后继是C。 3.3.3 指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树(Threaded Binary Tree)。 3.3.4 其实线索二叉树，等于是把一棵二叉树转变成了一个双向链表，这样对我们的插入删除结点都带来了方便。 3.3.5 对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化。 3.3.6 在每个节点再增设两个标志域ltag和rtag，只存放0或1数字的布尔型变量，其占用的内存空间要小于像lchild和rchild的指针变量。结点结构如下： lchild ltag data rtag rchild 其中： ltag为0时指向该结点的左孩子，为1时指向该结点的前驱。 rtag为0时指向该结点的右孩子，为1时指向该结点的后继。 因此对于图3-1的二叉链表图可以修改为图3-2的样子。 12345678 0A0 / \\ 0B0 0C0 / \\ / \\ 0D0 0E1 1F1 1G1 / \\ /1H1 1I1 1J1 图3-2 3.4 线索二叉树结构实现 线索化的过程就是在遍历的过程中修改空指针的过程。 中序遍历线索化的递归函数代码如下： 12345678910111213141516171819BiThrTree pre; /* 全局变量，始终指向刚刚访问过的节点 *//* 中序遍历进行中序线索化 */void InThreading(BiThrTree p){ if(p){ InThreading(p-&gt;lchild); /* 递归左子树线索化 */ if(!p-&gt;lchild){ /* 没有左孩子 */ p-&gt;LTag=Thread; /* 前驱线索 */ p-&gt;lchild=pre; /* 左孩子指针指向前驱 */ } if(!pre-&gt;rchild){ /* 前驱没有右孩子 */ p-&gt;RTag=Thread; /* 后继线索 */ p-&gt;rchild=p; /* 前驱右孩子指针指向后继（当前结点p） */ } pre=p; /* 保持pre指向p的前驱 */ InThreading(p-&gt;rchild); /* 递归右子树线索化 */ }} 有了线索二叉树后，我们对它进行遍历时发现，其实就等于是操作一个双向链表结构。 和双向链表结构一样，在二叉树线索链表上添加一个头结点，如图3-3所示，并另其lchild域的指针指向二叉树的根节点（图中的a），其rchild域的指针指向中序遍历时访问的最后一个结点（图中的b）。 反之，令中序序列中的第一个结点H的lchild域指针和最后一个结点的rchild域指针均指向头结点。这样定义的好处就是我们既可以从第一个节点起顺后继进行遍历，也可以从最后一个结点起顺前驱进行遍历。 12345678910 头指针-&gt;| |0#1| | a/ | 0A0 | / \\ |b 0B0 0C0 | / \\ / \\| 0D0 0E1 1F1 1G1 / \\ /1H1 1I1 1J1 图3-3 遍历代码如下： 1234567891011121314151617/* T指向头结点，头结点左链lchild指向根节点，头结点右键rchild指向中序遍历的 *//* 最后一个结点。中序遍历二叉线索链表表示的二叉树T */Status InOrderTraverse_Thr(BiThrTree T){ BiThrTree p; p = T-&gt;lchild; /* p指向根结点 */ while(p != T){ /* 空树或遍历结束时，p==T */ while(p-&gt;LTag==Link) /* 当LTag==0时循环到中序序列第一个结点 */ p = p-&gt;lchild; printf(\"%c\", p-&gt;data); /* 显示结点数据，可以更改为其他对结点操作 */ while(p-&gt;RTag==Thread &amp;&amp; p-&gt;rchild!=T){ p = p-&gt;rchild; printf(\"%c\", p-&gt;data); } p = p-&gt;rchild; /* p进至其右子树根 */ } return OK;} 相当于是一个链表的扫描，所以时间复杂度为O(n)。 如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。 4.二叉树遍历算法应用算法都在二叉树的应用和二叉排序树噢！ 5.树遍历算法应用 树转换为二叉树 森林转换为二叉树 二叉树转换为树 二叉树转换为森林 5.1 树的遍历两种方式 一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。 另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。 比如图5-1中的树，它的先根遍历序列为ABEFCDG，后根遍历序列为EFBCGDA。 123456 A / | \\ B C D / \\ /E F G 图5-1 5.2 森林的遍历两种方式 前序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。比如图5-2中的森林，前序遍历序列的结果就是ABCDEFGHJI。 123456 A E G / | \\ | / \\B C D F H I | J 图5-2 后序遍历：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。比如图5-2中的森林，后序遍历序列的结果就是BCDAFEJHIG。","link":"/2020/06/26/%E6%A0%91%E7%9A%84%E8%A6%81%E7%82%B9%E5%BD%92%E7%BA%B3/"},{"title":"Hexo博客迁移","text":"Hexo用户指南 - 博客迁移GitHub+Hexo搭建博客的过程比较平滑，但是它的配置却非常耗时，一旦电脑出现问题或者需要在另外一台电脑上写博客，那么Hexo博客的迁移非常就让人头疼。下面参考其他博客的方法，针对类似问题，整理出一个能在平时就管理重要文件的方法，方便随时迁移。 解决类似问题 创建Git分支将Hexo博客迁移到其它电脑换了电脑如何使用hexo继续写博客 我整理了网上的方法并根据自己的实际情况总结出了我的解决方法 操作步骤1.基础配置电脑的基础配置还是要有的，比如： Git客户端NodeJS生成SSH密钥等 2.源文件拷贝Hexo博客系统中影响迁移的只有一部分文件和文件夹，所以只需要备份它们即可 文件（夹） 说明 scaffolds/ 博客文章的模版 source/ 所有博客文章，以及about、tags、categories等page themes/ 网站的主题所在文件夹 .gitignore 在push时需要忽略的文件和文件夹 _config.yml 站点配置文件 package.json 依赖包的名称和版本号 我们要做的就是通过各种方式备份这些文件和文件夹，比如说以下两种静态备份方式： 1.通过U盘或移动硬盘保存2.通过网盘保存 3.本地配置 3.1 创建目录 创建一个名为&quot;自己的git用户名.github.io&quot;的文件夹（推荐用这个用户名以免后面遇到问题）， 3.2 初始化 Hexo 1$ hexo init 3.3 初始化git本地仓库 1$ git init 3.4 复制文件到指定目录 把备份过的文件和文件夹都复制到hexo文件夹下完成后hexo的目录结构应该如下123456789101112.deploy_git.gitnode_modulespublicscaffoldsscourcethemes.gitignore_config.ymldb.jsonpackage.jsonpackage-lock.json 4.测试1$ hexo s 这时候浏览器基本可以看到博客了。 5.部署发布文章12345678910// 清除缓存 网页正常情况下可以忽略此条命令$ hexo clean// 生成静态网页$ hexo g // 开始部署$ hexo d$ hexo g -d","link":"/2020/06/21/Hexo%E8%BF%81%E7%A7%BB/"},{"title":"数据结构进阶实训八 数组，规律","text":"Data structure advanced training course notes and algorithm exercises Source Code: https://github.com/MysticalGuest/DataStructure/tree/master/AdvancedJuniorTraining 题目1123荷兰国旗现有n个红蓝白三种不同颜色的小球，乱序排列在一起；请通过两两交换任意两个球，使得从左到右的球依次：红球、白球、蓝球 1.1 算法设计思想 把题目理解为这样的问题：一个循环，把红色球和剩余的球交换，那么红球就排序好了，就是两两交换问题；另一个循环，把剩下没排序好的白球和蓝球也排序好，也是两两交换；程序的时间复杂度取决于长度取决于第一个循环，O(n) 1.2 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#define RED 0#define WHITE 1#define BLUE 2void swap(int *p, int *q){ int temp; temp = *p; *p = *q; *q = temp;}void sort(int array[], int start, int end, int collor){ int i=start, j=end; while(i &lt; j){ while(array[i]==collor){ i++; } while(array[j]!=collor){ j--; } swap(&amp;array[i], &amp;array[j]); i++; }}void main(){ int ball[20]={1,2,2,0,1,0,1,2,0,0,0,1,2,1,0,1,2,0,0,1}; int i, num_red=0; printf(\"There are 20 red, blue and white balls in three different colors, \\ arranged together in disorder:\\n\"); for(i=0; i&lt;20; i++){ if(ball[i]==RED){ num_red++; printf(\"Red \"); } if(ball[i]==WHITE) printf(\"White \"); if(ball[i]==BLUE) printf(\"Blue \"); } printf(\"\\n\"); sort(ball, 0, 20, RED); // 把红色球排好序 sort(ball, num_red, 20, WHITE); // 把白色球排好序 printf(\"\\nAfter sorting: \\n\"); for(i=0; i&lt;20; i++){ if(ball[i]==RED) printf(\"Red \"); if(ball[i]==WHITE) printf(\"White \"); if(ball[i]==BLUE) printf(\"Blue \"); } printf(\"\\n\");} 1.3 运行情况截图 题目21234完美洗牌算法有一个长度为2n的数组{a1,a2,a3,…an,b1,b2,b3, …bn},希望“排序”后，变为{a1, b1, a2, b2, a3, b3,…an, bn}。要求：尽可能高效。能否在时间复杂度为O(n)，空间复杂度为O（1）的解法 2.1 算法设计思想 依次考察每个位置的变化规律a1: 0 -&gt; 不变a2: 1 -&gt; 2a3: 2 -&gt; 4a4: 3 -&gt; 6…an: n-1 -&gt; 2n-2b1: n -&gt; 1b2: n+1 -&gt; 3b3: n+2 -&gt; 5…bn-1: 2n-2 -&gt; 2n-3bn: 2n-1 -&gt; 不变可以得出下标的变化规律：j=(i * 2) % (n2 -1)所以将值赋给辅助数组即可 2.2 源代码 1234567891011void perfect_shuffle(char *a[],int n) { int n2 = n * 2, i, j; char *b[20]; for (i = 1; i &lt; n2-1; i++) { j=(i * 2) % (n2 -1); b[j] = a[i]; } for (i = 1; i &lt; n2-1; i++) { a[i] = b[i]; }} 2.3 运行情况截图 题目312345买票找零问题在一场激烈的球赛开始之前，售票工作正在紧张地进行中，每张球票为50元。现有2n个人排队购票，其中有n个人手持50元的钞票，另外的n个人手持100元的钞票，假设开始售票时，售票处没有零钱。要求：问这2n个人有多少种排队方式，不至于使售票处出现找不开钱的局面呢 3.1 算法设计思想 找规律递推的方法；要求持50元n人，100元n人，多少种排队方式，那么排在最后的一定是持100元的人，所以和持50元n人，100元n-1人的排队方式相同；发现规律，持50元n-1人，100元n-1人和持50元n-1人，100元n-2人的排队方式相同；所以这就可以从最小的1开始求了，然后累加到n，得到最后结果 3.2 源代码 123456789101112131415161718#define N 100int arrange(int n){ int array[N][N]; int i, j; // 当100元和50元人数不相等，100元0人，则只有1中解决方案 for(i=0; i&lt;n; i++){ array[i][0]=1; } // 若50元人数小于100元人数，则没有解决方案 // 则二维数组的上三角的值都为0，不用初始化赋值 // 开始递推，填满下三角矩阵数组 for(i=1; i&lt;=n; i++){ for(j=0; j&lt;=i; j++) array[i][j]=array[i-1][j]+array[i][j-1]; } return array[n][n];} 3.3 运行情况截图","link":"/2020/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E5%85%AB/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"OS","slug":"OS","link":"/tags/OS/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Electron-Vue","slug":"Electron-Vue","link":"/tags/Electron-Vue/"},{"name":"Element-UI","slug":"Element-UI","link":"/tags/Element-UI/"},{"name":"Axios","slug":"Axios","link":"/tags/Axios/"},{"name":"C","slug":"C","link":"/tags/C/"}],"categories":[{"name":"Compile","slug":"Compile","link":"/categories/Compile/"},{"name":"课程","slug":"课程","link":"/categories/%E8%AF%BE%E7%A8%8B/"},{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"},{"name":"主题","slug":"主题","link":"/categories/%E4%B8%BB%E9%A2%98/"},{"name":"配置","slug":"配置","link":"/categories/%E9%85%8D%E7%BD%AE/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}]}