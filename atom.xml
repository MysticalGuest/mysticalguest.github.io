<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Longing(MysteryGuest的博客)</title>
  
  <subtitle>心向星光</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mysticalguest.github.io/"/>
  <updated>2022-03-08T03:22:57.075Z</updated>
  <id>https://mysticalguest.github.io/</id>
  
  <author>
    <name>MysticalGuest</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>牛客网-Java题库</title>
    <link href="https://mysticalguest.github.io/Java/1baae15a.html"/>
    <id>https://mysticalguest.github.io/Java/1baae15a.html</id>
    <published>2022-03-08T02:59:14.809Z</published>
    <updated>2022-03-08T03:22:57.075Z</updated>
    
    <content type="html"><![CDATA[<p>牛客刷题整理</p><a id="more"></a><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><p>1、JSP内置对象</p><p>session对象，request对象，application对象，response对象</p><p>2、下列代码运行结果<code>prints:3</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">   <span class="keyword">int</span> x=<span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x,y;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">   x--;</span><br><span class="line">   myMethod( );</span><br><span class="line">   System.out.println(x+y+ ++x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">( )</span></span>&#123;</span><br><span class="line">  y=x++ + ++x;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、下面代码输出<code>编译正确，输出”It is a account type”thrice followed by”FIXED”</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> AccountType</span><br><span class="line">&#123;</span><br><span class="line">    SAVING, FIXED, CURRENT;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AccountType</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"It is a account type"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnumOne</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(AccountType.FIXED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">It is a account type</span><br><span class="line">It is a account type</span><br><span class="line">It is a account type</span><br><span class="line">CURRENT</span><br></pre></td></tr></table></figure><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><p>1、AccessViolationException异常触发后，下列程序的输出结果为（   ）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(string[] args)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">try</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AccessViolationException();  </span><br><span class="line">        Console.WriteLine(<span class="string">"error1"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">catch</span> (Exception e)  </span><br><span class="line">    &#123;  </span><br><span class="line">        Console.WriteLine(<span class="string">"error2"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    Console.WriteLine(<span class="string">"error3"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error2</span><br><span class="line">error3</span><br></pre></td></tr></table></figure><p>2、下面的程序将来打印什么?（）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIncr</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        i = i++ + i;</span><br><span class="line">        System.out.println(<span class="string">"I ="</span> +i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：<code>2</code></p><p>3、以下说法错误</p><ul><li>java线程类优先级相同</li><li>Thread和Runnable接口没有区别</li><li>如果一个类继承了某个类，只能使用Runnable实现线程</li></ul><p>4、下面有关java类加载器，说法正确</p><ul><li>引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的</li><li>扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库</li><li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类</li><li>tomcat为每个App创建一个Loader，里面保存着此WebApp的ClassLoader。需要加载WebApp下的类时，就取出ClassLoader来使用</li></ul><h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><p>1、以下代码返回值是<code>false</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">returnTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e)</span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、假设有以下代码<code>String s = &quot;hello&quot;;String t = &quot;hello&quot;;char c [ ] = {&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;};</code>下列选项中返回false的语句是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回false</span></span><br><span class="line">t.equals (c);</span><br><span class="line"><span class="comment">// 返回true</span></span><br><span class="line">s.equals (t);</span><br><span class="line">s==t;</span><br><span class="line">t.equals (<span class="keyword">new</span> String (<span class="string">"hello"</span>));</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><blockquote><ul><li>java数据类型分为：<ul><li><strong>基本数据类型</strong></li><li><strong>引用数据类型</strong></li></ul></li><li>对于”==”：<ul><li>用于<strong>基本数据</strong>类型相互比较，比较二者的<strong>值</strong>是否相等</li><li>用于<strong>引用数据</strong>类型相互比较，比较二者<strong>地址</strong>是否相等</li><li>不能用于基本数据类型与引用型比较</li></ul></li><li>对于”equals”：<ul><li>不能用于基本数据类型比较（因为这是一个方法，继承自object）</li><li>用于进行<strong>对象</strong>的比较，比较二者的<strong>引用地址</strong>是否相同</li></ul></li><li>特殊情况：<ul><li>数值型基本类型和数值型类会存在<strong>自动装箱</strong>和<strong>自动拆箱</strong></li><li>字符串会以常量形式存在，如果多个字符串变量<strong>值相同</strong>，则他们指向<strong>同一个地址</strong></li><li>数值类型会存在<strong>类型自动转换</strong></li></ul></li></ul></blockquote><p>3、下列流当中，属于处理流的是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理流</span></span><br><span class="line">DatalnputStream</span><br><span class="line">BufferedlnputStream</span><br><span class="line"><span class="comment">// 非处理流</span></span><br><span class="line">FilelnputStream</span><br><span class="line">lnputStream</span><br></pre></td></tr></table></figure><h2 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h2><p>1、Java数据库连接库JDBC用到哪种设计模式？正确答案：桥接模式</p><ul><li>选项还有：生成器、抽象工厂、单例模式</li></ul><p>2、jdk1.8中，下面有关java 抽象类和接口的区别，说法错误的是：</p><ul><li>抽象类中可以包含非抽象的普通方法，接口中的方法必须是抽象的，不能有非抽象的普通方法</li><li>接口中可以有普通成员变量，抽象类中没有普通成员变量</li></ul><p>正确的是：</p><ul><li>抽象类可以有构造方法，接口中不能有构造方法</li><li>一个类可以实现多个接口，但只能继承一个抽象类</li></ul><p><strong>总结</strong></p><blockquote><ul><li><strong>抽象类</strong><ul><li>抽象类中可以构造方法</li><li>抽象类中可以存在普通属性，方法，静态属性和方法</li><li>抽象类中可以存在抽象方法</li><li>如果一个类中有一个抽象方法，那么当前类一定是抽象类；抽象类中不一定有抽象方法</li><li>抽象类中的抽象方法，需要有子类实现，如果子类不实现，则子类也需要定义为抽象的</li></ul></li><li><strong>接口</strong><ul><li>在接口中只有方法的声明，没有方法体</li><li>在接口中只有常量，因为定义的变量，在编译的时候都会默认加上<code>public static final</code></li><li>在接口中的方法，永远都被public来修饰</li><li>接口中没有构造方法，也不能实例化接口的对象</li><li>接口可以实现多继承</li><li>接口中定义的方法都需要有实现类来实现，如果实现类不能实现接口中的所有方法，则实现类定义为抽象类</li></ul></li></ul></blockquote><p>3、<code>synchronized</code>保证三大性，原子性，有序性，可见性，<code>volatile</code>保证有序性，可见性，不能保证原子性；选项中还有：持久性</p><h2 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h2><p>1、以下代码执行后输出结果为：<code>hello and dbc</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTest</span> </span>&#123;</span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">char</span>[] ch = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(String str, <span class="keyword">char</span> ch[])</span></span>&#123;</span><br><span class="line">str=<span class="string">"world"</span>;</span><br><span class="line">ch[<span class="number">0</span>]=<span class="string">'d'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ClassTest test1 = <span class="keyword">new</span> ClassTest();</span><br><span class="line">test1.fun(test1.str,test1.ch);</span><br><span class="line">System.out.print(test1.str + <span class="string">" and "</span>);</span><br><span class="line">System.out.print(test1.ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解：</p><blockquote><p><code>fun</code>方法修改的都是形参，区别是一个仅仅只是<strong>修改形参的引用</strong>，另一个是通过形参修改堆值。</p><p><code>ch</code>是一个数组，<strong>数组是一个对象</strong>，对象存放在堆中，<code>fun</code>方法区堆中修改值，改变了。</p><p><code>fun</code>方法为形参赋值时，修改的是形参的引用指向，成员变量<code>str</code>原来引用的<code>String</code>值未被修改。</p></blockquote><p>2、下面代码输出结果是：<code>CBB</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    C() &#123;</span><br><span class="line">        System.out.print(<span class="string">"C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    C c = <span class="keyword">new</span> C();</span><br><span class="line"> </span><br><span class="line">    A() &#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">"A"</span>);</span><br><span class="line">        System.out.print(<span class="string">"A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    A(String s) &#123;</span><br><span class="line">        System.out.print(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    Test() &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"B"</span>);</span><br><span class="line">        System.out.print(<span class="string">"B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解：</p><blockquote><p>首先<code>new</code>了一个子类对象，那么就要调用构造方法来初始化该子类对象。</p><p>因为<code>Test</code>方法已经显式调用了<code>super(&quot;B&quot;)</code>，所以会直接调用A的有参构造，不会再调用A的无参构造。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;牛客刷题整理&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://mysticalguest.github.io/categories/Java/"/>
    
    
      <category term="积累" scheme="https://mysticalguest.github.io/tags/%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>计算机视觉</title>
    <link href="https://mysticalguest.github.io/CV/746b0d51.html"/>
    <id>https://mysticalguest.github.io/CV/746b0d51.html</id>
    <published>2021-12-08T13:13:28.172Z</published>
    <updated>2021-12-09T11:48:31.090Z</updated>
    
    <content type="html"><![CDATA[<p>视觉相关概念</p><a id="more"></a><h2 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h2><p>深度学习相当于函数逼近问题，即函数或曲面的拟合 ，所不同的是，这里用作基函数的是非线性的神经网络函数，而原来数学中的用的则是多项式、三角不等式等。</p><h3 id="贡献度分配问题（Credit-Assignment-Problem，CAP）"><a href="#贡献度分配问题（Credit-Assignment-Problem，CAP）" class="headerlink" title="贡献度分配问题（Credit Assignment Problem，CAP）"></a>贡献度分配问题（Credit Assignment Problem，CAP）</h3><p>深度学习采用的模型一般比较复杂，指样本的原始输入到输出目标 之间的数据流经过多个线性或非线性的组件（component）。因为每个组件都会对信息进行加工，并进而影响后续的组件，所以当我们最后得到输出结果时，我们并不清楚其中每个组件的贡献是多少。这个问题叫作贡献度分配问题。</p><p>目前，一种可以比较好解决贡献度分配问题的模型是人工神经网络。神经网络和深度学习并不等价，深度学习可以采用神经网络模型，也可以采用其他模型（比如深度信念网络是一种概率图模型）。</p><h3 id="深度学习-1"><a href="#深度学习-1" class="headerlink" title="深度学习"></a>深度学习</h3><p>深度学习是将原始的数据特征通过多步的特征转换得到一种特征表示，并进一步输入到预测函数得到最终结果。深度学习需要解决的关键问题是贡献度分配问题。</p><p>深度学习采用的模型主要是神经网络模型，其主要原因是神经网络模型可以使用误差反向传播算法，从而可以比较好地解决贡献度分配问题。将超过一层的神经网络都看作深度学习模型。度的不断增加，其特征表示的能力也越来越强，从而使后续的预测更加容易。</p><h2 id="ROI-Pooling"><a href="#ROI-Pooling" class="headerlink" title="ROI Pooling"></a>ROI Pooling</h2><p>特点是输入特征图尺寸不固定，但是输出特征图尺寸固定。</p><h2 id="NMS非极大值抑制"><a href="#NMS非极大值抑制" class="headerlink" title="NMS非极大值抑制"></a>NMS非极大值抑制</h2><h2 id="bounding-box"><a href="#bounding-box" class="headerlink" title="bounding box"></a>bounding box</h2><h2 id="为什么要使用深层网络"><a href="#为什么要使用深层网络" class="headerlink" title="为什么要使用深层网络"></a>为什么要使用深层网络</h2><ul><li>深度神经网络的学习是特征递进的，浅层的神经元只能学习一些低层次的简单特征（如边缘、纹理），而深层神经网络可以学到更高级特征。</li><li>深层网络的隐藏单元数目较少，隐藏层数目较多。 若浅层网络想达到同样的计算结果须指数级增长单元数量。</li><li>在神经元数量相同的情况下，深层网络具有更大容量，能构造更复杂的映射关系。</li></ul><h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><h3 id="激活函数的作用"><a href="#激活函数的作用" class="headerlink" title="激活函数的作用"></a>激活函数的作用</h3><ul><li>可以引入非线性因素，方便学习复杂数据。</li><li>激活函数可以把当前特征空间通过一定的线性映射转换到另一个空间，让数据能够更好的被分类。</li></ul><h3 id="常见的激活函数"><a href="#常见的激活函数" class="headerlink" title="常见的激活函数"></a>常见的激活函数</h3><ul><li>sigmoid激活函：仅仅输出层为2分类问题时使用。</li><li>tanh激活函数：非常优秀的，几乎适合所有场合。</li><li>Relu激活函数：如果在隐藏层上不确定使用哪个激活函数，那么通常会使用 Relu 激活函数。有时，也会使用 tanh 激活函数。</li><li>Leak Relu激活函数：如果遇到了一些死的神经元，我们可以使用 Leaky Relu 函数。</li><li>Softmax激活函数：Softmax用于多分类问题，其将多个神经元的输出映射到（0,1）区间内，并且他们的和为1，因而我们可以将每个Softmax值理解为概率。选取概率最大的值作为分类的类别。</li></ul><h3 id="激活函数的性质"><a href="#激活函数的性质" class="headerlink" title="激活函数的性质"></a>激活函数的性质</h3><ul><li>非线性</li><li>可导性：梯度计算</li><li>单调性：当激活函数是单调的时候，单层网络能够保证是凸函数</li><li><script type="math/tex">f(x)\approx x</script>：训练更高效</li></ul><h2 id="Batch-Size"><a href="#Batch-Size" class="headerlink" title="Batch Size"></a>Batch Size</h2><p>将一个epoch分批次进行训练，每批次训练样本的大小。</p><p>可以分批次进行训练，避免一次性读取所有数据而引发的内存不足问题。</p><h2 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h2><ul><li>同一量纲，统一数据的评价标准。 </li><li>保证数据小的值不被吞食。</li><li>加快收敛速度。</li><li>避免神经元饱和。（神经元的激活在0或1时会饱和）。</li></ul><h3 id="归一化类型"><a href="#归一化类型" class="headerlink" title="归一化类型"></a>归一化类型</h3><ul><li>线性归一化</li><li>标准差归一化</li><li>非线性归一化</li><li>局部响应归一化（LRN）</li></ul><h2 id="批归一化（Batch-Normalization，BN）"><a href="#批归一化（Batch-Normalization，BN）" class="headerlink" title="批归一化（Batch Normalization，BN）"></a>批归一化（Batch Normalization，BN）</h2><ul><li>归一化的必要性<ul><li>神经网络学习的本质就是学习数据的分布规律，如果训练数据分布与测试数据分布不同，网络的泛化能力就会大大降低。同时如果每批的数据分布各不相同，那么网络每次迭代都要适应不同的分布，这样会大大降低网络训练速度。 </li></ul></li><li>批归一化的原因<ul><li>由于本层的输入由上一层的参数和输入得到，而上一层的参数在训练过程中会一直跟新，因此必然导致其后面每一层的数据分布。</li></ul></li><li>定义<ul><li>以前在神经网络训练中，只对输入层的数据进行归一化处理，但是经过多层的神经网络运算后，数据分布变化会很大。因而考虑在中间层进行归一化处理。BatchNorm就是在每一层的输入时均选择一小批进行归一化处理。（BN）</li></ul></li></ul><p>批归一化算法</p><h2 id="组归一化（Group-Normalization，GN）"><a href="#组归一化（Group-Normalization，GN）" class="headerlink" title="组归一化（Group Normalization，GN）"></a>组归一化（Group Normalization，GN）</h2><h2 id="预训练和微调"><a href="#预训练和微调" class="headerlink" title="预训练和微调"></a>预训练和微调</h2><h2 id="权重随机初始化方法"><a href="#权重随机初始化方法" class="headerlink" title="权重随机初始化方法"></a>权重随机初始化方法</h2><p>高斯初始化</p><p>Xavier初始化</p><h2 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h2><p>学习率决定了梯度下降的步长，在前期，学习率较大，梯度下降的步长会较长，这时能以较快的速度下降。而后期减小学习率，减小步长，能使算法易于收敛得到最优解。</p><h3 id="学习率衰减的方法"><a href="#学习率衰减的方法" class="headerlink" title="学习率衰减的方法"></a>学习率衰减的方法</h3><ul><li>分段常数衰减</li><li>指数衰减</li><li>自然对数衰减</li><li>多项式衰减</li><li>余弦衰减</li></ul><h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>深度学习可能存在过拟合问题（低偏差——预测值偏离真实值小，高方差——-预测值较集中），通常可以使用增加训练数据量和正则化解决。</p><p>正则化的定义：通过修改学习算法减少泛化误差。</p><ul><li>L1正则化</li><li>L2正则化</li><li>dropout正则化</li></ul><h2 id="样本增强"><a href="#样本增强" class="headerlink" title="样本增强"></a>样本增强</h2><p>在训练样本较少时，通过样本增强增加样本数量，减少过拟合。</p><h3 id="常用样本增强的方法（Augmentor包）"><a href="#常用样本增强的方法（Augmentor包）" class="headerlink" title="常用样本增强的方法（Augmentor包）"></a>常用样本增强的方法（Augmentor包）</h3><ul><li>对颜色增强：亮度、对比度、饱和度。 </li><li>裁剪、缩放</li><li>水平、垂直翻转</li><li>平移、旋转</li><li>高斯噪声、模糊处理</li></ul><h2 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h2><p>池化层作用：保留显著特征。 减小特征图像大小。 增大感受野。</p><ul><li>全局平均池化（GAP）</li></ul><blockquote><p>训练过程中模型不收敛，是否说明该模型无效？ 导致模型不收敛的原因</p><p>不能说明，可能存在以下原因： </p><ol><li>学习率过大。</li><li>数据集标签不准确。</li><li>数据未做归一化。</li><li>样本信息量太大，模型不足以承受整个样本空间。</li><li>网络太浅。</li></ol></blockquote><h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><ul><li>随机梯度下降法（SGD）</li><li>Momentum动量优化器</li><li>AdaGrad自适应学习率优化器</li><li>AdaDelta自适应学习率优化器</li><li>RMSprop自适应学习率优化器</li><li>Adam自适应学习率优化器</li></ul><h2 id="提升网络泛化能力的方法"><a href="#提升网络泛化能力的方法" class="headerlink" title="提升网络泛化能力的方法"></a>提升网络泛化能力的方法</h2><p>数据方面：增加数据量，对已有数据样本增强，数据归一化（BN）。</p><p>参数方面：学习率、batch_size</p><p>模型方面: 合适的初始化方法、添加正则化（dropout）、激活函数、优化器。</p><h2 id="欠拟合与过拟合"><a href="#欠拟合与过拟合" class="headerlink" title="欠拟合与过拟合"></a>欠拟合与过拟合</h2><h3 id="欠拟合现象"><a href="#欠拟合现象" class="headerlink" title="欠拟合现象"></a>欠拟合现象</h3><ul><li>模型不能很好的拟合数据，通常表现在训练集上准确率不高。</li><li>判断方法：每次只训练相同的数据，若一段时间后准确率很高，则说明网络的拟合能力不足，即当前网络无法拟合全部数据。</li></ul><h3 id="欠拟合解决方法"><a href="#欠拟合解决方法" class="headerlink" title="欠拟合解决方法"></a>欠拟合解决方法</h3><ul><li>增加网络的深度。</li><li>减小正则化参数。</li></ul><h3 id="过拟合现象"><a href="#过拟合现象" class="headerlink" title="过拟合现象"></a>过拟合现象</h3><p>模型学的太彻底，把一些噪声特征也学到了。通常表现在训练集上表现很好，但在测试集上准确率不高。</p><h3 id="过拟合解决方法"><a href="#过拟合解决方法" class="headerlink" title="过拟合解决方法"></a>过拟合解决方法</h3><ul><li>增加训练数据量，并对已有数据进行样本增强。</li><li>采用正则化（dropout、L1、L2正则），</li><li>BN层。</li></ul><h2 id="神经网络为啥用交叉熵"><a href="#神经网络为啥用交叉熵" class="headerlink" title="神经网络为啥用交叉熵"></a>神经网络为啥用交叉熵</h2><h2 id="卷积核size为奇数"><a href="#卷积核size为奇数" class="headerlink" title="卷积核size为奇数"></a>卷积核size为奇数</h2><ul><li>锚点在中间</li><li>Padding时图像两侧仍对称</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;视觉相关概念&lt;/p&gt;
    
    </summary>
    
    
      <category term="CV" scheme="https://mysticalguest.github.io/categories/CV/"/>
    
    
      <category term="算法" scheme="https://mysticalguest.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>论文写作与学术规范</title>
    <link href="https://mysticalguest.github.io/Thesis/43518d0d.html"/>
    <id>https://mysticalguest.github.io/Thesis/43518d0d.html</id>
    <published>2021-09-22T12:14:10.032Z</published>
    <updated>2021-12-10T05:04:08.045Z</updated>
    
    <content type="html"><![CDATA[<p>课程</p><a id="more"></a><h1 id="第一讲-学术规范与科学伦理"><a href="#第一讲-学术规范与科学伦理" class="headerlink" title="第一讲 学术规范与科学伦理"></a>第一讲 学术规范与科学伦理</h1><h2 id="1-学术规范与学术不端"><a href="#1-学术规范与学术不端" class="headerlink" title="1.学术规范与学术不端"></a>1.学术规范与学术不端</h2><h3 id="1-1-学术规范"><a href="#1-1-学术规范" class="headerlink" title="1.1 学术规范"></a>1.1 学术规范</h3><ul><li><p>学术规范的定义</p><p>学术共同体内形成的进行<strong>学术活动的基本规范</strong>，或者根据学术发展规律制定的有关<strong>学术活动的基本准则</strong>。</p></li><li><p>学术规范的内涵</p><p>学术研究、学术评审、学术批评、学术管理的规范。</p><p>内容层面、价值方面、技术操作层面的规范。</p></li></ul><h3 id="1-2-学术不端"><a href="#1-2-学术不端" class="headerlink" title="1.2 学术不端"></a>1.2 学术不端</h3><ul><li><p>学术不端的定义</p><p>学术不端是指违反学术规范、学术道德的<strong>行为</strong>。</p></li><li><p>学术不端的内涵</p><ul><li>国际：捏造数据、篡改数据和剽窃成果。</li><li>国内：除了上述三点之外，增加了：一稿多投、侵占学术成果、伪造学术履历等等。</li></ul></li></ul><h2 id="2-科学论文中的学术规范与学术不端"><a href="#2-科学论文中的学术规范与学术不端" class="headerlink" title="2.科学论文中的学术规范与学术不端"></a>2.科学论文中的学术规范与学术不端</h2><h3 id="2-1科学数据不端行为"><a href="#2-1科学数据不端行为" class="headerlink" title="2.1科学数据不端行为"></a>2.1科学数据不端行为</h3><ul><li><p>捏造数据</p><p>如果研究人员没有做过某个实验、试验、观察或调查，却谎称做过，无中生有地编造数据，这就构成了最严重的学术不端行为一捏造数据。</p></li><li><p>篡改数据</p><p>对数据进行窜改或故意误报。常见的窜改数据行为：去掉不利数据、添加有利数据夸大实验重复次数、夸大实验动物或试验患者的数量等等。</p></li></ul><h3 id="2-2-剽窃不端行为"><a href="#2-2-剽窃不端行为" class="headerlink" title="2.2 剽窃不端行为"></a>2.2 剽窃不端行为</h3><ul><li><p>剽窃行为一：<strong>成果剽窃</strong>。</p><p>剽窃他人的观点、实验数据、结果，<strong>最严重剽窃</strong>行为。</p></li><li><p>剽窃行为二：<strong>文字剽窃</strong>。</p><p>欧美主流学术期刊规定：<strong>连续7个单词的拼写和顺序与别人论文的完全相同</strong>，就是剽窃！（i）使用别人论文中的句子来描述实验结果。（ii）引言部分介绍他人成果时，也不能直接照抄他人语句。如果照抄，则必须用引号把照抄部分引起来；否则，即使标注引用也会被认为构成文字剽窃。</p></li><li><p>剽窃行为三：<strong>图片剽窃</strong>。</p><p>不同的论文使用了相同图片，或者同一论文重复使用同图片，都是学术不端行为。但是<strong>进展类综述论文除外</strong>。</p></li><li><p>剽窃行为四：<strong>自我抄袭、自我剽窃</strong>。</p><p>虽然本文的通讯作者和主要作者与已经发表和引用的论文中的通讯作者和主要作者相同，本文也不能过多地套用后者文中的语句，否则构成自我抄袭、自我剽窃。</p><p><strong>总之，科学论文就是要鼓励创新，包括内容和表述的创新！</strong></p></li></ul><h3 id="3-剽窃的适度标准"><a href="#3-剽窃的适度标准" class="headerlink" title="3.剽窃的适度标准"></a>3.剽窃的适度标准</h3><ul><li><p>适度标准一：<strong>不引起原创歧义，可以不引用。</strong></p><p>对别人的比较新颖、比较前沿的观点，如果不做说明就有可能被误会为是论文作者的原创的情况，<strong>必须引用</strong>！对于已经成为<strong>学术界常识</strong>、即使不做说明或者引用也不会对成果的归属产生误会的观点，可以不引用。例如，现在提及自然选择学说时可以不引用达尔文《物种起源》；现在提及DNA双螺旋结枃模型时可以不引用沃森、克里克的论文。</p></li><li><p>适度标准二：<strong>使用日常用语和格式化短句不算文字剽窃</strong>。</p><p>如果语句太短、太常见（例如只有几个字词的日常用语），或者表述非常格式化,例如对实验材料和方法的描述，不同的人书写的结果都差不多，那么就不存在剽窃的问题。</p></li><li><p>适度标准三：<strong>科普作品可以不标注引用</strong>。</p><p>科普文章一般是介绍他人的科学成果，即使不标注引用也不会被读者误认为是作者的成果，因此可以不标注引用。但是，科普文章必须防止文字剽窃。</p></li><li><p>适度标准四：<strong>引用未正式发表成果，必须作者书面许可</strong>！</p><p>在论文中引用他人已经正式发表的成果，无须获得作者同意；但是，如果引用未正式发表的成果（例如通过私人通信或学术会议的交流而获取的他人成果），那么必须征得原作者的书面许可。</p></li></ul><h3 id="4-署名不端行为"><a href="#4-署名不端行为" class="headerlink" title="4.署名不端行为"></a>4.署名不端行为</h3><ul><li>作者署名：<strong>对论文工作有实质贡献、且共同担责的人</strong>。<ul><li><strong>第一作者</strong>：对本论文的工作作出了最直接、最主要的理论和实验贡献,并且通常是论文初稿的撰写者。</li><li><strong>通讯作者</strong>：是该论文与外界的<strong>联系人</strong>，也是该论文成果学术正确性的<strong>负责人</strong>，所以也叫<strong>责任作者</strong>，一般是论文课题的学术领导人，<strong>为论文工作确定总的研究方向</strong>和<strong>论文点子的提出者</strong>，并且在研究过程中，在理论上或技术上对其他作者进行了具体指导。在多数情况下，通讯作者是第一作者的<strong>导师</strong>或<strong>上司</strong>。</li></ul></li><li>论文的投稿、任何结论必须是所有作者都<strong>知情</strong>，且<strong>一致同意</strong>，如果某个作者有不同意见，有权利退出署名，撤下与其有关的那部分结果。不应该在某个人不知情的情况下就把他列为共同作者。</li><li>如果有两个主要贡献者的工作确实难以分出主次，可以注明两人贡献相等、<strong>为共同第一作者</strong>。一般一篇论文有<strong>多名共同第一作者</strong>，或<strong>多名通讯作者</strong>，<strong>属于不正常现象</strong>，会让人猜疑是为了増加一篇论文在评价工作中的使用价值所做的安排。</li><li>论文的署名既是一种<strong>荣耀</strong>，也是一种<strong>责任</strong>。</li><li>如果在论文发表后被发现存在造假、剽窃等问题，<strong>全部作者都要承担相应的责任，不应该以不知情做为借口，试图推卸切责任</strong>。造假者、剽窃者固然要承担最主要的责任，但是<strong>全部作者都要承担连带责任</strong>。</li><li>在列举自己的论文时，应该<strong>保留论文原有的全部作者和原有的排名顺序</strong>，可以采用黑体字或画线的方式突出自己的名字，但是<strong>不能改变论文排名顺序或者不写其他作者</strong>。</li><li>如果作者人数较多,难以全部列出,国际通常做法是写出前两名或者前三名作者,再在后面<strong>写上et al</strong>.。</li><li>如果是学术专著，应该清楚写明自己的贡献：如果是专著的主编而非作者，应该注明“编”或“Ed.”；如果自己撰写了专著中的某个章节，应该注明该章节。</li><li>非正式期刊发表的论文要清楚标注发表类型，例如：期刊的増刊，会议摘要，墙报展示论文等等。</li></ul><h3 id="5-发表的不端行为"><a href="#5-发表的不端行为" class="headerlink" title="5.发表的不端行为"></a>5.发表的不端行为</h3><ul><li><strong>禁止一稿多投和重复发表</strong>：一篇论文只能投给一家期刊，只有在确知被退稿后，才能改投其他期刊。许多学术期刊都明文禁止一稿多投或重复发表。如果一组数据、图片、结果已经在某篇论文中发表过，就不宜在新的论文中继续做为新数据来使用，否则也会被当成重复发表。如果在新论文中需要用到已发表论文的数据，应该采用引用的方式注明文献出处。</li><li>中英文重复发表问题:一篇论文先在中国期刊上发表中文论文，再在国际期刊上发表同一内容的英文论文，这种做法严格来说也是重复发表，但是由于有助于促进国际交流，所以也没有必要深究。但是不宜先发表英文论文,再翻译成中文重复发表</li><li>综述类论文明确引用，不算重复发表：对于研究进展类的综述论文，只要明确引用,可以重复发表作者本人或者他人的、已经发表过的数据、图片、结果、结论。</li></ul><h2 id="3-学术不端公布案例"><a href="#3-学术不端公布案例" class="headerlink" title="3.学术不端公布案例"></a>3.学术不端公布案例</h2><h2 id="4-科学伦理及其种类"><a href="#4-科学伦理及其种类" class="headerlink" title="4.科学伦理及其种类"></a>4.科学伦理及其种类</h2><h2 id="5-规范科学伦理，防止学术不端"><a href="#5-规范科学伦理，防止学术不端" class="headerlink" title="5.规范科学伦理，防止学术不端"></a>5.规范科学伦理，防止学术不端</h2><h1 id="第二讲-科学精神与价值取向"><a href="#第二讲-科学精神与价值取向" class="headerlink" title="第二讲 科学精神与价值取向"></a>第二讲 科学精神与价值取向</h1><h1 id="第三讲-学位期刊与文献检索"><a href="#第三讲-学位期刊与文献检索" class="headerlink" title="第三讲 学位期刊与文献检索"></a>第三讲 学位期刊与文献检索</h1><h2 id="1-文献类型与常用数据库"><a href="#1-文献类型与常用数据库" class="headerlink" title="1.文献类型与常用数据库"></a>1.文献类型与常用数据库</h2><h3 id="1-1-文献类型"><a href="#1-1-文献类型" class="headerlink" title="1.1 文献类型"></a>1.1 文献类型</h3><ul><li><p><strong>期刊论文：作者 、题目 、期刊名称 、卷号 （期号 ）、起始 页码 （~终止页码 ）、出版年份</strong>。</p><ul><li><blockquote><p>周刊：每周出一期。</p><p>半月刊：每半个月（两周）出一期。</p><p>月刊：每个月出一期。</p><p>双月刊：每两个月出一期</p><p>季刊：每季度 （三个月）出一期。</p><p>周期更长的期刊比较少见。 </p></blockquote></li></ul></li><li><p><strong>学位论文：作者 、题目 、学校名称 、学位论文类型 、出版年份</strong>。</p><ul><li><blockquote><p>学士学位论文（本科毕业论文）。</p><p>硕士学位论文。</p><p>博士学位论文。</p><p>博士后出站报告。</p></blockquote></li></ul></li><li><p><strong>书：作者 （编者 ）、书名 、出版社 、出版地点 、出版年份 、版次。</strong></p><ul><li><blockquote><p>教科书 。手册。 会议论文集。 其他书籍。</p><p>公共常识，失去版权信息，开源代码，开源期刊免费下载，非开源读者要收费，不能下载全文时，可通过摘要获取主要内容，摘要写详细。投开源期刊，导师要同意。</p></blockquote></li></ul></li><li><p><strong>网络链接信息：网络链接地址 、年份</strong>。</p><ul><li><blockquote><p>网上非审稿论文。网络数据信息。网络开源信息。</p></blockquote></li></ul></li></ul><h3 id="1-2-常用数据库"><a href="#1-2-常用数据库" class="headerlink" title="1.2 常用数据库"></a>1.2 常用数据库</h3><ul><li><p>中国知网（CNKI）</p><ul><li><blockquote><p><a href="https://www.cnki.net/">中国知网</a>，<a href="https://kns.cnki.net/kns/brief/result.aspx?dbPrefix=CJFQ">华南师范大学知网</a></p><p>华南师范大学→华南师范大学图书馆→中国知网</p><p>校内用户：通过IP地址免费登录</p><p>校外用户：通过一卡通账户登录</p></blockquote></li></ul></li><li><p><a href="https://www.wanfangdata.com.cn/">万方数据知识服务平台</a></p></li><li><p><a href="https://www.duxiu.com/">读秀知识库</a></p></li><li><p><a href="http://www.sslibrary.com/">超星电子图书</a></p></li><li><p><a href="http://www.englibrary.com/">环球英语多媒体数据库</a></p></li><li><p><a href="https://www.letpub.com.cn/">LetPub数据库</a></p><ul><li><blockquote><p>中科院，论文标准名称，论文简称，打点？</p><p>期刊网址；投稿网址；影响因子，几区，中科院分区方式；以LetPub公布的数据为准。</p></blockquote></li></ul></li></ul><h1 id="2-SCI期刊与中文核心期刊"><a href="#2-SCI期刊与中文核心期刊" class="headerlink" title="2.SCI期刊与中文核心期刊"></a>2.SCI期刊与中文核心期刊</h1><h3 id="2-1-SCI期刊"><a href="#2-1-SCI期刊" class="headerlink" title="2.1 SCI期刊"></a>2.1 SCI期刊</h3><ul><li><p>SCI数据库</p><ul><li><blockquote><p>《<strong>科学引文索引</strong>》（<strong>Science Citation Index，简称SCI</strong>）美国科学信息研究所（ Institute for Scientific Information，简称ISI）尤金·加菲尔德( Eugene Garfield)于1957年在美国费城创办的引文数据库。<strong>SCI</strong>（科学引文索引）、EI（工程索引）、ISTP（科技会议录索引)是世界著名的三大科技文献检索系统,是国际公认的进行科学统计与科学评价的主要检索工具。</p></blockquote></li><li><blockquote><p>SCI出版形式包括印刷版期刊、光盘版、联机数据库、互联网Web版数据库。</p><p>SCI收录全世界出版的数、理、化、农、林、医、生命科学、天文、地理、环境、材料、工程技术等自然科学各学科的核心期刊约3500种，选用刊物来源于40多个国家，50多种文字其中主要的国家有美国、英国、荷兰、德国、俄罗斯、法国、日本、加拿大等,也收录部分中国（包括港澳台）刊物。</p></blockquote></li><li><blockquote><p>1976年，ISI在SCI基础上引出<strong>期刊引用报告（Journal Citation Report，JCR）</strong>，提供了一套统计数据，展示科学期刊被引用情况、发表论文数量以及论文的平均被引用情况。在JCR中可以计算出每种期刊<strong>影响因子（Impact Factor，IF）</strong>。影响因子在一定程度上可以反映一个期刊的影响力。</p></blockquote></li><li><p>有的即可被SCI收录，又被EI收录；引用A期刊的B论文不被SCI收录，数据不算数。</p></li></ul></li><li><p>SCI数据库作为中国科研量化指标的前世今生</p><ul><li><blockquote><p>改革开放之前，中国整体科研水平较低，科研经费的拨付并没有什么量化标准，也没有同行参与评价，完全是由行政部门官员说了算。</p><p>在这种情况下，南京大学率先用SCI量化指标来衡量科研人员水平，并被国内广大高校和机构广泛沿用，这对于引导国内学者在全球高水平期刊发表论文、提升中国科研在国际上的影响力，在当时是起到了积极作用的。</p></blockquote></li><li><blockquote><p>2020年2月，教育部、科技部印发了《关于规范高等学校SCI论文相关指标使用，树立正确评价导向的若干意见》，该文件要<em>破除论文“SCI至上”</em>，也要以此为突破口，拿出针对性强、操作性强的实招硬招，<em>破除“唯论文”</em>，树立正确的评价导向。</p></blockquote></li></ul></li></ul><h3 id="2-2-中文核心期刊"><a href="#2-2-中文核心期刊" class="headerlink" title="2.2 中文核心期刊"></a>2.2 中文核心期刊</h3><ul><li><p>核心中文期刊</p><ul><li><blockquote><p>《中文核心期刊》是2011年12月北京大学出版社发行部出版的图书，作者是朱强。该书由北京大学图书馆朱强馆长等任主编。<br>北京多所高校图书馆及中国科学院国家科学图书馆、中国社会科学院文献信息中心、中国人民大学书报资料中心、中国学术期刊（光盘版）电子杂志社、中国科学技术信息研究所、北京万方数据股份有限公司、国家图书馆等27个相关单位的百余名专家和期刊工作者参加了研究。</p></blockquote></li><li><blockquote><p>《中文核心期刊要目总览》是学术界对某类中文期刊等级的权威划分。中文核心期刊是北京大学图书馆联合众多学术界权威专家鉴定，是除南大核心、中国科学引文数据库（CSCD）以外学术影响力最权威的一种。</p><p>北大核心期刊每四年由北大图书馆评定一次，并出版《北大核心期刊目录要览》一书,已于1992、1996、2000、2004、2008、2011年出版过六版。</p></blockquote></li></ul></li></ul><h2 id="3-影响因子与SCI期刊分区"><a href="#3-影响因子与SCI期刊分区" class="headerlink" title="3.影响因子与SCI期刊分区"></a>3.影响因子与SCI期刊分区</h2><h3 id="3-1-影响因子"><a href="#3-1-影响因子" class="headerlink" title="3.1 影响因子"></a>3.1 影响因子</h3><ul><li><p>影响因子</p><ul><li><blockquote><p>影响因子是汤森路透（Thomson reuters）出品的JCR中的一项数据，为某期刊前一年发表的论文在该报告年份中被引用总次数除以该期刊在这一年内发表的论文总数。这是一个国际上通行的期刊评价指标。</p><p>影响因子现已成为国际上通用的期刊评价指标。中国大陆各大高校都以学术期刊的影响因子作为评判研究生毕业的主要标准。</p></blockquote></li></ul></li><li><p>影响因子计算方法</p><ul><li><p>公式：<script type="math/tex">IF=\frac AB</script>，</p></li><li><blockquote><p>A=该期刊前两年所有文章在前一年中被SCI期刊的引用总次数；</p><p>B=该期刊前一年所有文章数。</p><p>例如：计算 Nature期刊2021年的影响因子时，</p><p>A=Nature期刊2019年发表的所有文章在2020年中被SCI期刊引用的总次数；B= Nature期刊2019年发表的所有文章数。</p><p>影响因子一般在每年的3月份左右公布。</p></blockquote></li></ul></li></ul><h3 id="3-2-SCI期刊分区"><a href="#3-2-SCI期刊分区" class="headerlink" title="3.2 SCI期刊分区"></a>3.2 SCI期刊分区</h3><ul><li><p>SCI期刊分区</p><ul><li><blockquote><p>关于期刊分区影响较为广泛的有两种：</p><p>Thomson reuters公司制定的分区，即汤森路透分区</p><p>中科院国家科学图书馆制定的分区，简称中科院分区</p></blockquote></li></ul></li><li><p>SCI期刊分区一：汤森路透分区</p><ul><li><blockquote><p>汤森路透每年出版一本《期刊引用报告》（JCR）。JCR对86000多种SCI期刊的影响因子等指数加以统计。JCR将收录期刊分为176个不同学科类别。每个学科分类按照期刊的影响因子高低，平均分为Q1（Q表示 Quartile in Category）、Q2、Q3和Q4四个区：各学科分类中影响因子前25%（含25%）期刊划分为<strong>Q1区</strong>，前25%~50%（含50%）为Q2区，前50%~75%（含75%）为<strong>Q3区</strong>，75%之后的为<strong>Q4区</strong>。</p></blockquote></li></ul></li><li><p><strong>SCI期刊分区二：中科院分区</strong></p><ul><li><blockquote><p>中科院首先将JCR中所有期刊分为数学、物理、化学、生物、地学、天文、工程技术、医学、环境科学、农林科学、社会、科学、管理科学及综合性期刊13大类。然后，将13大类期刊分各自为4个区。按照各类期刊影响因子划分，前5%为该类<strong>1区</strong>、6%~20%为2区、21%~50%为<strong>3区</strong>，其余的为<strong>4区</strong>。</p></blockquote></li><li><p>盲审量化，第三关，学院答辩，全院一起，导师不能参加，平常能发就发？难？都采用中科院的分区方式，学位论文要求母语。</p></li></ul></li></ul><h2 id="4-文献检索"><a href="#4-文献检索" class="headerlink" title="4.文献检索"></a>4.文献检索</h2><h3 id="4-1-中文文献检索"><a href="#4-1-中文文献检索" class="headerlink" title="4.1 中文文献检索"></a>4.1 中文文献检索</h3><ul><li><p>华师图书馆</p><ul><li><blockquote><p>华南师范大学→华南师范大学图书馆→文献检索</p><p>馆藏图书、学校购买的相关数据库</p></blockquote></li></ul></li><li><p>普通检索</p><ul><li><blockquote><p>主题、篇关摘、关键词、篇名（题目）、全文、作者、第一作者、通讯作者、作者单位、基金、摘要、小标题、参考文献、分类号、文献来源（期刊名称）、DOI（论文的数字对象唯一标识符，Digital Object Unique Identifier，简称为DOI，相当于论文的身份证号码）</p></blockquote></li></ul></li><li><p>其他检索</p><ul><li><blockquote><p>高级检索、专业检索、作者发文检索、句子检索、框式检索、知识元检索、引文检索</p></blockquote></li></ul></li><li><p>网络平台直接检索</p><ul><li>百度、搜狗、知乎、雅虎等等。百度又细分为百度百科、百度学术、百度网盘、百度翻译、百度地图、……</li></ul></li><li><p>中文期刊检索</p><ul><li>登录相关的中文期刊，通过作者、题目、卷号、期号、时间、关键词等等方式检索该发表在期刊上的论文。</li></ul></li></ul><h3 id="4-2-英文文献检索"><a href="#4-2-英文文献检索" class="headerlink" title="4.2 英文文献检索"></a>4.2 英文文献检索</h3><ul><li><p>网络平台直接检索</p></li><li><p>英文期刊检索</p><ul><li><blockquote><p>登录相关的英文期刊，通过作者、题目、卷号、期号、时间、关键词等等方式检索该发表在期刊上的论文。</p></blockquote></li></ul></li></ul><h2 id="5-文献管理"><a href="#5-文献管理" class="headerlink" title="5.文献管理"></a>5.文献管理</h2><h3 id="5-1-文件管理"><a href="#5-1-文件管理" class="headerlink" title="5.1 文件管理"></a>5.1 文件管理</h3><ul><li><em>硬盘分区管理</em>：操作系统、常用软件、生活文件、工作件等等实行分区管理。</li><li><em>文件属性管理</em>：工作文件按照参考文献、工作笔记、自编程序、理论结果、计算结果、实验结果、论文撰写、投稿管理等等不同属性实行分类管理。</li><li><em>结果阶段管理</em>：程序、计算、实验等等的临时结果、每日版本、阶段版本、终结版本实行分阶段管理。</li><li><em>论文版本管理</em>：投稿论文、学位论文实行版本管理。</li><li>人工分类管理：参考文献可以按照属性、目的、自己的习惯进行人工管理。</li><li>常用软件管理：目前使用比较多的免费文献管理软件有如下五种。<a href="https://www.endnote.com/">Endnote</a>、 <a href="https://www.mendeley.com/">Mendeley</a>、 <a href="https://www.zotero.org/">Zotero</a>、 <a href="https://www.jabref.org/">JabRef</a>、 <a href="http://www.inoteexpress.com/">NoteExpress</a>。</li></ul><h1 id="第四讲-学位论文要素与规范"><a href="#第四讲-学位论文要素与规范" class="headerlink" title="第四讲 学位论文要素与规范"></a>第四讲 学位论文要素与规范</h1><h2 id="1-科学论文分类及属性"><a href="#1-科学论文分类及属性" class="headerlink" title="1.科学论文分类及属性"></a>1.科学论文分类及属性</h2><h3 id="1-1-学位论文"><a href="#1-1-学位论文" class="headerlink" title="1.1 学位论文"></a>1.1 学位论文</h3><ul><li><p>学士学位论文</p><ul><li><blockquote><p>国内的学士学位论文,通常也称为本科毕业论文、本科毕业设计论文、本科毕业答辩论文。</p><p>属性：主要是对本科毕业设计工作的成果总结。有些在本科阶段从事了课外科研的学生，也可以把本科阶段发表、完成的科研成果包括进来。</p></blockquote></li></ul></li><li><p>硕士学位论文</p><ul><li><blockquote><p>硕士学位论文，俗称攻读硕士期间的大论文。</p><p><strong>属性</strong>：主要是对攻读硕士期间全部工作的成果总结，包含了硕士生期间已录用、已发表、已完成但暂未发表的科研成果。</p></blockquote></li></ul></li><li><p>博士学位论文</p><ul><li><blockquote><p>博士学位论文，俗称攻读博士期间的大论文。</p><p>属性：主要是对攻读博士期间全部工作的成果总结，包含了博士生期间已录用、已发表、已完成但暂未发表的科研成果。</p></blockquote></li></ul></li><li><p>博士后出站报告</p><ul><li><blockquote><p>博士后出站时的大论文。有些国家、国内有些单位目前把博士后看成一种学历，但绝大部分国家和国内大部分单位把博士后看成一种工作经历。</p><p>属性：主要是对博士后在站工作期间全部工作的成果总结，包含了博士后在站期间已录用、已发表、已完成但暂未发表的科研成果。</p></blockquote></li></ul></li></ul><p>图、表，引用他人，图标，说明，式子，上方，公式写法。</p><h3 id="1-2-期刊论文"><a href="#1-2-期刊论文" class="headerlink" title="1.2 期刊论文"></a>1.2 期刊论文</h3><ul><li>发表原创工作的<strong>完整论文式</strong>期刊论文<ul><li>发表作者的原创科研工作成果，需要通过了多位审稿人的盲审后方能发表。论文篇幅较长，格式完整，称为完整论文式期刊论文，称为article类的paper。</li><li>属性：论文中除了明确标注引用的参考文献外，论文的主体部分用来描述作者做出的最新原创科研工作成果。在撰写这种论文时，一定要防止过度引用、抄袭和剽窃他人科研成果、抄袭和剽窃自己已经发表过的科研成果，还要防止文字剽窃！</li></ul></li><li>发表原创工作的<strong>快报式</strong>期刊论文<ul><li>发表作者的原创科研工作成果，需要通过了多位审稿人的盲审后方能发表。论文篇幅较短，一般不超过4页或者3页，格式不完整，甚至没有小标题，称为letter类的paper。</li><li>属性：论文中除了明确标注引用的参考文献外，论文的主体部分用来描述作者做出的最新原创科研工作成果。在撰写这种论文时,一定要防止过度引用、抄袭和剽窃他人科研成果、抄袭和剽窃自己已经发表过的科研成果，还有防止文字剽窃！</li></ul></li><li>发表原创工作的<strong>新闻式</strong>期刊论文<ul><li>发表作者的原创科研工作成果，需要通过了多位审稿人的盲审后方能发表。论文篇幅极短，一般不到1页，没有小标题、没有摘要、没有过程等等部分，称为news类的paper。</li><li>属性：论文中引用参考文献的篇数、全文字数、图片数量等等高度受限。主要是 Nature等个别期刊有这种文体。</li></ul></li><li>发表非原创工作的<strong>综述式</strong>期刊论文<ul><li>有些期刊发表相关领域的研究进展论文，论文中的工作般不是、或者不全是作者的原创科研工作成果，通常也需要通过了多位审稿人的盲审后方能发表。</li><li>属性：论文题目一般明确标明“综述”、“研究进展”等相关词汇，论文中描述的科研工作成果必须明确标注引用。在撰写这种论文时，过度引用的尺度可以适当放宽，但是最好用作者自己的语言描述参考文献中的科研成果为宜。</li></ul></li></ul><h2 id="2-学位论文要素及格式"><a href="#2-学位论文要素及格式" class="headerlink" title="2.学位论文要素及格式"></a>2.学位论文要素及格式</h2><h3 id="2-1-学士学位论文"><a href="#2-1-学士学位论文" class="headerlink" title="2.1 学士学位论文"></a>2.1 学士学位论文</h3><p>国内的学士学位论文的格式和要求，不同学校、不同院系、不同专业都不太相同。相关的字体、字号、页面设置、图表格式、公式格式、论文篇幅、参考文献格式和数量等等<strong>具体要求</strong>一定要<strong>以本校、本学院、本专业的具体要求为准</strong>。</p><p>本课程主要面对硕士生和博士生开设，所以，本科学位论文略讲。</p><h3 id="2-2-硕士、博士学位论文"><a href="#2-2-硕士、博士学位论文" class="headerlink" title="2.2 硕士、博士学位论文"></a>2.2 硕士、博士学位论文</h3><p>国内的硕士学位论文和博士学位论文的格式和要求，不同学校、不同院系、不同专业都不太相同。相关的字体、字号页面设置、图表格式、公式格式、论文篇幅、参考文献格式和<br>数量等等<strong>具体要求</strong>一定要<strong>以本校、本学院、本专业的具体要求为准</strong>。</p><ul><li><p>封面</p><ul><li><p>按照学校研究生处下发的相关文件要求认真填写。每年基本相同，最好参照上届学生的格式，再咨询当年是否有更新、变更。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Thesis/SCNU_dissertation_cover.jpg" style="zoom:50%;" /></p></li></ul></li><li><p>中文摘要</p><ul><li><p>页眉：题目；</p></li><li><p>题目</p></li><li><p>专业、申请人、导师</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Thesis/abstract.jpg" style="zoom:50%;" /></p></li><li><p>摘要：</p><ul><li><p><strong>最基本的要求</strong>：不能使用口语，必须采用书面语；且<strong>语句通顺，没有语病，标点符号使用正确</strong>。这不仅是摘要部分、也是全文的最基本要求。</p></li><li><p>主体部分：<strong>先总后分</strong>，大致分为两部分。第一部分就是第一段，是总结段，要求<strong>高度凝练</strong>，一般包含5点内容：</p><ul><li><p>破题，解释题目中的专有名称或者体系，</p></li><li><p>本学位论文工作的研究背景，</p></li><li><p>本文完成的主要工作，</p></li><li><p>本工作的科学意义、应用价值或者潜在的应用可能性，</p></li><li><p>本文结构安排。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Thesis/abstract1.jpg" style="zoom:50%;" /></p></li></ul></li><li><p>第二部分是分述段，论文有几章就可以分成几段进行分述。每一段对每一章的内容进行介绍，最好采用先总后分的方式。每段的第一句最好为总结句，后面适当予以展开。</p></li><li><p>关键词：最后是关键词，一般为5~8个，以便于本文获得更多的被读者检索<br>和引用的机会。</p></li></ul></li></ul></li><li><p>英文摘要</p><ul><li><p>页眉：中文题目</p></li><li><p>英文题目。以下全部是前面中文摘要部分的英文翻译。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Thesis/en_abstract.jpg" style="zoom:50%;" /></p></li></ul></li><li><p>目录</p><ul><li><p>页眉：中文题目</p></li><li><p>目录</p></li><li><p>章节内容：最好通过关联方式自动生成超链接目录，既便于读者快速跳转，也便于修改过程中页码的自动更新。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Thesis/catalogue.jpg" style="zoom:50%;" /></p></li></ul></li><li><p>第一章绪论（引言、序言、引论）</p><ul><li><p>本学位论文工作的研究背景，重要概念的诠释，本领域的发展历程，主要里程碑<br>式的工作，目前尚未解决的、本学位论文解决了或者部分解决了的重要问题。</p></li><li><p>本论文工作的来源、目的、获得的主要相关资助。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Thesis/introduction.jpg" style="zoom:50%;" /></p></li><li><p>本论文的主要研究脉络和取得的主要研究成果，以及今后研究工作的简单展望。</p></li></ul></li><li><p>全文要求即格式</p><ul><li><p>在结构方面，最好采用<strong>总一分一总</strong>方式，即每一章的前面第一（或者更多）自<br>然段为本章的引言和高度总结，中间为本章内容的展开详述，最后为<strong>本章小结</strong>。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Thesis/text.jpg" style="zoom:50%;" /></p></li><li><p>在引用方面，全文一定要<strong>清楚标注</strong>参考文献的引用，包括文中、插图和表格部分的<strong>引用</strong>；还要<strong>防止文字剽窃</strong>，尽量用自己的语言阐述参考文献中的研究成果！<br>在格式方面，全文必须要遵循统一的的格式要求：</p><ul><li><p><strong>数学公式</strong>居中、标号,标号右对齐。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Thesis/formula.jpg" style="zoom: 33%;" /></p></li><li><p>公式中的数字、运算符号、函数名称、简写名称全部为<strong>正体</strong>，其它为<strong>斜体</strong>。</p></li><li><p><strong>矢量</strong>要么用粗体、要么用箭头表示，但全文只能选择其中的种方式，不能混用！</p></li><li><p>公式视为一个句子，因此，<strong>公式</strong>后面一般<strong>加标点符号</strong>，绝大部分学术期刊也是如此规定；公式后面有“其中”者，加逗号。</p></li><li><p>在引用<strong>参考文献提到作者</strong>时，中国人可以写出全部姓名，外国人只需要写出姓，不需要写出名；最多写出两人，超过两人写等人；名字后面不需要写称谓或者头衔。例如，黄昆[6]给出了关于…，爱因斯坦[16]发现…，普朗克和爱因斯坦[8]的研究表明…，德布罗意等人[6]指出…。</p></li><li><p>无论中英文，使用<strong>简称</strong>时，必须在第一次使用简称时先写出全称，然后才能使用简称；而且，全称必须在摘要和中文中分别出现一次。例如，晶格波（格波）, Photonic band gap（PBG）。</p></li><li><p>英文单词的英国写法和美国写法不同时，一般采用英国写法。</p></li><li><p><strong>图形的图标</strong>说明尽量简洁明了，<strong>曲线</strong>尽量不要和文字交叠，图中的<strong>文字</strong>、包括坐标标度必须清楚，而且尽量在不放大的情况下就可以清楚阅读。</p></li><li><p>图中<strong>包含多个分图</strong>时，分图标号尽量标注在分图的相同位置。分图之间可以采用无缝拼接，也可以互相或者部分间隔；分图的横坐标/纵坐标相同时，可以互相公用。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Thesis/picture.jpg" style="zoom:50%;" /></p></li><li><p>包含多个分图的图标说明最好采用先总后分的方式阐述，尽量避免重复。</p></li><li><p>图标说明必须有完整的标点符号。哪怕只有一个单词，也属于<strong>独词句</strong>，末尾加句号。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Thesis/picture2.jpg" style="zoom:50%;" /></p></li><li><p>表格的<strong>表标说明</strong>大体与图标说明相类似。</p></li><li><p>表格一般采用<strong>三线表</strong>，这样可以与国际主流学术期刊接轨。最终的格式要求，以本校、本学院的格式要求为准。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Thesis/table.jpg" style="zoom:50%;" /></p></li></ul></li></ul></li><li><p><strong>论文主体</strong>部分</p><ul><li>从<strong>结构</strong>来说，论文从第二章开始，阐述本学位论文工作所使用的理论和实验研究方法，建立的理论模型，采用的实验仪器、实验装置、实验步骤、实验样品及材料，得出的解析结果、数值计算结果、实验观测结果，制作的材料样品或者仪器原型，解决的科学问题，推岀的科学结论，以及成果的科学价值、可能的潜在推广应用价值等。</li><li>从写作来说，一定要严格区分哪些部分是别人的研究方法或者成果、哪些才是本人研究工作成果，一定要在文中明确标注。严禁抄袭、剽窃、过度引用，包括文字剽窃！</li></ul></li><li><p><strong>论文后续</strong>部分</p><ul><li><p><strong>最后一章为全文总结及工作展望</strong>，对全文从第二章到倒数第二章内容进行逐章小结，重要公式和结论必须呈现在小结中。</p></li><li><p>全文总结及工作展望的最后一部分必须是工作展望。</p></li><li><p><strong>最后一章之后不再标注章节</strong>，还有3部分内容，第一部分为全文引用的<strong>参考文献</strong>。<strong>在数量上</strong>，<strong>硕士</strong>学位论文一般不少于<strong>50篇</strong>参考文献，博士学位论文一般不少于<strong>100篇</strong>参考文献；<strong>在时间上</strong>，一般要有毕业当年的新文献引用；<strong>在格式上</strong>，无论<br>是字体、字号、字母大小写、要素排列顺序都要完全统一；<strong>在类别上</strong>，一般有期刊论文、会议论文、书籍、网络信息等几种文献,不同类别格式不同。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Thesis/summary.jpg" style="zoom: 33%;" /></p></li><li><p>最后一章之后的第二部分内容是<strong>攻读学位期间完成的工作</strong>。如果攻读学位期间完成的工作已经全部发表了，标题可以是攻读学位期间发表的工作；否则，就是完成的工作，可以把未录用、未投稿的工作全部列出。这一部分的论文，和前面的参考文献相比，可以增加当年该期刊的影响因子和当年中科院SCI分区数，以展示工作的具体学术水平；还可标出作者的中文姓名，以示强调本人在文中的贡献。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Thesis/published_papers.jpg" style="zoom:50%;" /></p></li><li><p>全文的最后一部分为<strong>致谢</strong>，表达本人对攻读学位期间给予自己帮的主要人员的<strong>感谢和感恩</strong>。一般需要提及的人员包括：导师、给自己上课的老师、学院的领导和老师、同学、室友、家人、以及外单位给自己提供过帮助的其他人员。<strong>写作建议：真情实感，有感而发，不要过多吹嘘和无病呻吟</strong>。</p></li></ul></li></ul><blockquote><p>图清楚美观合理布局，标注，横向排列的两（多）幅图横坐标相同可以合并，只写一个，纵坐标同理，字大，清楚，参考文献中至少一篇当年的，否则评委说你不了解现今的发展，或者你的研究成果已经有人有人研究出来了。盲审，硕士3篇送外省，正分才可同意答辩，所有信息抹掉，名字，自己的工作量中的期刊信息抹掉，以示公平。其他有助信息也要写出来，考虑下到硕士期间的工作量，未录用未投稿的论文啥的都写出来。</p><p>答辩时候的致谢可以比论文上的致谢多一点，多谢评委啥的，提前一个星期就知道评委分组了。</p></blockquote><h1 id="第五讲-期刊论文写作技巧"><a href="#第五讲-期刊论文写作技巧" class="headerlink" title="第五讲 期刊论文写作技巧"></a>第五讲 期刊论文写作技巧</h1><h2 id="1-撰写流程"><a href="#1-撰写流程" class="headerlink" title="1.撰写流程"></a>1.撰写流程</h2><p>完整整理数据结果</p><p>精心绘制相关图表：模型、装置、材料成分及结构、数据处理结果</p><p><strong>常规论文撰写顺序</strong>：①模型、装置→②方法、步骤→③数据处理→④结果、结论→⑤摘要→⑥题目→⑦引言→⑧参考文献→⑨致谢→⑩投稿信</p><blockquote><p>工作做完之后，不着急写论文，整理。导师改的话，就是改题目，引言。</p><p>写清自己负责的工作，成果，讲清楚。导师参与指导结论，结果。</p><p>雏形已好，题目第一精彩，摘要引言第二精彩，导师尽全力修改。</p></blockquote><h2 id="2-题目"><a href="#2-题目" class="headerlink" title="2.题目"></a>2.题目</h2><p>亮题目</p><ul><li>目：眼睛</li><li>题目：论文的眼睛</li><li>眼睛：意大利文艺复兴时期画家达芬奇从人物画的角度提出：“眼睛是心灵的窗户”。</li><li>题目：反映论文的主要亮点，要吸引审稿专家和今后读者的眼球，要有闪亮登场的效果！</li></ul><blockquote><p>最大的创新点，最大的亮点</p></blockquote><h2 id="3-摘要"><a href="#3-摘要" class="headerlink" title="3.摘要"></a>3.摘要</h2><p>精摘要，摘要一定要精炼，尽量用长句，至少应该包含4个要素：</p><ul><li>本文使用的方法材料；</li><li>研究的对象/构建的模型/构造的系统；</li><li>发现的规律、性质/解决的问题；</li><li>可能的价值/应用的前景。</li></ul><h2 id="4-引言"><a href="#4-引言" class="headerlink" title="4.引言"></a>4.引言</h2><h3 id="4-1-重引言"><a href="#4-1-重引言" class="headerlink" title="4.1 重引言"></a>4.1 重引言</h3><p>引言占<strong>40%的分量</strong>，是<strong>打动</strong>审稿专家的敲门砖，对能否发表至关重要!</p><p>一定要多读文献，精心写作，至少应该包含6个要素：</p><ul><li>本文的<strong>研究背景及科学意义</strong>；</li><li>本课题/领域<strong>里程碑式的工作</strong>引用；</li><li>与本文密切相关的目前存在的<strong>问题</strong>；<ul><li><em>有的放矢</em>，对号入座！</li></ul></li><li>本文用什么方法得出的规律/<strong>解决的问题</strong>；<ul><li><em>前后呼应</em>，重中之重，王婆卖瓜，<strong>最大亮点</strong>！</li><li>般1~2个句子，最多不要超过4个句子进行精确描述！最考验作者的精确概况能力。</li></ul></li><li>本文成果有何<strong>主要价值</strong>/意义/可能；<ul><li><em>理论意义、实验意义、应用意义</em></li></ul></li><li>本文的章节安排。<ul><li>便于审稿人、读者整体了解，不同期刊要求不同，灵活处理。</li></ul></li></ul><h2 id="5-正文"><a href="#5-正文" class="headerlink" title="5.正文"></a>5.正文</h2><h3 id="5-1-准模型"><a href="#5-1-准模型" class="headerlink" title="5.1 准模型"></a>5.1 准模型</h3><p>对于本文建立的模型、使用的材料、采取的实验方案、使用的理论和方法,都要准确描述,不能模棱两可、含糊不淸，也不要漏掉参量、参数等细节。</p><p>要准确到能够让同行重复出你的工作！</p><h3 id="5-2-详结果"><a href="#5-2-详结果" class="headerlink" title="5.2 详结果"></a>5.2 详结果</h3><p>本文得出的数值计算结果、解析推导结果、实验测量结果、新方法的应用结果，一定要尽可能地详尽。有多少写多少，不要遗漏，不要浪费。</p><p>每个结果最好按照<strong>先总后分</strong>方式，分三段描述：一般规律、举例说明、可能应用。</p><p>图标说明/表标说明最好也按照<strong>先总后分</strong>方式，按照Nature的写法，总的说明概括共同的内容/要素，表达本图/表放在此处想要给读者增加的信息！分图说明只讲不同的要素/要点。</p><blockquote><p>多图放在一起，要总分，说明之间的联系，还要介绍没张图。</p></blockquote><p>自己一定要清楚每个图/表的必要性，想要表达的重要信息，要给读者增加重要的、新的信息！</p><p>图、表，尤其是图要尽量漂亮！不同的颜色搭配，不同的线型组合，不同的分图比例及摆放位置，不同的字体、字号规范，都要既能准确、清晰、明了地表达特定的科学信息，又要尽量给人以美观、匀称、和谐的感觉。特别是SCI一区、影响因子在10以上的一流学术期刊要求作图达到专业绘图水平！</p><h3 id="5-3-深分析"><a href="#5-3-深分析" class="headerlink" title="5.3 深分析"></a>5.3 深分析</h3><p>对于本文得出的结果、发现的现象/规律要深入地<strong>分析/解释/类比/预测</strong>。</p><ol><li><strong>数学</strong>上：函数关系、极值最值、极点奇点、连续突变、变化趋势</li><li><strong>物理</strong>上：传播模式、相互作用、机制类比等等</li></ol><h3 id="5-4-略展望"><a href="#5-4-略展望" class="headerlink" title="5.4 略展望"></a>5.4 略展望</h3><p>对于本文得出的结果、发现的现象/规律和提出的创新方法可以简略地从<strong>理论、实验、应用、学科</strong>等方面进行<strong>展望</strong>。</p><h3 id="5-5-全结论"><a href="#5-5-全结论" class="headerlink" title="5.5 全结论"></a>5.5 全结论</h3><h2 id="6-结论"><a href="#6-结论" class="headerlink" title="6.结论"></a>6.结论</h2><p>在结论部分，可以对全文除引言以外的模型、方法、结果、结论、展望进行全面总结。</p><p>结论与摘要、引言、正文的区别和联系：</p><ol><li>摘要只摘录全文结果、结论中的精华部分。</li><li>引言中的亮点阐述，要求仅仅只用2个左右的句子，把全文结果的最大亮点摆出来，高度凝练，不能出现公式。</li><li>正文中各个小部分的总结只需要对具体的某个结果进行小结，包括公式和文字的总结。</li><li>结论的总结比较全面，可以出现公式和展望。</li></ol><h2 id="7-致谢"><a href="#7-致谢" class="headerlink" title="7.致谢"></a>7.致谢</h2><p>在致谢部分，不仅仅包含致谢，根据不同期刊的相应要求，需要包含不同的内容。</p><p>通常有：</p><ol><li>对于本文工作完成提供了学术讨论和帮助、语言修改和润色、提供样品和实验便利的单位和人员，他们没有出现在本文的作者和单位中时，应该予以感谢和感恩。</li><li>主要资助的基金名称和号码。</li><li>有些期刊还包括每个作者对本文作出的具体贡献描述。</li></ol><h2 id="8-参考文献"><a href="#8-参考文献" class="headerlink" title="8.参考文献"></a>8.参考文献</h2><h3 id="8-1-准文献"><a href="#8-1-准文献" class="headerlink" title="8.1 准文献"></a>8.1 准文献</h3><p>对于本文引用的全部文献，提倡“<strong>不看不引，引则必读</strong>”的原则。对于每篇参考文献的作者、题目、期刊名、卷、期、起止页码、发表时间，力争<strong>零错误</strong>！</p><p>编辑和审稿专家对牛人、牛组是极其宽容的，对无名之辈、无名之组是极不宽容的，有时候甚至是零容忍！</p><h1 id="第六讲-期刊论文投稿与发表"><a href="#第六讲-期刊论文投稿与发表" class="headerlink" title="第六讲 期刊论文投稿与发表"></a>第六讲 期刊论文投稿与发表</h1><h2 id="1-投稿流程"><a href="#1-投稿流程" class="headerlink" title="1.投稿流程"></a>1.投稿流程</h2><p>常规的期刊论文投稿流程：</p><ul><li><p>①自我评估学术水平</p></li><li><p>②选择合适学术期刊</p></li><li><p>③按照期刊要求准备投稿材料</p><blockquote><p>老师帮忙预测论文有几区的水平，自己再查近些年是否发过给类似的工作，国人发表过？华师人发表过？影响因子的发展趋势</p></blockquote></li><li><p>④<strong>预投稿、完善投稿材料</strong></p><blockquote><p>期刊要求新变化？</p></blockquote></li><li><p>⑤正式投稿、密切关注状态进展</p></li><li><p>⑥处理审稿意见、针对性修改论文</p></li><li><p>⑦签署文件、校对清样</p></li><li><p>⑧支付版面费、下载发表论文</p></li></ul><h2 id="2-期刊选择技巧"><a href="#2-期刊选择技巧" class="headerlink" title="2.期刊选择技巧"></a>2.期刊选择技巧</h2><p>（1）学术水平定位：本文学术水平达到SCI一区？二区？三区？四区？</p><p>（2）学术内容匹配：查看期刊的Topics，查看期刊近3年是否发表过与本论文相关度高的论文。<br>（3）学术群体匹配：查看该期刊近年来中国人、本单位、本研究组是否在上面发表过论文。<br>（4）论文属性匹配：本文的文体、篇幅、理论和实验属性是否与该期刊相匹配。</p><h2 id="3-投稿准备与正式投稿"><a href="#3-投稿准备与正式投稿" class="headerlink" title="3.投稿准备与正式投稿"></a>3.投稿准备与正式投稿</h2><p>（1）确定期刊后，按照期刊要求准备投稿材料。</p><p>（2）下载该期刊最新的论文作为模板，比对所有格式。</p><ul><li><strong>题目</strong>包含空格的字符数</li><li><strong>作者</strong>拼写方法、第一作者和通讯作者标注方法</li><li><strong>单位</strong>拼写方法、排列方法和位置</li><li><strong>摘要</strong>的字数、格式、术语简写</li><li><strong>关键词</strong>、各种<strong>代码</strong>（OCIS、PACS、PACC）等等</li><li>术语简写，包括Figure，Section，Equation，Table，Reference等等在句首、句中的不同写法。其他相关简写确认：</li><li>Section VI，Section 6，Sec.VI.Sec. 6，Subsection 3. 1，Subsubsection3.6.2</li><li>Figure 1，Fig. 1，Figs. 1（a）-（c）， Figs.1(a)-1(c)，Figs.1（a）and（b）</li><li>Equation（6）.Eq（6）. Eqs. （6）-（8）. Eqs.（6）and（8）</li><li>Table 6. Tab. 6. Tabs. 6-8. Tabs. 6 and 8</li><li>References[3-6]，Ref.3，Refs. [6-8]</li><li><strong>基金</strong>的拼写、格式</li><li><strong>参考文献</strong>拼写方法、内容、排列顺序</li></ul><p>（3）<strong>润色</strong></p><ul><li><strong>单词检查</strong>：用相应的软件检查，要求单词拼写零错误</li><li><strong>语法检查</strong>：软件检查，多读几遍！</li><li><strong>提高文学修养</strong>：多读中文小说,背诵名作名段。强力推荐金庸的武侠小说：构思严谨，情节精彩，文笔流畅，文字优美，描写精微，情感细腻，弘扬正气，歌颂正义，读来不仅可以提高文学功底，而且能够学习到不少方法论。</li><li><strong>加强英文写作</strong>：多读英文名著，多看顶级期刊论文，摘录、抄写、背诵精彩长句。达到一定词汇量和写作水平之后，多用长句，多用成语，多用插入语，多用排比句，多用英语思维方式写作。</li></ul><h2 id="4-回复评审意见与论文修改"><a href="#4-回复评审意见与论文修改" class="headerlink" title="4.回复评审意见与论文修改"></a>4.回复评审意见与论文修改</h2><p>（1）认真回复审稿意见</p><ul><li>正确理解编辑和审稿专家的问题</li><li>认真回答审稿专家的每一个问题，包括细节</li><li>对于不合理的问题要敢于合理争辩</li><li>高水平的回答+精美的格式</li></ul><p>（2）根据审稿意见认真修改论文，不要画蛇添足。</p><h2 id="5-版权转让协议与校对清样"><a href="#5-版权转让协议与校对清样" class="headerlink" title="5.版权转让协议与校对清样"></a>5.版权转让协议与校对清样</h2><p>（1）适时完成版权转让协议书的签署</p><p>（2）认真校对清样，站好最后一班岗。</p><ul><li>论文录用之后仍然要坚持站好最后一班岗！</li><li>校对、检查、修改：姓名、单位名、基金号、单词拼写、图表公式、文献引用等等</li></ul><h2 id="6-开源期刊与版面费支付"><a href="#6-开源期刊与版面费支付" class="headerlink" title="6.开源期刊与版面费支付"></a>6.开源期刊与版面费支付</h2><p>（1）开源期刊：期刊上发表的论文，作者需要支付出版的版面费，读者可以免费下载阅读。<br>（2）非开源期刊：期刊上发表的论文，作者不需要支付出版的版面费，读者不能免费下载阅读，需要付费。<br>（3）在开始投槁时，一定要慎重选择期刊的开源类型，和导师协商好。</p><h2 id="7-慎重对待拒稿"><a href="#7-慎重对待拒稿" class="headerlink" title="7.慎重对待拒稿"></a>7.慎重对待拒稿</h2><ul><li>正确面对拒稿意见</li><li>认真思考、认真修改论文</li><li>认真选择新期刊</li><li>认真修改格式细节，不要留下蛛丝马迹！</li></ul><h1 id="第七讲-学术报告与交流"><a href="#第七讲-学术报告与交流" class="headerlink" title="第七讲 学术报告与交流"></a>第七讲 学术报告与交流</h1><h2 id="1-口头报告"><a href="#1-口头报告" class="headerlink" title="1.口头报告"></a>1.口头报告</h2><p>按照会议论文的要求认真准备论文摘要</p><p>按照会议要求投稿、审稿</p><p>录用后,认真准备课件,多次演练控制好报告时间</p><p>口头报告的基本要素：</p><p>（1）题目、报告人、单位、时间、地点、单位LOGO</p><p>（2）报告目录</p><p>（3）报告内容</p><p>（4）报告总结</p><p>（5）报告致谢</p><p>（6）认真准备提问环节,珍惜学术交流机会</p><p>（7）会后加深联系：温习老朋友、结识新朋友</p><ul><li>墙报展示也是会议交流的一种方式，同样需要审稿、录用步骤</li><li>按照会议的要求准备墙报论文：纸张质量、规格、颜色、数量</li><li>按照各个分会场的时间和场地安排自己张贴</li><li>墙报展示时力争全程参与，准备好记录、联系的工具，珍惜交流机会</li></ul><h2 id="2-墙报展示"><a href="#2-墙报展示" class="headerlink" title="2.墙报展示"></a>2.墙报展示</h2><ul><li>墙报展示也是会议交流的一种方式，同样需要审稿、录用步骤</li><li>按照会议的要求准备墙报论文：纸张质量、规格、颜色、数量</li><li>按照各个分会场的时间和场地安排自己张贴</li><li>墙报展示时内力争全程参与，准备好记录、联系的工具，珍惜交流机会</li></ul><p>结束的时候写篇综述论文。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;课程&lt;/p&gt;
    
    </summary>
    
    
      <category term="Thesis" scheme="https://mysticalguest.github.io/categories/Thesis/"/>
    
    
      <category term="课程" scheme="https://mysticalguest.github.io/tags/%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析</title>
    <link href="https://mysticalguest.github.io/Machine-Learing/3274548c.html"/>
    <id>https://mysticalguest.github.io/Machine-Learing/3274548c.html</id>
    <published>2021-09-18T02:03:34.734Z</published>
    <updated>2021-11-08T04:48:18.768Z</updated>
    
    <content type="html"><![CDATA[<p>算法设计与分析课程</p><a id="more"></a><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>贪心算法，蛮力算法</p><p>问题求解的关键</p><p>建模：对输入参数和解给出形式化或半形式化的描述</p><p>设计算法：采用什么算法设计技术，正确性——是否对所有的实例都得到正确的解</p><p>分析算法——效率</p><p>目标函数，约束条件</p><p>运筹学</p><p>递归树是迭代的模型</p><h2 id="1-1-问题的计算复杂度：排序问题"><a href="#1-1-问题的计算复杂度：排序问题" class="headerlink" title="1.1 问题的计算复杂度：排序问题"></a>1.1 问题的计算复杂度：排序问题</h2><h2 id="1-2-货郎问题与计算复杂度"><a href="#1-2-货郎问题与计算复杂度" class="headerlink" title="1.2 货郎问题与计算复杂度"></a>1.2 货郎问题与计算复杂度</h2><h2 id="1-3-算法及其时间复杂度"><a href="#1-3-算法及其时间复杂度" class="headerlink" title="1.3 算法及其时间复杂度"></a>1.3 算法及其时间复杂度</h2><h2 id="1-4-算法的伪码表示"><a href="#1-4-算法的伪码表示" class="headerlink" title="1.4 算法的伪码表示"></a>1.4 算法的伪码表示</h2><h2 id="1-5-算法的渐进的界"><a href="#1-5-算法的渐进的界" class="headerlink" title="1.5 算法的渐进的界"></a>1.5 算法的渐进的界</h2><h2 id="1-6-有关函数渐进的界的定理"><a href="#1-6-有关函数渐进的界的定理" class="headerlink" title="1.6 有关函数渐进的界的定理"></a>1.6 有关函数渐进的界的定理</h2><h2 id="1-7-几类重要的函数"><a href="#1-7-几类重要的函数" class="headerlink" title="1.7 几类重要的函数"></a>1.7 几类重要的函数</h2><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><h2 id="2-1-序列求和的方法"><a href="#2-1-序列求和的方法" class="headerlink" title="2.1 序列求和的方法"></a>2.1 序列求和的方法</h2><h2 id="2-2-递推方程与算法分析"><a href="#2-2-递推方程与算法分析" class="headerlink" title="2.2 递推方程与算法分析"></a>2.2 递推方程与算法分析</h2><h2 id="2-3-迭代法求解递推方程"><a href="#2-3-迭代法求解递推方程" class="headerlink" title="2.3 迭代法求解递推方程"></a>2.3 迭代法求解递推方程</h2><h2 id="2-4-差消法求"><a href="#2-4-差消法求" class="headerlink" title="2.4 差消法求"></a>2.4 差消法求</h2><h2 id="2-5-递归树"><a href="#2-5-递归树" class="headerlink" title="2.5 递归树"></a>2.5 递归树</h2><h2 id="2-6-主定理及其证明"><a href="#2-6-主定理及其证明" class="headerlink" title="2.6 主定理及其证明"></a>2.6 主定理及其证明</h2><h2 id="2-7-主定理的应用"><a href="#2-7-主定理的应用" class="headerlink" title="2.7 主定理的应用"></a>2.7 主定理的应用</h2><p>迭代推时间复杂度，不能使用定理的，可以使用递归树求解</p><h1 id="3-分治算法的设计思想与分析方法"><a href="#3-分治算法的设计思想与分析方法" class="headerlink" title="3 分治算法的设计思想与分析方法"></a>3 分治算法的设计思想与分析方法</h1><h2 id="3-1-分治策略的设计思想"><a href="#3-1-分治策略的设计思想" class="headerlink" title="3.1 分治策略的设计思想"></a>3.1 分治策略的设计思想</h2><h2 id="3-2-分治算法的一般描述和分析方法"><a href="#3-2-分治算法的一般描述和分析方法" class="headerlink" title="3.2 分治算法的一般描述和分析方法"></a>3.2 分治算法的一般描述和分析方法</h2><p>二分检索</p><p>二分归并排序</p><p>Hanoi塔的递归算法</p><h2 id="3-3-芯片测试"><a href="#3-3-芯片测试" class="headerlink" title="3.3 芯片测试"></a>3.3 芯片测试</h2><p>蛮力算法</p><h2 id="3-4-快速排序"><a href="#3-4-快速排序" class="headerlink" title="3.4 快速排序"></a>3.4 快速排序</h2><h2 id="3-5-幂乘算法及应用"><a href="#3-5-幂乘算法及应用" class="headerlink" title="3.5 幂乘算法及应用"></a>3.5 幂乘算法及应用</h2><h2 id="3-6-改进分治算法的途径1：减少子问题数"><a href="#3-6-改进分治算法的途径1：减少子问题数" class="headerlink" title="3.6 改进分治算法的途径1：减少子问题数"></a>3.6 改进分治算法的途径1：减少子问题数</h2><h2 id="3-7-改进分治算法的途径2：增加预处理"><a href="#3-7-改进分治算法的途径2：增加预处理" class="headerlink" title="3.7 改进分治算法的途径2：增加预处理"></a>3.7 改进分治算法的途径2：增加预处理</h2><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法设计与分析课程&lt;/p&gt;
    
    </summary>
    
    
      <category term="Machine-Learing" scheme="https://mysticalguest.github.io/categories/Machine-Learing/"/>
    
    
      <category term="算法" scheme="https://mysticalguest.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>起步</title>
    <link href="https://mysticalguest.github.io/Machine-Learing/32df0da.html"/>
    <id>https://mysticalguest.github.io/Machine-Learing/32df0da.html</id>
    <published>2021-09-12T02:46:26.920Z</published>
    <updated>2021-09-12T10:53:32.726Z</updated>
    
    <content type="html"><![CDATA[<p>导师公众号内容</p><a id="more"></a><h1 id="一、基于深度强化学习的像素材料设计"><a href="#一、基于深度强化学习的像素材料设计" class="headerlink" title="一、基于深度强化学习的像素材料设计"></a>一、基于深度强化学习的像素材料设计</h1><p><strong>英文原题：</strong>Deep reinforcement learning for digital materials design</p><h2 id="1-1-关键词"><a href="#1-1-关键词" class="headerlink" title="1.1 关键词"></a>1.1 关键词</h2><p>深度神经网络（Deep Neural Network, DNN）</p><p>深度强化学习（Deep Reinforcement Learning, DRL）</p><p>深度Q网络（Deep Q Network, DQN）</p><p>遗传算法（genetic algorithm, GA）</p><h2 id="1-2-关键内容"><a href="#1-2-关键内容" class="headerlink" title="1.2 关键内容"></a>1.2 关键内容</h2><p>深度学习相关理论也应用在其他自然学科的研究，例如<strong>新材料研发与生物高分子解析</strong>，而近期热议的<strong>Alphafold2</strong>就很好的展示了深度学习在学科交叉方面的优势。在<strong>材料与结构设计优化领域</strong>，深度强化学习（Deep Reinforcement Learning, DRL）有着巨大的应用潜力，或将有效降低传统设计过程中的人工成本。</p><p>通过<strong>试错自动迭代算法</strong>找到解决问题的最优决策，结合深度神经网络对问题的<strong>强大感知与泛化能力</strong>，深度强化学习得以解决现实世界中更加复杂的实际问题。</p><p><strong>加州大学伯克利分校</strong>的研究团队<strong>针对像素材料（Digital Materials, DMs）首次提出了基于深度强化学习的自动化设计方法</strong>。</p><p>如图1所示，深度强化学习算法可自动提升复合材料的某一物理属性（如<strong>平均杨氏模量 Emean</strong>）。区别于传统的<strong>参数化设计</strong>（Parametric Design），<strong>像素化设计思想</strong>将设计空间看做由材料微元组合而成，将提供更高的设计自由度以及结构复杂性。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/MachineLearing/640.webp" alt="图1. 基于深度强化学习的像素材料设计系统概要"></p><p>文中使用了<strong>像素复合材料</strong>作为主体研究对象，系统执行方式如图2所示。复合材料由可3D打印的硬材料（数位0表示）与软材料（数位1表示）组成。起始状态下，系统将按照一定的<strong>硬软材料比例</strong>随机生成图案。图案的当前状态（state）可以<strong>转化为一维二进制数组并传递至深度Q网络</strong>（Deep Q Network, DQN）, 由其可能带来最大未来回报（reward）的动作（action）做出下一步决策，图案状态发生改变，随后<em>有限元仿真软件</em>得出新状态的平均杨氏模量。新旧状态的图案和物理信息都将记录在经验回放池（replay buffer）中，用于<strong>更新深度Q网络</strong>。经过不断更新迭代，最终得到的图案将在保证初始限定的硬软材料比例不变的条件下拥有最大的平均杨氏模量。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/MachineLearing/641.webp" alt="图2. 基于深度强化学习的像素材料设计系统执行路线"></p><p>文中决策器的实际执行过程中用到了一对<strong>协同运作</strong>的深度Q网络（collaborative DQN），其工作机制如图3 所示。两个深度Q网络<script type="math/tex">Q_{net1}</script>和<script type="math/tex">Q_{net2}</script>分别代表了两个<strong>不同智能体（agent）的执行方式</strong>。<script type="math/tex">Q_{net1}</script>负责找到其<em>最大Q值对应的原图案位置并将对应的软材料翻转为硬材料</em>，而<script type="math/tex">Q_{net2}</script>负责对本身判断的<em>最大Q值位置执行硬材料向软材料的翻转</em>。经过这一对动作过程，设计图案的硬软材料比例便可维持不变。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/MachineLearing/642.webp" alt="图3. 深度Q协同网络运行机制"></p><p>针对相对复杂的设计问题，该系统相较传统智能设计方法，如遗传算法（genetic algorithm, GA）在运行效率和最终结果上都有较大的优势。如图4a下排所示，尽管在3 X 3的设计空间中，深度Q协同网络的实际表现并不如如遗传算法。当设计空间的自由度提升到5 X 5和7 X 7时，如4b-c下排所示，深度Q协同网络将反超遗传算法得到更高杨氏模量的图案。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/MachineLearing/643.webp" alt="图4. 比较深度Q协同网络与如遗传算法在不同设计空间大小下的算法表现"></p><p>本文总共研究了3 X 3,5 X 5和7 X 7三种设计空间大小下的11个硬软材料比例。所有条件下的深度Q协同网络提出的最优设计方案如图5所示。就最终结果而言，深度Q协同网络可以在所有条件下实现等同或优于遗传算法的结果。尤其是在硬软材料比例为[15:10], [10:15], [30:19], [20:19] 的条件下，本文提出的方法相较遗传算法给出的设计有着更显著的性能，平均杨氏模量有最高15.9%的提升。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/MachineLearing/644.webp" alt="图5. 深度Q学习网络在不同设计空间大小下提出的最优图案"></p><p>由于深度Q学习网络是逐步更新实现设计优化，其间也使用了<strong>批量训练</strong>（batch training）的方法，每步更新的过程中样本的Emean分布都可视。如图6便展示了在7 X 7设计空间下硬软材料比例为 [24:25] 时的样本性能分布的逐步更新。从图中可以看出，经过24歩的翻转动作，新的样本性能分布已经大大优于原本<strong>随机的初始分布</strong>，并且超半数的样本都拥有比初始分布最优值更高的性能，体现了较高的优化效率。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/MachineLearing/645.webp" alt="图6. 深度Q学习网络样本性能随更新步数的变化"></p><p>本文所提出的基于深度强化学习的结构设计方法是关于智能制造的一次创新性尝试，该团队未来计划将本工作的核心思想推广至更高自由度、更多材料组合的情形，并期望本工作所提出的相关方法能够更加广泛的应用于智能材料领域的探索。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;导师公众号内容&lt;/p&gt;
    
    </summary>
    
    
      <category term="Machine-Learing" scheme="https://mysticalguest.github.io/categories/Machine-Learing/"/>
    
    
      <category term="算法" scheme="https://mysticalguest.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>机器学习导论</title>
    <link href="https://mysticalguest.github.io/Machine-Learing/8420e1e9.html"/>
    <id>https://mysticalguest.github.io/Machine-Learing/8420e1e9.html</id>
    <published>2021-09-08T00:57:29.775Z</published>
    <updated>2021-12-29T08:56:14.749Z</updated>
    
    <content type="html"><![CDATA[<p>Introduction to Machine Learning</p><a id="more"></a><h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="1-1-什么是机器学习"><a href="#1-1-什么是机器学习" class="headerlink" title="1.1 什么是机器学习"></a>1.1 什么是机器学习</h2><p>Arthur Samuel定义的机器学习：在没有明确设置的情况下，使计算机具有学习能力的研究领域。</p><p>Tom Mitchell定义的机器学习：一个适当的学习问题定义如下：计算机程序从<strong>经验E</strong>中学习，解决某一<strong>任务T</strong>进行某一<strong>性能度量P</strong>，通过P测试在T上的表现因经验E而提高。</p><p>最主要的两类学习算法：监督学习和无监督学习。</p><ul><li>监督学习：我们会教计算机做某件事情；</li><li>无监督学习：我们让计算机自己学习；</li></ul><p>机器学习方法在大型数据库中的应用称为数据挖掘（data mining）。</p><p>机器学习不仅仅是数据库方面的问题，他也是人工智能的组成部分。机器学习还可以帮助我们解决视觉、语音识别以及机器人方面的许多问题。</p><h2 id="1-2-机器学习的应用实例"><a href="#1-2-机器学习的应用实例" class="headerlink" title="1.2 机器学习的应用实例"></a>1.2 机器学习的应用实例</h2><h3 id="1-2-1-学习关联性"><a href="#1-2-1-学习关联性" class="headerlink" title="1.2.1 学习关联性"></a>1.2.1 学习关联性</h3><p>购物篮分析：发现顾客所购商品之间的关联性；打包策略。</p><p>关联规则，<script type="math/tex">P(chips|beer)=0.7</script>，定义规则，购买啤酒的顾客中有<script type="math/tex">70%</script>的人也买了薯片。</p><h3 id="1-2-2-分类"><a href="#1-2-2-分类" class="headerlink" title="1.2.2 分类"></a>1.2.2 分类</h3><p><strong>信用评分</strong>，客户属性及其风险性的关联性。</p><p><strong>分类</strong>：低风险客户和高风险客户。客户信息作为分类器的输入，分类器的任务是<strong>将输入指派</strong>到其中的一个<strong>类</strong>。</p><p>规则的用途是<strong>预测</strong>。</p><p><strong>模式识别</strong>方面的应用：光学字符识别（OCR），即从字符图像识别字符编码。</p><p><strong>人脸识别</strong>输入的是人脸，类是需要识别的人，并且学习程序应当学习人脸图像与身份识别之间的关联性。这个问题比OCR更困难，原因是人脸会有更多的类，输入图像也更大一些，并且人脸是三维的，不同的姿势和光线等都会导致图像的显著变化。</p><p>对于<strong>医学诊断</strong>（medical diagnosis），输入是关于患者的信息，而类是疾病。输人包括患者的年龄、性别、既往病史、目前症状等。</p><p>在<strong>语音识别</strong>（speech recognition），输入是语音，类是可以读出的词汇。这里要学习的是从语音信号到某种语言的词汇的关联性。由于年龄、性别或口音方面的差异，不同的人对于相同词汇的读音不同，这使得语音识别问题相当困难。语音识别的另一个特点是其输入信号是时态的（temporal），词汇作为音素的序列实时读出，而且有些词汇的读音会较长一些。一种语音识别的新方法涉及利用照相机记录口唇动作，作为语音识别的补充信息源。这需要<strong>传感器融合</strong>（sensor fusion）技术，集成来自不同形态的输入，即集成声音和视频信号。</p><blockquote><p>机器学习，自然语言处理，垃圾邮件过滤，机器翻译</p></blockquote><p>生物测定学（biometrics）使用人的生理和行为特征来识别或认证人的身份，需要集成来自不同形态的输人。生理特征的例子是面部图像、指纹、虹膜和手掌；行为特征的例子是签字的力度、嗓音、步态和击键。</p><p>从数据中学习规则也为<strong>知识抽取</strong>提供了可能性。风险识别。</p><p>机器学习还可以进行<strong>压缩</strong>。用规则拟合数据，得到比数据更简单的解释，存储空间更好，计算更少。</p><p><strong>离群点检测</strong>，即发现那些不遵守规则的例外实例。</p><h3 id="1-2-3-回归"><a href="#1-2-3-回归" class="headerlink" title="1.2.3 回归"></a>1.2.3 回归</h3><p><strong>回归（regression）问题</strong>：预测二手车价格的系统。输入是影响车价的属性信息：品牌、车龄、发动机性能等，输出是车的价格，这种输出为数值的问题。</p><p>调查交易情况，收集训练数据，机器学习程序用一个函数拟合这些数据来学习x的函数y。</p><p>回归和分类均为监督学习（supervised learning）问题，其中输入x和输出y给定，任务是学习从输入到输出的映射。参数模型，判别式函数，误差最小，非线性函数。</p><p>回归的另一个例子是对<strong>移动机器人</strong>的导航。例如，自动汽车导航。其中输出是每次转动车轮的角度，使得汽车前进而不会撞到障碍物或偏离车道。这种情况下，输入由汽车上的传感器（如视频相机、GPS等）提供。训练数据可以通过监视和记录驾驶员的动作收集。</p><p>假设造一个焙炒咖啡的机器，该机器有多个影响咖啡品质的输入：各种温度、时间、咖啡豆种类等配置。针对不同的输入配置进行大量试验，并测量测量咖啡的品质。为寻求最优配置，我们拟合一个<strong>联系</strong>这些输入和咖啡品质的回归模型，并在当前模型的最优样本附近选择一些新的点，以便寻找更好的配置。我们抽取这些点，检测咖啡的品质，将它们加入训练数据，并拟合新的模型。这通常被称为<strong>响应面设计</strong>（response surface design）。</p><h3 id="1-2-4-非监督学习"><a href="#1-2-4-非监督学习" class="headerlink" title="1.2.4 非监督学习"></a>1.2.4 非监督学习</h3><p>监督学习，目标是学习从输入到输出的映射关系，输出的正确值已经由指导者提供。非监督学习中却没有这样的指导者,，只有输入数据。目标是发现输入数据中的规律。输入空间存在着<strong>某种结构</strong>，使得特定的模式比其他模式<strong>更常出现</strong>，而我们希望<br>知道哪些经常发生，哪些不经常发生。在统计学中，这称为密度估计（density estimation）。</p><p>密度估计的一种方法是聚类（clustering），其目标是发现输入数据的簇或分组。对于拥有老客户数据的公司，客户数据包括客户的个人统计信息，及其以前与公司的交易，公司也许想知道其客户的分布，搞清楚什么类型的客户会频繁出现。这种情况下，聚类模型会将属性相似的客户分派到相同的分组，为公司提供其客户的自然分组；这称作<em>客户市场划分</em>(customer segmentation)。一旦找出了这样的分组，公司就可能做出一些决策，比如对不同分组的客户提供特别的服务和产品等；这称作客户关系管理（customer relationship management）。这样的分组也可以用于识别”离群点”，即那些不同于其他客户的客户。这可能意味着一块新的市场，公司可以进一步开发。</p><p>聚类的有趣应用是<strong>图像压缩</strong>。图像被量化。主色调。</p><p>文档聚类，相似的文档分组。</p><p>机器学习方法还应用于生物信息学。计算机科学在分子生物学的应用领域之一就是<strong>比对</strong>，即序列匹配。很多模板串进行匹配问题。聚类用于学习结构域。</p><h3 id="1-2-5-增强学习"><a href="#1-2-5-增强学习" class="headerlink" title="1.2.5 增强学习"></a>1.2.5 增强学习</h3><p>在某些应用中，系统的输出是动作的序列。在这种情况下，单个的动作并不重要，重要的是策略，即达到目标的正确动作的序列。不存在中间状态中最好动作这种概念。如果一个动作是好的策略的组成部分，那么该动作就是好的。这种情况下，机器学<br>习程序就应当能够<strong>评估策略的好坏程度</strong>，并从以往好的动作序列中学习，以便能够产生策略。这种学习方法称为<strong>增强学习</strong>（reinforcement learning）算法。</p><p>游戏是一个很好的例子。在游戏中，单个移动本身并不重要，正确的移动序列才是重要的。如果一个移动是一个好的游戏策略的一部分，则它就是好的。游戏是人工智能和机器学习的重要研究领域，这是因为游戏容易描述，但又很难玩好。像国际象棋，规则少量几条，但非常复杂，因为在每种状态下都有大量可行的移动，并且每局又都包含有大量的移动。一旦有了能够学习如何玩好游戏的好算法，我们也可以将这些算法用在具有更显著经济效益的领域。</p><p>用于在某种环境下<strong>搜寻目标位置</strong>的机器人导航是增强学习的另一个应用领域。在任何时候，机器人都能够朝着多个方向之一移动。经过多次的试运行，机器人应当学到正确的动作序列，尽可能快地从某一初始状态到达目标状态，并且不会撞到任何障碍物。致使增强学习难度增加的一个因素是系统具有不可靠和不完整的感知信息。例如，装备视频照相机的机器人就得不到完整的信息，因此该机器人总是处于部分可观测状态，并且应当将这种不确定性考虑在内。一个任务还可能需要多智能主体的并行操作，这些智能主体将相互作用并协同操作，以便完成一个共同的目标。</p><h1 id="第二章-监督学习"><a href="#第二章-监督学习" class="headerlink" title="第二章 监督学习"></a>第二章 监督学习</h1><h2 id="2-1-由实例学习类"><a href="#2-1-由实例学习类" class="headerlink" title="2.1 由实例学习类"></a>2.1 由实例学习类</h2><p>学习，实例，被测人，涵盖目标分类的描述，预测。类识别器的输入，训练数据绘制在二维空间上，专家谈论和分析数据，确定范围，假设类集合。训练集，经验误差，预测值，预期值，泛化问题。假设，诱导类。</p><h1 id="上海交大张志华机器学习"><a href="#上海交大张志华机器学习" class="headerlink" title="上海交大张志华机器学习"></a>上海交大张志华机器学习</h1><p>计算，统计，信息论，算法，控制论，最优化</p><p>机器学习=矩阵+优化+算法+统计</p><p>回归问题，数据，预测估计， </p><h1 id="吴恩达机器学习"><a href="#吴恩达机器学习" class="headerlink" title="吴恩达机器学习"></a>吴恩达机器学习</h1><p>网页排序，图像识别，邮件过滤，</p><h2 id="1-3-监督学习"><a href="#1-3-监督学习" class="headerlink" title="1.3 监督学习"></a>1.3 监督学习</h2><p>数据集，包括正确答案，给出更多正确答案，回归问题，数值的连续输出</p><p>分类问题，预测一个离散值的输出，可能两个以上的输出值</p><p>无穷多的特征，向量机</p><h2 id="1-4-无监督学习"><a href="#1-4-无监督学习" class="headerlink" title="1.4 无监督学习"></a>1.4 无监督学习</h2><p>数据集无任何标签，聚类算法，新闻专题，计算机集群，现在octave中建立模型，然后再迁移到其他编程语言。</p><h2 id="2-1-模型描述"><a href="#2-1-模型描述" class="headerlink" title="2.1 模型描述"></a>2.1 模型描述</h2><p>监督学习是如何工作的，预测房价，每个例子都有一个“正确答案”，也是回归问题的例子，回归是指我们预测一个具体的数值输出。</p><p>另一个监督学习常见的例子是分类问题，我们用它来预测离散值输出。做判断。</p><ul><li>M：样本输入量，训练样本的数量，样本容量。</li><li>x：输入值，特征</li><li>y：输出变量，预测的目标变量</li><li><script type="math/tex">(x, y)</script>表示一个训练样本</li><li><script type="math/tex">(x^{(i)},y^{(i)})</script>表示第i个训练样本</li></ul><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/MachineLearing/hypothesis.jpg" alt="图1"></p><p>向算法提供房价的训练集，算法输出的<strong>假设函数</strong>，作用是：把房子的大小作为输入变量，h是一个引导从x得到y的函数。</p><p>决定怎么表示这个假设函数h。</p><p>表示假设函数：<script type="math/tex">h_\theta =\theta_0+\theta_1 x</script></p><p>函数的作用是预测y是关于x的线性函数，线性是学习的基础。一元线性回归模型（单变量线性回归）</p><h2 id="2-2-代价函数"><a href="#2-2-代价函数" class="headerlink" title="2.2 代价函数"></a>2.2 代价函数</h2><h3 id="零"><a href="#零" class="headerlink" title="零"></a>零</h3><p>弄清楚如何把最有可能的直线与我们的数据相拟合，<script type="math/tex">\theta_i</script>称为模型参数，如何选择这两个参数值<script type="math/tex">\theta_0</script>和<script type="math/tex">\theta_i</script>，不同的参数值 <script type="math/tex">\to</script> 不同的假设 <script type="math/tex">\to</script> 不同的假设函数；</p><p>使<script type="math/tex">h(x)</script>，输入x时，我们预测的值最接近该样本对应的y值的参数<script type="math/tex">\theta_0,\theta_1</script></p><p>给出标准的定义，在线性回归中，我们要解决的是一个最小化问题，所以要写出<script type="math/tex">\theta_0,\theta_1</script>的最小化，式子及其小？<script type="math/tex">h(x)</script>与y之间的差异要小，减少假设的输出与房子真实价格之间的差的平方。</p><p>对所有训练样本进行一个求和，对<script type="math/tex">i=1</script>到<script type="math/tex">i=M</script>的样本，将对假设进行预测得到的结果，此时输入是第i号房子的面积，将第i号对应的预测结果，减去第i号房子的实际价格所得的差的平方相加得到总和。<script type="math/tex">\sum_{i=1}^M[h_\theta(x^{(i)})-y^{(i)}]^2</script>，尽量减少这个值，也就是预测值和实际值的差的平方，误差和，或者说预测价格和实际卖出价格的差的平方。<script type="math/tex">\frac{1}{M}\sum_{i=1}^M[h_\theta(x^{(i)})-y^{(i)}]^2</script>，减少平均误差，表示关于<script type="math/tex">\theta_0</script>和<script type="math/tex">\theta_1</script>的最小化过程，找到<script type="math/tex">\theta_0</script>和<script type="math/tex">\theta_1</script>，使这个值最小，转化为目标函数。<script type="math/tex">\frac{1}{2M}\sum_{i=1}^M[h_\theta(x^{(i)})-y^{(i)}]^2</script>，加<script type="math/tex">\frac{1}{2}</script>是因为后面平方求导多出2</p><p>定义一个代价函数，<script type="math/tex">J(\theta_0,\theta_1)=\frac{1}{2M}\sum_{i=1}^M[h_\theta(x^{(i)})-y^{(i)}]^2</script>，对于函数<script type="math/tex">J(\theta_0,\theta_1)</script>求最小值，常用（对大多数合理），平方误差函数，平方误差代价函数，MSE（mean squared error，均方差），</p><p>对于回归问题，是个合理的选择，其他代价函数也可</p><h3 id="一"><a href="#一" class="headerlink" title="一"></a>一</h3><blockquote><p>Hypothesis：<script type="math/tex">h_\theta(x)=\theta_0+\theta_1x</script></p><p>Parameters：<script type="math/tex">\theta_0,\theta_1</script></p><p>Cost Function：<script type="math/tex">J(\theta_0,\theta_1)=\frac{1}{2M}\sum_{i=1}^M[h_\theta(x^{(i)})-y^{(i)}]^2</script></p><p>Goal：<script type="math/tex">\underbrace{minimize}_{\theta_0,\theta_1} J(\theta_0,\theta_1)</script>，二次函数？</p></blockquote><p>simplified</p><blockquote><p>Hypothesis：<script type="math/tex">h_\theta(x)=\theta_1x</script></p><p>Parameters：<script type="math/tex">\theta_1</script></p><p>Cost Function：<script type="math/tex">J(\theta_1)=\frac{1}{2M}\sum_{i=1}^M[h_\theta(x^{(i)})-y^{(i)}]^2</script></p><p>Goal：<script type="math/tex">\underbrace{minimize}_{\theta_1} J(\theta_1)</script></p></blockquote><p>使代价函数可视化，学习算法的优化目标</p><h3 id="二"><a href="#二" class="headerlink" title="二"></a>二</h3><p>代价函数的作用，等高线图，等高图像，代价函数图形化，加入<script type="math/tex">\theta_0,\theta_1</script>，碗状3维图，碗状曲面，代价函数的形状，从<script type="math/tex">\theta_0,\theta_1</script>所在平面截取，即得到等高线图，以后更复杂，更高维</p><h2 id="2-5-梯度下降"><a href="#2-5-梯度下降" class="headerlink" title="2.5 梯度下降"></a>2.5 梯度下降</h2><p>一种算法，梯度下降法（Gradient descent algorithm），常用，可以将代价函数J最小化，应用于线性回归及机器学习的众多领域，最小化其他函数</p><blockquote><p>Have some fuction <script type="math/tex">J(\theta_0,\theta_1)</script></p><p>Want <script type="math/tex">\underbrace{min}_{\theta_0,\theta_1} J(\theta_0,\theta_1)</script></p><p>Outline：</p><ul><li>Start with some <script type="math/tex">\theta_0,\theta_1</script>（将其初始化都设为0，<script type="math/tex">\theta_0=0,\theta_1=0</script>）有时也会初始化为其他值</li><li>Keep changing <script type="math/tex">\theta_0,\theta_1</script> reduce <script type="math/tex">J(\theta_0,\theta_1)</script> until we hopefully end up at a minimun（最小值，局部最小值）</li></ul><p>更一般化的问题，<script type="math/tex">\theta_0,\theta_1,...,\theta_n</script></p></blockquote><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/MachineLearing/JFunction.png" alt="图2"></p><p>从红色高峰尽快走下山，周围方向，直到收敛至局部最低点</p><p>算法特点：不同出发点，到达不同局部最优处</p><p>背后的数学原理：（梯度算法的定义）</p><blockquote><p>repeat until convergence（收敛）{</p><p>​        <script type="math/tex">\theta_j:=\theta_j-\alpha\frac{\partial}{\partial\theta_j}J(\theta_0,\theta_1)\ (for\ j=0\ and\ j=1)</script></p><p>}    :=表示赋值，a=b真值判定，第一部分，<script type="math/tex">\alpha</script>是被称为学习速率的数字，用来控制梯度下降时，我们迈出多大的步子，<script type="math/tex">\alpha</script>越大，梯度下降很迅速，它控制我们以多大的幅度更新这个参数<script type="math/tex">\theta_j</script>，第二部分是导数项，有什么用？</p><p>correct：<strong>Simultaneous</strong> update更新参数</p><script type="math/tex; mode=display">temp0:=\theta_0-\alpha\frac{\partial}{\partial\theta_0}J(\theta_0,\theta_1)</script><script type="math/tex; mode=display">temp1:=\theta_1-\alpha\frac{\delta}{\delta\theta_1}J(\theta_0,\theta_1)</script><script type="math/tex; mode=display">\theta_0:=temp0</script><script type="math/tex; mode=display">\theta_1:=temp1</script><p>上面满足<strong>同步更新</strong>，与下面的方式不同</p><p>Incorrect：</p><script type="math/tex; mode=display">temp0:=\theta_0-\alpha\frac{\partial}{\partial\theta_0}J(\theta_0,\theta_1)</script><script type="math/tex; mode=display">\theta_0:=temp0</script><script type="math/tex; mode=display">temp1:=\theta_1-\alpha\frac{\partial}{\partial\theta_1}J(\theta_0,\theta_1)$$（$$\theta_0$$更新后计算这个倒数项）$$\theta_1:=temp1</script></blockquote><p>微妙处，对于更新方程，同时更新<script type="math/tex">\theta_0,\theta_1</script>，梯度下降<script type="math/tex">\to</script>同步更新</p><h2 id="2-6-梯度下降知识点总结"><a href="#2-6-梯度下降知识点总结" class="headerlink" title="2.6 梯度下降知识点总结"></a>2.6 梯度下降知识点总结</h2><p>梯度算法是做什么的以及梯度下降算法的更新过程有什么意义</p><p>上面梯度算法，两部分有什么用？以及为什么当把这两部分放在一起时，整个更新过程是有意义的？</p><p>考虑最小化函数只有一个参数的情形，<script type="math/tex">\underbrace{min}_{\theta_1} J(\theta_1)，\theta_1\in R</script>，画出一维的曲线（想象一个二次函数曲线，开口向上），选取一点（正斜率的那点），不断更新，<script type="math/tex">\theta_1=\theta_1-\alpha*\frac{d}{d\theta_1}J(\theta_1)，\alpha</script>永远是一个正数，又因为是正斜率，则<script type="math/tex">\frac{d}{d\theta_1}J(\theta_1)</script>为正数，<script type="math/tex">\theta_1</script>减去正数，其减小，则会向最小点方向移动，更接近最低点；同理我们取斜率为负的点，<script type="math/tex">\theta_1</script>会增大。那么研究更新规则<script type="math/tex">\alpha</script>，如果其太大或太小会出现什么情况，如果<script type="math/tex">\alpha</script>太小，需要很多步才能到达最低点；如果<script type="math/tex">\alpha</script>太大，那么梯度下降可能会越过最低点，甚至可能无法收敛或发散？离最低点越来越远，斜率变大，使<script type="math/tex">\theta_1</script>的值变化很大，所以无法收敛甚至发散。</p><p>如果<script type="math/tex">\theta_1</script>已经处在一个局部最优点，下一步梯度下降会怎样？假设将<script type="math/tex">\theta_1</script>初始化在局部最低点或最优处，局部最优处导数等于0，导数项为0，<script type="math/tex">\theta_1</script>将不再改变，梯度下降更新其实什么都没做，但这正是我们想要的，它使解始终保持在局部最优点。这也解释了，即使学习速率<script type="math/tex">\alpha</script>保持不变，梯度下降法也可以收敛到局部最低点的原因。</p><p>随着越接近最优处，导数越小接近0，<script type="math/tex">\theta_0</script>更新的幅度就会更小，所以梯度下降法会自动采用更小的幅度，这就是梯度下降的运行方式，所以没必要在另外减小<script type="math/tex">\alpha</script>。</p><p>回归本质，线性回归中的代价函数，平方代价函数，综合梯度下降函数</p><h2 id="2-7-线性回归的梯度下降"><a href="#2-7-线性回归的梯度下降" class="headerlink" title="2.7 线性回归的梯度下降"></a>2.7 线性回归的梯度下降</h2><p>将梯度下降和代价函数结合，得到线性回归算法，它可以用直线模型来拟合数据，2.2节线性假设和平方差代价函数。将梯度算法应用到最小化平方差代价函数，为了应用梯度下降法，写好<code>repeat until convergence</code>部分代码，关键步骤是那个导数项，弄清楚这个偏导数是什么，写出代价函数J，</p><p>写出<script type="math/tex">\frac{\partial}{\partial\theta_j}J(\theta_0,\theta_1)=\frac{\partial}{\partial\theta_j}\frac{1}{2M}\sum_{i=1}^M[h_\theta(x^{(i)})-y^{(i)}]^2=\frac{\partial}{\partial\theta_j}\frac{1}{2M}\sum_{i=1}^M[\theta_0+\theta_1x^{(i)}-y^{(i)}]^2</script></p><p>将假设的定义带入，在j等于0和J等于1的时候，两种情况的偏导数，简化，在训练集中求和</p><p>一：<script type="math/tex">j=0:\ \frac{\partial}{\partial\theta_0}J(\theta_0,\theta_1)=\frac{1}{M}\sum_{i=1}^M[h_\theta(x^{(i)})-y^{(i)}]</script></p><p>二：<script type="math/tex">j=1:\ \frac{\partial}{\partial\theta_1}J(\theta_0,\theta_1)=\frac{1}{M}\sum_{i=1}^M[h_\theta(x^{(i)})-y^{(i)}]*x^{(i)}</script></p><p>算出微分，即函数J的斜率，现将他们带回梯度下降算法，</p><blockquote><p>repeat until convergence（收敛）{</p><p>​        <script type="math/tex">\theta_0:=\theta_0-\alpha\frac{1}{m}\sum_{i=1}^m[h_\theta(x^{(i)})-y^{(i)}]</script></p><p>​        <script type="math/tex">\theta_1:=\theta_1-\alpha\frac{1}{m}\sum_{i=1}^m[h_\theta(x^{(i)})-y^{(i)}]*x^{(i)}</script></p><p>} 不断重复该过程直到收敛，<script type="math/tex">\theta_0和\theta_1</script>更新为原值减去<script type="math/tex">\alpha</script>乘后面的微分项，这就是线性回归算法。注意一些细节，才能同时更新<script type="math/tex">\theta_0和\theta_1</script>。梯度算法容易陷入局部最优，如图2，但线性回归的代价函数总是一个弓状函数，凸函数，这个函数没有局部最优解，只有一个全局最优解，总会收敛，</p></blockquote><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/MachineLearing/convex_function.PNG" alt="图3" style="zoom:67%;" /></p><p>看假设函数<script type="math/tex">h_{\theta}(x)</script>和代价函数<script type="math/tex">J(\theta_0,\theta_1)</script>，通常在零点初始化，形象解释，初始化<script type="math/tex">\theta_0=900,\theta_1=-0.1,h(x)=-900-0.1x</script>，代价函数往下移（接近最优解），假设函数变化，越来越符合数据，Batch梯度下降，每一步下降，都遍历了整个训练集样本m，有的梯度下降算法，每次只关注小的子集。梯度下降适用于更大的数据集。</p><p>正规方程组法。</p><h2 id="3-1-矩阵和向量"><a href="#3-1-矩阵和向量" class="headerlink" title="3.1 矩阵和向量"></a>3.1 矩阵和向量</h2><p>矩阵，数组，矩阵的项，表示，快速访问</p><p>向量是一种特殊的矩阵，常用1作为开始下标，大写字母表示矩阵，小写表示数字</p><h2 id="3-2-加法和标量乘法"><a href="#3-2-加法和标量乘法" class="headerlink" title="3.2 加法和标量乘法"></a>3.2 加法和标量乘法</h2><p>矩阵加法，矩阵乘法（kA），矩阵除法（<script type="math/tex">A/k=\frac1kA</script>）</p><h2 id="3-3-矩阵向量乘法"><a href="#3-3-矩阵向量乘法" class="headerlink" title="3.3 矩阵向量乘法"></a>3.3 矩阵向量乘法</h2><p>类似于矩阵乘法，不过其中有一个矩阵是行向量或者列向量。</p><script type="math/tex; mode=display">h_\theta(x)=-40+0.25x$$，转化为矩阵的形式：$$\begin{bmatrix}1&2014\\1&1416\\1&1534\\1&852\\\end{bmatrix} * \begin{bmatrix}-40\\0.25\\\end{bmatrix}=\begin{bmatrix}-40*1+0.25*2104\\-40*1+0.25*1416\\-40*1+0.25*1534\\-40*1+0.25*852\\\end{bmatrix}</script><p>转化为左边的式子，可以使代码简洁高效，后面线性回归会用到</p><h2 id="3-4-矩阵乘法"><a href="#3-4-矩阵乘法" class="headerlink" title="3.4 矩阵乘法"></a>3.4 矩阵乘法</h2><p>矩阵乘法是如何解决<script type="math/tex">\theta_0</script>和<script type="math/tex">\theta_1</script>的问题，不需要用到梯度下降算法的迭代。</p><p>矩阵相乘（<script type="math/tex">A*[b_1,b_2]</script>），转化为（<script type="math/tex">[A*b_1,A*b_2]</script>）。</p><p>House sizes:                       Have 3 competing hypotheses:</p><script type="math/tex; mode=display">\begin{cases} 2104\\ 1416\\1534\\852 \end{cases}\quad\quad\quad\quad\quad\quad\quad \left \{  \begin{array}{c} h_\theta(x)=-40+0.25x \\h_\theta(x)=200+0.1x \\h_\theta(x)=-150+0.4x \end{array} \right.</script><p>构造矩阵</p><script type="math/tex; mode=display">\begin{bmatrix}1&2014\\1&1416\\1&1534\\1&852\\\end{bmatrix} * \begin{bmatrix}-40&200&-150\\0.25&0.1&0.4\\\end{bmatrix}=\begin{bmatrix}480&410&692\\314&342&416\\344&353&464\\173&285&191\\\end{bmatrix}</script><p>线性代数库，并行计算</p><h2 id="3-5-矩阵乘法特征"><a href="#3-5-矩阵乘法特征" class="headerlink" title="3.5 矩阵乘法特征"></a>3.5 矩阵乘法特征</h2><p>结合律，单位矩阵，是方阵，对角线元素为1。</p><p>For any matrix A, <script type="math/tex">A_{mn}*I_{nn}=I_{mm}*A_{mn}=A_{mn}</script></p><p>交换律只有当其中有一个矩阵为单位矩阵才满足，且另一个矩阵为方阵。</p><h2 id="3-6-逆和转置"><a href="#3-6-逆和转置" class="headerlink" title="3.6 逆和转置"></a>3.6 逆和转置</h2><p>If A is an m * m matrix, and if it has an inverse, <script type="math/tex">AA^{-1}=A^{-1}A=I</script></p><p>求解逆矩阵的库</p><h2 id="4-1-多功能"><a href="#4-1-多功能" class="headerlink" title="4.1 多功能"></a>4.1 多功能</h2><p>新的线性回归的版本，这种形式适用于多个变量，或者多特征量的情况，比如之前利用只房租面积来预测房价，现在有房租楼层、年龄等信息，多个特征量，<script type="math/tex">h(x)=\theta_0+\theta_1x+.....\theta_nx</script>，多元线性回归</p><h2 id="4-2-多元梯度下降法"><a href="#4-2-多元梯度下降法" class="headerlink" title="4.2 多元梯度下降法"></a>4.2 多元梯度下降法</h2><p>讨论如何设定该假设的参数，如何使用梯度下降算法来处理多元线性回归，</p><p>多元线性回归的假设形式：</p><blockquote><p>Hypothesis: <script type="math/tex">h_\theta(x)=\theta^Tx=\theta_0x_0+\theta_1x_1+\theta_2x_2.....\theta_nx_n</script></p><p>Parameters: <script type="math/tex">\theta_0,\theta_1,...,\theta_n</script></p><p>Cost function: <script type="math/tex">J(\theta_0,\theta_1,...,\theta_n)=\frac{1}{2m}\sum_{i=1}^m[h_\theta(x^{(i)})-y^{(i)}]^2</script></p><p>其中已经按惯例是<script type="math/tex">x_0=1</script>，不将其看作n个独立的参数，而是考虑把这些参数看作一个n+1维的<script type="math/tex">\theta</script>向量</p><p>Gradient descent：（以下面的方式不断更新<script type="math/tex">\theta_j</script>）</p><p>Repeat {</p><p>​        <script type="math/tex">\theta_j:=\theta_j-\alpha\frac{\partial}{\partial\theta_j}J(\theta_0,...,\theta_n)</script></p><p>} (simultaneously update for every j=0,…,n)</p></blockquote><p>将此模型的参数看作一个向量，代价函数通过误差项的平方和来给定，但又不把代价函数看作这n+1个数的函数，使用更通用的方式把J写成参数<script type="math/tex">\theta</script>这个向量的函数，这里<script type="math/tex">\theta</script>是一个向量，</p><blockquote><p>Gradient descent：</p><p>Previously(n=1)：n=1时的梯度下降算法</p><p>Repeat {</p><p>​        <script type="math/tex">\theta_0:=\theta_0-\alpha\underbrace{\frac1m(h_\theta(x^{(i)})-y^{(i)})}_{\frac{\partial}{\partial\theta_0}J(\theta)}</script></p><p>​        <script type="math/tex">\theta_1:=\theta_1-\alpha\frac1m\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x^{(i)}</script></p><p>​        (simultaneously update <script type="math/tex">\theta_0,\theta_1</script>)</p><p>}</p><p>两个独立的更新规则，分别对应参数<script type="math/tex">\theta_0,\theta_1</script>，这是之前的，看现在的</p><p>New algorithm<script type="math/tex">(n\ge1)</script>：</p><p>Repeat {</p><p>​        <script type="math/tex">\theta_j:=\theta_j-\alpha\frac1m\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}</script></p><p>​        (simultaneously update <script type="math/tex">\theta_j</script> for j=0,…,n)</p><p>}</p><p>用于多元函数线性回归的梯度下降算法</p></blockquote><p>相似的，下面，考虑超过两个特征值的情况，因此，有3条更新规则来更新参数<script type="math/tex">\theta_0,\theta_1,\theta_2</script>：</p><blockquote><ul><li><script type="math/tex; mode=display">\theta_0:=\theta_0-\alpha\frac1m\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_0^{(i)}</script></li><li><script type="math/tex; mode=display">\theta_1:=\theta_1-\alpha\frac1m\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_1^{(i)}</script></li><li><script type="math/tex; mode=display">\theta_2:=\theta_2-\alpha\frac1m\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_2^{(i)}</script></li></ul><p>和之前两个参数的梯度算法是等效的</p></blockquote><p>这样就得到了可行的线性回归模型</p><h2 id="4-3-多元梯度下降法演练"><a href="#4-3-多元梯度下降法演练" class="headerlink" title="4.3 多元梯度下降法演练"></a>4.3 多元梯度下降法演练</h2><h3 id="4-3-1-特征缩放"><a href="#4-3-1-特征缩放" class="headerlink" title="4.3.1 特征缩放"></a>4.3.1 特征缩放</h3><p>有个机器学习问题，这个问题有多个特征，</p><blockquote><p>Feature Scaling</p><p>Idea: Make sure features are on a similar scale.（如果能确保这些特征都处在一个相近的范围），这样梯度下降法就能更快地收敛</p><p>E.g. <script type="math/tex">x_1=size(0-2000feet^2)</script></p><p>​       <script type="math/tex">x_2=number\ of\ bedrooms(1-5)</script></p><p>假设有个模型由两个参数，<script type="math/tex">x_1</script>表示房屋面积，<script type="math/tex">x_2</script>表示卧室数量，画出等值线图，是非常高大细长的椭圆形，构成了代价函数<script type="math/tex">J(\theta)</script>的等值线。</p></blockquote><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/MachineLearing/j_func.jpg" style="zoom:67%;" /></p><p>如果在这种代价函数上运行梯度下降的话，最终可能需要花很长一段时间，并且可能会来回波动，然后会经过很长时间，最终才收敛到全局最小值。</p><p>如果这些等值线更夸张一些，椭圆画的更细更长，结果就是梯度下降更缓慢，反复来回震荡，才找到一条通往全局最小值的路。这种情况下，一种有效的方法是进行<strong>特征缩放</strong>。</p><p>具体来说，如果把特征<script type="math/tex">x_1</script>定义为房子的面积大小除以2000，并且把<script type="math/tex">x_2</script>定义为卧室的数量除以5，那么代价函数<script type="math/tex">J(\theta)</script>的等值线，就会变得偏移没那么严重，就会看起来更圆一些了，如果在这样的函数上执行梯度下降的话，就会找到一条更直接的路径，通向全局最小值，而不像上面那样，沿着一条复杂得多的路径。</p><p>因此，通过这些特征缩放，它们的值的范围变得相近，两个特征值都在0和1之间，这样得到的梯度下降算法就会更快地收敛。</p><p>更一般地，执行特征缩放时，将特征的取值约束到-1到+1的范围内，具体来说，特征<script type="math/tex">x_0</script>总是等于1，因此，这已经是在这个范围内（[-1, +1]），但对其他的特征，可能需要通过除以不同的数，来使其处于这个范围内。</p><p>但其实，<script type="math/tex">\pm1</script>不重要，如果特征<script type="math/tex">x_1\in[0,3]</script>，另一个特征<script type="math/tex">x_2\in[-2,0.5]</script>，这些范围其实非常接近<script type="math/tex">[-1,+1]</script>，其实都可以。但如果有个特征<script type="math/tex">x_4\in[-100,+100]</script>，这个范围和<script type="math/tex">[-1,+1]</script>有很大不同了，或者<script type="math/tex">x_4\in[-0.00001,+0.000001]</script>那么这同样是一个和<script type="math/tex">[-1,+1]</script>不同的范围。如何判断数据的不同，其实因人而异，比如以3为界。</p><p>只要范围相差不大，梯度下降算法就可以正常工作。除了将特征值除以最大值以外，在特征值缩放中，有时候也会进行一个称为均值归一化的工作，</p><blockquote><p>Mean normalization</p><p>Replace <script type="math/tex">x_i</script> with <script type="math/tex">x_i-\mu_i</script> to make features have approximately zero mean(Do not apply to <script type="math/tex">x_0=1</script>).</p><p>E.g. <script type="math/tex">x_1=\frac{size-1000}{2000}</script>（1000是2000的平均值）</p><p>​    <script type="math/tex">x_2=\frac{\#bedrooms-2}{5}</script></p><p>​    <script type="math/tex">-0.5\leq x_1\leq0.5,-0.5\leq x_2\leq0.5</script></p></blockquote><p>就是用<script type="math/tex">x_i-\mu_i</script>来替换特征<script type="math/tex">x_i</script>，让特征值具有为0的平均值，不需要将这一步运用到<script type="math/tex">x_0</script>中，因为其始终等于1，不可能有为0的平均值。</p><p>还可以这样代替：<script type="math/tex">x_1\leftarrow \frac{x_1-\mu_1}{s_1}</script>，定义<script type="math/tex">\mu_1</script>是训练集中特征<script type="math/tex">x_1</script>的平均值，<script type="math/tex">s_1</script>是该特征值的范围，这里的范围是指最大值减去最小值，同理其他特征值。</p><p>其实特征缩放并不精确，但能够运行得更快一点而已，迭代次数更少。</p><h3 id="4-3-2-学习率"><a href="#4-3-2-学习率" class="headerlink" title="4.3.2 学习率"></a>4.3.2 学习率</h3><p>将具体讨论学习率<script type="math/tex">\alpha</script>，即梯度算法的更新规则</p><blockquote><p>Gradient descent</p><p>​        <script type="math/tex">\theta_j:=\theta_j-\alpha\frac{\partial}{\partial\theta_j}J(\theta)</script></p><ul><li>“Debugging”: How to make sure gradient descent is workinng correctly.</li><li>How to choose learing rate <script type="math/tex">\alpha</script>.</li></ul></blockquote><p>调试，小技巧来确保梯度下降是正常工作的，并解释如何选择学习率<script type="math/tex">\alpha</script>。</p><p>在梯度下降算法工作时，给出代价函数<script type="math/tex">J(\theta)</script>的值，x轴表示的是梯度下降算法的迭代次数（与之前不同，之前x轴是<script type="math/tex">\theta</script>）。代价函数随迭代步数增加的变化曲线。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/MachineLearing/j_diedai.jpg" style="zoom:67%;" /></p><p>A点的含义：运行100次的梯度下降迭代，无论100步迭代后，得到什么<script type="math/tex">\theta</script>值，在100次迭代后得到某个<script type="math/tex">\theta</script>值，对于这个<script type="math/tex">\theta</script>值，将评估代价函数<script type="math/tex">J(\theta)</script>，A点的垂直高度就代表：梯度下降算法100步迭代之后得到的<script type="math/tex">\theta</script>算出的<script type="math/tex">J(\theta)</script>值。后面同理。</p><p>这条曲线的用处在于，它可以告诉你，在后面迭代次数增加时，看起来<script type="math/tex">J(\theta)</script>并没有下降多少，到达400后，已经很平坦了，梯度下降算法差不多已经收敛了，因为代价函数没有再继续下降了，所以通过这条曲线可以帮助判断，梯度下降算法是否已经收敛。</p><p>不同模型的梯度下降算法收敛时迭代次数可能回想相差很大，有些模型梯度下降算法只需要30步迭代就可以达到收敛，然而换一个问题就需要3000步迭代。实际上我们很难判断一个问题的梯度下降算法需要多少步迭代才能收敛，</p><p>通常通过看这种曲线来判断，梯度下降算法是否已经收敛，也可以进行一些自动的收敛测试，让另一种算法来判断梯度下降算法是否已经收敛，自动收敛测试。</p><p>例：如果代价函数<script type="math/tex">J(\theta)</script>一步迭代后的下降小于一个很小的值<script type="math/tex">\epsilon</script>，这个测试就判断函数已收敛，<script type="math/tex">\epsilon</script>可以是<script type="math/tex">10^{-3}</script>，不过通常要选择一个合适的阈值<script type="math/tex">\epsilon</script>是相当困难的。因此，为了检测梯度下降算法是否收敛，通常还是通过上面的曲线，这种曲线还可以显示出或警告算法没有正常工作。</p><p>如果得到的代价函数随迭代步数增加的变化曲线逐渐上升的曲线，即代价函数随迭代次数增多变得更大（造成这种情况的原因比如，目标函数是二次函数曲线），不趋于稳定，而这样的曲线图通常意味着应该使用较小的学习率<script type="math/tex">\alpha</script>（梯度算法会不断越过最小值，得到代价函数越来越大）。</p><p>已证明，学习率足够小，那么每次迭代后代价函都会下降；但不易过小。</p><p>每隔10倍（3倍）取一个<script type="math/tex">\alpha</script>值，然后对于这些不同的<script type="math/tex">\alpha</script>值，绘制<script type="math/tex">J(\theta)</script>随迭代步数变化的曲线，然后选择使得<script type="math/tex">J(\theta)</script>快速下降的一个<script type="math/tex">\alpha</script>值，如何找到合适的学习率。</p><p>找到一个太小的值，再找到另一个太大的值，然后取最大可能值，或者比最大值略小一些的，比较合理的值。</p><h2 id="4-4-特征和多项式回归"><a href="#4-4-特征和多项式回归" class="headerlink" title="4.4 特征和多项式回归"></a>4.4 特征和多项式回归</h2><p>一些可供选择的特征，以及如何得到不同的学习算法，当选择了合适的特征后，这些算法往往是非常有效的，</p><p>多项式回归，使得能够使用线性回归的方法来拟合非常复杂的函数，甚至是非线性函数，以预测房价为例，</p><p>假设有两个特征，分别是房子临街的宽度（<script type="math/tex">x_1</script>）和垂直宽度（<script type="math/tex">x_2</script>），在用线性回归时，不一定非要用<script type="math/tex">x_1</script>和<script type="math/tex">x_2</script>作为特征，可以创造新的特征，因此，如果要预测房子的价格，会做的是确认真正能够决定房子大小的是拥有的土地的大小。新的特征即临街宽度与纵深的乘积，就是拥有土地的面积，于是将这个乘积作为假设，只用一个特征，就是土地的面积。具体问题取决视情况而定，有时通过定义新的特征，可以得到更好的模型。</p><p>与选择特征的想法，密切相关的一个概念，被称为多项式回归，例如，现有这样一个住房价格的数据集，可能会有多个不同的模拟用于拟合，选择之一是像这样的二次模型，直线似乎并不能很好地拟合这些数据，因此，会想到，用这样的二次模型去拟合，会考虑到价格可能是一个二次函数，得到曲线一样的拟合结果，二次模型合理吗？因为一个二次模型最终会（先上升）降下来，但事实是房价会随着面积增加而下降？因此，也许会选择一个不同的多项式模型，并转而选择使用一个三次函数，用其进行拟合，不会最后下降。那么如何将模型与数据进行拟合呢？</p><p>使用多元线性回归的方法，对算法做一个简单的修改来实现它，按照之前的假设，</p><p>即<script type="math/tex">h_\theta(x)=\theta_0+\theta_1(size)+\theta_2(size)^2+\theta_3(size)^3,x_1=(size),x_2=(size)^2,x_3=(size)^3</script>特征缩放变得重要，因为房子大小在1到1000之间，那么立方就会到<script type="math/tex">10^9</script>，因此这三个特征有很大不同，这样才能将值的范围变得具有可比性，</p><p>除了3次模型不会下降，还有<script type="math/tex">h_\theta(x)=\theta_0+\theta_1(size)+\theta_2\sqrt{(size)}</script>凭借对数据的形状和函数的了解，</p><h2 id="4-5-正规方程（区别于迭代方法的直接解法）"><a href="#4-5-正规方程（区别于迭代方法的直接解法）" class="headerlink" title="4.5 正规方程（区别于迭代方法的直接解法）"></a>4.5 正规方程（区别于迭代方法的直接解法）</h2><p>目前为止，一直使用线性回归方法，梯度下降法，</p><p>Normal equation: Method to solve for <script type="math/tex">\theta</script> analytically.（不用迭代，一次性求解<script type="math/tex">\theta</script>的最优值）</p><p>优缺点及何时使用这个算法</p><blockquote><p>Intuition: if 1D (<script type="math/tex">\theta\in R</script>)</p><p>​    <script type="math/tex">J(\theta)=a\theta^2+b\theta+c</script></p><p>这是个二次函数，怎么求极值，倒数置0，</p><script type="math/tex; mode=display">\theta\in R^{n+1}\quad J(\theta_0,\theta_1,...,\theta_m)=\frac{1}{2m}\sum_{i=1}^m[h_\theta(x^{(i)})-y^{(i)}]^2 \quad \frac{\partial}{\partial\theta_j}J(\theta)=...=0 (for every j)</script><p>Solve for <script type="math/tex">\theta_0,\theta_1,...,\theta_n</script></p><p>这里实际问题中<script type="math/tex">\theta</script>是n+1维向量，代价函数是关于这个向量的函数，那么现在如何最小化这个函数呢？是对向量中每个参数<script type="math/tex">\theta_j</script>对代价函数求偏导，然后把这些偏导数全部置0。</p><p>但是遍历所有偏微分，麻烦，</p></blockquote><p>Example：m=4，4个训练样本，如何使用正规方程方法，假设这4个样本是所有数据，加一列对应额外特征变量的<script type="math/tex">x_0</script>，</p><div class="table-container"><table><thead><tr><th><script type="math/tex">x_0</script></th><th>Size<script type="math/tex">(feet^2) \ x_1</script></th><th>Number of bedrooms <script type="math/tex">x_2</script></th><th>Number of floors <script type="math/tex">x_3</script></th><th>Age of home (years) <script type="math/tex">x_4</script></th><th>Price($1000)</th></tr></thead><tbody><tr><td>1</td><td>2104</td><td>5</td><td>1</td><td>45</td><td>460</td></tr><tr><td>1</td><td>1416</td><td>3</td><td>2</td><td>40</td><td>232</td></tr><tr><td>1</td><td>1534</td><td>3</td><td>2</td><td>30</td><td>315</td></tr><tr><td>1</td><td>852</td><td>2</td><td>1</td><td>36</td><td>178</td></tr></tbody></table></div><p>构建一个矩阵X，<script type="math/tex">X=\begin{bmatrix}1&2014&5&1&45\\1&1416&3&2&40\\1&1534&3&2&30\\1&852&2&1&36\\\end{bmatrix}\quad \quad y=\begin{bmatrix}460\\232\\315\\178 \end{bmatrix}</script></p><p>X是一个<script type="math/tex">m*(n+1)</script>维矩阵，y是一个m维向量，</p><p>使用<script type="math/tex">\theta=(X^TX)^{-1}X^Ty</script>，就能得到使代价函数最小化的<script type="math/tex">\theta</script>。</p><blockquote><p>m examples <script type="math/tex">(x^{(1)},y^{(1)}),...,(x^{(m), y^{m}})</script>; n features.</p><p>所以每个训练样本可能是：<script type="math/tex">x^{i}=\begin{bmatrix}x_0^{(i)}\\x_1^{(i)}\\x_2^{(i)}\\...\\x_n^{(i)} \end{bmatrix}\in R^{n+1}</script></p><p>构建矩阵的方法，设计矩阵，用上面向量的转置作为矩阵X的行</p><p>矩阵X是一个<script type="math/tex">m*(n+1)</script>维矩阵，<script type="math/tex">X=\begin{bmatrix}(x^{(1)})^T\\(x^{(1)})^T\\...\\(x^{(m)})^T\\\end{bmatrix}</script></p></blockquote><p>使用正规方程方法就不需要特征缩放，</p><p>何时应该使用梯度下降法，何时使用正规方程法（优点和缺点）</p><blockquote><p>m <strong>training examples</strong>, n <strong>feature</strong>.</p><p><strong>Gradient Descent</strong></p><ul><li>缺点<ul><li>Need to choose <script type="math/tex">\alpha</script>.</li><li>Needs many iterations.更多的迭代</li></ul></li><li>优点<ul><li>Works well even when n is large.</li></ul></li></ul><p><strong>Normal Equation</strong></p><ul><li>优点<ul><li>No need to choose <script type="math/tex">\alpha</script>.（也不需要检测收敛性）</li><li>Don’t need to iterate.</li></ul></li><li>缺点<ul><li>Need to compute <script type="math/tex">(X^TX)^{-1}</script>，n*n的矩阵，计算量大，<script type="math/tex">O(n^3)</script></li><li>Slow if n is very large</li></ul></li></ul><p>根据习惯，n大于1万，就使用梯度算法，</p></blockquote><h2 id="4-6-正规方程在矩阵不可逆情况下的解决方法"><a href="#4-6-正规方程在矩阵不可逆情况下的解决方法" class="headerlink" title="4.6 正规方程在矩阵不可逆情况下的解决方法"></a>4.6 正规方程在矩阵不可逆情况下的解决方法</h2><blockquote><script type="math/tex; mode=display">\theta=(X^TX)^{-1}X^Ty</script><p>如果<script type="math/tex">X^TX</script>不可逆怎么办？其实这种情况很少发生。</p><p>不可逆的原因：</p><ul><li>包含多余的特征<ul><li>E.g. <script type="math/tex">x_1=size\ in\ feet^2\quad x_2=size\ in\ m^2</script>（两个特征线性相关）</li></ul></li><li>有很多特征（E.g. <script type="math/tex">m\leq m</script>）</li></ul></blockquote><p>伪逆</p><h2 id="5-1-基本操作"><a href="#5-1-基本操作" class="headerlink" title="5.1 基本操作"></a>5.1 基本操作</h2><p>Octave</p><p>控制语句while，if，break</p><h2 id="5-2-移动数据"><a href="#5-2-移动数据" class="headerlink" title="5.2 移动数据"></a>5.2 移动数据</h2><p>将训练集导入程序</p><h2 id="5-3-计算数据"><a href="#5-3-计算数据" class="headerlink" title="5.3 计算数据"></a>5.3 计算数据</h2><p>矩阵间操作</p><h2 id="5-4-数据绘制"><a href="#5-4-数据绘制" class="headerlink" title="5.4 数据绘制"></a>5.4 数据绘制</h2><h2 id="5-5-矢量"><a href="#5-5-矢量" class="headerlink" title="5.5 矢量"></a>5.5 矢量</h2><p>线性代数库</p><blockquote><p>Vectorization example:</p><script type="math/tex; mode=display">h_\theta(x)=\sum_{j=0}^n\theta_jx_j=\theta^Tx</script><p>可以转化为两个向量的内积</p></blockquote><h2 id="6-1-分类"><a href="#6-1-分类" class="headerlink" title="6.1 分类"></a>6.1 分类</h2><p>要预测的变量y是一个离散值，情况下的分类问题，开发一个logistics回归算法，当时最流行最广泛使用的学习算法之一，</p><blockquote><p>例子：Classification</p><p>Email: Spam/Not Spam?</p><p>Online Transactions: Fraudulent(Yes/No)? 网上交易是否欺诈</p><p>Tumor: Malignant/Benign? 肿瘤分类</p><p>都有以下两变量</p><p>​    <script type="math/tex">y\in \{0,1\}</script>    0: “Negative Class”(e.g., benign tumor)负类</p><p>​                          1: “Positive Class”(e.g., malignant tumor)正类</p></blockquote><p>先讨论二分类问题，稍后多分类问题<script type="math/tex">y\in \{0,1,2,3\}</script>，</p><p>如何开发一个分类算法？</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/MachineLearing/classification.jpg" style="zoom:67%;" /></p><p>阈值Threshold classifier output <script type="math/tex">h_\theta(x)\ at\ 0.5</script>:即纵坐标值为0.5</p><ul><li>If <script type="math/tex">h_\theta(x)\ge 0.5</script>, predict “y=1”</li><li>If <script type="math/tex">h_\theta(x)\lt 0.5</script>, predict “y=0”</li></ul><p>线性回归也可以简单分类，但会出现问题，</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/MachineLearing/classification_liner.jpg" style="zoom:67%;" /></p><p>黄线运气好，拟合得很好，对用阈值A也分类很好；但加入P点后，反而效果没那么好了</p><p>Classification: y=0 or 1,    <script type="math/tex">h_\theta(x)\ can\ be\ \gt1\ or \lt 0</script>，预测值远大于1或远小于0，就离谱，</p><p>后面介绍的logistic算法，得到的预测值总会在0到1之间</p><h2 id="6-2-假设陈述"><a href="#6-2-假设陈述" class="headerlink" title="6.2 假设陈述"></a>6.2 假设陈述</h2><p>开始谈logistic回归，函数表达，解释</p><blockquote><p>Logistic Regression Model</p><p>  Want <script type="math/tex">0\le h_\theta(x)\le 1</script></p><script type="math/tex; mode=display">h_\theta(x)=g(\theta^Tx)</script><p>  sigmoid函数或logistic函数<script type="math/tex">g(z)=\frac{1}{1+e^{-z}}</script>，函数图像</p><p>则<script type="math/tex">h_\theta(x)=\frac{1}{1+e^{-\theta^Tx}}</script></p></blockquote><p>解释：假设h(x)的输出，当假设输出某个数字，把这个数字当做对一个输入x，y=1的概率估计，</p><blockquote><p>肿瘤Example: If <script type="math/tex">x=\begin{bmatrix}x_0\\x_1\end{bmatrix}=\begin{bmatrix}1\\tumorSize\end{bmatrix}\quad h_\theta(x)=0.7</script></p><p>将一位病人的tumorSize输入已经建立好的模型，得到输出0.7，</p><p>解释：对于一个特征为x的患者，y=1的概率是0.7，也就是说这个患者70%或者说0.7的可能性是恶性肿瘤，</p><p>公式表达：<script type="math/tex">h_\theta(x)=P(y=1|x;\theta)</script>，即在给定x的条件下y=1的概率。</p></blockquote><p>这是个分类任务，y必须是0或1，</p><p>则<script type="math/tex">P(y=0|x;\theta)+P(y=1|x;\theta)=1\quad P(y=0|x;\theta)=1-P(y=1|x;\theta)</script></p><h2 id="6-3-决策陈述"><a href="#6-3-决策陈述" class="headerlink" title="6.3 决策陈述"></a>6.3 决策陈述</h2><p>决策边界的概念，帮助理解logistic函数，及假设函数在计算什么，</p><p>sigmoid函数，何时会将y预测为1，何时将其预测为0；假设函数的特征，形状，多个特征时。</p><blockquote><p>具体地说，这个假设函数输出的是给定x和参数<script type="math/tex">\theta</script>时，y=1的估计概率；因此如果想要预测y=1还是等于0，可以这样做：（取决于估计概率）</p><p>Suppose predict “y=1” if <script type="math/tex">h_\theta(x)\ge0.5</script>    predict “y=0” if <script type="math/tex">h_\theta(x)\lt0.5</script></p><p>等于0.5的情况预测哪个都行，这里归为1类，</p><p>还有，<script type="math/tex">when\ z\ge0,g(z)\ge0.5</script>，同理，<script type="math/tex">when\ \theta^Tx\ge0,h_\theta(x)=g(\theta^Tx)\ge0.5</script></p></blockquote><p>Decision Boundary     <script type="math/tex">h_\theta(x)=g(\theta_0+\theta_1x_1+\theta_2x_2)</script></p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/MachineLearing/liner.jpg" style="zoom:50%;" /></p><p>如何拟合次模型中的参数？（下一节）现假设已经拟合好了参数，</p><p>假设<script type="math/tex">h_\theta(x)=g(-3+1x_1+1x_2)\quad 向量\theta=[-3,1,1]</script></p><blockquote><p>Predict “y=1” if <script type="math/tex">-3+x_1+x_2\ge0, 也就是x_1+x_2\ge3</script>，对应图像上半区域，同理，小于0对应下半区域，两个区域的边界线称为决策边界，即<script type="math/tex">x_1+x_2=3</script>这条直线，等于0.5的点，</p><p>决策边界是假设函数的一个属性，即使去掉图上的点圈，边界依然存在，决定于其参数，并不是数据集的属性，不需要通过绘制训练集来确定边界，</p></blockquote><p>更复杂的例子：Non-liner decision boundaries（叉代表正样本，圈代表负样本）</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/MachineLearing/non-liner.jpg" style="zoom:50%;" /></p><p>怎么拟合呢？多特征？高阶多项？</p><p>这样<script type="math/tex">h_\theta(x)=g(\theta_0+\theta_1x_1+\theta_2x_2+\theta_3x^2_1+\theta_4x^2_2)</script>添加额外2个特征，现有5个参数，假设向量<script type="math/tex">\theta=[-1,0,0,1,1]</script></p><blockquote><p>Predict “y=1” if <script type="math/tex">-1+x^2_1+x^2_2\ge0</script>，的特征越复杂，决策边界也就越复杂，不仅仅是用直线隔开，</p></blockquote><p>更复杂的边界<script type="math/tex">h_\theta(x)=g(\theta_0+\theta_1x_1+\theta_2x_2+\theta_3x^2_1+\theta_4x^2_2+\theta_5x^2_1x^2_2+\theta_6x^3_1x_2+...)</script></p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/MachineLearing/complex-non-liner.jpg" style="zoom:50%;" /></p><h2 id="6-4-代价函数"><a href="#6-4-代价函数" class="headerlink" title="6.4 代价函数"></a>6.4 代价函数</h2><p>拟合logistics函数，</p><blockquote><p>监督学习中logistic回归模型的拟合问题：</p><p>Training set: {<script type="math/tex">(x^{(1)},y^{(1)}),(x^{(2)},y^{(2)}),...,(x^{(m)},y^{(m)})</script>}</p><p>m examples            <script type="math/tex">x\in\begin{bmatrix}x_0\\x_1\\...\\x_n\end{bmatrix}\quad x_0=1,y\in \{0,1\}\quad h_\theta(x)=\frac{1}{1+e^{-\theta Tx}}</script></p><p>How to choose parameters <script type="math/tex">\theta</script> ?</p></blockquote><p>在之前的代价函数基础上改进</p><blockquote><p>Cost Function: <script type="math/tex">J(\theta)=\frac{1}{m}\sum_{i=1}^m\frac12[h_\theta(x^{(i)})-y^{(i)}]^2</script></p><p>将<script type="math/tex">Cost(h_\theta(x^{(i)}),y^{(i)})=\frac12[h_\theta(x^{(i)})-y^{(i)}]^2</script></p><p>代价函数变为：<script type="math/tex">J(\theta)=\frac{1}{m}\sum_{i=1}^mCost(h_\theta(x^{(i)},y^{(i)}) \quad h_\theta(x)</script>是很复杂的非线性函数，所以会导致代价函数是非凸函数（波浪线），局部最优；</p><p>抹掉(i)，平方定义，会得到凹函数，全局最小值</p><p>Logistic regression cost function: <script type="math/tex">Cost(h_\theta(x,y)=\begin{cases} -log(h_\theta(x))\quad if\ y=1\\ -log(1-h_\theta(x))\quad if\ y=0 \end{cases}</script></p><p>画出图像看，凸优化问题</p></blockquote><h2 id="6-5-简化代价函数与梯度下降"><a href="#6-5-简化代价函数与梯度下降" class="headerlink" title="6.5 简化代价函数与梯度下降"></a>6.5 简化代价函数与梯度下降</h2><p>如何实现一个完整的logistic回归算法</p><blockquote><p>Logistic regression cost function: 分类问题</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{m}\sum_{i=1}^mCost(h_\theta(x^{(i)},y^{(i)}) \quad Cost(h_\theta(x,y)=\begin{cases} -log(h_\theta(x))\quad if\ y=1\\ -log(1-h_\theta(x))\quad if\ y=0 \end{cases}</script><p>Note: <script type="math/tex">y=0\ or\ 1\ always</script>对于分类问题y总是非0即1</p><p>则<script type="math/tex">Cost(h_\theta(x^{(i)},y^{(i)})=-ylog(h_\theta(x))+(1-y)log(1-h_\theta(x))</script>带入原代价函数，极大似然法，统计学</p><p>To fit parameters <script type="math/tex">\theta</script>:    <script type="math/tex">\underbrace{min}_\theta J(\theta)</script></p><p>To make a prediction given new x:     output <script type="math/tex">h_\theta(x)=\frac{1}{1+e^{-\theta Tx}}</script></p></blockquote><p>输出概率，如何最小化这个代价函数，这样才能为训练集拟合出参数<script type="math/tex">\theta</script>，梯度下降</p><blockquote><p>Gradient descent：</p><script type="math/tex; mode=display">J(\theta)=-\frac1m[\sum_{i=1}^my^{(i)}logh_\theta(x^{(i)})+(1-y^{(i)})log(1-h_\theta(x^{(i)}))]</script><p>Want <script type="math/tex">\underbrace{min}_\theta J(\theta)</script></p><p>Repeat {</p><p>​        <script type="math/tex">\theta_j:=\theta_j-\alpha\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}</script></p><p>​        (simultaneously update <script type="math/tex">\theta_j</script>)</p><p>}</p></blockquote><p>logistic回归对比之前的线性回归，<script type="math/tex">h_\theta</script>已发生变化，更新规则相同，但由于假设的定义发生了变化，所以和线性回归的梯度下降是两个完全不同的东西。</p><h2 id="6-6-高级优化"><a href="#6-6-高级优化" class="headerlink" title="6.6 高级优化"></a>6.6 高级优化</h2><p>高级优化算法和高级优化的概念，与梯度算法相比，大大提高logistic回归的速度，更适合解决大型机器学习问题</p><blockquote><p>Optimization algorithm</p><p>Cost function <script type="math/tex">J(\theta)</script>. Want <script type="math/tex">\underbrace{min}_\theta J(\theta)</script></p><p>Given <script type="math/tex">\theta</script>, we have code that can compute（代码计算下面两值）</p><p> —-   <script type="math/tex">J(\theta)</script>   （收敛性）</p><p> —-  <script type="math/tex">\frac{\partial}{\partial\theta_j}J(\theta)\quad (for j=0,1,...,n)</script></p><p>Gradient descent:（带入，更新）</p><p>Repeat {</p><p>​      <script type="math/tex">\theta_j:=\theta_j-\alpha\frac{\partial}{\partial\theta_j}J(\theta)</script></p><p>}</p><p>Optimization algorithms:（更高级的优化算法，需要一种方法来计算<script type="math/tex">J(\theta)</script>和偏导项）</p><ul><li>Gradient descent</li><li>Conjugate gradient</li><li>BFGS（共轭梯度法）</li><li>L-BFGS</li></ul><p>上面的第2,3,4个算法优点和缺点：</p><ul><li>优点<ul><li>不需要手动选择学习率<script type="math/tex">\alpha</script>，给出计算导数项和代价函数的方法，智能内循环（线性搜索算法，自动尝试不同的学习率并自动选择一个好的学习速率，甚至可以为每次迭代选择不同的学习速率）</li><li>收敛得远远快于梯度下降，更复杂的事情，不止于选择一个好的学习率，</li></ul></li><li>缺点<ul><li>比梯度下降复杂得多，超出我们研究的范围，除非数值计算的专家，否则不要实现这种算法，直接用库</li></ul></li></ul></blockquote><p>代码，例子，优化一个二元二次函数，代码写出它的偏导，利用库函数求出最优解</p><h2 id="6-7-多元分类：一对多"><a href="#6-7-多元分类：一对多" class="headerlink" title="6.7 多元分类：一对多"></a>6.7 多元分类：一对多</h2><p>逻辑回归解决多类别分类问题，介绍“一对多”的分类算法</p><blockquote><p>Multiclass classification</p><p>Email foldering/tagging: Work, Friends, Family, Hobby（自动地将邮件归类到不同的文件夹里），所以这是个包含四个分类的问题</p><p>用数字表示，分别用y=1,y=2,y=3,y=4来代表；</p><p>天气分类，病情分类</p><p>其中6.1到6.3节讲过2分类问题；那么多分类问题的数据集是下图这样：</p></blockquote><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/MachineLearing/multi_class_classification.jpg" alt=""></p><p>3种不同的符号代表3个类别；如何针对这种数据集得到一个学习算法来进行分类呢？我们已知可以用逻辑回归解决二分类问题，利用直线将数据集分为正负类，是否可以利用一对多的思想？</p><p>一对多（一对余）分类的原理</p><p>将上图3分类问题，转化为3个独立的二元分类问题；</p><p>以三角形为例，创建新的“伪”训练集，其中类别2类别3设定为负类，类别1设定为正类，创建一个新的数据集，拟合一个分类器，称其为<script type="math/tex">h_\theta^{(1)}(x)</script>，上标1表示类别1，对三角形类别1进行这样的处理，来训练一个标准的逻辑回归分类器；得到一个判定边界；</p><p>同理，以正方体拟合第二个逻辑回归分类器<script type="math/tex">h_\theta^{(2)}(x)</script>；以叉拟合第三个逻辑回归分类器<script type="math/tex">h_\theta^{(3)}(x)</script>；</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/MachineLearing/multi_classification_hx.jpg" alt=""></p><p>拟合出：<script type="math/tex">h_\theta^{(i)}(x)=P(y=i|x;\theta)\quad (i=1,2,3)</script></p><blockquote><p>One-vs-all</p><p>Train a logistic regression classifer <script type="math/tex">h_\theta^{(i)}(x)</script> for each class i to predict the probability that y=i.</p><p>On a new input x, to make a prediction, pick the class i that maximizes <script type="math/tex">\underbrace{max}_i h_\theta^{(i)}(x)</script>，3个分类器运行输入x，然后选择h最大的类别，也就是要选择分类器，选择出3个中，</p></blockquote><p>可信度最高，效果最好的那个分类器，无论i值是多少，都能得到一个最高的概率值，</p><p>预测y就是那个值。</p><h2 id="7-1-过拟合问题"><a href="#7-1-过拟合问题" class="headerlink" title="7.1 过拟合问题"></a>7.1 过拟合问题</h2><p>已经介绍几种不同的学习算法，线性回归和逻辑回归</p><p>解释过拟合，讨论正则化的技术，可改善过拟合问题</p><p>欠拟合：算法具有高偏差；上下波动，过度拟合，具有高方差；如果拟合一个高阶多项式，那么这个假设函数，能拟合几乎所有的数据，这就面临可能的函数太过庞大，变量太多的问题，没有足够的数据来约束它，来获得一个好的假设函数，这就是过渡拟合；</p><p>间于欠拟合和过拟合之间的情况叫：“刚好合适”。</p><p>过度拟合的问题将会在变量过多的时候出现。这时训练出的假设能很好地拟合训练集，代价函数可能非常接近于0，但会得到过拟合的曲线，无法泛化到新的样本中，无法预测新样本的价格；这里“泛化”指的是一个假设模型应用到新样本的能力。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/MachineLearing/liner_regression.jpg" alt=""></p><p>线性回归过拟合的例子；类似的应用到逻辑回归；</p><p>逻辑回归的例子</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/MachineLearing/logistics_regression.jpg" alt=""></p><p>从左到右，加入更多高阶项，逻辑回归变得扭曲，千方百计找出一条曲线拟合数据；</p><p>调试和诊断；导致学习算法出错的问题时，用工具识别过拟合和欠拟合的情况；</p><p>过拟合问题发生时如何解决？当使用一维或二维数据时，可以通过汇出假设模型的图像，来研究问题，再选择合适的多项式阶数，以之前的房屋价格为例，绘制假设模型图像；</p><p>可以看出来绘制的曲线非常扭曲，来选择合适的多项式阶次，绘制假设模型曲线；</p><p>多个特征变量时，绘图变得更难，通过数据的可视化，来决定保留哪些特征变量也更难；</p><p>具体如果要预测房价，可能会有很多特征变量有关，如果有过多变量，而只有很少的训练数据，就会出现过拟合的问题；</p><blockquote><p>为了解决过拟合问题，有两个办法解决，</p><ol><li>尽量减少选取变量的数量，可以人工检查变量清单，并以此决定哪些变量更为重要，哪些特征变量应该保留，哪些应该舍弃；模拟选择算法，这种算法可以自动选择，有效减少过拟合的发生；缺点：舍弃一部分特征变量，也就是舍弃了关于问题的一些信息，</li><li>正则化：保留所有特征变量，但是减少量级，或参数<script type="math/tex">\theta_j</script>的大小；其中每一个变量都能对预测的y值产生一点影响，</li></ol></blockquote><h2 id="7-2-代价函数"><a href="#7-2-代价函数" class="headerlink" title="7.2 代价函数"></a>7.2 代价函数</h2><p>高阶函数（<script type="math/tex">\theta_0+\theta_1x+\theta_2x^2+\theta_3x^3+\theta_4x^4</script>）过拟合，泛化不好，不妨在函数中加入惩罚项，使得参数<script type="math/tex">\theta_3</script>和<script type="math/tex">\theta_4</script>都非常小</p><blockquote><p>优化问题：<script type="math/tex">\underbrace{min}_\theta\frac{1}{2m}\sum_{i=1}^m[h_\theta(x^{(i)})-y^{(i)}]^2</script></p><p>最小化其均方误差代价函数，修改，变为：</p><p>优化问题：<script type="math/tex">\underbrace{min}_\theta\frac{1}{2m}\sum_{i=1}^m[h_\theta(x^{(i)})-y^{(i)}]^2+1000*\theta_3^2+1000*\theta_4^2</script></p><p>1000只是随便一个比较大的数，要使这个函数最可能小，就是<script type="math/tex">\theta_3</script>和<script type="math/tex">\theta_4</script>要尽可能小，因为他们的系数很大，会使得整个函数变得很大，</p><p>尽量使<script type="math/tex">\theta_3</script>和<script type="math/tex">\theta_4</script>尽量接近于0，函数还是相当于2次函数，因为2次函数是一种更好地假设模型，这就是正则化背后的思想，简化假设模型，</p><p>参数值越小，得到函数越平滑，更不易出现过拟合问题，</p><p>例子：100个特征值，并不知道<script type="math/tex">\theta_3,\theta_4</script>是高阶项，就是不知道哪些变量的相关度较低，因此正则化中，就是对代价函数，修改它来缩小所有的参数，因为不知道该修改谁，所以在后面添加新的项，加一个额外的正则化项，来缩小每个参数的值，</p><p>正则化的优化目标：<script type="math/tex">J(\theta)=\frac{1}{2m}[\sum_{i=1}^m[h_\theta(x^{(i)})-y^{(i)}]^2+\lambda\sum_{j=1}^n\theta_j^2]\quad \lambda</script>是正则化参数，作用是控制两个不同目标之间的取舍</p><p>第一个目标与目标函数的第一项有关，更好拟合训练集；第二个目标就是要保持参数尽可能地小，与目标函数第二项有关，与正则化目标有关，与正则化项有关；<script type="math/tex">\lambda</script>控制两个目标间的平衡关系，即更好地去拟合训练集的目标，和将参数控制得更小的目标，从而保持假设模型的相对简单，避免出现过拟合的情况。</p><p>例如100个参数，都想保留去，其中有高阶项，可以利用加入正则项，也可以得到平滑曲线，但这个曲线并不是一个二次函数，</p></blockquote><p>其中<script type="math/tex">\lambda</script>设置过大，就会对参数有太大的惩罚程度，就会降低为一次函数，甚至常函数，就会欠拟合，偏见性太低，偏差过高，合适地选择正则化参数<script type="math/tex">\lambda</script>；后面会有方法自动选择这个参数，</p><h2 id="7-3-线性回归的正则化"><a href="#7-3-线性回归的正则化" class="headerlink" title="7.3 线性回归的正则化"></a>7.3 线性回归的正则化</h2><p>对于线性回归，之前推导了两种算法，一种基于梯度下降，另一种基于正规方程，</p><p>这节将两种算法推广到正则化线性回归中去，</p><p>之前使用梯度下降法，在没有正则化项的情况下，去最小化最初的代价函数，进行常规的线性回归，</p><blockquote><p>Repeat {</p><p>​        <script type="math/tex">\theta_0:=\theta_0-\alpha\frac 1m\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_0^{(i)}</script>，其中<script type="math/tex">\frac 1m\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_0^{(i)}</script>是<script type="math/tex">J(\theta)</script>对<script type="math/tex">\theta_0</script>的偏导数</p><p>​        <script type="math/tex">\theta_j:=\theta_j-\alpha\frac 1m\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}</script>，其中<script type="math/tex">\frac 1m\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}</script>是<script type="math/tex">\frac{\partial}{\partial\theta_j}J(\theta)</script></p><p>}</p><p>正则化项时，没有惩罚<script type="math/tex">\theta_0</script>，正则化线性回归在处理<script type="math/tex">\theta_0</script>的时候，会将它区别对待，用正则化项修改这个算法，将上式修改为</p><script type="math/tex; mode=display">\theta_j:=\theta_j-\alpha[\frac 1m\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}+\frac \lambda m\theta_j]</script><p>就可以对正则化代价函数<script type="math/tex">J(\theta)</script>用梯度下降法进行最小化。</p><p>化简：<script type="math/tex">\theta_j:=\theta_j(1-\alpha\frac \lambda m)-\alpha\frac 1m\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}</script>，通常学习率<script type="math/tex">\alpha</script>很小，但<script type="math/tex">m</script>很大。就是<script type="math/tex">\theta_j:=\theta_j*0.9999...</script>，就是<script type="math/tex">\theta_j</script>的平方范数变小了，</p><p>正则化线性回归时，都是将<script type="math/tex">\theta_j</script>乘以一个非常小的数，把参数缩小一些，然后减去剩余的项，</p></blockquote><p>第二种方法，用正规方程来解决，建立一个设计矩阵X，每一行代表一个单独的训练样本，然后建立一个向量y，m维向量，包含了训练集中所有标签，X是一个<script type="math/tex">m*(n+1)</script>维的矩阵，</p><blockquote><p>最小化代价函数的方法：</p><p>Non-invertibility(optional/advance).</p><p>Suppose   <script type="math/tex">m(\#eamples)\le n(\#features)</script>，样本总数m小于等于特征的数量n</p><p>​     <script type="math/tex">\theta=(X^TX)^{-1}X^Ty</script></p><p>If <script type="math/tex">\lambda\gt0</script>,  <script type="math/tex">\theta=(X^TX+\lambda\begin{bmatrix}0&&&&\\&1&&&\\&&1&&\\&&&...&\\&&&&1\end{bmatrix})^{-1}X^Ty</script></p><p>这个计算出来的<script type="math/tex">\theta</script>，可以使代价函数<script type="math/tex">J(\theta)</script>最小化，此时的代价函数是没有正则化项的，</p><p>现用正则化来得到想要的最小值，将对各个参数的偏导数设为0，然后进行一些数学推导，</p><p>这个矩阵是<script type="math/tex">(n+1)*(n+1)</script>维矩阵，<em>不可逆问题</em>？</p><p>如果样本数量比特征数量少，那么这个X转置乘X的矩阵是不可逆的，奇异矩阵，矩阵退化，伪逆矩阵，模型不好，</p><p>只要<script type="math/tex">\lambda</script>严格大于0，<script type="math/tex">X^TX+[]</script>一定不是奇异矩阵，因此进行正则化可以解决一些X的转置乘X不可逆的问题，</p></blockquote><h2 id="7-4-Logistic回归的正则化"><a href="#7-4-Logistic回归的正则化" class="headerlink" title="7.4 Logistic回归的正则化"></a>7.4 Logistic回归的正则化</h2><h2 id="8-1-非线性假设"><a href="#8-1-非线性假设" class="headerlink" title="8.1 非线性假设"></a>8.1 非线性假设</h2><h2 id="8-2-神经元与大脑"><a href="#8-2-神经元与大脑" class="headerlink" title="8.2 神经元与大脑"></a>8.2 神经元与大脑</h2><h2 id="8-3-模型展示Ι"><a href="#8-3-模型展示Ι" class="headerlink" title="8.3 模型展示Ι"></a>8.3 模型展示Ι</h2><h2 id="8-4-模型展示Ⅱ"><a href="#8-4-模型展示Ⅱ" class="headerlink" title="8.4 模型展示Ⅱ"></a>8.4 模型展示Ⅱ</h2><h2 id="8-5-例子与直觉理解Ι"><a href="#8-5-例子与直觉理解Ι" class="headerlink" title="8.5 例子与直觉理解Ι"></a>8.5 例子与直觉理解Ι</h2><h2 id="8-6-例子与直觉理解Ⅱ"><a href="#8-6-例子与直觉理解Ⅱ" class="headerlink" title="8.6 例子与直觉理解Ⅱ"></a>8.6 例子与直觉理解Ⅱ</h2><h2 id="8-7-多元分类"><a href="#8-7-多元分类" class="headerlink" title="8.7 多元分类"></a>8.7 多元分类</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Introduction to Machine Learning&lt;/p&gt;
    
    </summary>
    
    
      <category term="Machine-Learing" scheme="https://mysticalguest.github.io/categories/Machine-Learing/"/>
    
    
      <category term="算法" scheme="https://mysticalguest.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>常用</title>
    <link href="https://mysticalguest.github.io/GitHub/6eb7acd3.html"/>
    <id>https://mysticalguest.github.io/GitHub/6eb7acd3.html</id>
    <published>2021-08-12T00:00:00.000Z</published>
    <updated>2021-09-15T05:15:51.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用Mathjax语法"><a href="#常用Mathjax语法" class="headerlink" title="常用Mathjax语法"></a>常用Mathjax语法</h1><a id="more"></a><div class="table-container"><table><thead><tr><th>显示</th><th>命令</th><th>显示</th><th>命令</th></tr></thead><tbody><tr><td>小于（<script type="math/tex">\lt</script>）</td><td>\lt</td><td>大于（<script type="math/tex">\gt</script>）</td><td>\gt</td></tr><tr><td>小于等于（<script type="math/tex">\le</script>）</td><td>\le</td><td>大于等于（<script type="math/tex">\ge</script>）</td><td>\ge</td></tr><tr><td>不等于（<script type="math/tex">\ne</script>）</td><td>\ne</td><td><script type="math/tex">\sim</script></td><td>\sim</td></tr><tr><td>加减（<script type="math/tex">\pm</script>）</td><td>\pm</td><td></td><td></td></tr><tr><td><script type="math/tex">\alpha</script></td><td>\alpha</td><td></td><td></td></tr><tr><td>右箭头（<script type="math/tex">\to,\rightarrow</script>）</td><td>\to, \rightrrow</td><td>左箭头（<script type="math/tex">\leftarrow</script>）</td><td>\leftarrow</td></tr></tbody></table></div><p>括号、方程组</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span><span class="variable">$out</span>...\begin&#123;cases&#125;</span><br><span class="line">...\\</span><br><span class="line">...\\</span><br><span class="line">...\\</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line"><span class="variable">$</span><span class="variable">$</span></span><br></pre></td></tr></table></figure><p>显示为</p><script type="math/tex; mode=display">out...\begin{cases}...\\...\\...\\\end{cases}</script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常用Mathjax语法&quot;&gt;&lt;a href=&quot;#常用Mathjax语法&quot; class=&quot;headerlink&quot; title=&quot;常用Mathjax语法&quot;&gt;&lt;/a&gt;常用Mathjax语法&lt;/h1&gt;
    
    </summary>
    
    
      <category term="GitHub" scheme="https://mysticalguest.github.io/categories/GitHub/"/>
    
    
      <category term="基类" scheme="https://mysticalguest.github.io/tags/%E5%9F%BA%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>人机交互</title>
    <link href="https://mysticalguest.github.io/Study/1adb816b.html"/>
    <id>https://mysticalguest.github.io/Study/1adb816b.html</id>
    <published>2021-06-16T08:31:37.294Z</published>
    <updated>2021-06-18T15:37:45.952Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人机交互课程复习</p></blockquote><a id="more"></a><h2 id="一、交互设计简介"><a href="#一、交互设计简介" class="headerlink" title="一、交互设计简介"></a>一、交互设计简介</h2><p>可用的交互设计必须考虑一个产品被使用的上下文。</p><p>”用户做什么“的信息来源于：（决定了为什么需要技术，及技术需要支持什么）</p><script type="math/tex; mode=display">产品的使用上下文3个方面\begin{cases}用户\\用户的任务\\交互发生的环境\\\end{cases}</script><script type="math/tex; mode=display">交互设计包括4项活动\begin{Bmatrix}标识需要并建立需求\\开发满足需求的候选设计方案\\构建设计的交互式设计原型\\评估设计\\\end{Bmatrix}这些活动间通常具有联系，且具有联系且本身是迭代过程</script><p>目标：期望一个活动或过程执行后达到的状态。</p><p>可用性指易于使用，令人满意；满足什么目标取决于上下文。</p><h3 id="1-1-交互设计的目标分为两类"><a href="#1-1-交互设计的目标分为两类" class="headerlink" title="1.1 交互设计的目标分为两类"></a>1.1 交互设计的目标分为两类</h3><script type="math/tex; mode=display">设计的产品在交互方面应满足的性质\begin{Bmatrix}可用性目标\\（6种可用性）\begin{cases}有效使用\\高效使用\\安全使用\\良好的实用性\\易于学习\\易于记忆如何使用\\\end{cases}\\用户体验目标\begin{cases}满足\\舒适\\有趣\\刺激\\\end{cases}\\\end{Bmatrix}可用性目标和用户体验目标的区别</script><script type="math/tex; mode=display">Norman提出的6个基本设计原理\begin{cases}可视性\\反馈\\（3种）限制\begin{cases}物理限制\\逻辑限制\\文化限制\\\end{cases}\\映射\\（2种）一致性\begin{cases}内部一致性\\外部一致性\\\end{cases}\\启发性\\\end{cases}</script><script type="math/tex; mode=display">交互过程的3个关键特征\begin{cases}以用户为中心：将用户包含在制品的设计和评估之中\\专用的可用性准则：定义可量化、可度量的可用性准则\\迭代：迭代不可避免\\\end{cases}</script><p>交互式系统的定义：为了支持人类用户的任务执行，而从他们那里接受输入，并将输出表示给他们的软件和硬件构件的集合。</p><h2 id="二、理解与概念化交互"><a href="#二、理解与概念化交互" class="headerlink" title="二、理解与概念化交互"></a>二、理解与概念化交互</h2><h3 id="2-1-什么是原型？"><a href="#2-1-什么是原型？" class="headerlink" title="2.1 什么是原型？"></a>2.1 什么是原型？</h3><ul><li>对产品概念的形象化和具体化，是设计师构思的体现。</li><li>不是产品，是产品的一种近似或受限表示。</li><li>作用：用户可以通过与之交互来探索其使用，可用性。</li></ul><h3 id="2-2-概念模型"><a href="#2-2-概念模型" class="headerlink" title="2.2 概念模型"></a>2.2 概念模型</h3><p>概念模型：即所感兴趣的事物的概念以及它们之间关系的描述。在HCI中，概念模型通常用于描述用户界面应做什么。</p><script type="math/tex; mode=display">2类概念模型\begin{Bmatrix}活动模型\stackrel{4种人机交互方式}{\longrightarrow} \begin{cases}指令型：用户指示系统做某事\\会话型：用户与系统的实时信息交换\\操作型：用户直接操作虚指空间中的对象\\探索型：用户穿越虚指空间\stackrel{2个相关概念}{\longrightarrow}\begin{cases}导航\\浏览\\\end{cases}\\\end{cases} \\对象模型\\\end{Bmatrix}如何选择概念模型</script><script type="math/tex; mode=display">界面隐喻\stackrel{2个概念}{\longrightarrow}\begin{cases}隐喻：是一种短语，他通过陈述另一件事来描述一件事\\类比\\\end{cases}</script><script type="math/tex; mode=display">7种交互泛型\begin{cases}无处不在的计算\\普适计算\\可穿戴计算\\实物用户界面\\增强现实\stackrel{AR系统的3个特征}{\longrightarrow}\begin{cases}真实对象和虚拟对象在真实环境中的结合\\交互并实时的运行\\真实对象和虚拟对象相互之间准确重合（对位）\\\end{cases}\\上下文感知计算\\计算机支持的协同工作\\\end{cases}</script><h2 id="三、理解用户"><a href="#三、理解用户" class="headerlink" title="三、理解用户"></a>三、理解用户</h2><script type="math/tex; mode=display">什么是认知\begin{cases}2种认知模式\begin{cases}经验式认知\\思考式认知\\\end{cases}\\5种认知过程\begin{cases}注意\\感知\\记忆和识别\begin{cases}记忆的结构模型\\2种长期记忆中的信息探索\begin{cases}回忆\\识别\\\end{cases}\\短时记忆的7\pm2理论\\\end{cases}\\读、听、说\\推理、决策、规划、问题求解\end{cases}\\\\\end{cases}</script><h2 id="四、协作与通信的设计"><a href="#四、协作与通信的设计" class="headerlink" title="四、协作与通信的设计"></a>四、协作与通信的设计</h2><p>通信是个体间的交换过程。</p><script type="math/tex; mode=display">3种协作和通信中的社会机制\begin{cases}会话机制\stackrel{2类会话}{\longrightarrow}\begin{cases}正式会话：有组织结构的会议\\非正式会话：无结构的free-talking\\\end{cases}\\协调机制\stackrel{3种机制}{\longrightarrow}\begin{cases}语言和非语言的通信\\时间表、规定和约定\\共享外部表示：\\外部表示可以为成员提供各种协调他们活动的信息\\\end{cases}\\感知机制：感官训练，对感知范围内的环境状态的理解\\\end{cases}</script><script type="math/tex; mode=display">3类以计算机为介质的通信（CMC）\begin{cases}同步通信\\异步通信\\与其他活动相结合的CMC\\\end{cases}</script><p>认知的本质是<strong>分布的</strong>，认知现象<strong>不仅包括个人头脑中所发生的认知活动</strong>，还涉及<strong>人与人之间</strong>，以及<strong>人与技术工具</strong>之间通过<strong>交互实现某一活动</strong>的过程。<strong>通信交流</strong>是分布式认知的必备条件。</p><h2 id="五、理解界面对用户的影响"><a href="#五、理解界面对用户的影响" class="headerlink" title="五、理解界面对用户的影响"></a>五、理解界面对用户的影响</h2><h2 id="六、交互设计过程"><a href="#六、交互设计过程" class="headerlink" title="六、交互设计过程"></a>六、交互设计过程</h2><script type="math/tex; mode=display">设计的两个定义\begin{cases}为某一特定的目的或效果而在头脑中想象和计划\\画出一幅画或图案，以显示某物是如何制作的\\\end{cases}</script><script type="math/tex; mode=display">交互设计的4项基本活动\begin{cases}识别用户需要并建立需求\stackrel{4类参与者}{\longrightarrow}\begin{cases}\begin{Bmatrix}主要方\\第二方\\第三方\\\end{Bmatrix}甲方\\\begin{Bmatrix}提供方\end{Bmatrix}乙方\end{cases}\\设计候选方案\begin{cases}2种产品特征\\（需要选择的产品特征\\可概括为两类）\begin{cases}内部特征：\\对用户通常是不可见或不可度量的属性\\外部特征：\\对用户而言，可见及可度量的属性\\\end{cases}\\可用性规约由7项组成\\（设计决策的依据）\begin{cases}属性\\度量概念\\度量方法\\当前水平\\计划水平\\最坏情况\\最好情况\\画出一幅画或图案，以显示某物是如何制作的\\\end{cases}\\\end{cases}\\建立设计的交互式版本\\评估设计\\\end{cases}</script><script type="math/tex; mode=display">交互设计过程中的3个关键特征\begin{cases}以用户为中心的设计\\可用性目标和度量准则\\迭代\\\end{cases}</script><script type="math/tex; mode=display">生命周期模型\begin{cases}交互设计的4项活动之间的输入/输出及时序关系\\软工中的3种生命周期模型\begin{cases}瀑布模型\\螺旋模型\\RAD模型\end{cases}\\HCI中的2种生命周期模型\begin{cases}面向评估的星形生命周期模型\\可用性生命周期模型\\\end{cases}\\\end{cases}</script><p>交互设计模型是对其他过程模型在可用性目标上的补充。</p><h2 id="七、识别需求并建立需求"><a href="#七、识别需求并建立需求" class="headerlink" title="七、识别需求并建立需求"></a>七、识别需求并建立需求</h2><p>5种方法的适用情形、信息类型和优缺点，如何选择。</p><script type="math/tex; mode=display">5种类型的需求\begin{cases}功能需求\\数据\\环境\begin{cases}物理环境\\社会\\组织\\技术\\\end{cases}\\用户\\可用性\\\end{cases}</script><script type="math/tex; mode=display">5种数据收集技术\begin{cases}问卷调查\\访谈\\专题组和研讨会\\自然观察\\研究文档\\\end{cases}</script><script type="math/tex; mode=display">3种任务描述（提供面向任务的解释）\begin{Bmatrix}情节：一种非线性的叙事性描述\\用例：对情节进行抽象\\基本用例：在一个抽象层次上指定用户和系统的交互\\\end{Bmatrix}任务描述的方法的总结结论</script><h2 id="八、设计原型建立与构造"><a href="#八、设计原型建立与构造" class="headerlink" title="八、设计原型建立与构造"></a>八、设计原型建立与构造</h2><script type="math/tex; mode=display">建立和构造原型\begin{cases}2类原型\begin{cases}低保真原型：用简单的方式来快速、近似地表示产品的概念\\高保真原型：构建的原型更接近于最终产品\\\end{cases}\\2种基于原型的开发方法\begin{cases}丢弃式：旨在获得最终产品的需求/设计，原型被丢弃\\演化式：产品从很有限的版本逐步演化为最终发行版本\\\end{cases}\\\end{cases}</script><p>选择何种类型的原型，取决于使用它们的目的，按原型表达产品的真实程度。</p><script type="math/tex; mode=display">设计活动包括2个方面\begin{cases}开发概念模型\stackrel{3个方面}{\longrightarrow}\begin{cases}交互方式（对用户的活动提供支持）\begin{cases}基于活动的模式\\基于对象的模式\\\end{cases}\\隐喻：使用户易于理解产品的使用\\交互泛型：为具体化概念模型提供指导\\\end{cases}\\物理设计模型...\\\end{cases}</script><h2 id="九、以用户为中心的交互设计"><a href="#九、以用户为中心的交互设计" class="headerlink" title="九、以用户为中心的交互设计"></a>九、以用户为中心的交互设计</h2><script type="math/tex; mode=display">以用户为中心的设计方法的主要原理\begin{cases}交互设计的3个关键特征\\以研究用户及其任务为基础的5项具体原理\\\end{cases}</script><ul><li>开发以用户任务和目标来驱动</li><li>系统需要对用户的行为和使用上下文提供支持</li><li>捕捉用户的特征并将其应用于设计</li><li>在整个开发过程中咨询用户，并认真考虑他们的意见</li><li>应在使用的上下文中做出所有的决策设计</li></ul><script type="math/tex; mode=display">2种用于理解用户工作的现场研究方法\begin{cases}一致性方法\\上下文设计------上下文质询（询问）\\\end{cases}</script><p>将人种学研究应用于实地调查的方法。</p><p>调查采用一种用户访谈形式：上下文访谈；</p><ul><li>“师徒模式”，其中用户是专家，而设计者是学徒；</li><li>设计者观察用户的工作，提问并作记录。</li></ul><p>旨在从用户实际工作的情况下收集数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;人机交互课程复习&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Study" scheme="https://mysticalguest.github.io/categories/Study/"/>
    
    
      <category term="计算机基础" scheme="https://mysticalguest.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>毕业设计</title>
    <link href="https://mysticalguest.github.io/Study/4e025b73.html"/>
    <id>https://mysticalguest.github.io/Study/4e025b73.html</id>
    <published>2021-05-09T09:08:31.974Z</published>
    <updated>2021-05-20T02:55:19.181Z</updated>
    
    <content type="html"><![CDATA[<p>毕设相关</p><a id="more"></a><h2 id="Netty介绍和应用场景"><a href="#Netty介绍和应用场景" class="headerlink" title="Netty介绍和应用场景"></a>Netty介绍和应用场景</h2><h3 id="入门介绍"><a href="#入门介绍" class="headerlink" title="入门介绍"></a>入门介绍</h3><p>Netty编程涉及技术有：Java多线程编程、Java IO编程、Java网络编程、常用的Java设计模式（例如观察者模式、命令模式、职责模式）、常用的数据结构（例如链表）</p><ul><li>Netty是由 JBOSS提供的一个<strong>Java开源框架</strong>，现为 Github上的独立项目。</li><li>Netty是一个<strong>异步的</strong>、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络IO程序。</li><li>Netty主要针对在TCP协议下，面向Clients端的高并发应用，或者P2P场景下的大量数据持续传输的应用。</li><li>Netty本质是一个NIO框架，适用于服务器通讯相关的多种应用场景。</li><li>层次关系：TCP/IP —&gt; 原生的JDK，Java IO编程和网络编程 —&gt; NIO —&gt; Netty</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>互联网行业：分布式系统，节点远程服务调用，高性能的RFC框架将Netty作为基础通信组件。RPC（Remote Procedure Call）远程过程调用，简单的理解是一个节点请求另一个节点提供的服务。阿里的分布式服务框架Dubbo协议默认使用Netty框架。</li><li>游戏行业：手机端游和网络游戏，Netty提供TCP/UDP和HTTP协议栈，方便定制和开发私有协议栈，账号登录等。</li><li>大数据领域：经典的Hadoop的高性能通信和序列化组件Avro的RFC框架，默认采用Netty进行跨界点通信，其Netty Service基于Netty框架二次封装。</li><li>使用到Netty的<a href="https://netty.io/wiki/related-projects.html">开源框架</a>。</li></ul><h2 id="Java-BIO编程"><a href="#Java-BIO编程" class="headerlink" title="Java BIO编程"></a>Java BIO编程</h2><h3 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h3><ul><li>I/O模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能。</li><li>Java共支持3种网络编程模型I/O模式：BIO、NIO、AIO。</li><li>Java BIO：同步并阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要<em>启动一个线程进行处理</em>，如果这个连接不做任何事情会造成不必要的线程开销。<ul><li>模式：服务器<em>每建立一个</em>与客户端的<em>连接</em>，就要<em>开启一个</em>单独的<em>线程</em>负责与这个客户端的读写操作。</li></ul></li><li>Java NIO：同步非阻塞，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的连接请求都会注册到多路复用器（Selector）上，多路复用器轮询到连接有I/O请求就进行处理。<ul><li>模式：服务器开启多个线程，每个线程对应一个Selector，每个Selector连接多个客户端。</li></ul></li><li>Java AIO（NIO.2）：异步非阻塞，AIO引入异步通道的概念，釆用了Proactor模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</li></ul><h2 id="粒度控制"><a href="#粒度控制" class="headerlink" title="粒度控制"></a>粒度控制</h2><p>粒度上通常称为粗粒度和细粒度，粒度控制主要指的是在<strong>系统设计</strong>的过程中<strong>如何根据需求去控制设计的范围</strong>。粒度的把握是软件设计的关键。</p><p>例如，软件市场上有许多不同软件可以实现相同的功能，但在各自粒度的控制上或者说达到的程度上都是不同的，其在性能、伸缩性以及友好性都有所不同，用户会根据自己的喜好，适用等原因选择自己喜欢的那款软件。</p><p>开发人员就是提供客户需要的东西，客户当然希望用最少的钱得到最适用的软件，但作为开发者，当然希望利润越高越好，这就需要减少开发成本，缩短进度。卖方和买方本来就是一对矛盾体，可以说双方为了共同的利益需要寻找到一个平衡点，这就是软件的粒度控制，也许这个名词不好理解，也可以叫做范围控制，在进行系统设计时，同样也是如此。要做到的是控制在满足需求以及将来变化的范围内的粒度的系统设计是最完美的。做技术的往往在很多时候更偏向追求技术的完美、先进等等，但客户并不会关心那么的多，这个时候需要通过控制粒度来决定是否需要采用复杂具有难度的技术，技术的先进必然就带来了技术的难度、风险。</p><p>所以对于“开发基于粒度控制的FTP代理”的理解就是，根据自己对于FTP代理的理解和研究深度，进行开发即可。</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>eclipse下查找某个接口、类的源码的快捷键：<code>ctrl + shift + t</code> </p><p>eclipse查看某接口、类的所有子类：<code>ctrl + t</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;毕设相关&lt;/p&gt;
    
    </summary>
    
    
      <category term="Study" scheme="https://mysticalguest.github.io/categories/Study/"/>
    
    
      <category term="课程" scheme="https://mysticalguest.github.io/tags/%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>笔试和面经</title>
    <link href="https://mysticalguest.github.io/Interview/48d83c99.html"/>
    <id>https://mysticalguest.github.io/Interview/48d83c99.html</id>
    <published>2021-04-20T00:00:00.000Z</published>
    <updated>2021-10-27T03:17:19.688Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>面试Java研发实习生所做的知识准备，及以后的积累</p></blockquote><a id="more"></a><h2 id="面试MindCoord过程"><a href="#面试MindCoord过程" class="headerlink" title="面试MindCoord过程"></a>面试MindCoord过程</h2><p>邮件通知时间也挺准（2021/4/20 – 15:10-15:25, UTC+8），我大概15:08进腾讯会议的，里面只有我一个人。到了10分钟会进来一个小姐姐，确认身份后，会问你对公司的了解，也没有自我介绍。说完自己的了解后，她会以很快且口齿清楚的方式快速介绍MindCoord公司的一些情况。介绍完就开始问问题了，题量和时间都是有限的，如果思考一会儿还是回答不出，就会跳过。下面是我印象中所有问题（不分先后）：</p><h3 id="技术类问题"><a href="#技术类问题" class="headerlink" title="技术类问题"></a>技术类问题</h3><ul><li>进程和线程</li><li>什么是Java深拷贝和浅拷贝</li><li>Java基本数据类型，枚举（穷举？），除了基本类型，其他叫什么类型（引用类型）</li><li>编程遇到的错误类型，除0是什么错误类型（RuntimeException）</li><li>Java四种引用类型</li><li>finally的用法，fianl的用法</li><li>创建多线程的方法（这里问的就是线程创建的方法！！我就只以为是单线程！！）</li><li>Spring的设计模式</li><li>静态方法能不能调用非静态方法，并说明（不能！！我以为能）</li><li>数据库的范式（），并详细说一下第一范式</li><li>什么是索引，为什么有索引，优点及缺点</li></ul><h3 id="非技术类问题"><a href="#非技术类问题" class="headerlink" title="非技术类问题"></a>非技术类问题</h3><ul><li>平时娱乐去哪些场所，消费如何</li><li>工作中不喜欢和什么样的人合作</li><li>对于工作中任务较多，压力较大，怎么看的</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>面试都是Java基础，MindCoord是美国的一个创业公司，国内信息很少，我也是从官网上收集的信息。</p><blockquote><p>MindCoord Inc. 是一家成立于美国波士顿的新科技企业,拥有自由、开放、包容、多元的全球化团队,囊括了来自世界各地的智慧人才。公司致力于为所有人提供更简单的虚拟空间创作方案,业务涵盖VR、AR、XR等虚拟成像领域,旗下拥有3D动画快速制作短视频APP——PortalHiker、HereFounder等软件产品和机器宠物等硬件产品。我们欢迎想挑战全新领域的科技人才一同加入,在未知的道路上尽情探索,享受发明创造的乐趣。</p><p><strong>产品</strong></p><ul><li>3D广告：我们通过桌面软件PortalHiker为AR内容制作解决方案提供帮助，该软件可以帮助企业产生可在其网站和移动应用程序上使用的交互式AR体验。</li><li>PortalHiker是3D和AR内容制作应用程序，既是内容创建引擎又是3D / AR内容社交媒体。作为在移动设备上生成3D内容的最简单方法，PortalHiker允许用户通过将虚拟元素与现实世界相结合来创建和共享他们的创造力。</li><li>在各个平台的视频游戏中插入无干扰的品牌广告，为游戏开发人员提供了通过其游戏获利的可能性。</li></ul><p>使用增强现实技术来训练患有帕金森氏病的患者再次行走。</p><p><strong>技术</strong></p><ul><li>捕捉运动：以人为中心的计算机视觉的基础是机器看到和理解人的运动的能力。3D / AR体验或虚拟实时流的形式制作动画内容。将易用性和性能作为重中之重的原因。</li><li>3D内容编辑器：生成3D和AR内容。</li><li>3D检视器：我们基于网络的3D查看器可在网站上高质量显示3D内容。</li></ul></blockquote><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><ul><li>每日一个Java学习视频</li><li>每日刷题，力扣，牛客等</li></ul><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><ul><li><p>自动类型提升</p><p>结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>/<span class="keyword">char</span>/<span class="keyword">short</span>--&gt;<span class="keyword">int</span>--&gt;<span class="keyword">long</span>--&gt;<span class="keyword">float</span>--&gt;<span class="keyword">double</span></span><br></pre></td></tr></table></figure><p>特别的：当<code>byte、char、short</code>三种类型的变量做运算时，结果为int型。String特殊</p></li></ul><h3 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h3><ul><li>强引用（StrongReference）<ul><li>强引用可以直接访问目标对象。</li><li>强引用所指向的对象在任何时候都不会被系统回收。JVM宁愿抛出OOM异常，也不会回收强引用所指向的对象。</li><li>可能导致内存泄露？</li></ul></li><li>软引用（SoftReference）<ul><li>一个持有软引用的对象不会被JVM很快回收，JVM会根据当前堆的使用情况来判断何时回收。当堆使用率临近阈值时，才会回收软引用的对象。因此，软引用可以用于实现对内存敏感的高速缓存。</li></ul></li><li>弱引用（WeakReference）<ul><li>在系统GC时，只要<strong>发现弱引用</strong>，不管系统堆空间是否足够，都会将对象<strong>进行回收</strong>。</li></ul></li><li>虚引用（PhantomReference）<ul><li>一个持有虚引用的对象，和没有引用几乎是一样的，<strong>随时可能被垃圾回收器回收</strong>。当试图通过虚引用的get()方法取得强引用时，总是会失败。并且，虚引用必须和引用队列一起使用，它的作用在于跟踪垃圾回收过程。</li></ul></li></ul><h3 id="Java-GC"><a href="#Java-GC" class="headerlink" title="Java GC"></a>Java GC</h3><ul><li>介绍<ul><li>Java在JVM虚拟机上增加了垃圾回收（GC）机制，用以在合适的时间触发垃圾回收，将不需要的内存空间回收释放，避免无限制的内存增长导致的OOM。</li></ul></li><li>如何判断一个对象需要被回收<ul><li>引用计数<ul><li>Java在GC时会看这个对象是否与其他引用有关联，如果存在引用关系则表示这个对象还有用，不能被回收，如果不存在引用关系则可基本定性为可被回收的对象。优点：效率高；缺点：无法解决循环引用的问题。</li></ul></li><li>可达性分析<ul><li>为了解决循环引用的问题，Java采用了可达性分析的方式，主要是通过Roots对象作为起点进行搜索，搜索的路径被称为“引用链”，当一个对象到Roots没有任何引用链相连的时，证明此对象不可用，当然被判定为不可达的对象不一定就会成为可回收对象。被判定为不可达的对象要成为可回收对象必须至少经历<strong>两次标记</strong>过程，如果在这两次标记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就会成为可回收对象。能够被回收其实主要看finalize()方法有没有与引用链上的对象关联，如果在finalize()方法中有关联则自救成功，该对象不可被回收，反之如果没有关联则成功被二次标记，就可以称为要被回收的垃圾了。</li></ul></li><li>Roots对象<ul><li>虚拟机栈中引用的对象？</li><li>方法区中类静态属性引用的对象？</li><li>本地方法栈引用的对象？</li></ul></li><li>4种引用类型</li></ul></li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li><p><code>sleep</code>方法与<code>wait</code>方法的区别</p><ul><li><p>wait：此方法来自于Object类，必须由<strong>锁对象</strong>进行调用（不是任意对象调用）</p><p>注意：</p><ul><li>锁对象需要在哪里存在？锁对象必须在同步中出现。</li><li>同步方法的锁对象默认就是字节码对象。</li></ul></li><li><p>sleep：此方法来自于Thread类，是Thread类的静态方法，可以类名加点调用</p></li><li><p>wait方法：</p><ul><li>空参数：会让线程进入无限等待状态，进入了无限等待状态后，必须由（其他线程的）notify方法对其进行唤醒。</li><li>有参数：效果和sleep类似</li></ul></li><li><p>区别：wait方法在等待的过程中，释放锁对象；sleep方法在休眠的过程中不会释放锁对象。</p></li></ul></li></ul><ul><li><p><code>ConcurrentHashMap</code>与<code>HashMap</code>底层数据结构</p><ul><li><code>JDK1.7</code>中HashMap由<strong>数组</strong>+<strong>链表</strong>组成，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。</li><li><code>JDK1.8</code>中HashMap由<strong>数组</strong>+<strong>链表/红黑树</strong>组成，当链表长度大于<strong>阈值</strong>（默认为8）时，将链表转化为红黑树，以减少搜索时间。转为红黑树后，链表的结构仍然会存在，通过next属性维持，红黑树节点在进行操作时都会维护链表的结构。</li><li>原理<ul><li>如何实现扩容：初始容量16和加载因子0.75。每次扩容都为原来的两倍。当达到其容量的3/4时，会自动进行扩容，如初始为16，存储第12个元素时，这时候会扩容为32，同时，这时需要创建一张新表，将原表的数据移到新表，可以看<code>resize()</code>和<code>transfer()</code>方法。表？<code>Entry[] newTable = new Entry[newCapacity];</code></li><li>如何实现存取：HashMap存取时，都需要<strong>计算</strong>当前key应该对应Entry[]数组哪个元素，通过调用<code>hash()</code>方法，得到<strong>hash值</strong>，再调用<code>indexFor()</code>得到Entry[]数组<strong>下标</strong>。如果有两个相同的结果，如果<strong>hash相同且key对象为同一个</strong>，则为同一个对象，直接在该位置替换原对象；否则为不同对象，这时候发生<strong>碰撞</strong>了，我们通过链表来存储，可以分析<code>createEntry()</code>方法。</li></ul></li><li><code>JDK1.7</code>中ConcurrentHashMap由<strong>分段数组</strong>+<strong>链表</strong>组成。ConcurrentHashMap是由<em>Segment数据结构</em>和<em>HashEntry数据结构</em>组成。</li><li><code>JDK1.8</code>中ConcurrentHashMap<em>取消了Segment分段锁</em>，采用CAS算法和<em>synchronized</em>来保证并发安全。数据结构跟HashMap1.8的结构类似， 是<strong>数组</strong>+<strong>链表/红黑树</strong>。（jdk1.6以后对synchronized锁做了很多优化，比如偏向锁、轻量级锁、自旋锁、锁消除、锁粗化等）</li><li>如何实现同步：<ul><li>HashEntry用于存储键值对数据，HashEntry内部类里的value ，以及链表next都是<code>volatile</code>修饰的，能保证获取时的可见性。</li><li><strong>Segment数组</strong>中的每个元素包含一个<strong>HashEntry数组</strong>，HashEntry数组中的每个元素是一个链表结构的元素。Segment数组的每个元素各守护着一个HashEntry数组中的素有元素。当对HashEntry数组的数据进行修改时，必须首先获得对应的Segment数组元素的锁。</li><li><code>JDK1.7</code>时实现线程安全的方式：首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问，提高并发访问率。</li><li><code>JDK1.8</code>时实现线程安全的方式：synchronized只锁定当前链表或者红黑树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</li></ul></li></ul></li><li><p>volatile和synchronized区别</p><ul><li>线程安全性包括两个方面：可见性，原子性。</li><li>volatile轻量级，只能<strong>修饰变量</strong>；只保证数据的<strong>可见性</strong>，不能用来同步，多个线程并发访问volatile修饰的变量<strong>不会阻塞</strong>。</li><li>synchronized重量级，可以修饰类、方法、代码段；保证可见性和原子性，多个线程争取synchronized锁对象时，会出现阻塞。</li></ul></li></ul><p>多线程访问这个方法（类方法）就存在线程不安全的问题</p><p>指令重排</p><p>11没看</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="六大范式（Normal-form）"><a href="#六大范式（Normal-form）" class="headerlink" title="六大范式（Normal form）"></a>六大范式（Normal form）</h3><p>关系数据库中的关系是满足一定要求的，满足不同程度要求的称为<em>不同的范式</em>。满足最低要求的称为<em>第一范式</em>，简称<strong>1NF</strong>；在第一范式的基础上满足进一步要求的称为第二范式，简称2NF，其余范式以此类推。一般来说，数据库只需满足第三范式就行了。</p><p>对于各范式之间有如下关系：<script type="math/tex">1NF\supset2NF\supset3NF\supset BCNF\supset4NF\supset5NF</script></p><ul><li><p>第一范式</p><ul><li><p>定义：属于第一范式关系的所有属性都不可再分，即数据项不可分。</p></li><li><p>理解：1NF强调数据表的原子性，是其他范式的基础</p></li><li><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|  商品  |</span><br><span class="line">|名称|数量|</span><br></pre></td></tr></table></figure><p>上表将<em>商品</em>这一数据项又划分为<em>名称</em>和<em>数量</em>两个数据项，不符合1NF。应改为如下表所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|商品名称|商品数量|</span><br></pre></td></tr></table></figure><p>但日常生活中仅用第一范式来规范表格是远远不够的，依然会存在数据冗余过大、删除异常、插入异常、修改异常的问题，此时就需要引入<em>规范化</em>概念，将其转化为更标准化的表格，减少数据依赖。</p></li><li><p>规范化：一个低一级的<em>关系模式</em>通过模式分解可以转化为若干个高一级范式的关系模式的集合，这个过程叫做规范化。</p></li></ul></li><li><p>第二范式</p><ul><li><p>候选码：若关系中的某一<em>属性组</em>的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码。若一个关系中有<em>多个候选码</em>，则选定其中一个为<em>主码</em>。</p></li><li><p>主属性：所有候选码的属性称为主属性。不包含在任何候选码中的属性称为<em>非主属性</em>或<em>非码属性</em>。</p></li><li><p>函数依赖：设R(U)是属性集U上的关系模式，X、Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称Y函数依赖于X或X函数确定Y。</p><script type="math/tex; mode=display">X\rightarrow Y \ \ Y函数依赖于X</script></li><li><p>完全函数依赖： 设R(U)是属性集U上的关系模式，X、Y是U的子集。如果Y函数依赖于X，且对于X的任何一个真子集X’，都有Y不函数依赖于X’，则称Y对X完全函数依赖。记作：如果Y函数依赖于X，但Y不完全函数依赖于X，则称Y对X部分函数依赖。</p><script type="math/tex; mode=display">X\stackrel{F}{\longrightarrow} Y \quad\quad\quad\quad Y对X完全函数依赖</script><script type="math/tex; mode=display">X\stackrel{P}{\longrightarrow} Y \quad\quad\quad\quad Y对X部分函数依赖</script></li><li><p>定义：若某关系R属于第一范式，且每一个非主属性<strong>完全函数依赖于</strong>任何一个<em>候选码</em>，则关系R属于第二范式。</p></li><li><p>理解：第二范式是指每个表必须有一个（有且仅有一个）数据项作为主键（primary key），其他数据项与关键字或者主键一一对应，即其他数据项完全依赖于关键字或主键。由此可知单主属性的关系均属于第二范式。</p></li></ul></li><li><p>第三范式</p><ul><li>定义：非主属性既不<strong>传递依赖于</strong>码，也不<strong>部分依赖于</strong>码。</li><li>传递函数依赖的概念：在<script type="math/tex">R(U)</script>中，若<script type="math/tex">X\rightarrow Y,Y\nrightarrow X,Y\rightarrow Z</script>，Z不属于Y，则称Z对X传递函数依赖。记作<script type="math/tex">X \stackrel{传递}{\longrightarrow}Z</script> 。</li><li>理解：第三范式要求在满足第二范式的基础上，<em>任何非主属性**</em>不依赖于<em>*其他非主属性，即在第二范式的基础上，</em>消除了传递依赖*。</li></ul></li><li><p>BC范式（巴斯-科德范式）</p><ul><li>定义：关系模式<script type="math/tex">R(U,F)</script>中，若每一个决定因素都包含码，则<script type="math/tex">R(U,F)</script>属于BCFN。</li><li>理解：根据定义我们可以得到结论，一个满足BC范式的关系模式有<ul><li>所有非主属性对每一个码都是完全函数依赖</li><li>所有主属性对每一个不包含它的码也是完全函数依赖</li><li>没有任何属性完全函数依赖于非码的任何一组属性</li></ul></li><li>举例：有关系模式C(Cno, Cname, Pcno)，Cno, Cname, Pcno依次表示课程号、课程名、先修课。可知关系C只有一个码Cno，且没有任何属性对Cno部分函数依赖或传递函数依赖，所以关系C属于第三范式，同时Cno是C中的唯一决定因素，所以C也属于BC范式。</li></ul></li><li><p>第四范式</p><ul><li>定义：限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。</li><li>理解：显然一个关系模式是4NF，则必为BCNF。也就是说，当一个表中的非主属性互相独立时（3NF），这些非主属性不应该有多值，若有多值就违反了4NF。</li></ul></li><li><p>第五范式（完美范式）</p><ul><li>第五范式有以下要求：<ul><li>必须满足第四范式</li><li>表必须可以分解为较小的表，除非那些表在逻辑上拥有与原始表相同的主键。</li></ul></li><li>第五范式是在第四范式的基础上做的进一步规范化。第四范式处理的是相互独立的多值情况，而第五范式则处理相互依赖的多值情况。</li></ul></li></ul><h3 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h3><p><strong>关系模式是对关系的描述</strong>，或者说二维表的表头，设有关系R，属性A1、A2、A3，则表示为<script type="math/tex">R(A1,A2,A3)</script>，关系数据库中的关系模式是型，关系的值。</p><ul><li><p>什么是关系？</p><p>关系实质上是<em>一张二维表</em>，并满足以下条件：</p><ul><li>列不可分性（1NF）</li><li>行列无序性（交换列的前后顺序不影响关系模型的语义表达）</li><li>实体完整性（唯一）</li></ul></li><li><p>属性：二维表中的每一列称为属性</p></li><li><p>值域（域）：属性的取值范围</p></li><li><p>元组（记录）：二维表中的一行数据。</p></li><li><p>关系模式可用五元组表示</p><p><script type="math/tex">R(U,D,Dom,F)</script>，其中R：表示关系名，U：表示属性集合，D为U中属性对应域的集合（数据域？），Dom：表示属性域，F：表示函数依赖。</p></li><li><p>关系模型完整性约束</p><ul><li>实体完整性</li><li>参照完整性</li><li>用户自定义完整性</li></ul></li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul><li><p>定义：索引是定义在数据库表基础之上，有助于<em>无需检查所有记录</em>而<em>快速定位</em>所需记录的一种辅助存储结构，由一系列存储在磁盘上的索引项组成，每一种索引项由<em>索引字段</em>和<em>行指针</em>构成。</p></li><li><p>优点：</p><ul><li>提高查询效率</li><li>通过创建唯一索引，可以保证数据库中每一行数据的<em>唯一性</em></li><li>在使用分组和排序子句进行数据检索时，可以减少查询中<em>分组和排序</em>的时间</li></ul></li><li><p>缺点：</p><ul><li>创建索引和维护索引<em>耗费时间</em>，且时间随数据量增大而增大</li><li><em>占用物理内存</em>，如果建立聚簇索引，所需空间更大</li><li>在对表中的数据进行增删改时需要耗费较多的时间，因为索引也要<em>动态地维护</em></li></ul></li><li><p>概念：</p><ul><li>聚簇索引：将数据存储与索引<em>放到一块</em>，找到索引也就找到了数据，主文件按照对应字段排序存储，索引文件无重复排序存储。</li><li>非聚簇索引：将数据存储于索引分开存储，索引结构的叶子节点指向了数据的对应行，主文件并没有按照对应字段排序存储，索引文件有重复排序存储。</li></ul></li><li><p><em>索引用于快速找出在某个列中有一特定值的行。不使用索引，MySQL必须从第1条记录开始然后读完整个表直到找出相关的行，还需要考虑每次读入数据页的IO开销。</em></p><p><em>大多数情况下都（默认）采用B树来构建索引。只是空间列类型的索引使用R-树，并且MEMORY表还支持hash索引。B树是平衡多叉树，每个节点存放多少个值取决于值所占的空间，这与每一张数据页存放多少条记录与记录信息量有关同理。节点中的值是以非降序进行排列的，节点中的值总是小于等于指向它的结点中的值。</em></p><p><em>MySQL使用B树构造索引的情况下，是由叶子指向具体的页和记录的。并且一个叶子有一个指针指向下一个叶子。</em></p></li><li><p>使用索引时需要注意：</p><ul><li>只对<code>WHERE</code>和<code>ORDER BY</code>需要查询的字段设置索引，避免无意义的硬盘开销</li><li>组合索引支持<em>前缀索引</em></li><li>更新表的时候，如增删记录，MySQL会自动更新索引，保持树的平衡；因此更多的索引意味着<strong>更多的维护成本</strong></li></ul></li><li><p>索引分四类：</p><ul><li>index：普通的索引，数据可以重复</li><li>fulltext：全文索引，用来对大表的文本域(char，varchar，text)进行索引。语法和普通索引一样</li><li>unique：唯一索引，唯一索引，要求所有记录都唯一</li><li>primary key：主键索引，也就是在唯一索引的基础上相应的列必须为主键</li></ul></li></ul><h3 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h3><ul><li>为什么要使用联合索引？<ul><li>减少开销：建立一个组合索引<code>(A,B,C)</code>，实际相当于建立了<code>(A),(A,B),(A,B,C)</code>三个索引。<em>每多一个索引，都会增加写操作的开销和磁盘空间的开销</em>。但对于大量数据的表，使用组合索引会大大减小开销！</li><li>覆盖索引：如果有查询操作，可以直接通过遍历索引取数据，无需查询表，这会减少随机IO操作。减少随机操作是DBA主要优化策略。</li><li>效率高：多条件筛选数据。</li></ul></li><li>使用方法：<ul><li>最左原则（<em>带头大哥不能死，中间兄弟不能断</em>）：从前往后依次使用生效，如果中间某个索引没有使用，那么断点前面的索引部分起作用，断点后面的索引<em>没有起作用</em>。上面的组合索引可以支持<code>(A),(A,B),(A,B,C)</code>三种组合进行查找。两个或更多个列上的索引被称作复合索引。</li></ul></li></ul><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><ul><li><p>悲观锁</p><p>总是<strong>假设最坏的情况</strong>，每次<em>当前线程</em>去拿数据的时候都认为<em>其他线程</em>会修改，所以每次在拿数据的时候<strong>都会上锁</strong>，这样<em>其他线程</em>想拿这个数据就会阻塞直到<em>其他线程</em>拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<code>synchronized</code>和<code>ReentrantLock</code>等<em>独占锁</em>就是悲观锁思想的实现。</p></li><li><p>乐观锁</p><p>总是<strong>假设最好的情况</strong>，每次<em>当前线程</em>去拿数据的时候都认为<em>其他线程</em>不会修改，所以<strong>不会上锁</strong>，但是在更新的时候会判断一下在此期间<em>其他线程</em>有没有去更新这个数据，可以使用<em>版本号机制</em>和<em>CAS算法</em>实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于<em>write_condition机制</em>，其实都是提供的乐观锁。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式<em>CAS</em>实现的。</p></li><li><p>两种锁的使用场景</p><p>两种锁<strong>各有优缺点</strong>，不可认为一种好于另一种，乐观锁适用于<strong>写比较少</strong>的情况下（<strong>多读少写场景</strong>），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个<strong>吞吐量</strong>。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的<em>进行retry</em>，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适（<strong>多写场景</strong>）。</p></li><li><p>乐观锁常见的两种实现方式</p><ul><li><p>版本号机制</p><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值<strong>相等时</strong>才更新，否则重试更新操作，直到更新成功。</p></li><li><p>CAS算法（compare and swap，比较与交换）</p><p>有名的<strong>无锁算法</strong>。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。<strong>CAS算法</strong>涉及到三个操作数</p><ul><li>需要读写的变量值 V</li><li>进行比较的值 A</li><li>拟写入的新值 B</li></ul><p>当且仅当 V 的值等于A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个<strong>自旋操作</strong>，即<strong>不断的重试</strong>。</p></li></ul></li><li><p>乐观锁的缺点</p><ul><li><p><strong>ABA问题</strong>：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。</p><p><code>JDK 1.5</code>以后的<code>AtomicStampedReference</code>类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p></li><li><p><strong>循环时间长开销大</strong>：<strong>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销</strong>。<em>如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</em></p></li><li><p><strong>只能保证一个共享变量的原子操作</strong>：CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference</code>类把多个共享变量合并成一个共享变量来操作。</p></li></ul></li></ul><h3 id="数据库事务特性（Transaction）"><a href="#数据库事务特性（Transaction）" class="headerlink" title="数据库事务特性（Transaction）"></a>数据库事务特性（Transaction）</h3><ul><li><p>事务</p><ul><li>定义：所谓事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。</li><li>四个特点ACID：<ul><li>原子性Atomicity</li><li>一致性Consistency</li><li>隔离性Isolation</li><li>耐久性Durability</li></ul></li></ul></li><li><p>原子性</p><ul><li><p>定义：原子性是指事务是一个<em>不可再分割</em>的工作单位，事务中的操作要么都发生，要么都不发生。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/MySQL/atomicity.jpg" style="zoom:60%;" /></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">begin transaction</span><br><span class="line">  select ... from ...;</span><br><span class="line">  ...;</span><br><span class="line">  update account set ... where ...;</span><br><span class="line">  if Error then</span><br><span class="line">    rollback</span><br><span class="line">  else</span><br><span class="line">    commit</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>分析：在事务中的增删改查语句，要么都执行，要么就都不执行。</p></li><li><p>解决方法：在DBMS中，默认情况下一条SQL就是一个单独事务，事务是自动提交的。只有显式地使用<code>start transaction</code>开启一个事务，才能将一个代码块放在事务中执行。保障事务的原子性是DBMS的责任，为此许多数据源采用日志机制。<em>例如，SQL Server使用一个预写事务日志，在将数据提交到实际数据页面前，先写在事务日志上。</em></p></li></ul><ul><li><p>一致性</p><ul><li><p>定义：一致性是指在事务开始之前和事务结束以后，数据库的<strong>完整性约束没有被破坏</strong>。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。</p></li><li><p>解决方法：保障事务的一致性，可以从以下两个层面入手</p><ul><li><p>数据库机制层面</p><p>在一个事务执行之前和之后，数据会符合你设置的约束（唯一约束，外键约束，Check约束等）和触发器设置。这一点是由<code>SQL SERVER</code>进行保证的。比如<em>转账</em>，则可以使用CHECK约束两个账户之和等于2000来达到一致性目的。</p></li><li><p>业务层面</p><p>对于业务层面来说，一致性是保持业务的一致性。这个业务一致性需要由<em>开发人员进行保证</em>。当然，很多业务方面的一致性，也可以通过转移到数据库机制层面进行保证。</p></li></ul></li></ul></li><li><p>隔离性</p><ul><li><p>定义：多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。（Java多线程锁对象）</p></li><li><p>分析：这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它<em>之前的状态</em>，要么是另一事务修改它<em>之后的状态</em>，事务不会查看到<em>中间状态</em>的数据。</p><p>当多个事务并发时，SQL Server利用<strong>加锁和阻塞</strong>来保证事务之间不同等级的隔离性。一般情况下，完全的隔离性是不现实的，完全的隔离性要求数据库同一时间只执行一条事务，这样会严重<em>影响性能</em>。想要理解SQL Server中对于隔离性的保障，首先要了解并发事务之间是如何干扰的。</p></li><li><p>事务之间的互相影响：<strong>脏读</strong>，<strong>不可重复读</strong>，<strong>幻读</strong>，<strong>丢失更新</strong>。</p></li><li><p>脏读：一个事务读取了另一个事务<strong>未提交的数据</strong>，而这个数据是有可能回滚的。</p></li><li><p>不可重复读：在数据库访问中，一个事务范围内两个<strong>相同的查询却返回了不同数据</strong>。这是由于查询时系统中其他事务修改的提交而引起的。</p></li><li><p>幻读（虚读）：当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种<strong>修改</strong>涉及到表中的<strong>全部数据行</strong>。同时，第二个事务也修改这个表中的数据，这种修改是向表中<strong>插入</strong>一行<strong>新数据</strong>。那么，以后就会发生操作第一个事务的用户发现表中还有<strong>没有修改的数据行</strong>，就好象发生了幻觉一样。</p></li><li><p>丢失更新：两个事务同时读取同一条记录，A先修改记录，B也修改记录（B是不知道A修改过），B提交数据后B的修改结果<strong>覆盖了</strong>A的<strong>修改结果</strong>。</p></li><li><p>理解SQL SERVER中的隔离级别</p><p>数据库的事务隔离级别（TRANSACTION ISOLATION LEVEL）是一个数据库上很基本的一个概念。为什么会有事务隔离级别，SQL Server上实现了哪些事务隔离级别？事务隔离级别的前提是一个多用户、多进程、多线程的并发系统，在这个系统中为了保证数据的一致性和完整性，我们引入了事务隔离级别这个概念，对一个单用户、单线程的应用来说则不存在这个问题。</p><p>为了避免上述几种事务之间的影响，SQL Server通过设置不同的隔离级别来进行不同程度的避免。因为高的隔离等级意味着更多的锁，从而牺牲性能。所以这个选项开放给了用户根据具体的需求进行设置。不过默认的隔离级别Read Commited符合了多数的实际需求。</p><p>SQL Server隔离事务之间的影响是通过锁来实现的，通过阻塞来阻止上述影响。不同的隔离级别是通过加不同的锁，造成阻塞来实现的，所以会以付出性能作为代价；安全级别越高，处理效率越低；安全级别越低，效率高。</p><p>使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET TRANSACTIONISOLATION LEVEL REPEATABLE READ</span><br></pre></td></tr></table></figure></li></ul></li></ul><div class="table-container"><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th>丢失更新</th><th>并发模型</th><th>更新冲突检测</th><th>内容</th></tr></thead><tbody><tr><td>未提交读：Read Uncommited</td><td>是</td><td>是</td><td>是</td><td>是</td><td>悲观</td><td>否</td><td>在读数据时不会检查或使用任何锁。因此，在这种隔离级别中可能读取到没有提交的数据</td></tr><tr><td>已提交读：Read commited</td><td>否</td><td>是</td><td>是</td><td>是</td><td>悲观</td><td>否</td><td>只读取提交的数据并等待其他事务释放排他锁。读数据的共享锁在读操作完成后立即释放。已提交读是SQL Server的默认隔离级别</td></tr><tr><td>可重复读：Repeatable Read</td><td>否</td><td>否</td><td>是</td><td>否</td><td>悲观</td><td>否</td><td>像已提交读级别那样读数据，但会保持共享锁直到事务结束</td></tr><tr><td>可串行读：Serializable</td><td>否</td><td>否</td><td>否</td><td>否</td><td>悲观</td><td>否</td><td>工作方式类似于可重复读。但它不仅会锁定受影响的数据，还会锁定这个范围。这就阻止了新数据插入查询所涉及的范围</td></tr></tbody></table></div><ul><li><p>持久性</p><ul><li>定义：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。即使出现了任何事故比如断电等，事务一旦提交，则持久化保存在数据库中。</li><li><code>SQL SERVER</code>通过<code>write-ahead transaction log</code>来保证持久性。<code>write-ahead transaction log</code>的意思是，事务中对数据库的改变在写入到数据库之前，首先写入到事务日志中。而事务日志是按照顺序排号的（LSN）。当数据库崩溃或者服务器断点时，重启动<code>SQL SERVER</code>，<code>SQL SERVER</code>首先会<strong>检查日志顺序号</strong>，将本应对数据库做更改而<strong>未做的部分持久化到数据库</strong>，从而保证了持久性。</li></ul></li><li><p>总结：</p><p>事务的（ACID）特性是由关系数据库管理系统（RDBMS，数据库系统）来实现的。数据库管理系统采用日志来保证事务的原子性、一致性和持久性。日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。</p><p>　　数据库管理系统采用锁机制来实现事务的隔离性。当多个事务同时更新数据库中相同的数据时，只允许持有锁的事务能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。</p></li></ul><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul><li>TCP和UDP的区别</li></ul><div class="table-container"><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>可靠性</td><td>可靠</td><td>不可靠</td></tr><tr><td>思想</td><td>面向字节流</td><td>面向报文</td></tr><tr><td>拥塞控制</td><td>慢启动、快速恢复、拥塞避免</td><td>不提供拥塞控制</td></tr><tr><td>双工性</td><td>全双工</td><td>一对一、多对一、一对多、多对多</td></tr><tr><td>效率</td><td>传输效率低</td><td>传输效率高</td></tr><tr><td>应用场景</td><td>准确率要求高，效率要求低</td><td>效率要求高，准确率要求低</td></tr></tbody></table></div><ul><li><p>HTTPS握手过程</p><ul><li><p>HTTPS简介</p><ul><li><p>HTTP：直接通过明文在浏览器和服务器之间传递信息</p></li><li><p>HTTPS：<code>Hypertext Transfer Protocol Secure</code>，超文本传输安全协议。采用<strong>对称加密</strong>和<strong>非对称加密</strong>结合的方式来保护浏览器和服务端之间的通信安全。</p><p><em>对称加密算法加密数据+非对称加密算法交换密钥+数字证书验证身份=安全</em></p></li><li><p>HTTP是运行在TCP层之上的，而HTTPS则是在HTTP和TCP层之间多加了一个SSL/TSL层，SSL层向上提供加密和解密的服务，对 HTTP来说是透明的。</p></li><li><p>Secure Socket Layer，安全套接字层。TLS（Transport Layer Security）安全网络传输协议。HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p></li></ul></li><li><p>对称加密与非对称加密</p><ul><li>定义：加密和解密都使用<em>同一种算法</em>的加密方法，称之为对称加密。加密和解密使用<em>不同的算法</em>，则为非对称加密。</li><li>分析：对称加密需要一把钥匙就够了。非对称加密算法需要两把钥匙，公钥和私钥，它们是一对。用公钥加密的密文只能用相应的私钥解开，用私钥加密的密文只能用相应的公钥解开。其中，公钥是公开的，私钥是不对外公开的。</li><li>对比：两者的主要区别在于密钥的<em>长度不同</em>，长度越长，相应的加/解密花费的时间就会更长，对称加密使用的密钥长度会短一些。SSL结合了这两种加密算法的优点，利用非对称加密算法来协商<em>生成对称加密的密钥</em>，然后之后就用<em>对称加密来进行通信</em>。</li></ul></li><li><p>握手过程（关于HTTP的三次握手，其实就是使用三次TCP握手确认建立一个HTTP连接）</p><ol><li>客户端提交HTTPS请求</li><li>服务器响应客户，并把<em>服务器公钥</em>发送给客户端</li><li>客户端<em>验证公钥</em>的有效性</li><li>客户端验证有效后，会生成一个<em>会话密钥</em>（一个随机数）</li><li>客户端用<em>服务器公钥</em>加密这个<em>会话密钥</em>后，发送给服务器</li><li>服务器收到<em>公钥加密</em>的密钥后，用<em>私钥解密</em>，获取<em>会话密钥</em></li><li>客户端与服务器利用<em>会话密钥</em>对传输数据进行对称加密通信</li></ol><p>下图为<strong>HTTPS加密请求（一次握手）过程</strong></p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/computernetwork/https_handshake.png" style="zoom:80%;" /></p></li><li><p>CA证书</p><p>CA（Certificate Authority）是负责管理和签发证书的第三方权威机构，是所有行业和公众都信任的、认可的。</p><p>CA证书，就是CA颁发的证书，可用于验证网站是否可信（针对HTTPS）、验证某文件是否可信（是否被篡改）等，也可以用一个证书来证明另一个证书是真实可信，最顶级的证书称为根证书。除了根证书（自己证明自己是可靠），其它证书都要依靠上一级的证书，来证明自己。</p></li><li><p>HTTPS和HTTP的区别</p><ul><li>HTTPS协议需要到CA申请证书或自制<em>证书</em>。</li><li>HTTP的信息是明文传输，HTTPS则是具有安全性的SSL<em>加密</em>。</li><li>HTTP是直接与TCP进行数据传输，而HTTPS是经过一层SSL（OSI表示层），用的<em>端口</em>也不一样，前者是80（需要国内备案），后者是443。</li><li>HTTP的连接很简单，是<em>无状态</em>的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。</li></ul></li><li><p>注意</p><ul><li>HTTPS报文在被包装成TCP报文的时候完成加密的过程，无论是HTTPS的<code>header</code>域也好，<code>body</code>域也罢都是会被加密的。</li><li>当使用<code>tcpdump</code>或者<code>wireshark</code>之类的TCP层工具抓包，获取是加密的内容，而如果用应用层抓包，使用<code>Charels(Mac)</code>、<code>Fildder(Windows)</code>抓包工具，那当然看到是明文的。</li></ul></li><li><p>HTTPS一般使用的加密与HASH算法如下：</p><ul><li>非对称加密算法：RSA，DSA/DSS</li><li>对称加密算法：AES，RC4，3DES</li><li>HASH算法：MD5，SHA1，SHA256</li></ul></li></ul></li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>在应用这个模式时，单例对象的类必须保证只有一个实例存在，整个系统只能使用一个对象实例。</p><p>优点：不会频繁地创建和销毁对象，浪费系统资源。</p><p>使用场景：IO 、数据库连接、Redis 连接等。</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式又叫静态工厂方法模式，就是建立一个工厂类，<strong>对实现了同一接口的一些类进行实例的创建</strong>，不需要管它内部的具体实现，只要告诉它需求即可得到对应想要的产品实例。</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂模式是在简单工厂的基础上<strong>将未来可能需要修改的代码抽象出来</strong>，通过继承的方式让<strong>子类去做</strong>决定。抽象工厂里只声明方法，具体的实现交给子类（子工厂）去实现，这个时候再有新增品类的需求，只需要新创建代码即可。</p><p>软件设计的“开闭原则”？</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式是定义对象间的一对多依赖关系，使得每当一个<strong>对象状态发生改变</strong>时，其相关<strong>依赖对象皆得到通知</strong>并被自动<strong>更新</strong>。</p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>装饰器模式是指<strong>动态地给一个对象增加</strong>一些额外的功能，同时又<strong>不改变其结构</strong>。</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器模式是将一个类的接口<strong>变成客户端所期望的另一种接口</strong>，从而使原本因接口不匹配而无法一起工作的两个类能够<strong>在一起工作</strong>。</p><h3 id="Spring中都使用的设计模式"><a href="#Spring中都使用的设计模式" class="headerlink" title="Spring中都使用的设计模式"></a>Spring中都使用的设计模式</h3><ul><li>代理模式：在AOP中使用</li><li>单例模式：bean默认是单例模式</li><li>模板方法模式：JDBCTemplate</li><li>工厂模式：BeanFactory</li><li>观察者模式：Spring事件驱动模型就是观察者模式很经典的一个应用</li><li>适配器模式：SpringMVC中用到适配器模式适配Controller</li></ul><h2 id="中邮消费金融有限公司"><a href="#中邮消费金融有限公司" class="headerlink" title="中邮消费金融有限公司"></a>中邮消费金融有限公司</h2><h3 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h3><p>中邮在5月8号发了笔试的邀请，点击网址直接做题，应该是自动用邮箱登录的，现在回忆起来笔试大概分4部分，单选，多选，填空，问答，给了90分钟，但我用了不到30分钟就做完了。题目涉及Java基础，多线程，问答有问线程池？最后一个问答好像是从足够多的日志中拿n条日志，如何快速和低内存拿到？我也是随便想到就答了。</p><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p>12号打电话通知，13号发邮件，14号早上9:30手机多面APP，两人面试我一个。</p><ul><li>3分钟自我介绍，我就介绍了基本情况，花了不到30秒感觉</li><li>做过Springboot，那你说说负责什么模块，用到了什么技术，事务处理机制，Springboot IOC？</li><li>好像Springboot也不会，来说说Java基础，线程创建方法，聊聊线程池，线程安全</li><li>List和LinkedList区别，Map和List区别，Map排序？</li></ul><h2 id="TCL"><a href="#TCL" class="headerlink" title="TCL"></a>TCL</h2><p>40分钟54道Java选择题。基础题，暴露问题基础薄弱。</p><p>标识符：就是给类、接口、方法、变量、常量等起名字时使用的字符序列。</p><p>0.6333属于float还是double。</p><p>数组是对象吗。</p><p>线程，Thread的方法getPriority()，stop()?有这些方法吗？</p><p>权限修饰符，接口可以用什么修饰符？抽象类、方法，abstract可以修饰哪些？</p><p>对称加密算法，非对称加密算法。</p><h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><ul><li><p>查看日志文件后100行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail <span class="operator">-f</span> <span class="literal">-n</span> <span class="number">100</span> 日志文件名</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;面试Java研发实习生所做的知识准备，及以后的积累&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Interview" scheme="https://mysticalguest.github.io/categories/Interview/"/>
    
    
      <category term="校招" scheme="https://mysticalguest.github.io/tags/%E6%A0%A1%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>Hexo之SEO优化</title>
    <link href="https://mysticalguest.github.io/Hexo/32054.html"/>
    <id>https://mysticalguest.github.io/Hexo/32054.html</id>
    <published>2021-04-08T09:07:41.221Z</published>
    <updated>2021-04-22T13:47:43.601Z</updated>
    
    <content type="html"><![CDATA[<p>SEO（Search Engine Optimization），即搜索引擎优化。简单来说，SEO就是您可以使用提升网站排名的所有方法的总称，SEO用于确保您的网站及其内容在搜索引擎结果页面（SERP）上的可见性。</p><a id="more"></a><h2 id="验证网站"><a href="#验证网站" class="headerlink" title="验证网站"></a>验证网站</h2><p>验证自己的网站，让博客被搜索引擎找到，查看博客是否被收入。</p><p>在谷歌或者百度的搜索链接中，使用以下格式可以直接搜索自己的域名， 如果能搜索到就说明已经被收录，反之则没有。可以直接搜索自己的域名，或者加一些关键词来更好地判断，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site: https://mysticalguest.github.io/</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Configuration/hexo/site.png" style="zoom:80%;" /></p><h2 id="提交博客网站"><a href="#提交博客网站" class="headerlink" title="提交博客网站"></a>提交博客网站</h2><p>若未被搜索引擎收录，则需进行以下配置，首先要让搜索引擎先验证我们对网站的所有权，两个搜索引擎提交的入口分别为：<a href="https://www.google.com/webmasters/tools/home?hl=zh-CN">Google Search Console</a>和<a href="http://ziyuan.baidu.com/site/siteadd">百度站长平台</a></p><h3 id="首先介绍谷歌"><a href="#首先介绍谷歌" class="headerlink" title="首先介绍谷歌"></a>首先介绍谷歌</h3><ul><li><p>当然需要登录谷歌账号，然后访问出现以下界面。选择第二个，输入博客的网址。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Configuration/hexo/enter_domain.png" style="zoom:80%;" /></p></li><li><p>点击继续，弹出以下对话框。点击下载这个指定文件即可。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Configuration/hexo/download_html.png" style="zoom:75%;" /></p></li><li><p>处理这个html文件</p><p>有多种验证方式，这里推荐 <code>HTML</code> 文件上传方式。下载 <code>HTML</code> 验证文件，拷贝到 <code>../sources/</code> 文件夹下，为了使 hexo 不处理这两个验证文件，并且不生成关于这两个文件的 <code>sitemap</code>，我们需要打开验证文件，在最上面添加以下代码，html变为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">layout: false</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">google-site-verification: google************.html</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>然后执行 hexo 部署命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>回到刚才的页面点击继续，完成验证</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Configuration/hexo/Google_verification.png" alt=""></p></li></ul><h3 id="然后介绍百度"><a href="#然后介绍百度" class="headerlink" title="然后介绍百度"></a>然后介绍百度</h3><ul><li><p>输入博客网址，选择属性，验证网站</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Configuration/hexo/baidu_verification.png" alt=""></p></li><li><p>如何添加标签验证</p><p>根据自己的主题情况选择，可以直接写在<code>jsx</code>文件中；我是写在了我的主题的配置文件<code>_config.yml</code>中：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Page metadata configurations</span></span><br><span class="line"><span class="attr">head:</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">    <span class="comment"># https://hexo.io/docs/helpers.html#open-graph</span></span><br><span class="line">    <span class="attr">open_graph:</span></span><br><span class="line">        <span class="comment"># Page title (og:title) (optional)</span></span><br><span class="line">        <span class="comment"># You should leave this blank for most of the time</span></span><br><span class="line">        <span class="attr">title:</span> </span><br><span class="line">        <span class="string">...</span></span><br><span class="line">    <span class="comment"># Structured data of the page</span></span><br><span class="line">    <span class="comment"># https://developers.google.com/search/docs/guides/intro-structured-data</span></span><br><span class="line">    <span class="attr">structured_data:</span></span><br><span class="line">        <span class="comment"># Page title (optional)</span></span><br><span class="line">        <span class="comment"># You should leave this blank for most of the time</span></span><br><span class="line">        <span class="attr">title:</span> </span><br><span class="line">        <span class="string">...</span></span><br><span class="line">    <span class="comment"># Additional HTML meta tags in an array</span></span><br><span class="line">    <span class="attr">meta:</span></span><br><span class="line">        <span class="comment"># Meta tag specified in &lt;attribute&gt;=&lt;value&gt; style</span></span><br><span class="line">        <span class="comment"># E.g., name=theme-color;content=#123456 =&gt; </span></span><br><span class="line">        <span class="comment"># &lt;meta name="theme-color" content="#123456"&gt;=</span></span><br><span class="line">        <span class="comment"># - ''</span></span><br><span class="line">        <span class="bullet">-</span></span><br><span class="line">            <span class="comment"># baidu SEO</span></span><br><span class="line">            <span class="string">name=baidu-site-verification;content=code-kyGo8s2mM1</span></span><br><span class="line">    <span class="comment"># URL or path to the website's RSS atom.xml</span></span><br><span class="line">    <span class="attr">rss:</span> <span class="string">/atom.xml</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>然后执行 hexo 部署命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>最后返回验证页面，就可以查看验证是否通过了</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Configuration/hexo/verification_passed.png" style="zoom:80%;" /></p></li></ul><h2 id="生成Sitemap"><a href="#生成Sitemap" class="headerlink" title="生成Sitemap"></a>生成Sitemap</h2><p>Sitemap即网站地图，它的作用在于便于搜索引擎更加智能地抓取网站。最简单和常见的sitemap形式，是XML文件，在其中列出网站中的网址以及关于每个网址的其他元数据</p><h3 id="安装sitemap生成插件"><a href="#安装sitemap生成插件" class="headerlink" title="安装sitemap生成插件"></a>安装sitemap生成插件</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo<span class="literal">-generator</span><span class="literal">-sitemap</span> -<span class="literal">-save</span></span><br><span class="line">npm install hexo<span class="literal">-generator</span><span class="literal">-baidu</span><span class="literal">-sitemap</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure><h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><p>站点目录下的_config.yml，添加以下字段，直接放在最末就可以了</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#hexo sitemap</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure><h3 id="向百度提交"><a href="#向百度提交" class="headerlink" title="向百度提交"></a>向百度提交</h3><p>直接向百度交<code>sitemap.xml</code>，登录 <a href="http://ziyuan.baidu.com/linksubmit/index">百度站长平台</a>，点击 <code>资源提交</code>下的<code>普通收录</code>，在 <code>资源提交</code>中选择 <code>sitemap</code>标签，输入自己的<strong>域名加 baidusitemap.xml</strong> 即可，之后可查看 url 提取是否成功。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Configuration/hexo/baidusitemap.png" style="zoom:80%;" /></p><p>由于 GitHub 屏蔽了百度的爬虫，即使提交成功，百度知道这里有可供抓取的链接，也不一定能抓取成功。 首先我们先检测一下百度爬虫是否可以抓取网页。在百度站长平台<code>数据统计</code>下的<code>抓取诊断</code> 中，选择<code>PC UA</code>点击抓取 , 查看抓取状态， 如果显示 <code>抓取失败</code>， 则需要进一步的配置。我的直接抓取成功了。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Configuration/hexo/crawl_diagnosis.png" alt=""></p><h3 id="添加robots-txt"><a href="#添加robots-txt" class="headerlink" title="添加robots.txt"></a>添加robots.txt</h3><p>robots.txt（统一小写）是一种存放于网站根目录下的ASCII编码的文本文件，它的作用是告诉搜索引擎此网站中哪些内容是可以被爬取的，哪些是禁止爬取的。</p><ul><li><p>在 <code>source</code> 目录下增加 <code>rebots.txt</code> 文件，网站生成后在网站的根目录（<code>站点目录/public/</code>）下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /archives/</span><br><span class="line">Allow: /categories/</span><br><span class="line">Allow: /tags/</span><br><span class="line"></span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br><span class="line"></span><br><span class="line">Sitemap: https://你的域名/sitemap.xml</span><br><span class="line">Sitemap: https://你的域名/baidusitemap.xml</span><br></pre></td></tr></table></figure><blockquote><p><code>Allow</code>表示允许被访问的，<code>Disallow</code>是不允许的意思。注意后面两个Sitemap就是网站地图了。而网站地图前面说了是给爬虫用的。这里配置在robots中。</p></blockquote></li><li><p>验证robots文件</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Configuration/hexo/robots.png" alt=""></p></li></ul><h3 id="向谷歌提交"><a href="#向谷歌提交" class="headerlink" title="向谷歌提交"></a>向谷歌提交</h3><p>向谷歌提交 sitemap 比较简单，登录 <a href="https://www.google.com/webmasters/tools/home?hl=zh-CN">Google Search Console</a> ，选择已经验证过的站点，在<code>站点地图</code> 中，可看到 <code>添加新的站点地图</code>，添加 <code>sitemap.xml</code> 的链接即可，谷歌效率较高，一般当天或者第二天就能收到结果吧。如图：</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Configuration/hexo/Google_sitemap.png" style="zoom:80%;" /></p><p>结果，等到第二天百度还没有结果，谷歌已经有了结果：</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Configuration/hexo/Google_result.png" style="zoom:80%;" /></p><h2 id="Url持久化"><a href="#Url持久化" class="headerlink" title="Url持久化"></a>Url持久化</h2><p>我们可以发现hexo默认生成的文章地址路径是{网站名称／年／月／日／文章名称}。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Configuration/hexo/permalink_origin.png" alt=""></p><p>这种链接对搜索爬虫是很不友好的，第一它的url结构超过了三层，太深了。<br>下面我推荐一种方式：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo<span class="literal">-abbrlink</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure><p>根目录下配置_config.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># permalink: :year/:month/:day/:title/</span></span><br><span class="line"><span class="comment"># 可选 permalink: abbrlink 短链接模式</span></span><br><span class="line"><span class="comment"># permalink: :title.html #文章的url 如 http://localhost:4000/theme/博客源码分享.html</span></span><br><span class="line"><span class="comment"># permalink: posts/:abbrlink/ #文章的永久链接</span></span><br><span class="line"><span class="comment"># permalink: posts/:abbrlink.html 如：http://localhost:4000/post/article.html</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:category/:abbrlink.html</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>  <span class="comment"># 算法：crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>    <span class="comment"># 进制：dec(default) and hex</span></span><br></pre></td></tr></table></figure><p>之后部署一下，就看到你的链接变成了这样：</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Configuration/hexo/permalink_addrlink.png" alt=""></p><h2 id="添加-nofollow-标签"><a href="#添加-nofollow-标签" class="headerlink" title="添加 nofollow 标签"></a>添加 nofollow 标签</h2><p>给非友情链接的出站链接添加「nofollow」标签，nofollow 标签是由谷歌领头创新的一个「反垃圾链接」的标签，并被百度、yahoo 等各大搜索引擎广泛支持，引用 nofollow 标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有 nofollow 属性的任何出站链接，以减少垃圾链接的分散网站权重。</p><p>有意者可以查看noopener与之区别。</p><p>无论主题的区别，在<code>footer.*</code>文件中做如下修改：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a ... rel=<span class="string">"noopener"</span>&gt;Hexo&lt;<span class="regexp">/a&gt;&amp;nbsp;&amp;&amp;nbsp;</span></span><br><span class="line"><span class="regexp">&lt;a ... target="_blank" rel="noopener"&gt;Icarus&lt;/</span>a&gt;</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a ... rel=<span class="string">"noopener nofollow"</span>&gt;Hexo&lt;<span class="regexp">/a&gt;&amp;nbsp;&amp;&amp;nbsp;</span></span><br><span class="line"><span class="regexp">&lt;a ... target="_blank" rel="noopener nofollow"&gt;Icarus&lt;/</span>a&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SEO（Search Engine Optimization），即搜索引擎优化。简单来说，SEO就是您可以使用提升网站排名的所有方法的总称，SEO用于确保您的网站及其内容在搜索引擎结果页面（SERP）上的可见性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="https://mysticalguest.github.io/categories/Hexo/"/>
    
    
      <category term="配置" scheme="https://mysticalguest.github.io/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>软件工程课程复习</title>
    <link href="https://mysticalguest.github.io/Study/56860.html"/>
    <id>https://mysticalguest.github.io/Study/56860.html</id>
    <published>2021-03-31T15:26:50.884Z</published>
    <updated>2021-07-16T02:02:25.938Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>整理目的：</p><ol><li>我还是认为基础知识不能丢，也是对以前知识的回顾。</li><li>考研软件工程方向考软件工程这门学科的并不多，我选择了两所学校来进行整理。</li></ol><p>以中南大学944软件工程考试大纲和复旦961软件工程专业基础综合考试大纲为基础。</p></blockquote><a id="more"></a><h2 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h2><h3 id="0-1-考试性质"><a href="#0-1-考试性质" class="headerlink" title="0.1 考试性质"></a>0.1 考试性质</h3><p>《软件工程》考试是为高等院校和科研院所招收硕士研究生而设置的具有选拔性质的全国统一入学考试科目，其目的是科学、公平、有效地测试学生掌握大学本科阶段软件工程课程的基本概念、原理、方法与技术，以及分析和解决问题的能力，评价的标准是高等学校本科毕业生能达到的及格以上水平，以保证被录取者具有基本的软件工程专业素质，并有利于各高等院校和科研院所在专业上择优选拔。</p><h3 id="0-2-考察目标"><a href="#0-2-考察目标" class="headerlink" title="0.2 考察目标"></a>0.2 考察目标</h3><p>掌握：软件工程的产生、软件工程学的研究对象与原则、软件开发方法、软件工程的生存周期模型以及软件工程发展的新方向；软件需求分析的任务和要求、可行性研究的任务以及系统建模方法；软件开发阶段的仼务、过程、方法和技术。<br>理解：软件质量的概念、分析技术；软件维护阶段的活动、提高软件可维护性的策略；软件工程的相关管理技术。</p><h2 id="一、软件工程与软件过程"><a href="#一、软件工程与软件过程" class="headerlink" title="一、软件工程与软件过程"></a>一、软件工程与软件过程</h2><p>边际成本，1968年NATO首次提出。</p><p>软件工程是用工程，科学和数学的原则与方法研制、维护计算机软件的有关技术及管理方法，它由<strong>方法</strong>、<strong>工具</strong>和<strong>过程</strong>三部分组成。</p><h3 id="1-1-软件工程的产生"><a href="#1-1-软件工程的产生" class="headerlink" title="1.1 软件工程的产生"></a>1.1 软件工程的产生</h3><p>软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题。</p><p>产生软件危机的原因：一方面与软件本身的特点有关，另一方面也和软件开发与维护的方法不正确有关。</p><p>要缓解软件危机，既要有先进的技术和方法，又需要高水平的组织管理措施。而软件工程正是综合了管理和技术两方面，研究如何更好地开发软件的一门新兴学科。所以，就目前而言，软件工程是缓解软件危机的最好途径。</p><p>软件工程是指导计算机软件开发和维护的一门工程学科。采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的<strong>管理技术</strong>和当前能够得到的最好的技术方法结合起来，以经济地开发出高质量的软件并有效地维护它，这就是软件工程。</p><h3 id="1-2-软件工程的研究对象与基本原理"><a href="#1-2-软件工程的研究对象与基本原理" class="headerlink" title="1.2 软件工程的研究对象与基本原理"></a>1.2 软件工程的研究对象与基本原理</h3><h3 id="1-3-软件开发方法"><a href="#1-3-软件开发方法" class="headerlink" title="1.3 软件开发方法"></a>1.3 软件开发方法</h3><h3 id="1-4-软件工程工具和环境"><a href="#1-4-软件工程工具和环境" class="headerlink" title="1.4 软件工程工具和环境"></a>1.4 软件工程工具和环境</h3><ul><li><p>软件工程环境</p><p>方法与工具的结合，加上配套的软、硬件支持称为软件工程环境。它能支持开发者按照软件工程的方法,全面完成生存周期中的各项任务。</p></li><li><p>软件工具是什么？按照软件生存周期可将其分为几类？</p><p>软件工具是指为支持计算机软件及其文档的开发、维护、模拟、移植或管理而研制的程序系统。按照软件生存周期可将其分为如下几类： </p><ul><li>需求分析：如数据流图绘制与分析工具、状态转换图绘制与分析工具、面向对象的模型和分析工具、快速原型构造工具、数据字典与数据库工具等。</li><li>软件设计：如HIPO图、PDL(程序设计语言)或PAD(问题分析图)支持工具等。</li><li>编码：集成化的程序员工作平台。如各种正文编辑器和常规的编译程序、汇编程序、连结程序及符号调试器等。</li><li>软件测试：如静态分析器、动态覆盖率测试器、测试用例生成器、测试报告生成器及环境模拟器等。</li><li>软件维护：如反汇编程序、反编译程序、程序结构分析器、源程序格式化工具、文档生成工具、源程序至PAD(问题分析图)或流程图的自动转换工具等。</li></ul></li><li><p>软件工程的基本原理</p><ul><li>用分阶段的生命周期计划严格管理</li><li>坚持进行阶段评审</li><li>实行严格的产品控制</li><li>采用现代程序设计技术</li><li>结果应能清楚地审查</li><li>开发小组应该少而精</li><li>承认不断改进软件工程实践的必要性</li></ul></li></ul><h3 id="1-5-软件生存期过程"><a href="#1-5-软件生存期过程" class="headerlink" title="1.5 软件生存期过程"></a>1.5 软件生存期过程</h3><p>三个时期八个阶段</p><p>软件生命期瀑布模型分为六个阶段：</p><ul><li><p>可行性研究与计划（确定系统的目标和规模，分析项目的可行性）；</p></li><li><p>需求分析与规格说明（明确系统的规格和要求）</p></li><li>设计（包括概要设计和详细设计，将系统分解为模块）</li><li>编程（用程序语言实现每个模块，简单容易）；</li><li>测试（发现并改正错误，分为模块测试、集成测试和系统联调三级）；</li><li>运行维护（扩充功能、纠错等）。</li></ul><p>WBS work breakdown structure 工作分解结构</p><p>软件生命周期由软件定义、软件开发和运行维护（也成软件维护）3个时期组成。</p><h3 id="1-6-软件工程常用生存周期模型"><a href="#1-6-软件工程常用生存周期模型" class="headerlink" title="1.6 软件工程常用生存周期模型"></a>1.6 软件工程常用生存周期模型</h3><p>软件生存周期模型是描述软件开发过程中各种活动如何执行的模型。</p><p>八种经典软件过程模型的特点（瀑布模型、增量和迭代模型、演化模型、统一过程模型、V模型、原型模型、操作规范、转换模型、螺旋模型、敏捷模型）</p><p>V-V原则：validation（核实）：确保系统实现了所有的需求。 verification（验收）：确保每个功能正确运行。</p><h4 id="1-6-1-瀑布模型"><a href="#1-6-1-瀑布模型" class="headerlink" title="1.6.1 瀑布模型"></a>1.6.1 瀑布模型</h4><ul><li><p>传统瀑布模型特点</p><ul><li>阶段间具有顺序性与依赖性</li><li>推迟实现的观点</li><li>质量保证的观点</li></ul></li><li><p>瀑布模型</p><ul><li>优点<ul><li>可强迫开发人员使用规范的方法（例如：结构化技术）；</li><li>严格规定每个阶段必须提交的文档；</li><li>要求每个阶段交出的所有产品都必须通过验证。</li></ul></li><li>·缺点<ul><li>“瀑布模型是由文档驱动的”成为主要缺点</li></ul></li><li>适用范围<ul><li>适合于<strong>用户需求明确、完整、无重大变化</strong>的软件项目开发。</li></ul></li></ul></li></ul><h4 id="1-6-2-增量和迭代模型"><a href="#1-6-2-增量和迭代模型" class="headerlink" title="1.6.2 增量和迭代模型"></a>1.6.2 增量和迭代模型</h4><ul><li><p>特点</p><ul><li>反复的应用瀑布模型的基本成分和原型模型的迭代特征，每一个线型过程产生一个“增量”的发布或提交，该增量均是一个可运行的产品。</li><li>早期的版本实现用户的基本需求，并提供给用户评估的平台。</li></ul></li><li><p>优点</p><ul><li>在较短时间内向用户提交可完成部分工作的产品；</li><li>逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击；</li></ul></li><li><p>缺点</p><ul><li>软件体系结构必须是开放的；</li><li>开发人员既要把软件系统看作整体。又要看成可独立的构件，相互矛盾；</li><li>多个构件并行开发，具有无法集成的风险。</li></ul></li></ul><h4 id="1-6-3-演化模型"><a href="#1-6-3-演化模型" class="headerlink" title="1.6.3 演化模型"></a>1.6.3 演化模型</h4><h4 id="1-6-4-（Rational）统一过程模型"><a href="#1-6-4-（Rational）统一过程模型" class="headerlink" title="1.6.4 （Rational）统一过程模型"></a>1.6.4 （Rational）统一过程模型</h4><p>RUP重复一系列周期，每个周期由一个交付给用户的产品结束。每个周期划分为初始、细化、构造和移交四个阶段，每个阶段围绕着五个核心工作流（需求、分析、设计、实现、测试）分别迭代。</p><h4 id="1-6-5-V模型"><a href="#1-6-5-V模型" class="headerlink" title="1.6.5 V模型"></a>1.6.5 V模型</h4><h4 id="1-6-6-（快速）原型模型"><a href="#1-6-6-（快速）原型模型" class="headerlink" title="1.6.6 （快速）原型模型"></a>1.6.6 （快速）原型模型</h4><ul><li>适用范围<ul><li>用户不能给出完整、准确的需求说明，或者开发者不能确定算法的有效性、操作系统的适应性或人机交互的形式等情况。</li></ul></li></ul><h4 id="1-6-7-操作规范"><a href="#1-6-7-操作规范" class="headerlink" title="1.6.7 操作规范"></a>1.6.7 操作规范</h4><h4 id="1-6-8-转换模型"><a href="#1-6-8-转换模型" class="headerlink" title="1.6.8 转换模型"></a>1.6.8 转换模型</h4><h4 id="1-6-9-螺旋模型"><a href="#1-6-9-螺旋模型" class="headerlink" title="1.6.9 螺旋模型"></a>1.6.9 螺旋模型</h4><ul><li><p>基本思想</p><ul><li>使用原型或其他方法来降低风险。</li></ul></li><li><p>适用范围</p><ul><li>适用于内部开发大规模软件项目。</li></ul></li><li><p>优点</p><ul><li>对可选方案和约束条件的强调有利于已有软件的重用，也有助于把软件质量作为软件发的一个重要目标</li><li>减少了过多测试或测试不足</li><li>维护和开发之间并没有本质区别</li></ul></li><li><p>缺点</p><ul><li>风险驱动，需要相当丰富的风险评估经验和专门知识，否则风险更大</li><li>随着迭代次数的增加，工作量加大，软件开发成本增加</li></ul></li></ul><h4 id="1-6-10-敏捷模型"><a href="#1-6-10-敏捷模型" class="headerlink" title="1.6.10 敏捷模型"></a>1.6.10 敏捷模型</h4><h4 id="1-6-11-喷泉模型"><a href="#1-6-11-喷泉模型" class="headerlink" title="1.6.11 喷泉模型"></a>1.6.11 喷泉模型</h4><ul><li>特点<ul><li>喷泉模型是一种以用户需求为动力，以对象为驱动的模型，主要用于采用对象技术的软件开发项目。该模型认为软件开发过程自下而上周期的各阶段是相互迭代和无间隙的特性</li></ul></li></ul><h3 id="1-7-软件过程的概念"><a href="#1-7-软件过程的概念" class="headerlink" title="1.7 软件过程的概念"></a>1.7 软件过程的概念</h3><h3 id="1-8-过程评估与CMM-CMMI的基本概念"><a href="#1-8-过程评估与CMM-CMMI的基本概念" class="headerlink" title="1.8 过程评估与CMM/CMMI的基本概念"></a>1.8 过程评估与CMM/CMMI的基本概念</h3><h3 id="1-9-敏捷宣言与敏捷过程的特点"><a href="#1-9-敏捷宣言与敏捷过程的特点" class="headerlink" title="1.9 敏捷宣言与敏捷过程的特点"></a>1.9 敏捷宣言与敏捷过程的特点</h3><h2 id="二、需求分析"><a href="#二、需求分析" class="headerlink" title="二、需求分析"></a>二、需求分析</h2><p>需求分析中应该建立哪三种模型：数据模型、功能模型、行为模型</p><h3 id="2-1-软件需求的概念"><a href="#2-1-软件需求的概念" class="headerlink" title="2.1 软件需求的概念"></a>2.1 软件需求的概念</h3><p>四种类型的需求（用两种文档表示）：1：功能需求      2：质量（性能需求）      3：设计约束      4：过程约束</p><ul><li><p>两种描述需求的文档</p><ul><li><p>需求定义：客户想要实现的所有内容的完整列表。</p></li><li><p>需求规格说明书 设计建模UML：要求重新表述为所提出的系统应如何表现的规范</p></li></ul></li><li><p>RTM 需求跟踪矩阵</p><ul><li>系统怎么做什么的订需求定义</li><li>根据需求生成的设计模块</li><li>实现设计的程序代码</li><li>验证系统功能的测试</li><li>描述系统的文档</li></ul></li><li><p>从哪些方面验证软件需求的正确性</p><ul><li>一致性，即所有需求必须是一致的，任何一条需求不能和其他需求互相矛盾。</li><li>完整性，需求必须是完整的，规格说明书应该包括用户需要的每一个功能或性能。</li><li>现实性，指定的需求应该是用现有的硬件技术和软件技术基本上可以实现的。</li><li>有效性，必须证明需求是正确有效的，确实能解决用户面对的问题。</li></ul></li></ul><h3 id="2-2-需求工程的基本过程"><a href="#2-2-需求工程的基本过程" class="headerlink" title="2.2 需求工程的基本过程"></a>2.2 需求工程的基本过程</h3><p>需求工程过程包括如下主要活动：获取需求、需求分析与建模、需求规格说明、确认需求、需求管理。</p><h3 id="2-3-需求分析的目标"><a href="#2-3-需求分析的目标" class="headerlink" title="2.3 需求分析的目标"></a>2.3 需求分析的目标</h3><p>需求分析阶段的基本任务是要准确的定义新系统的目标，为了满足用户需要，回答系统必须“做什么”的问题。</p><p>本阶段要进行以下几方面的工作：问题识别、分析与综合，导出软件的逻辑模型、编写文档</p><ul><li>基本任务<ul><li>问题识别：双方确定对问题的综合需求，这些需求包括功能需求，性能需求，环境需求，用户界面需求。</li><li>分析与综合，导出软件的逻辑模型 </li><li>编写文档：包括编写”需求规格说明书”,”初步用户使用手册”,”确认测试计划”,”修改完善软件开发计划”</li></ul></li></ul><h3 id="2-4-可行性分析"><a href="#2-4-可行性分析" class="headerlink" title="2.4 可行性分析"></a>2.4 可行性分析</h3><p>了解可行性研究中的任务和过程</p><p><strong>任务：</strong>用最小的代价在尽可能短的时间内确定问题是否能够解决. </p><ul><li><p><strong>过程</strong></p><ul><li>复查系统规模和目标</li><li>研究目前正在使用的系统</li><li>导出新系统的高层逻辑模型</li><li>进一步定义问题</li><li>导出和评价供选择的解法</li><li>推荐进行方针</li><li>草拟开发计划</li><li>书写文档提交审查</li></ul></li><li><p>可行性研究目的</p><ul><li>确定在问题定义中所提出的问题是否值得去解，在限制条件下，问题能否解决。</li></ul></li><li><p>可行性研究的任务</p><ul><li>进一步分析和澄清问题的定义，在澄清问题的基础上，导出系统的逻辑模型；</li><li>从系统逻辑模型中，选择问题的若干种主要解法，研究每一种解法的可行性，为以后的行动提出建议；</li><li>如果问题没有可行的解，建议停止系统开发；如果问题有可行的解，应该推荐一个较好的解决方案，并为工程制定一个初步的计划。</li></ul></li><li><p>可行性研究包括哪几方面的内容</p><ul><li>技术可行性：现有技术能否实现本系统，现有技术人员能否胜任，开发系统的资源能否满足；</li><li>经济可行性：经济效益是否超出开发成本；</li><li>操作可行性：系统操作在用户内部行得通吗？</li><li>法律可行性：新系统开发是否会侵犯他人、集体或国家利益，是否违反国家法律。</li></ul></li><li><p>可行性研究的步骤</p><ul><li>复查系统的规模和目标；</li><li>研究目前正在使用的系统，总结现有系统的优劣，提出新系统的雏形；</li><li>导出新系统的高层逻辑模型；</li><li>推荐建议方案； </li><li>推荐行动方针；</li><li>书写计划任务书(可行性报告)； </li><li>提交审查。</li></ul></li><li><p>可行性研究报告的主要内容</p><p>可行性分析的结果是可行性研究报告，内容包括</p><ul><li>系统概述：说明开发的系统名称,提出单位和开发单位。</li><li>可行性研究的前提:系统目标；要求；约束和限制；可行性研究的基本准则等。</li><li>对现有系统的分析:处理流程，图示说明现有系统的处理流程和数据流程；现有系统存在的问题。 </li><li>系统需求:主要功能；主要性能及其要求；操作要求；信息要求；限制性要求。</li><li>建议系统:系统目标；处理流程；系统结构,功能,性能；系统技术可行性；投资和效益分析；操作可行性；法律可行性。</li><li>其它可选方案:与国内外同类型方案的比较；提出一两个可行性方案供论证和探讨。</li><li>制定下一阶段的预算。</li><li>结论性意见：由用户方、设计方和投资方共同签署意见。</li></ul></li></ul><h3 id="2-5-需求收集"><a href="#2-5-需求收集" class="headerlink" title="2.5 需求收集"></a>2.5 需求收集</h3><h3 id="2-6-需求规格说明"><a href="#2-6-需求规格说明" class="headerlink" title="2.6 需求规格说明"></a>2.6 需求规格说明</h3><ul><li><p>简述软件需求说明书（软件规格说明书）中包含的内容</p><ul><li>软件系统的开发背景资料（主要相关人、财、物或设备）；</li><li>所开发软件的功能、性能、用户界面及运行环境等作出详细的说明；</li><li>软件系统详细的逻辑模型：数据流图(DFD)+数据词典（DD）或面向对象的三大模型（对象模型、动态模型和功能模型）等</li><li>系统开发计划表</li><li>所有附加文档：调查问卷信息、BPFD等</li></ul></li><li><p>软件需求规格说明书由哪些部分组成，组成包括</p><ul><li>引言：编写目的、背景说明、术语定义及参考资料等。</li><li>概述主要功能、约束条件或特殊需求。</li><li>数据流图与数据字典。</li><li>用户接口、硬件接口及软件接口。</li><li>性能需求、属性等。</li><li>其它需求，如数据库、操作及故障处理等。</li></ul></li></ul><h3 id="2-7-数据流建模"><a href="#2-7-数据流建模" class="headerlink" title="2.7 数据流建模"></a>2.7 数据流建模</h3><p>（分层数据流模型）</p><h3 id="2-8-实体一关系建模"><a href="#2-8-实体一关系建模" class="headerlink" title="2.8 实体一关系建模"></a>2.8 实体一关系建模</h3><p>用例和场景建模及其UML表达（用例图、活动图、泳道图、顺序图）</p><h3 id="2-9-系统行为建模"><a href="#2-9-系统行为建模" class="headerlink" title="2.9 系统行为建模"></a>2.9 系统行为建模</h3><p>（数据模型建模及其UML表达（类图））（行为模型建模及其UML表达（状态机图））</p><h3 id="2-10-IDEF0功能建模"><a href="#2-10-IDEF0功能建模" class="headerlink" title="2.10 IDEF0功能建模"></a>2.10 IDEF0功能建模</h3><h3 id="2-11-IDEF1x数据建模"><a href="#2-11-IDEF1x数据建模" class="headerlink" title="2.11 IDEF1x数据建模"></a>2.11 IDEF1x数据建模</h3><h2 id="三、软件设计"><a href="#三、软件设计" class="headerlink" title="三、软件设计"></a>三、软件设计</h2><h3 id="3-1-软件体系结构及体系结构风格的概念"><a href="#3-1-软件体系结构及体系结构风格的概念" class="headerlink" title="3.1 软件体系结构及体系结构风格的概念"></a>3.1 软件体系结构及体系结构风格的概念</h3><p>软件体系结构为软件系统提供了一个结构、行为和属性的高级抽象，由构成系统的元素的描述、元素间的相互作用、指导元素集成的模式以及这些模式的约束组成。软件体系结构不仅指定了系统的组织结构和拓扑结构，并且显示了系统需求和构成系统的元素之间的对应关系，提供了一些设计决策的基本原理。良好的体系结构是普遍适用的，它可以高效地处理各种各样的个体需求。</p><p>软件架构也有通用的解决方案，叫做体系结构风格</p><p>体系结构风格提供有关如何将问题分解为软件单元以及这些单元应如何相互交互的建议</p><p>使用体系结构风格的六种方法：</p><ul><li>去理解系统：他能做什么和怎么做</li><li>去判断多少系统可以去复用先前就建立好的系统，多少系统在以后将不能复用。</li><li>提供构建系统的蓝图，提供构建系统的蓝图，包括系统的“承载”部分可能在哪里     </li><li>推断系统如何发展，包括表现，成本，原型设计</li><li>去分析依赖，选择最合适的设计，实现，和测试技术</li><li>支持管理厥词，理解实施和维护中固有的风险</li></ul><h3 id="3-2-设计模式的概念"><a href="#3-2-设计模式的概念" class="headerlink" title="3.2 设计模式的概念"></a>3.2 设计模式的概念</h3><h3 id="3-3-模块化设计的基本思想及概念"><a href="#3-3-模块化设计的基本思想及概念" class="headerlink" title="3.3 模块化设计的基本思想及概念"></a>3.3 模块化设计的基本思想及概念</h3><p>（抽象、分解、模块化、封装、信息隐藏、功能独立）</p><ul><li><p>什么是模块？模块具有哪几个特征？总体设计主要考虑什么特征？</p><ul><li>模块是数据说明、可执行语句等程序对象的集合，可以单独命名且可通过名字来访问。</li><li>模块具有输入和输出(参数传递)、功能、内部数据结构(局部变量)和程序代码四个特性。</li><li>概要设计主要考虑输入、输出(参数传递)和功能两个特性。</li></ul></li><li><p>什么是模块化</p><ul><li>模块化是按规定的原则将一个大型软件划分为一个个较小的、相对独立但又相关的模块。</li></ul></li><li><p>模块设计的准则</p><ul><li>改进软件结构, 提高模块独立性:在对初步模块进行合并、分解和移动的分析、精化过程中力求提高模块的内聚，降低藕合。</li><li>模块大小要适中:大约50行语句的代码，过大的模块应分解以提高理解性和可维护性;过小的模块,合并到上级模块中。</li><li>软件结构图的深度、宽度、扇入和扇出要适当。一般模块的调用个数不要超过5个。</li><li>尽量降低模块接口的复杂程度；</li><li>设计单入口、单出口的模块。</li><li>模块的作用域应在控制域之内。</li></ul></li></ul><h3 id="3-4-软件重构的概念"><a href="#3-4-软件重构的概念" class="headerlink" title="3.4 软件重构的概念"></a>3.4 软件重构的概念</h3><h3 id="3-5-软件体系结构的UML建模"><a href="#3-5-软件体系结构的UML建模" class="headerlink" title="3.5 软件体系结构的UML建模"></a>3.5 软件体系结构的UML建模</h3><p>软件开发的过程犹如雕琢一件工艺品，由无形到有形，由粗到细。鉴于软件系统的复杂性和规模的不断增大，项目失败的可能性也相应增加。需要建立不同的模型对系统的各个层次进行描述。在长期的研究与实践中，人们越来越深刻地认识到，建立简明准确的表示模型是把握复杂系统的关键。模型是对事物的一种抽象，在软件开发过程中，建立各种模型，以便更透彻地了解系统的本质。由于UML以图形模型为主，模型的直观性及丰富的信息描述便于开发人员与用户的交流。建立的模型也为以后的系统维护和升级提供了文档。总的来说，使用模型可以使人们从全局上把握系统的全貌及其相关部件之间的关系，可以防止过早地陷入各个模块的细节。因此，面向对象的分析与设计应该从建模开始。UML 是一种标准的图形化、可视化的建模型语言，UML的核心是建立系统的各类模型。</p><h4 id="3-5-1-包图"><a href="#3-5-1-包图" class="headerlink" title="3.5.1 包图"></a>3.5.1 包图</h4><h4 id="3-5-2-类图"><a href="#3-5-2-类图" class="headerlink" title="3.5.2 类图"></a>3.5.2 类图</h4><h4 id="3-5-3-构件图"><a href="#3-5-3-构件图" class="headerlink" title="3.5.3 构件图"></a>3.5.3 构件图</h4><h4 id="3-5-4-活动图（Activity-Diagram）"><a href="#3-5-4-活动图（Activity-Diagram）" class="headerlink" title="3.5.4 活动图（Activity Diagram）"></a>3.5.4 活动图（Activity Diagram）</h4><p>是由状态图变化而来的，从系统任务的观点来看，系统的执行过程是由一系列有序活动组成的。活动图可以有效地描述整个系统的流程，描述了系统的全局的动态行为，且只有活动图是唯一能够描述并发活动的UML图</p><h4 id="3-5-4-顺序图（Sequence-Diagram）"><a href="#3-5-4-顺序图（Sequence-Diagram）" class="headerlink" title="3.5.4 顺序图（Sequence Diagram）"></a>3.5.4 顺序图（Sequence Diagram）</h4><p>清晰地描述一组对象之间动态的交互关系、时间的约束关系，着重描述对象间消息传递的时间顺序，所以顺序图在实时系统中被大量使用。当参与交互的对象数目增加，交互关系复杂时用顺序图描述会显得杂乱。</p><h4 id="3-5-5-协作图（Collaboration-Diagram）"><a href="#3-5-5-协作图（Collaboration-Diagram）" class="headerlink" title="3.5.5 协作图（Collaboration Diagram）"></a>3.5.5 协作图（Collaboration Diagram）</h4><p>从另一个角度来更好地描述相互协作的对象间的交互关系和链接（Link）关系。着重体现交互对象间的静态链接关系和协作关系。协作图也可以从顺序图生成</p><h4 id="3-5-6-部署图"><a href="#3-5-6-部署图" class="headerlink" title="3.5.6 部署图"></a>3.5.6 部署图</h4><h4 id="3-5-7-状态图（State-Diagram）"><a href="#3-5-7-状态图（State-Diagram）" class="headerlink" title="3.5.7 状态图（State Diagram）"></a>3.5.7 状态图（State Diagram）</h4><p>用来描述一个特定对象在其生存周期或在某段时间内的所有可能的状态及其引起状态转移的事件。一个状态图包括一系列的状态以及状态之间的改变。例如订单的状态变化等，在实时系统中用得较多，还可以用于辅助设计用户界面。</p><h3 id="3-6-接口的概念"><a href="#3-6-接口的概念" class="headerlink" title="3.6 接口的概念"></a>3.6 接口的概念</h3><h3 id="3-7-面向对象设计原则"><a href="#3-7-面向对象设计原则" class="headerlink" title="3.7 面向对象设计原则"></a>3.7 面向对象设计原则</h3><p>（开闭原则、Liskov替换原则、依赖转置原则、接口隔离原则）</p><h3 id="3-8-内聚与耦合的概念、常见的内聚和耦合类型"><a href="#3-8-内聚与耦合的概念、常见的内聚和耦合类型" class="headerlink" title="3.8 内聚与耦合的概念、常见的内聚和耦合类型"></a>3.8 内聚与耦合的概念、常见的内聚和耦合类型</h3><p>耦合包含了哪些类型？每个类型的具体内容是什么？要求能通过程序代码识别出耦合类型。</p><ul><li>非直接耦合：就是没有耦合。 </li><li>数据耦合：就是参数传递耦合，它属于低级别耦合。  </li><li>标记耦合：标记耦合指两个模块之间传递的是数据结构。 </li><li>控制耦合：它属于中级别耦合，比如调度程序与进程之间的耦合，就是控制耦合。  </li><li>外部耦合：属于高级别耦合 </li><li>公共耦合：指通过一个公共数据环境相互作用的那些模块间的耦合。 </li><li>内容耦合：属于最高级别耦合，例如，一个模块利用分支或跳转技术，转入到另一个模块中去执行，就是内容耦合。</li></ul><h3 id="3-9-软件设计的任务和过程"><a href="#3-9-软件设计的任务和过程" class="headerlink" title="3.9 软件设计的任务和过程"></a>3.9 软件设计的任务和过程</h3><ul><li><p>系统设计包括哪两个阶段</p><ul><li>系统设计包括总体设计与详细设计两个阶段</li></ul></li><li><p>总体设计的主要任务是什么</p><ul><li>总体设计的主要任务是完成软件结构的设计，确定系统的模块及其模块之间的关系。</li></ul></li><li><p>详细设计的目的</p><ul><li>为软件结构图（SC图或HC图）中的每一个模块确定采用的算法和块内数据结构，用某种选定的表达工具给出清晰的描述。</li></ul></li><li><p>详细设计的主要任务</p><p>编写软件的“详细设计说明书”。软件人员要完成的工作：</p><ul><li>为每一个模块确定采用的算法，选择某种适当的工具表达算法的过程，写出模块的详细过程描述</li><li>确定每一模块使用的数据结构</li><li>确定模块结构的细节，包括对系统外部的接口和用户界面，对系统内部其它模块的接口，以及关于模块输入数据、输出数据及局部数据的全部细节</li><li>为每一个模块设计出一组测试用例，以便在编码阶段对模块代码（即程序）进行预定的测试。</li></ul></li><li><p>概要设计（结构设计）</p><ul><li>把一个软件需求转换为软件表示时，首先设计出软件总的体系结构。</li><li>基本任务<ul><li>设计软件系统结构</li><li>进行数据结构及数据库的设计</li><li>编写概要设计的文档</li><li>评审</li></ul></li></ul></li><li><p>详细设计</p><p>为SC图中的每个模块确定采用的算法和块内数据结构，用选定的表达工具（流程图、N-S图、PAD图、伪代码）给出清晰的描述。</p><ul><li>基本任务<ul><li>为每个模块进行详细的算法设计</li><li>为模块内的数据结构进行设计</li><li>对数据库进行物理设计</li><li>其他设计</li><li>编写详细设计说明书</li><li>评审</li></ul></li></ul></li></ul><h3 id="3-10-软件设计基本原则"><a href="#3-10-软件设计基本原则" class="headerlink" title="3.10 软件设计基本原则"></a>3.10 软件设计基本原则</h3><p>设计原则定义：将我们的系统需要的功能和行为分解为模块的指南（设计原理？）</p><p> 六个主导原则：</p><ul><li>模块化：耦合和类聚       我们说两个模块紧耦合，当他们彼此依赖很多。低耦合模块有一些依赖，但是他们的关联很微弱。解耦模块没有耦合<ul><li>内聚：cohesion ： 去测量多个模块的相互依赖程度，内聚指来自模块内部的依赖。最糟糕的情况，巧合：一个模块和另一个没有关系</li><li>内聚种类：巧合内聚，逻辑类聚，时间类聚，过程类聚，通信类聚，功能类聚，信息类据。</li><li>耦合是影响软件复杂程度的一个重要因素。设计时力争做到高内聚，并且能够辨认出低内聚的模块，有能力通过修改设计提高模块的内聚程度并且降低模块间的耦合程度，从而获得较高的模块独立性。</li></ul></li><li>接口      定义了软件单元给剩余的系统提供什么服务，其他单元如何访问那些服务。</li><li>信息隐藏（和局部化？）      使得软件系统更易于维护       它以分解系统的指导来区分：每个软件单元都包含了一个可以在未来改变的分离设计决策</li><li>增量开发</li><li>抽象      是一种模型或者表示，忽略一些细节从而可以专注其他细节。</li><li>泛化      使技术通用       泛化是一个设计原则，使得软件单元尽可能普遍接受，增加在未来别的系统复用的可能性</li></ul><h3 id="3-11-面向数据流图的设计方法"><a href="#3-11-面向数据流图的设计方法" class="headerlink" title="3.11 面向数据流图的设计方法"></a>3.11 面向数据流图的设计方法</h3><p>掌握面向数据流的设计方法，了解其中涉及到的概念（变换流，事务流），结合例子理解变换分析的具体过程。</p><p>面向数据流的设计方法把信息映射成软件结构，信息流的类型决定了映射的方法。信息流有两种</p><ul><li><p>变换流</p></li><li><p>事务流</p></li></ul><p><strong>变换流：</strong>信息沿输入通路进入系统，同时由外部形式变换成内部形式，进入系统的信息通过变换中心，经加处理以后再沿输出通路变换成外部形式离开软件系统。</p><p><strong>事务流</strong>：以事务为中心，事务型数据流图中存在一个事务中心（也就是数据处理、加工中心），它将输入分离成若干个发散的数据流，形成许多活动路径，并根据输入值选择其中一条路径，这类数据流就是事务流。</p><h3 id="3-12-面向对象的设计方法"><a href="#3-12-面向对象的设计方法" class="headerlink" title="3.12 面向对象的设计方法"></a>3.12 面向对象的设计方法</h3><ul><li><p>三种编程范型的特点</p><ul><li>过程式编程范型：把程序理解为一组被动的数据和一组能动的过程所构成；程序=数据结构+算法；着眼于程序的过程和基本控制结构，粒度最小</li><li>面向对象编程范型：数据及其操作被封装在对象中；程序=对象+消息；着眼于程序中的对象，粒度比较大</li><li>基于构件技术的编程范型：构件是通用的、可复用的对象类；程序=构件+架构；眼于适合整个领域的类对象，粒度最大</li></ul></li><li><p>用面向对象方法开发软件时，通常需要建立哪三种形式的模型？</p><ul><li>描述系统数据结构的对象模型。</li><li>描述系统控制结构的动态模型。</li><li>描述系统功能的功能模型。</li></ul></li></ul><p>面向对象方法学的出发点和基本原则，是尽可能模拟人类思维方法，是开发软件尽可能接近人类认识世界解决问题的方法与过程。</p><p>对象模型表示静态的，结构化的系统的“数据”性质。它是对模拟客观世界实体的对象以及对象彼此之间的关系的映射，描述了系统的静态结构。</p><p>动态模型表示瞬时的、行为化的系统的”控制“性质，它规定了对象模型中的对象的合法序列。</p><p>功能模型表示变化的系统的”功能“性质，他指明了系统应该”做什么”，因此更直接反映了用户对目标系统的需求。</p><h3 id="3-13-面向对象软件设计模式"><a href="#3-13-面向对象软件设计模式" class="headerlink" title="3.13 面向对象软件设计模式"></a>3.13 面向对象软件设计模式</h3><h3 id="3-14-模型-视图-控制器框架"><a href="#3-14-模型-视图-控制器框架" class="headerlink" title="3.14 模型-视图-控制器框架"></a>3.14 模型-视图-控制器框架</h3><h2 id="四、软件验证技术（软件测试）"><a href="#四、软件验证技术（软件测试）" class="headerlink" title="四、软件验证技术（软件测试）"></a>四、软件验证技术（软件测试）</h2><p>软件失败：软件不能做我们描述的需求。</p><h3 id="4-1-软件测试基础（软件测试及测试用例的概念）"><a href="#4-1-软件测试基础（软件测试及测试用例的概念）" class="headerlink" title="4.1 软件测试基础（软件测试及测试用例的概念）"></a>4.1 软件测试基础（软件测试及测试用例的概念）</h3><p>测试的目的是判断和发现软件是否有错误 , 调试的目的是定位软件错误并纠正错误。 </p><p>软件测试是按照特定的规则，发现软件错误的过程；好的测试方案是尽可能发现迄今尚未发现错误的测试；成功的测试方案是发现迄今尚未发现错误的测试</p><ul><li><p>软件测试的一般步骤</p><p>​    单元测试、子系统测试、系统测试、验收测试、平行测试。</p></li></ul><h3 id="4-2-代码复审"><a href="#4-2-代码复审" class="headerlink" title="4.2 代码复审"></a>4.2 代码复审</h3><h3 id="4-3-白盒测试"><a href="#4-3-白盒测试" class="headerlink" title="4.3 白盒测试"></a>4.3 白盒测试</h3><p>根据程序内部逻辑结构进行测试，来检验程序内部动作是否按照规格说明书的规定正常进行</p><p>软件的白盒测试是对软件的过程性细节做细致的检查。这种方法是把测试对象看做一个打开的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。通过在不同点检查程序状态，确定实际状态是否与预期的状态一致。因此白盒测试又称为结构测试或逻辑驱动测试。</p><p><strong>8</strong>个覆盖点：语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖、点覆盖、边覆盖、路径覆盖</p><p>白盒测试主要采用的技术有：路径测试技术和事务处理流程技术，对包含有大量逻辑判断或条件组合的程序采用基于逻辑的测试技术。</p><h3 id="4-4-黑盒测试"><a href="#4-4-黑盒测试" class="headerlink" title="4.4 黑盒测试"></a>4.4 黑盒测试</h3><p>根据程序外部特征来进行测试，着重测试软件功能，它并不能取代白盒测试，它是与白盒测试互补的测试方法</p><p>黑盒测试着重测试软件功能。这种方法是把测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。因此黑盒测试又叫功能测试或数据驱动测试。</p><p>黑盒测试主要采用的技术有:等价分类法、边沿值分析法、错误推测法和因果图等技术。</p><p>黑盒测试力图发现下述类型的错误</p><ul><li>功能不正确或遗漏了功能</li><li>界面错误</li><li>数据结构错误或外部访问数据库错误</li><li>性能错误</li><li>初始化和终止错误</li></ul><h3 id="4-5-单元测试"><a href="#4-5-单元测试" class="headerlink" title="4.5 单元测试"></a>4.5 单元测试</h3><p>单元测试集中监测软件设计的最小单元—模块。</p><p>从这些方面对模块进行测试</p><ul><li>模块接口</li><li>局部数据结构</li><li>重要的执行通路</li><li>出错处理通路</li><li>边界条件</li></ul><h3 id="4-6-集成测试"><a href="#4-6-集成测试" class="headerlink" title="4.6 集成测试"></a>4.6 集成测试</h3><p>是测试和组装软件的系统化技术。</p><ul><li>测试方法<ul><li>非渐增式测试</li><li>渐增式测试</li></ul></li></ul><p>当使用渐增方式把模块结合到程序中去时，有<strong>自顶向下</strong>和<strong>自底向上</strong>的两种集成策略</p><ul><li>比较集成试的两种方式的优劣<ul><li>非渐增式测试方式：分别测试模块,再把所有模块按设计要求放在一起组成所要的程序。该方法编写测试软件工作量大，模块间的接口错误发现得晚，错误定位较难诊断，总体测试有的错误容易漏掉，测试时间相对较少，可以并行测试所有模块，能充分利用人力，加快工程进度。。</li><li>渐增式测试方式：把下一个要测试的模块,同已经测试好的那些模块结合起来进行测试。该方法利用已测试过的模块作测试软件,开销小，较早发现模块间的接口错误，错误定位往往和最近入的模块相关，对已测试好的模块可在新加入模块的条件下受到新的检验，测试更彻底，需要较多的测试时间，不能并行测试。</li><li>总的来说，渐增式测试方法比较好。</li></ul></li></ul><h3 id="4-7-确认测试"><a href="#4-7-确认测试" class="headerlink" title="4.7 确认测试"></a>4.7 确认测试</h3><ul><li><p>什么是确认测试？该阶段有哪些工作？</p><ul><li>确认测试又称有效性测试。它的任务是检查软件的功能与性能是否与需求规格说明书中确定的指标相符合 。</li></ul></li><li><p>确认测试阶段有两项工作，进行确认测试与软件配置审查</p><ul><li>确认测试一般是在模拟环境中运用黑盒测试方法，由专门测试人员和用户参加的测试。</li><li>软件配置审查的任务是检查软件的所有文档资料的完整性、正确性。如果发现遗漏和错误，应补充和改正，同时要编排好目录，为以后的软件维护工作奠定基础。 </li></ul></li></ul><h3 id="4-8-系统测试"><a href="#4-8-系统测试" class="headerlink" title="4.8 系统测试"></a>4.8 系统测试</h3><h3 id="4-9-回归测试的概念"><a href="#4-9-回归测试的概念" class="headerlink" title="4.9 回归测试的概念"></a>4.9 回归测试的概念</h3><h3 id="4-10-程序正确性证明"><a href="#4-10-程序正确性证明" class="headerlink" title="4.10 程序正确性证明"></a>4.10 程序正确性证明</h3><h3 id="4-11调试"><a href="#4-11调试" class="headerlink" title="4.11调试"></a>4.11调试</h3><p>（调试的概念、调试与测试的关系）</p><p>测试与调试的主要区别？</p><ul><li>测试从一个侧面证明程序员的失败；调试证明程序员的正确；</li><li>测试从已知条件开始，使用预先定义的程序，且有预知的结果，不可预见的仅是程序是否通过测试；调试从不可知内部条件开始，除统计性调试外，结果是不可预见的；</li><li>测试有计划并且要进行测试设计；调试不受时间约束；</li><li>测试是发现错误、改正错误、重新测试的过程；调试是一个推理的过程；</li><li>测试执行是有规程的；调试执行要求程序员进行必要的推理；</li><li>测试由独立的测试组在不了解软件设计的件下完成；调试由了解详细设计的程序员完成；</li><li>大多数测试的执行和设计可由工具支持；调试用的工具主要是调试器。</li></ul><h3 id="4-12-测试覆盖度的概念"><a href="#4-12-测试覆盖度的概念" class="headerlink" title="4.12 测试覆盖度的概念"></a>4.12 测试覆盖度的概念</h3><h3 id="4-13-代码圈复杂度的计算方法"><a href="#4-13-代码圈复杂度的计算方法" class="headerlink" title="4.13 代码圈复杂度的计算方法"></a>4.13 代码圈复杂度的计算方法</h3><h3 id="4-14-白盒测试中的基本路径测试方法"><a href="#4-14-白盒测试中的基本路径测试方法" class="headerlink" title="4.14 白盒测试中的基本路径测试方法"></a>4.14 白盒测试中的基本路径测试方法</h3><p>路径测试技术中几种主要覆盖的含义？举例说明？</p><ul><li>语句覆盖：至少执行程序中所有语句一次。  </li><li>判定覆盖：使被测程序中的每一个分支至少执行一次。故也称为分支覆盖。</li><li>条件覆盖：执行所有可能的穿过程序的控制路流程。</li><li>条件组合测试：设计足够的测试用例，使每个判定中的所有可能条件取值组合至少执行一次</li></ul><h3 id="4-15-黑盒测试中的等价类划分方法"><a href="#4-15-黑盒测试中的等价类划分方法" class="headerlink" title="4.15 黑盒测试中的等价类划分方法"></a>4.15 黑盒测试中的等价类划分方法</h3><p>等价分类法的测试技术采用的一般方法?举例说明?</p><ul><li>为每个等价类编号；</li><li>设计一个新的测试方案,以尽可能多的覆盖尚未被覆盖的有效等价类,重复这一步骤,直到所有有效等价类被覆盖为止。</li><li>设计一个新的测试方案,使它覆盖一个尚未被覆盖的无效等价类, 重复这一步骤,直到所有无效等价类被覆盖为止。</li></ul><h3 id="4-16-Alpha和Beta测试"><a href="#4-16-Alpha和Beta测试" class="headerlink" title="4.16 Alpha和Beta测试"></a>4.16 Alpha和Beta测试</h3><p><strong>Alpha</strong>测试：由用户在开发者的场所进行，并且在开发者对用户的”指导”下进行测试。开发者负责记录发现的错误和使用中遇到的问题. </p><p><strong>Beta</strong>测试：由软件的最终用户在一个或多个客户场所进行。与Alpha测试不同，开发者通常不在Beta测试的现场，因此，Bate测试时软件在开发者不能控制的环境中的”真实”应用。</p><h2 id="五、软件维护技术"><a href="#五、软件维护技术" class="headerlink" title="五、软件维护技术"></a>五、软件维护技术</h2><h3 id="5-1-软件维护的基本概念"><a href="#5-1-软件维护的基本概念" class="headerlink" title="5.1 软件维护的基本概念"></a>5.1 软件维护的基本概念</h3><p>软件维护是指软件系统交付使用以后，为了改正错误或满足新的需求而修改软件的过程一个中等规模的软件，如果其开发过程需要一两年时间，则它投入使用以后，其运行时间可能持续5~10年之久。在这个维护阶段中，人们需要着手解决开发阶段尚未解决的问题，同时，还解决维护工作本身所产生的问题。做好软件的维护工作不仅能够排除软件中存在的错误，使它能够正常工作，而且还可以使它扩充功能，提高性能，为用户带来新的效益。维护阶段的花费约占整个软件生存周期花费的67%。 因此，应充分认识到维护现有软件的重要意义。</p><p>就是在软件已经交付使用之后，为了改正错误或满足新的需要而修改的过程。</p><p>软件的维护一般分为哪几类？</p><ul><li>改正性维护：满足用户对已开发产品的性能与运行环境不断提高的要求，进而达到延长软件寿命的目的。</li><li>适应性维护：对程序使用期间发现的程序错误进行诊断和改正的过程，配合变化了的环境进行修改软件的活动；</li><li>完善性维护：满足用户在使用过程中提出增加新的功能或修改已有功能的建议而进行的工作； </li><li>预防性维护：为了改善未来的可维护性或可靠性而修改软件的工作。</li></ul><p>软件维护的最终目的，是满足用户对已开发产品的性能与运行环境的不断提高的需求，进而延长软件的寿命。</p><h3 id="5-2-软件维护过程"><a href="#5-2-软件维护过程" class="headerlink" title="5.2 软件维护过程"></a>5.2 软件维护过程</h3><ul><li><p>维护过程</p><ul><li>维护组织</li><li>维护报告</li><li>维护的事件流</li><li>保存维护记录</li><li>评价维护活动。</li></ul></li><li><p>为什么说软件的维护是不可避免的？</p><ul><li>因为软件的开发过程中，一般很难检测到所有的错误，其次软件在应用过程中需要随用户新的要求或运行环境的变化而进行软件的修改或完成功能的增删等，为了提高软件的应用水平和使用寿命，软件的维护是不可避免的。</li></ul></li></ul><h3 id="5-3-软件可维护性"><a href="#5-3-软件可维护性" class="headerlink" title="5.3 软件可维护性"></a>5.3 软件可维护性</h3><p>软件的可维护性是指维护人员为纠正软件系统出现的错误或缺陷，以及为满足新的要求而理解、修改和完善软件系统的难易程度。可维护性是所有软件系统都应具备的特点。在软件工程的每一-阶段都应该努力提高系统的可维护性，在每个阶段结束前的审查和复审中，应着重对可维护性进行复审。</p><p>决定软件可维护性的因素</p><ul><li>软件的可理解性、可测试性、可修改性； </li><li>文档描述符合要求、用户文档简洁明确、系统文档完整并且标准。</li></ul><h4 id="5-3-1-可维护性度量的特性"><a href="#5-3-1-可维护性度量的特性" class="headerlink" title="5.3.1 可维护性度量的特性"></a>5.3.1 可维护性度量的特性</h4><p>主要有可理解性、可测试性和可修改性可理解性被定义为人们通过阅读源代码和文档了解软件系统的结构、接口、功能、内部过程以及如何运行的难易程度；可测试性被定义为诊断和测试系统的难易程度；可修改性被定义为修改软件系统的难易程度；它们是密切相关的。</p><h4 id="5-3-2-提高可维护性的方法有哪些"><a href="#5-3-2-提高可维护性的方法有哪些" class="headerlink" title="5.3.2 提高可维护性的方法有哪些"></a>5.3.2 提高可维护性的方法有哪些</h4><p>在软件工程的每一阶段都应该努力提高系统的可维护性，在每个阶段结束前的审查和复审中，应着重对可维护性进行复审。在需求分析阶段的复审中，应对将来要扩充和修改的部分加以注明。在讨论软件可移植性问题时，要考虑可能要影响软件维护的系统界面。在软件设计的复审中，应从便于修改、模块化和功能独立的目标出发，评价软件的结构和过程，还应对将来可能修改的部分预先做准备。在软件代码复审中，应强调编码风格和内部说明这两个影响可维护性的因素。在软件系统交付使用前的每一测试步骤中都应给出需要进行预防性维护部分的提示。在完成每项维护工作后，都应对软件维护本身进行仔细认真的复审。为了从根本上提高软件系统的可维护性，人们正试图通过直接维护软件规格说明来维护软件，同时也在大力发展软件重用技术。</p><p>简述提高软件可维护性的方法</p><ul><li>建立明确的软件质量标准；</li><li>使用先进软件开发技术和工具；</li><li>建立明确的软件质量保证工作；</li><li>选择可维护的程序设计语言；</li><li>改进程序文档。</li></ul><h3 id="5-4-软件再工程技术"><a href="#5-4-软件再工程技术" class="headerlink" title="5.4 软件再工程技术"></a>5.4 软件再工程技术</h3><p>简述软件再工程的过程</p><ul><li>库存目录分析：包含每个应用系统的信息，如：名称、构建日期、修改次数、过去18个月报告的错误、用户数量、文档质量、预期寿命，等。从中选出再工程的候选者。</li><li><p>文档重构</p><ul><li>如果一个程序走向生命终点，不再经历变化，则保持现状；</li><li>重构只针对当前正在修改的软件部分。</li></ul></li><li><p>逆向工程：逆向工程是一个恢复设计结果的过程，从程序代码中抽取数据结构、体系结构和处理过程的设计信息。</p></li><li>代码重构： 分析源代码，标注出与结构化程序设计概念不符的部分，重构它的代码，测试重构代码并更新代码。</li><li><p>数据重构：当数据结构较差时，进行再工程。如以文件方式保存数据变为以数据库方式存储。</p></li><li><p>正向工程：也称革新或改造，即应用软件工程的原理、概念、技术和方法来重新开发现有系统。</p></li></ul><h2 id="六、软件项目管理"><a href="#六、软件项目管理" class="headerlink" title="六、软件项目管理"></a>六、软件项目管理</h2><h3 id="6-1-成本估计"><a href="#6-1-成本估计" class="headerlink" title="6.1 成本估计"></a>6.1 成本估计</h3><p>软件开发成本估算方法有哪几种</p><ul><li><strong>自顶向下</strong>估算方法。估算人员参照以前完成的项目所耗费的总成本（或总工作量），来推算将要开发的软件的总成本（或总工作量），然后把它们按阶段、步骤和工作单元进行分配，这样方法称为自顶向下的估算方法。</li><li><strong>自底向上</strong>估算方法。自底向上估算方法是将待开发的软件细分，分别估算每一个子任务所需要的开发工作量，然后将它们加起来，得到软件的总开发量。</li><li><strong>差别估算</strong>方法。差别估算是将开发项目与一个或多个已完成的类似项目进行比较，找出与某个相类似项目的若干不同之处，并估算每个不同之处对成本的影响，导出开发项目的总成本。</li><li><strong>专家估算</strong>法。依靠一个或多个专家对要求的项目做出估算。</li><li><strong>类推估算</strong>法。</li><li>经验公式估算法。</li></ul><p>为什么在软件开发中，不能用简单增加人员的方法来缩短开发时间？ 大量软件开发实践说明：向一个已经延迟的项目追加开发人员，可能使它完成得更晚。因为当开发人员以算术级数增长时，而人员之间的通信将以几何级数增长，往往”得不偿失”。</p><h3 id="6-2-效益分析"><a href="#6-2-效益分析" class="headerlink" title="6.2 效益分析"></a>6.2 效益分析</h3><h3 id="6-3-风险分析"><a href="#6-3-风险分析" class="headerlink" title="6.3 风险分析"></a>6.3 风险分析</h3><h3 id="6-4-进度安排"><a href="#6-4-进度安排" class="headerlink" title="6.4 进度安排"></a>6.4 进度安排</h3><h3 id="6-5-项目组织与计划"><a href="#6-5-项目组织与计划" class="headerlink" title="6.5 项目组织与计划"></a>6.5 项目组织与计划</h3><h3 id="6-6-软件质量保证与分析"><a href="#6-6-软件质量保证与分析" class="headerlink" title="6.6 软件质量保证与分析"></a>6.6 软件质量保证与分析</h3><ul><li><p>影响软件质量的主要因素有哪些？</p><ul><li>产品运行：正确性、风险性、效率、完整性、健壮性和可用性；</li><li>产品修改：可理解性、可维护性、灵活性、可测试性；</li><li>产品转移：可移植性、可重用性和互运行性。</li></ul></li><li><p>如何做好软件质量保证工作？</p><p>软件质量保证工作是软件工程管理的重要内容，软件质量保证应做好以下几个方面的工作</p><ul><li>采用技术手段和工具。质量保证活动要贯彻开发过程始终，必须从采用技术手段和工具，尤其是使用软件开发环境来进行软件开发。</li><li>组织正式技术评审，在软件开发的第一个阶段结束时，都要组织正式的技术评审。国家标准要求单位必须采用审查、文档评审、设计评审、审计和测试等具体手段来保证质量。</li><li>加强软件测试。软件测试是质量保证的重要手段，因为测试可发现软件可发现软件中大多数潜在错误。</li><li>推选软件工程规范（标准）。用户可以自己指定软件工程规范（标准），但标准一旦确认就应贯彻执行。</li><li>对软件的变更进行控制。软件的修改和变更常常会引起潜伏的错误，因此必须严格控制软件的修改和变更。</li><li>对软件质量进行度量。即对软件质量进行跟踪，及时记录和报告软件质量情况。</li></ul></li></ul><p>基线是一个软件配置管理概念，它有助于人们在不严重合理变化的前提下来控制变化，简而言之，基线就是通过了正式复审的软件配置项。。在软件配置项变成基线之前，可以迅速而非正式地修改它。        </p><h2 id="七、参考书目"><a href="#七、参考书目" class="headerlink" title="七、参考书目"></a>七、参考书目</h2><ul><li>《软件工程：实践者的研究方法》（英文版，第7版），Roger  Pressman，机械工业出版社，2010年10月</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;整理目的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我还是认为基础知识不能丢，也是对以前知识的回顾。&lt;/li&gt;
&lt;li&gt;考研软件工程方向考软件工程这门学科的并不多，我选择了两所学校来进行整理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以中南大学944软件工程考试大纲和复旦961软件工程专业基础综合考试大纲为基础。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Study" scheme="https://mysticalguest.github.io/categories/Study/"/>
    
    
      <category term="计算机基础" scheme="https://mysticalguest.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>数字逻辑课程复习</title>
    <link href="https://mysticalguest.github.io/Study/60189.html"/>
    <id>https://mysticalguest.github.io/Study/60189.html</id>
    <published>2021-03-31T03:05:21.936Z</published>
    <updated>2021-04-08T13:02:52.446Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>考查目标</p><p>1、掌握逻辑代数的基础知识、基本概念及运算规律；</p><p>2、掌握半导体器件、门电路、组合逻辑、时序逻辑等电路基础知识、基本概念及工作原理；</p><p>3、掌握数字系统设计基本方法、逻辑函数优化实现及逻辑电路测试方法。</p><p>以西北工业大学801计算机专业基础为考纲，虽然当时考试未选这门课，但可以以此作为作为学习基础。</p></blockquote><a id="more"></a><h2 id="一、逻辑代数"><a href="#一、逻辑代数" class="headerlink" title="一、逻辑代数"></a>一、逻辑代数</h2><h3 id="1-1-逻辑代数的基本运算、基本定理、基本法则"><a href="#1-1-逻辑代数的基本运算、基本定理、基本法则" class="headerlink" title="1.1 逻辑代数的基本运算、基本定理、基本法则"></a>1.1 逻辑代数的基本运算、基本定理、基本法则</h3><h3 id="1-2-利用逻辑代数和卡诺图对逻辑函数进行转换与化简"><a href="#1-2-利用逻辑代数和卡诺图对逻辑函数进行转换与化简" class="headerlink" title="1.2 利用逻辑代数和卡诺图对逻辑函数进行转换与化简"></a>1.2 利用逻辑代数和卡诺图对逻辑函数进行转换与化简</h3><h3 id="1-3-各种形式的逻辑函数的相互转换方法"><a href="#1-3-各种形式的逻辑函数的相互转换方法" class="headerlink" title="1.3 各种形式的逻辑函数的相互转换方法"></a>1.3 各种形式的逻辑函数的相互转换方法</h3><h3 id="1-4-卡诺图化简方法"><a href="#1-4-卡诺图化简方法" class="headerlink" title="1.4 卡诺图化简方法"></a>1.4 卡诺图化简方法</h3><h3 id="1-5-不完全确定的逻辑函数的化简方法"><a href="#1-5-不完全确定的逻辑函数的化简方法" class="headerlink" title="1.5 不完全确定的逻辑函数的化简方法"></a>1.5 不完全确定的逻辑函数的化简方法</h3><h3 id="1-6-多输出逻辑函数的化简方法"><a href="#1-6-多输出逻辑函数的化简方法" class="headerlink" title="1.6 多输出逻辑函数的化简方法"></a>1.6 多输出逻辑函数的化简方法</h3><h2 id="二、门电路"><a href="#二、门电路" class="headerlink" title="二、门电路"></a>二、门电路</h2><h3 id="2-1-了解PN结的结构与原理，掌握PN结的伏安特性"><a href="#2-1-了解PN结的结构与原理，掌握PN结的伏安特性" class="headerlink" title="2.1 了解PN结的结构与原理，掌握PN结的伏安特性"></a>2.1 了解PN结的结构与原理，掌握PN结的伏安特性</h3><h3 id="2-2-掌握双极型晶体管和场效应晶体管的结构及工作原理"><a href="#2-2-掌握双极型晶体管和场效应晶体管的结构及工作原理" class="headerlink" title="2.2 掌握双极型晶体管和场效应晶体管的结构及工作原理"></a>2.2 掌握双极型晶体管和场效应晶体管的结构及工作原理</h3><h3 id="2-3-掌握CMOS门电路结构和工作原理；"><a href="#2-3-掌握CMOS门电路结构和工作原理；" class="headerlink" title="2.3 掌握CMOS门电路结构和工作原理；"></a>2.3 掌握CMOS门电路结构和工作原理；</h3><h3 id="2-4-掌握TTL门电路结构和工作原理"><a href="#2-4-掌握TTL门电路结构和工作原理" class="headerlink" title="2.4 掌握TTL门电路结构和工作原理"></a>2.4 掌握TTL门电路结构和工作原理</h3><h2 id="三、组合逻辑电路"><a href="#三、组合逻辑电路" class="headerlink" title="三、组合逻辑电路"></a>三、组合逻辑电路</h2><h3 id="3-1-掌握组合逻辑电路的分析方法"><a href="#3-1-掌握组合逻辑电路的分析方法" class="headerlink" title="3.1 掌握组合逻辑电路的分析方法"></a>3.1 掌握组合逻辑电路的分析方法</h3><h3 id="3-2-熟悉常用组合逻辑电路模块的结构和逻辑功能"><a href="#3-2-熟悉常用组合逻辑电路模块的结构和逻辑功能" class="headerlink" title="3.2 熟悉常用组合逻辑电路模块的结构和逻辑功能"></a>3.2 熟悉常用组合逻辑电路模块的结构和逻辑功能</h3><h3 id="3-3-掌握组合逻辑电路的设计过程"><a href="#3-3-掌握组合逻辑电路的设计过程" class="headerlink" title="3.3 掌握组合逻辑电路的设计过程"></a>3.3 掌握组合逻辑电路的设计过程</h3><h3 id="3-4-基于门电路的设计"><a href="#3-4-基于门电路的设计" class="headerlink" title="3.4 基于门电路的设计"></a>3.4 基于门电路的设计</h3><h3 id="3-5-基于常用组合逻辑电路模块的组合逻辑电路设计"><a href="#3-5-基于常用组合逻辑电路模块的组合逻辑电路设计" class="headerlink" title="3.5 基于常用组合逻辑电路模块的组合逻辑电路设计"></a>3.5 基于常用组合逻辑电路模块的组合逻辑电路设计</h3><h3 id="3-6-了解组合逻辑电路中的冒险现象及其消除方法"><a href="#3-6-了解组合逻辑电路中的冒险现象及其消除方法" class="headerlink" title="3.6 了解组合逻辑电路中的冒险现象及其消除方法"></a>3.6 了解组合逻辑电路中的冒险现象及其消除方法</h3><h2 id="四、触发器及时序逻辑电路"><a href="#四、触发器及时序逻辑电路" class="headerlink" title="四、触发器及时序逻辑电路"></a>四、触发器及时序逻辑电路</h2><h3 id="4-1-掌握常用触发器的结构和工作原理；"><a href="#4-1-掌握常用触发器的结构和工作原理；" class="headerlink" title="4.1 掌握常用触发器的结构和工作原理；"></a>4.1 掌握常用触发器的结构和工作原理；</h3><h3 id="4-2-掌握触发器的逻辑功能及描述方法；"><a href="#4-2-掌握触发器的逻辑功能及描述方法；" class="headerlink" title="4.2 掌握触发器的逻辑功能及描述方法；"></a>4.2 掌握触发器的逻辑功能及描述方法；</h3><h3 id="4-3-熟悉触发器及其简单应用电路；"><a href="#4-3-熟悉触发器及其简单应用电路；" class="headerlink" title="4.3 熟悉触发器及其简单应用电路；"></a>4.3 熟悉触发器及其简单应用电路；</h3><h3 id="4-4-掌握同步时序逻辑电路的分析和设计方法；"><a href="#4-4-掌握同步时序逻辑电路的分析和设计方法；" class="headerlink" title="4.4 掌握同步时序逻辑电路的分析和设计方法；"></a>4.4 掌握同步时序逻辑电路的分析和设计方法；</h3><h3 id="4-5-掌握异步时序电路的分析和设计方法；"><a href="#4-5-掌握异步时序电路的分析和设计方法；" class="headerlink" title="4.5 掌握异步时序电路的分析和设计方法；"></a>4.5 掌握异步时序电路的分析和设计方法；</h3><h3 id="4-6-掌握时序逻辑电路中的竞争-冒险现象和消除方法；"><a href="#4-6-掌握时序逻辑电路中的竞争-冒险现象和消除方法；" class="headerlink" title="4.6 掌握时序逻辑电路中的竞争-冒险现象和消除方法；"></a>4.6 掌握时序逻辑电路中的竞争-冒险现象和消除方法；</h3><h2 id="五、半导体存储器"><a href="#五、半导体存储器" class="headerlink" title="五、半导体存储器"></a>五、半导体存储器</h2><h3 id="5-1-掌握只读存储器结构和工作原理；"><a href="#5-1-掌握只读存储器结构和工作原理；" class="headerlink" title="5.1 掌握只读存储器结构和工作原理；"></a>5.1 掌握只读存储器结构和工作原理；</h3><h3 id="5-2-掌握随机存储器结构和工作原理；"><a href="#5-2-掌握随机存储器结构和工作原理；" class="headerlink" title="5.2 掌握随机存储器结构和工作原理；"></a>5.2 掌握随机存储器结构和工作原理；</h3><h3 id="5-3-掌握存储器容量扩展方法；"><a href="#5-3-掌握存储器容量扩展方法；" class="headerlink" title="5.3 掌握存储器容量扩展方法；"></a>5.3 掌握存储器容量扩展方法；</h3><h3 id="5-4-熟悉用存储器实现组合逻辑函数的方法；"><a href="#5-4-熟悉用存储器实现组合逻辑函数的方法；" class="headerlink" title="5.4 熟悉用存储器实现组合逻辑函数的方法；"></a>5.4 熟悉用存储器实现组合逻辑函数的方法；</h3><h2 id="六、可编程逻辑器件"><a href="#六、可编程逻辑器件" class="headerlink" title="六、可编程逻辑器件"></a>六、可编程逻辑器件</h2><h3 id="6-1-掌握复杂的可编程逻辑器件的结构和工作原理；"><a href="#6-1-掌握复杂的可编程逻辑器件的结构和工作原理；" class="headerlink" title="6.1 掌握复杂的可编程逻辑器件的结构和工作原理；"></a>6.1 掌握复杂的可编程逻辑器件的结构和工作原理；</h3><h3 id="6-2-掌握现场可编程逻辑阵列的基本结构、工作原理；"><a href="#6-2-掌握现场可编程逻辑阵列的基本结构、工作原理；" class="headerlink" title="6.2 掌握现场可编程逻辑阵列的基本结构、工作原理；"></a>6.2 掌握现场可编程逻辑阵列的基本结构、工作原理；</h3><h3 id="6-3-熟悉可编程逻辑器件的编程和数据下载方法；"><a href="#6-3-熟悉可编程逻辑器件的编程和数据下载方法；" class="headerlink" title="6.3 熟悉可编程逻辑器件的编程和数据下载方法；"></a>6.3 熟悉可编程逻辑器件的编程和数据下载方法；</h3><h2 id="七、Verilog硬件描述语言"><a href="#七、Verilog硬件描述语言" class="headerlink" title="七、Verilog硬件描述语言"></a>七、Verilog硬件描述语言</h2><h3 id="7-1-掌握Verilog基本程序结构；"><a href="#7-1-掌握Verilog基本程序结构；" class="headerlink" title="7.1 掌握Verilog基本程序结构；"></a>7.1 掌握Verilog基本程序结构；</h3><h3 id="7-2-掌握Verilog词法构成；"><a href="#7-2-掌握Verilog词法构成；" class="headerlink" title="7.2 掌握Verilog词法构成；"></a>7.2 掌握Verilog词法构成；</h3><h3 id="7-3-熟悉模块的描述方式；"><a href="#7-3-熟悉模块的描述方式；" class="headerlink" title="7.3 熟悉模块的描述方式；"></a>7.3 熟悉模块的描述方式；</h3><h3 id="7-4-掌握采用Verilog描述简单的组合逻辑电路和时序逻辑电路；"><a href="#7-4-掌握采用Verilog描述简单的组合逻辑电路和时序逻辑电路；" class="headerlink" title="7.4 掌握采用Verilog描述简单的组合逻辑电路和时序逻辑电路；"></a>7.4 掌握采用Verilog描述简单的组合逻辑电路和时序逻辑电路；</h3><h2 id="八、脉冲波形的产生和整形"><a href="#八、脉冲波形的产生和整形" class="headerlink" title="八、脉冲波形的产生和整形"></a>八、脉冲波形的产生和整形</h2><h3 id="8-1-掌握施密特触发器的结构和工作原理；"><a href="#8-1-掌握施密特触发器的结构和工作原理；" class="headerlink" title="8.1 掌握施密特触发器的结构和工作原理；"></a>8.1 掌握施密特触发器的结构和工作原理；</h3><h3 id="8-2-掌握单稳态触发器类型、结构和工作原理；"><a href="#8-2-掌握单稳态触发器类型、结构和工作原理；" class="headerlink" title="8.2 掌握单稳态触发器类型、结构和工作原理；"></a>8.2 掌握单稳态触发器类型、结构和工作原理；</h3><h3 id="8-3-掌握多谐振荡器类型、结构和工作原理；"><a href="#8-3-掌握多谐振荡器类型、结构和工作原理；" class="headerlink" title="8.3 掌握多谐振荡器类型、结构和工作原理；"></a>8.3 掌握多谐振荡器类型、结构和工作原理；</h3><h3 id="8-4-熟悉555定时器及其应用；"><a href="#8-4-熟悉555定时器及其应用；" class="headerlink" title="8.4 熟悉555定时器及其应用；"></a>8.4 熟悉555定时器及其应用；</h3><h2 id="九、逻辑电路测试"><a href="#九、逻辑电路测试" class="headerlink" title="九、逻辑电路测试"></a>九、逻辑电路测试</h2><h3 id="9-1-掌握容错模型"><a href="#9-1-掌握容错模型" class="headerlink" title="9.1 掌握容错模型"></a>9.1 掌握容错模型</h3><h3 id="9-2-掌握树形结构电路；"><a href="#9-2-掌握树形结构电路；" class="headerlink" title="9.2 掌握树形结构电路；"></a>9.2 掌握树形结构电路；</h3><h3 id="9-3-掌握随机测试方法；"><a href="#9-3-掌握随机测试方法；" class="headerlink" title="9.3 掌握随机测试方法；"></a>9.3 掌握随机测试方法；</h3><h3 id="9-4-掌握时序电路测试方法；"><a href="#9-4-掌握时序电路测试方法；" class="headerlink" title="9.4 掌握时序电路测试方法；"></a>9.4 掌握时序电路测试方法；</h3><h3 id="9-5-掌握内建自测试方法；"><a href="#9-5-掌握内建自测试方法；" class="headerlink" title="9.5 掌握内建自测试方法；"></a>9.5 掌握内建自测试方法；</h3><h2 id="十、参考书目"><a href="#十、参考书目" class="headerlink" title="十、参考书目"></a>十、参考书目</h2><ul><li>《数字电子技术基础》（第5版），阎石，高等教育出版社，2011年。</li><li>《数字逻辑与Verilog设计》（第3版），(美)布朗(Stephen Brown)，(美)弗兰民斯克(Zvonko Vran)，罗荣选译，清华大学出版社，2014年。  </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;考查目标&lt;/p&gt;
&lt;p&gt;1、掌握逻辑代数的基础知识、基本概念及运算规律；&lt;/p&gt;
&lt;p&gt;2、掌握半导体器件、门电路、组合逻辑、时序逻辑等电路基础知识、基本概念及工作原理；&lt;/p&gt;
&lt;p&gt;3、掌握数字系统设计基本方法、逻辑函数优化实现及逻辑电路测试方法。&lt;/p&gt;
&lt;p&gt;以西北工业大学801计算机专业基础为考纲，虽然当时考试未选这门课，但可以以此作为作为学习基础。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Study" scheme="https://mysticalguest.github.io/categories/Study/"/>
    
    
      <category term="计算机基础" scheme="https://mysticalguest.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>操作系统课程复习</title>
    <link href="https://mysticalguest.github.io/Study/4919.html"/>
    <id>https://mysticalguest.github.io/Study/4919.html</id>
    <published>2021-03-31T03:02:35.511Z</published>
    <updated>2021-04-19T10:13:44.983Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>考查目标：</p><ol><li><strong>掌握</strong>操作系统的基本概念、基本原理和基本功能，理解操作系统的整体运行过程。</li><li><p><strong>掌握</strong>操作系统进程、内存、文件和I/O管理的策略、算法、机制以及相互关系。</p></li><li><p>能够运用所学的操作系统原理、方法与技术分析问题和解决问题，并能利用C语言或其他高级语言描述相关算法。 </p></li></ol><p>以西北工业大学801计算机专业基础为考纲，虽然当时考试未选这门课，但可以以此作为作为学习基础。</p></blockquote><a id="more"></a><h2 id="一、操作系统概述"><a href="#一、操作系统概述" class="headerlink" title="一、操作系统概述"></a>一、操作系统概述</h2><h3 id="1-1-操作系统的概念、特征、功能和提供的服务"><a href="#1-1-操作系统的概念、特征、功能和提供的服务" class="headerlink" title="1.1 操作系统的概念、特征、功能和提供的服务"></a>1.1 操作系统的概念、特征、功能和提供的服务</h3><h3 id="1-2-操作系统的发展与分类"><a href="#1-2-操作系统的发展与分类" class="headerlink" title="1.2 操作系统的发展与分类"></a>1.2 操作系统的发展与分类</h3><h3 id="1-3-操作系统的运行环境"><a href="#1-3-操作系统的运行环境" class="headerlink" title="1.3 操作系统的运行环境"></a>1.3 操作系统的运行环境</h3><p>（内核态与用户态、中断、异常、系统调用）</p><h3 id="1-4-操作系统体系结构"><a href="#1-4-操作系统体系结构" class="headerlink" title="1.4 操作系统体系结构"></a>1.4 操作系统体系结构</h3><h2 id="二、进程管理"><a href="#二、进程管理" class="headerlink" title="二、进程管理"></a>二、进程管理</h2><h3 id="2-1-进程与线程"><a href="#2-1-进程与线程" class="headerlink" title="2.1 进程与线程"></a>2.1 进程与线程</h3><h4 id="2-1-1-进程概念、进程的状态与转换、进程控制、进程组织"><a href="#2-1-1-进程概念、进程的状态与转换、进程控制、进程组织" class="headerlink" title="2.1.1 进程概念、进程的状态与转换、进程控制、进程组织"></a>2.1.1 进程概念、进程的状态与转换、进程控制、进程组织</h4><h4 id="2-1-2-进程通信"><a href="#2-1-2-进程通信" class="headerlink" title="2.1.2 进程通信"></a>2.1.2 进程通信</h4><p>（共享存储、消息传递、、信箱通信、管道通信）</p><h4 id="2-1-3-线程概念与多线程模型"><a href="#2-1-3-线程概念与多线程模型" class="headerlink" title="2.1.3 线程概念与多线程模型"></a>2.1.3 线程概念与多线程模型</h4><h3 id="2-2-处理机调度"><a href="#2-2-处理机调度" class="headerlink" title="2.2 处理机调度"></a>2.2 处理机调度</h3><h4 id="2-2-1-调度的基本概念，调度的基本准则，调度时机、切换与过程、调度方式"><a href="#2-2-1-调度的基本概念，调度的基本准则，调度时机、切换与过程、调度方式" class="headerlink" title="2.2.1 调度的基本概念，调度的基本准则，调度时机、切换与过程、调度方式"></a>2.2.1 调度的基本概念，调度的基本准则，调度时机、切换与过程、调度方式</h4><h4 id="2-2-2-典型调度算法"><a href="#2-2-2-典型调度算法" class="headerlink" title="2.2.2 典型调度算法"></a>2.2.2 典型调度算法</h4><p>先来先服务、短作业（短进程、短线程）优先、时间片轮转、优先级、最高响应比优先、多级反馈队列调度算法</p><h3 id="2-3-进程同步与互斥"><a href="#2-3-进程同步与互斥" class="headerlink" title="2.3 进程同步与互斥"></a>2.3 进程同步与互斥</h3><h4 id="2-3-1-进程同步的基本概念"><a href="#2-3-1-进程同步的基本概念" class="headerlink" title="2.3.1 进程同步的基本概念"></a>2.3.1 进程同步的基本概念</h4><h4 id="2-3-2-实现临界区互斥的基本方法：软件实现方法、硬件实现方法"><a href="#2-3-2-实现临界区互斥的基本方法：软件实现方法、硬件实现方法" class="headerlink" title="2.3.2 实现临界区互斥的基本方法：软件实现方法、硬件实现方法"></a>2.3.2 实现临界区互斥的基本方法：软件实现方法、硬件实现方法</h4><h4 id="2-3-3-信号量、管程"><a href="#2-3-3-信号量、管程" class="headerlink" title="2.3.3 信号量、管程"></a>2.3.3 信号量、管程</h4><h4 id="2-3-4-经典同步问题：生产者-消费者问题、读者-写者问题、哲学家进餐问题等"><a href="#2-3-4-经典同步问题：生产者-消费者问题、读者-写者问题、哲学家进餐问题等" class="headerlink" title="2.3.4 经典同步问题：生产者-消费者问题、读者-写者问题、哲学家进餐问题等"></a>2.3.4 经典同步问题：生产者-消费者问题、读者-写者问题、哲学家进餐问题等</h4><h3 id="2-4-死锁"><a href="#2-4-死锁" class="headerlink" title="2.4 死锁"></a>2.4 死锁</h3><h4 id="2-4-1-死锁的概念、死锁处理策略"><a href="#2-4-1-死锁的概念、死锁处理策略" class="headerlink" title="2.4.1 死锁的概念、死锁处理策略"></a>2.4.1 死锁的概念、死锁处理策略</h4><h4 id="2-4-2-死锁预防"><a href="#2-4-2-死锁预防" class="headerlink" title="2.4.2 死锁预防"></a>2.4.2 死锁预防</h4><h4 id="2-4-3-死锁避免：系统安全状态、银行家算法"><a href="#2-4-3-死锁避免：系统安全状态、银行家算法" class="headerlink" title="2.4.3 死锁避免：系统安全状态、银行家算法"></a>2.4.3 死锁避免：系统安全状态、银行家算法</h4><h4 id="2-4-4-死锁检测和解除"><a href="#2-4-4-死锁检测和解除" class="headerlink" title="2.4.4 死锁检测和解除"></a>2.4.4 死锁检测和解除</h4><h2 id="三、内存管理"><a href="#三、内存管理" class="headerlink" title="三、内存管理"></a>三、内存管理</h2><h3 id="3-1-内存管理基础"><a href="#3-1-内存管理基础" class="headerlink" title="3.1 内存管理基础"></a>3.1 内存管理基础</h3><p>程序执行前<strong>需要先放到内存中才能被CPU处理</strong>——缓和CPU与硬件之间的速度矛盾。</p><ul><li><p>给内存的存储单元编地址</p><p>每个地址对应一个存储单元</p></li></ul><div class="table-container"><table><thead><tr><th>按字节编址</th><th>按字编址（设字长16位）</th></tr></thead><tbody><tr><td>每个存储单元大小为1字节</td><td>每个存储单元大小为1个字</td></tr><tr><td>1B，即8个二进制位</td><td>16个二进制位</td></tr><tr><td>字节是寻址的最小单位</td><td>字长是计算机一次处理数据的最大单位</td></tr></tbody></table></div><ul><li><p>补充知识</p><script type="math/tex; mode=display">2^{10}=1K, 2^{20}=1M, 2^{30}=1G</script></li><li><p>指令的工作原理</p><p>指令的工作基于‘地址’。每个地址对应一个数据的存储单元。</p><p>我们写的代码要翻译成CPU能识别的指令，这些指令会告诉CPU应该去内存的哪个地址读写数据。（所以引入程序装入？）</p></li></ul><h4 id="3-1-1-内存管理概念"><a href="#3-1-1-内存管理概念" class="headerlink" title="3.1.1 内存管理概念"></a>3.1.1 内存管理概念</h4><ul><li><p>内存空间的分配与回收</p><ul><li>连续分配管理方式</li><li>非连续分配管理方式</li></ul></li><li><p>内存空间的扩充</p><ul><li>覆盖技术（解决“程序大小超过物理内存总和”的问题）</li><li>交换（对换）技术</li><li>虚拟存储技术</li></ul></li><li><p>地址转换</p><blockquote><p><strong>逻辑地址到物理地址</strong>的转换（这个过程称为<strong>地址重定位</strong>，有3种装入方式）应该有操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。</p></blockquote></li><li><p>存储保护（内存保护），保证各进程在各自存储空间内运行，互不干扰</p><p>内存保护可采取两种方法：</p><ul><li>方法一：在CPU中<strong>设置一对上、下限寄存器</strong>，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。</li><li>方法二：采用<strong>重定位寄存器</strong>（又称<strong>基址寄存器</strong>）和<strong>界地址寄存器</strong>（又称<strong>限长寄存器</strong>）进行越界检查。重定位寄存器中存放的是进程的<strong>起始物理地址</strong>。界地址寄存器中存放的是进程的<strong>最大逻辑地址</strong>。</li></ul></li></ul><h4 id="3-1-2-程序装入与链接、逻辑地址与物理地址空间、内存保护"><a href="#3-1-2-程序装入与链接、逻辑地址与物理地址空间、内存保护" class="headerlink" title="3.1.2 程序装入与链接、逻辑地址与物理地址空间、内存保护"></a>3.1.2 程序装入与链接、逻辑地址与物理地址空间、内存保护</h4><ul><li>装入的三种方式</li></ul><div class="table-container"><table><thead><tr><th>方式</th><th>内容</th><th>特点</th><th>区别</th></tr></thead><tbody><tr><td>绝对装入</td><td>在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。</td><td>只适用于单道程序环境</td><td>程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。</td></tr><tr><td>静态重定位（可重定位装入）</td><td>编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的<strong>逻辑地址</strong>。根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）</td><td>在一个作业装入内存时，<strong>必须分配其要求的全部内存空间</strong>，如果没有足够的内存，就不能装入该作业。<br />用于早期的多道批处理操作系统</td><td>作业一旦进入内存后，在运行期间就不能移动，也不能再申请内存空间。</td></tr><tr><td>动态重定位（动态运行时装入）</td><td>编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是<strong>把地址转换推迟到程序真正要执行时才进行</strong>。因此装入内存后所有的地址依然是逻辑地址。</td><td>需要一个<strong>重定位寄存器</strong>的支持，用来装入模块存放的<strong>起始位置</strong>。<br />现代操作系统</td><td><strong>允许程序在内存中发生移动</strong>。并且可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，可动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间</td></tr></tbody></table></div><ul><li><p>编译</p><p>由编译程序将用户源代码编译成若干个<strong>目标模块</strong>（将高级语言翻译为机器语言）</p></li><li><p>链接</p><p>由<strong>链接程序</strong>将编译后形成的一组<strong>目标模块</strong>，以及所需库函数链接在一起，形成一个完整的<strong>装入模块</strong></p></li><li><p>装入（装载）</p><p>由<strong>装入程序</strong>将装入模块装入内存运行</p></li><li><p>链接的三种方式</p></li></ul><div class="table-container"><table><thead><tr><th>方式</th><th>内容</th></tr></thead><tbody><tr><td>静态链接</td><td>在程序运行之前，先将各目标模块及它们所需的库函数连接成一个<strong>完整</strong>的可执行文件（装入模块），之后不在拆开</td></tr><tr><td>装入时动态链接将</td><td>将各目标模块装入内存时，边装入边链接。（在内存中连续吗？）</td></tr><tr><td>运行时动态链接</td><td>在程序执行中<strong>需要</strong>该目标模块<strong>时</strong>，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。（如何共享？）</td></tr></tbody></table></div><h4 id="3-1-3-交换与覆盖"><a href="#3-1-3-交换与覆盖" class="headerlink" title="3.1.3 交换与覆盖"></a>3.1.3 交换与覆盖</h4><ul><li><p>覆盖技术（解决“程序大小超过物理内存总和”的问题）</p><p>思想：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。</p><p>内存中分为一个“固定区”和若干个“覆盖区”。</p><p>需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）；不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存。</p><blockquote><p>按照自身逻辑结构，让那些不可能同时被访问的程序段共享同一个覆盖区。必须由程序员声明覆盖结构，操作系统完成西大覆盖。缺点：对用户不透明，增加了用户编程复旦。覆盖技术只用于早期的操所系统。</p></blockquote></li><li><p>交换（对换）技术</p><p>思想：内存空间紧张时，系统将内存中某些进程暂时<strong>换出</strong>外存，把外存中某些已具备运行条件的进程<strong>换入</strong>内存（进程在内存与磁盘间动态调度）</p><p>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。</p><p>暂时换出外存等待的进程状态为<strong>挂起状态（Suspend）</strong>，挂起态又可以进一步细分为<strong>就绪挂起、阻塞挂起</strong>两种状态。</p><p><code>应该在外存（磁盘）的什么位置保存被换出的进程？</code></p><blockquote><p>具有对换功能的操作系统中，通常把磁盘空间分为<strong>文件区</strong>和<strong>对换区</strong>两部分。<strong>文件区</strong>主要用于存放文件，<strong>主要追求存储空间的利用率</strong>，因此对文件区空间的管理<strong>采用离散分配方式</strong>；<strong>对换区</strong>空间只占磁盘空间的小部分，<strong>被换出的进程数据就存放在对换区</strong>。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理<strong>主要追求换入换出速度</strong>，因此通常对换区<strong>采用连续分配方式</strong>（学过文件管理章节后即可理解）。总之，<strong>对换区的I/O速度比文件区的更快</strong>。</p></blockquote><p><code>什么时候应该交换？</code></p><blockquote><p>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程：如果缺页率明显下降，就可以暂停换出。</p></blockquote><p><code>应该换出哪些进程？</code></p><blockquote><p>可优先换出阻塞进程；可换出优先级低的进程：为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间。（注意：<strong>PCB会常驻内存</strong>，不会被换出外存）</p></blockquote></li></ul><h4 id="3-1-4-连续分配管理方式"><a href="#3-1-4-连续分配管理方式" class="headerlink" title="3.1.4 连续分配管理方式"></a>3.1.4 连续分配管理方式</h4><p>连续分配：指为用户进程分配的必须是一个连续的内存空间。</p><ul><li><p>单一连续分配</p></li><li><p>固定分区分配</p></li><li><p>动态分区分配</p><p>动态分区分配算法</p><ul><li>首次适应算法（First Fit）</li><li>最佳适应算法（Best Fit）</li><li>最坏适应算法（Worst Fit）</li><li>邻近适应算法（Next Fit）</li></ul></li></ul><h4 id="3-1-5-非连续（离散）分配管理方式"><a href="#3-1-5-非连续（离散）分配管理方式" class="headerlink" title="3.1.5 非连续（离散）分配管理方式"></a>3.1.5 非连续（离散）分配管理方式</h4><p>分页管理方式、分段管理方式、段页式管理方式</p><ul><li>基本分页存储管理的基本概念</li><li>基本分段存储管理</li><li>段页式存储管理</li></ul><h3 id="3-2-虚拟内存管理"><a href="#3-2-虚拟内存管理" class="headerlink" title="3.2 虚拟内存管理"></a>3.2 虚拟内存管理</h3><h4 id="3-2-1-虚拟内存基本概念"><a href="#3-2-1-虚拟内存基本概念" class="headerlink" title="3.2.1 虚拟内存基本概念"></a>3.2.1 虚拟内存基本概念</h4><h4 id="3-2-2-请求分页管理方式"><a href="#3-2-2-请求分页管理方式" class="headerlink" title="3.2.2 请求分页管理方式"></a>3.2.2 请求分页管理方式</h4><h4 id="3-2-3-页面置换算法"><a href="#3-2-3-页面置换算法" class="headerlink" title="3.2.3 页面置换算法"></a>3.2.3 页面置换算法</h4><p>最佳置换算法（OPT）、先进先出置换算法（FIFO）、最近最少使用置换算法（LRU）、时钟置换算法（CLOCK）等</p><h4 id="3-2-4-页面分配策略"><a href="#3-2-4-页面分配策略" class="headerlink" title="3.2.4 页面分配策略"></a>3.2.4 页面分配策略</h4><h4 id="3-2-5-工作集、抖动"><a href="#3-2-5-工作集、抖动" class="headerlink" title="3.2.5 工作集、抖动"></a>3.2.5 工作集、抖动</h4><h2 id="四、文件管理"><a href="#四、文件管理" class="headerlink" title="四、文件管理"></a>四、文件管理</h2><h3 id="4-1-文件系统基础"><a href="#4-1-文件系统基础" class="headerlink" title="4.1 文件系统基础"></a>4.1 文件系统基础</h3><h4 id="4-1-1-文件概念、文件的逻辑结构"><a href="#4-1-1-文件概念、文件的逻辑结构" class="headerlink" title="4.1.1 文件概念、文件的逻辑结构"></a>4.1.1 文件概念、文件的逻辑结构</h4><h4 id="4-1-2-文件的结构：顺序文件、索引文件、索引顺序文件"><a href="#4-1-2-文件的结构：顺序文件、索引文件、索引顺序文件" class="headerlink" title="4.1.2 文件的结构：顺序文件、索引文件、索引顺序文件"></a>4.1.2 文件的结构：顺序文件、索引文件、索引顺序文件</h4><h4 id="4-1-3-目录结构：文件控制块和索引节点，单级、两级和树形目录结构，图形目录结构"><a href="#4-1-3-目录结构：文件控制块和索引节点，单级、两级和树形目录结构，图形目录结构" class="headerlink" title="4.1.3 目录结构：文件控制块和索引节点，单级、两级和树形目录结构，图形目录结构"></a>4.1.3 目录结构：文件控制块和索引节点，单级、两级和树形目录结构，图形目录结构</h4><h4 id="4-1-4-文件共享"><a href="#4-1-4-文件共享" class="headerlink" title="4.1.4 文件共享"></a>4.1.4 文件共享</h4><h4 id="4-1-5-文件保护：访问类型、访问控制"><a href="#4-1-5-文件保护：访问类型、访问控制" class="headerlink" title="4.1.5 文件保护：访问类型、访问控制"></a>4.1.5 文件保护：访问类型、访问控制</h4><h3 id="4-2-文件系统实现"><a href="#4-2-文件系统实现" class="headerlink" title="4.2 文件系统实现"></a>4.2 文件系统实现</h3><h4 id="4-2-1-文件系统层次结构"><a href="#4-2-1-文件系统层次结构" class="headerlink" title="4.2.1 文件系统层次结构"></a>4.2.1 文件系统层次结构</h4><h4 id="4-2-2-目录实现"><a href="#4-2-2-目录实现" class="headerlink" title="4.2.2 目录实现"></a>4.2.2 目录实现</h4><h4 id="4-2-3-文件实现"><a href="#4-2-3-文件实现" class="headerlink" title="4.2.3 文件实现"></a>4.2.3 文件实现</h4><h3 id="4-3-磁盘组织与管理"><a href="#4-3-磁盘组织与管理" class="headerlink" title="4.3 磁盘组织与管理"></a>4.3 磁盘组织与管理</h3><h4 id="4-3-1-磁盘的结构"><a href="#4-3-1-磁盘的结构" class="headerlink" title="4.3.1 磁盘的结构"></a>4.3.1 磁盘的结构</h4><h4 id="4-3-2-磁盘调度算法"><a href="#4-3-2-磁盘调度算法" class="headerlink" title="4.3.2 磁盘调度算法"></a>4.3.2 磁盘调度算法</h4><p>先来先服务（FCFS）、最短寻道时间优先（SSTF）、电梯算法（SCAN）</p><h4 id="4-3-3-磁盘的管理"><a href="#4-3-3-磁盘的管理" class="headerlink" title="4.3.3.磁盘的管理"></a>4.3.3.磁盘的管理</h4><h2 id="五、输入输出（I-O）管理"><a href="#五、输入输出（I-O）管理" class="headerlink" title="五、输入输出（I/O）管理"></a>五、输入输出（I/O）管理</h2><h3 id="5-1-I-O管理概述"><a href="#5-1-I-O管理概述" class="headerlink" title="5.1 I/O管理概述"></a>5.1 I/O管理概述</h3><h4 id="5-1-1-I-O控制方式"><a href="#5-1-1-I-O控制方式" class="headerlink" title="5.1.1 I/O控制方式"></a>5.1.1 I/O控制方式</h4><h4 id="5-1-2-I-O软件层次结构"><a href="#5-1-2-I-O软件层次结构" class="headerlink" title="5.1.2 I/O软件层次结构"></a>5.1.2 I/O软件层次结构</h4><h3 id="5-2-I-O核心子系统"><a href="#5-2-I-O核心子系统" class="headerlink" title="5.2 I/O核心子系统"></a>5.2 I/O核心子系统</h3><h4 id="5-2-1-I-O调度概念"><a href="#5-2-1-I-O调度概念" class="headerlink" title="5.2.1 I/O调度概念"></a>5.2.1 I/O调度概念</h4><h4 id="5-2-2-出错处理"><a href="#5-2-2-出错处理" class="headerlink" title="5.2.2 出错处理"></a>5.2.2 出错处理</h4><h4 id="5-2-3-高速缓存与缓冲区"><a href="#5-2-3-高速缓存与缓冲区" class="headerlink" title="5.2.3 高速缓存与缓冲区"></a>5.2.3 高速缓存与缓冲区</h4><h4 id="5-2-4-假脱机技术（SPOOLing）"><a href="#5-2-4-假脱机技术（SPOOLing）" class="headerlink" title="5.2.4 假脱机技术（SPOOLing）"></a>5.2.4 假脱机技术（SPOOLing）</h4><h3 id="5-3-设备分配与回收"><a href="#5-3-设备分配与回收" class="headerlink" title="5.3 设备分配与回收"></a>5.3 设备分配与回收</h3><h2 id="六、参考书目"><a href="#六、参考书目" class="headerlink" title="六、参考书目"></a>六、参考书目</h2><ul><li><p>《计算机操作系统》汤子瀛等主编 西安电子科技大学出版社；</p></li><li><p>《操作系统教程》徐甲同、陆丽娜等编 西安电子科技大学出版社。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;考查目标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;掌握&lt;/strong&gt;操作系统的基本概念、基本原理和基本功能，理解操作系统的整体运行过程。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;掌握&lt;/strong&gt;操作系统进程、内存、文件和I/O管理的策略、算法、机制以及相互关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;能够运用所学的操作系统原理、方法与技术分析问题和解决问题，并能利用C语言或其他高级语言描述相关算法。 &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以西北工业大学801计算机专业基础为考纲，虽然当时考试未选这门课，但可以以此作为作为学习基础。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Study" scheme="https://mysticalguest.github.io/categories/Study/"/>
    
    
      <category term="计算机基础" scheme="https://mysticalguest.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理课程复习</title>
    <link href="https://mysticalguest.github.io/Study/57764.html"/>
    <id>https://mysticalguest.github.io/Study/57764.html</id>
    <published>2021-03-31T02:57:32.012Z</published>
    <updated>2021-04-08T13:04:02.130Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>考查目标</p><ol><li><p>深入理解单处理器计算机系统的组织结构、工作原理、互连结构，具有完整的计算机系统整机的概念；</p></li><li><p>掌握各部件的组成结构、工作原理、软硬件设计的舍取、以及硬件实现；</p></li><li><p>综合运用计算机组成的基本原理和基本方法，对有关计算机硬件系统中的理论和实际问题进行计算、分析，并能对一些基本部件进行逻辑设计。</p></li></ol><p>以西北工业大学801计算机专业基础为考纲，虽然当时考试未选这门课，但可以以此作为作为学习基础。</p></blockquote><a id="more"></a><h2 id="一、总线"><a href="#一、总线" class="headerlink" title="一、总线"></a>一、总线</h2><h3 id="1-1-总线的组成、分类、特性和性能指标"><a href="#1-1-总线的组成、分类、特性和性能指标" class="headerlink" title="1.1 总线的组成、分类、特性和性能指标"></a>1.1 总线的组成、分类、特性和性能指标</h3><h3 id="1-2-总线的层次结构"><a href="#1-2-总线的层次结构" class="headerlink" title="1.2 总线的层次结构"></a>1.2 总线的层次结构</h3><h3 id="1-3-总线定时、传送、仲裁"><a href="#1-3-总线定时、传送、仲裁" class="headerlink" title="1.3 总线定时、传送、仲裁"></a>1.3 总线定时、传送、仲裁</h3><h2 id="二、内存储器"><a href="#二、内存储器" class="headerlink" title="二、内存储器"></a>二、内存储器</h2><h3 id="2-1-存储器的基本概念、分类、层次结构"><a href="#2-1-存储器的基本概念、分类、层次结构" class="headerlink" title="2.1 存储器的基本概念、分类、层次结构"></a>2.1 存储器的基本概念、分类、层次结构</h3><h3 id="2-2-半导体主存储器"><a href="#2-2-半导体主存储器" class="headerlink" title="2.2 半导体主存储器"></a>2.2 半导体主存储器</h3><h3 id="2-3-高速缓冲存储器（Cache）"><a href="#2-3-高速缓冲存储器（Cache）" class="headerlink" title="2.3 高速缓冲存储器（Cache）"></a>2.3 高速缓冲存储器（Cache）</h3><h3 id="2-4-差错检测。"><a href="#2-4-差错检测。" class="headerlink" title="2.4 差错检测。"></a>2.4 差错检测。</h3><h2 id="三、输入-输出"><a href="#三、输入-输出" class="headerlink" title="三、输入/输出"></a>三、输入/输出</h2><h3 id="3-1-I-O编制的方法"><a href="#3-1-I-O编制的方法" class="headerlink" title="3.1 I/O编制的方法"></a>3.1 I/O编制的方法</h3><h3 id="3-2-编程I-O"><a href="#3-2-编程I-O" class="headerlink" title="3.2 编程I/O"></a>3.2 编程I/O</h3><h3 id="3-3-程序中断"><a href="#3-3-程序中断" class="headerlink" title="3.3 程序中断"></a>3.3 程序中断</h3><h3 id="3-4-DMA的原理及控制机制。"><a href="#3-4-DMA的原理及控制机制。" class="headerlink" title="3.4 DMA的原理及控制机制。"></a>3.4 DMA的原理及控制机制。</h3><h2 id="四、运算方法与运算器"><a href="#四、运算方法与运算器" class="headerlink" title="四、运算方法与运算器"></a>四、运算方法与运算器</h2><h3 id="4-1-计算机中的数制系统"><a href="#4-1-计算机中的数制系统" class="headerlink" title="4.1 计算机中的数制系统"></a>4.1 计算机中的数制系统</h3><h3 id="4-2-数的表示方法"><a href="#4-2-数的表示方法" class="headerlink" title="4.2 数的表示方法"></a>4.2 数的表示方法</h3><h3 id="4-3-定点数四则运算方法"><a href="#4-3-定点数四则运算方法" class="headerlink" title="4.3 定点数四则运算方法"></a>4.3 定点数四则运算方法</h3><h3 id="4-4-浮点数四则运算方法"><a href="#4-4-浮点数四则运算方法" class="headerlink" title="4.4 浮点数四则运算方法"></a>4.4 浮点数四则运算方法</h3><h3 id="4-5-定点加减法器设计。"><a href="#4-5-定点加减法器设计。" class="headerlink" title="4.5 定点加减法器设计。"></a>4.5 定点加减法器设计。</h3><h2 id="五、指令系统"><a href="#五、指令系统" class="headerlink" title="五、指令系统"></a>五、指令系统</h2><h3 id="5-1-指令格式"><a href="#5-1-指令格式" class="headerlink" title="5.1 指令格式"></a>5.1 指令格式</h3><h3 id="5-2-数据类型"><a href="#5-2-数据类型" class="headerlink" title="5.2 数据类型"></a>5.2 数据类型</h3><h3 id="5-3-寻址方式"><a href="#5-3-寻址方式" class="headerlink" title="5.3 寻址方式"></a>5.3 寻址方式</h3><h3 id="5-4-指令类型"><a href="#5-4-指令类型" class="headerlink" title="5.4 指令类型"></a>5.4 指令类型</h3><h3 id="5-5-指令系统设计与优化。"><a href="#5-5-指令系统设计与优化。" class="headerlink" title="5.5 指令系统设计与优化。"></a>5.5 指令系统设计与优化。</h3><h2 id="六、处理器技术"><a href="#六、处理器技术" class="headerlink" title="六、处理器技术"></a>六、处理器技术</h2><h3 id="6-1-CPU的结构"><a href="#6-1-CPU的结构" class="headerlink" title="6.1 CPU的结构"></a>6.1 CPU的结构</h3><h3 id="6-2-CPU中的寄存器组织"><a href="#6-2-CPU中的寄存器组织" class="headerlink" title="6.2 CPU中的寄存器组织"></a>6.2 CPU中的寄存器组织</h3><h3 id="6-3-控制器的结构和工作原理"><a href="#6-3-控制器的结构和工作原理" class="headerlink" title="6.3 控制器的结构和工作原理"></a>6.3 控制器的结构和工作原理</h3><h3 id="6-4-微程序设计技术。"><a href="#6-4-微程序设计技术。" class="headerlink" title="6.4 微程序设计技术。"></a>6.4 微程序设计技术。</h3><h2 id="七、参考书目"><a href="#七、参考书目" class="headerlink" title="七、参考书目"></a>七、参考书目</h2><ul><li><p>唐朔飞编著.计算机组成原理（第二版）.高等教育出版社，2008</p></li><li><p>白中英主编.计算机组成原理（第四版）.科学出版社，2009</p></li><li><p>蒋本珊编著.计算机组成原理（第二版）.清华大学出版社，2008</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;考查目标&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;深入理解单处理器计算机系统的组织结构、工作原理、互连结构，具有完整的计算机系统整机的概念；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;掌握各部件的组成结构、工作原理、软硬件设计的舍取、以及硬件实现；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;综合运用计算机组成的基本原理和基本方法，对有关计算机硬件系统中的理论和实际问题进行计算、分析，并能对一些基本部件进行逻辑设计。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以西北工业大学801计算机专业基础为考纲，虽然当时考试未选这门课，但可以以此作为作为学习基础。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Study" scheme="https://mysticalguest.github.io/categories/Study/"/>
    
    
      <category term="计算机基础" scheme="https://mysticalguest.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>尘埃落定</title>
    <link href="https://mysticalguest.github.io/Study/29260.html"/>
    <id>https://mysticalguest.github.io/Study/29260.html</id>
    <published>2021-03-30T01:45:04.270Z</published>
    <updated>2021-04-08T13:04:32.991Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>阶段总结：</p><ol><li>从20年9月底开始，到12月22号，进入西工大考场。</li><li>从12月23号下午五点放下手中的笔走出考场，到21年2月27号早上9点出成绩。</li><li>从等到3月25号西工大官网出计算机学院院线，到28号中午接到华南师大的复试通知。</li><li>从29号早上8点面试，11点结束，到29号晚上7点接到研招网的待录取通知。</li></ol><p>结束后停下来整理一下自己，总结分享经验</p></blockquote><a id="more"></a><h2 id="1-等成绩"><a href="#1-等成绩" class="headerlink" title="1.等成绩"></a>1.等成绩</h2><p>考研的点点滴滴就没有必要分享啥经验了，我其实开始复习挺晚的9月底才开始，也是因为个人原因，加之疫情影响，自己在家总是没有足够的约束力来逼迫自己复习。也是匆忙选择了一个学校。</p><h3 id="择校"><a href="#择校" class="headerlink" title="择校"></a>择校</h3><ul><li>目标院校（985，211，顶尖双非也是不错的选择，北上广深）</li><li>考学硕（数一英一）还是香啊，专业课2最好选择统考学科，特别是好调剂，研究所也是只收学术型硕士，深有体会。比如好多学校计算机调剂只接受408</li><li>有些学校保一志愿，有的不管的，比如北京的好多学校调剂要求就是只收一志愿报考这所学校才行</li><li>考完试修整一段时间就可以提前联系导师了，无论是一志愿还是调剂都是需要导师滴，导师的确好像有推荐</li><li>调剂本校也别大意，我就是大意了，联系的导师有点边沿人物，复试测试环境了，才说我被刷了</li><li>调剂总有不如人意，如果能和本科专业挂钩，已经是最好的了，起码有个学上啊</li></ul><p>知道自己一志愿过不了线挺难受的，加之本校也回不来更不好过了，调剂是真的难。</p><h2 id="2-远程网络复试"><a href="#2-远程网络复试" class="headerlink" title="2.远程网络复试"></a>2.远程网络复试</h2><p>调剂志愿的远程网络复试，其实挺简单，老师估计也知道是调剂生，不会太为难，没问专业问题，就谈了下规划，考察你对这个方向的认识，读一段有关方向的文献，并翻译。其实感觉自己回答的不是老师想听到的，但还是收到了待录取通知。</p><p>乾坤未定，你我皆是黑马！</p><p>调剂到信息光电子，是我很纠结的，偏材料，相对以后不学计算机了，还是伤感，争取和计算机相关的方向吧。</p><p>研究生的生涯还未开始，一切都是未知数，希望不会后悔！</p><h2 id="3-未雨绸缪"><a href="#3-未雨绸缪" class="headerlink" title="3.未雨绸缪"></a>3.未雨绸缪</h2><h4 id="知乎问题"><a href="#知乎问题" class="headerlink" title="知乎问题"></a>知乎问题</h4><blockquote><p>研究生期间能学到什么？对未来工作帮助大吗？下面是他们的见解：</p></blockquote><ul><li>我觉得读研期间最宝贵的看不到的收获，是思维方式的改变，是发现问题解决问题的能力，一段踏实刻苦的学术生涯，会在以后的生活工作中时刻鞭挞自己。</li><li>如果你觉得研究方向不很对胃口，那么首先考虑是否能换一个方向（通常不可能）。其次，在能够确保毕业的前提下（每天至少认真整三个小时），学你想学的，做你想做的，尽快让自己成熟起来，融入这个社会。</li><li>读个研做个工作能力提升缓冲。我本身工作能力（写代码）很强，但是在本科期间必须以学习及成绩为重点，无暇顾及竞赛，所以潜力没有发挥出来。假如我本科就去就业，我的能力根本无法变现。</li><li>研究生期间对你思维的训练，心志的磨砺，学历能力的培养都能让你在工作中快速的成长，快速的适应。</li><li>首先专业上，主要还是要养成本学科的思维方式吧，我本来也觉得本科学了四年专业没学到啥，但是读研之后观察一下跨专业进来的同学感觉思维上还是不一样，毕竟四年潜移默化还是具备一定本专业的思维能力的；然后就是生活、工作上，可以有意识地去锻炼自己处理和解决问题的能力，不要怕事～有的人遇到事就自乱阵脚，感觉这个对将来工作生活都还是挺重要的。</li><li>能学到什么知识不知道，个人能力会提升。</li><li>要问研究生能学到什么，那你学到的可能是书本没有的，比如我们学理工科的，多的是动手能力和思维方式，你开始学会质疑了，学会去探索了，学会改进方法了，再宽一点，学会了如何和老板沟通了，如何最大化节约时间了。要问有什么用，那现实一点，虽然研究生遍地走，但找工作绝对优势，进去也有学历优势。比如师兄出去，在部门因为只有一个研究生，所以主管可以为他专门买一台仪器，给他提供良好的科研环境。</li></ul><p>用武侠小说做比喻，算法是“内功”，而编程的各种框架，就犹如各种“招式”，内功不扎实，再多招式也只是花拳绣腿。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;阶段总结：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从20年9月底开始，到12月22号，进入西工大考场。&lt;/li&gt;
&lt;li&gt;从12月23号下午五点放下手中的笔走出考场，到21年2月27号早上9点出成绩。&lt;/li&gt;
&lt;li&gt;从等到3月25号西工大官网出计算机学院院线，到28号中午接到华南师大的复试通知。&lt;/li&gt;
&lt;li&gt;从29号早上8点面试，11点结束，到29号晚上7点接到研招网的待录取通知。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;结束后停下来整理一下自己，总结分享经验&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Study" scheme="https://mysticalguest.github.io/categories/Study/"/>
    
    
      <category term="考研" scheme="https://mysticalguest.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>调剂面试准备</title>
    <link href="https://mysticalguest.github.io/Study/1918.html"/>
    <id>https://mysticalguest.github.io/Study/1918.html</id>
    <published>2021-03-27T12:07:03.754Z</published>
    <updated>2021-04-08T13:03:56.894Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《(04)光电综合》考查目标：</p><ol><li>考察物理光学和数字电路的基础知识。</li><li>目的在于考察学生对物理光学基础知识和现代光电技术及仪器中所涉及的基本数字电路的了解情况和掌握程度。</li></ol><p>网络上搜索，自己准备，毕竟调剂。</p></blockquote><a id="more"></a><h2 id="光的干涉衍射和偏振"><a href="#光的干涉衍射和偏振" class="headerlink" title="光的干涉衍射和偏振"></a>光的干涉衍射和偏振</h2><h3 id="光的衍射"><a href="#光的衍射" class="headerlink" title="光的衍射"></a>光的衍射</h3><p>光离开直线路径绕到障碍物或小孔后面传播的现象。</p><p>发生明显衍射的条件：只有在障碍物或孔的尺寸比光的波长小或者跟波长差不多的条件下，才能发生明显的衍射现象。</p><p>常见的衍射现象有单缝衍射，圆孔衍射和泊松亮斑等。</p><h3 id="光的干涉"><a href="#光的干涉" class="headerlink" title="光的干涉"></a>光的干涉</h3><p>产生稳定干涉的条件：只有两列光波的频率相同，位相差恒定，振动方向一致的相干光源，才能产生光的干涉。由两个普通独立光源发出的光，不可能具有相同的频率，更不可能存在固定的相差，因此，不能产生干涉现象。</p><h4 id="双缝干涉"><a href="#双缝干涉" class="headerlink" title="双缝干涉"></a>双缝干涉</h4><p>两列或几列光波在空间相遇时相互叠加，在某些区域始终加强，在另一些区域则始终削弱，形成稳定的强弱分布的现象，证实了光具有波动性。</p><h3 id="光的偏振"><a href="#光的偏振" class="headerlink" title="光的偏振"></a>光的偏振</h3><p>太阳或灯泡所发出的光波，其方向很多，可能是水平的，竖直的，对角线的，如上图左下角红色的线，这是<strong>非偏振光</strong>。</p><p>偏振过滤器，即图中黑色方框，有一个偏振角，即图中蓝色线，只能让某一个方向的光波通过。如左边第一个蓝线只能让竖直方向的光波通过。多种方向的光波通过后只剩下一个方向，变成了<strong>偏振光</strong>。</p><p>但如果第二个偏振过滤器的偏振角并非垂直于剩下的电磁波，而是有一个角度呢？平行四边形法则，将剩下的光波分解成水平和垂直于偏振角的两个分量，垂直于偏振角的的被过滤掉了，剩下的就是水平的了。</p><h2 id="数字逻辑电路的基本知识"><a href="#数字逻辑电路的基本知识" class="headerlink" title="数字逻辑电路的基本知识"></a>数字逻辑电路的基本知识</h2><h2 id="半导体器件原理和输入输出特性"><a href="#半导体器件原理和输入输出特性" class="headerlink" title="半导体器件原理和输入输出特性"></a>半导体器件原理和输入输出特性</h2><p>另有一类物质的导电特性处于导体和绝缘体之间，称为半导体，如锗、硅、砷化镓和一些硫化物、氧化物等。</p><ul><li>物体导电性能取决于由自由电子浓度</li></ul><p>导体原子核对电子的束缚较小，自由电子浓度高，导电性能好</p><p>绝缘体中大多数电子都被原子核束缚，自由电子浓度很低，导电性能差</p><p>半导体则介于两者之间，且易受外界因数的影响</p><ul><li>价电子：半导体材料原子最外层的电子由于受原子核的束缚较小，比较容易变成自由电子。</li></ul><p>现代电子学中，用的最多的半导体是硅和锗，它们的最外层电子（价电子）都是四个。</p><p><strong>半导体的导电能力随<code>温度</code>、<code>光照</code>和<code>掺杂</code>等因素发生显著变化，这些特点使它们成为制作半导体元器件的重要材料</strong>。</p><p>本征半导体：纯净的单晶半导体。</p><p>价电子可以获得足够大的能量，挣脱共价键的束缚，游离出去，成为自由电子，并在共价键处留下带有一个单位的正电荷的空穴。这个过程称为<strong>本征激发</strong>。本征激发产生成对的自由电子和空穴，所以本征半导体中自由电子和空穴的数量相等。</p><p>价电子的反向递补运动<em>等价为</em>空穴在半导体中自由移动。因此，在本征激发的作用下，本征半导体中出现了带负电的自由电子和带正电的空穴，二者都可以参与导电，统称为载流子。</p><p>自由电子和空穴在自由移动过程中相遇时，自由电子填入空穴，释放出能量，从而消失一对载流子，这个过程称为<strong>复合</strong>。</p><p>自由电子（负电荷）：部分价电子挣脱共价键束缚离开原子而成为自由电子。自由电子可以在单晶体中自由移动。</p><p>空穴（正电荷）：失去价电子的共价键处留下一个空位，即空穴。</p><p>空穴的移动：相邻共价键中的电子在空位正电荷的吸引下会填补这个空位，即空位发生了移动。</p><p>空穴的移动实际上是束缚电子的反移动。</p><p>自由电子和空穴都可以参与导电，这是半导体不同于金属（只有自由电子）的区别之一。</p><p>本征激发：本征半导体受外界能量（热、电和光等）激发，同时产生电子、空穴对的过程。</p><p>本征半导体导电性能对温度的变化很敏感。本征载流子浓度随温度升高近似指数上升。本征半导体导电能力弱。禁带宽度越大，导电性能越差（绝缘性能越好)</p><h3 id="N型半导体和P型半导体"><a href="#N型半导体和P型半导体" class="headerlink" title="N型半导体和P型半导体"></a>N型半导体和P型半导体</h3><p>本征激发产生的自由电子和空穴的数量相对很少，这说明本征半导体的导电能力很弱。</p><p>我们可以人工少量掺杂某些元素的原子，从而显著提高半导体的导电能力，这样获得的半导体称为杂质半导体。根据掺杂元素的不同，杂质半导体分为N型半导体和P型半导体。</p><ul><li><p>N型半导体</p><p>在本征半导体中掺入五价原子，即构成N型半导体。N型半导体中每掺杂一个杂质元素的原子，就提供一个自由电子，从而大量增加了自由电子的浓度一一<em>施主电离</em>。</p><p>多数载流子一一自由电子</p><p>少数载流子一一空穴</p><p>但半导体仍保持电中性</p></li><li><p>P型半导体</p><p>在本征半导体中掺入三价原子，即构成P型半导体。P型半导体中每掺杂一个杂质元素的原子,就提供一个空穴,从而大量增加了空穴的浓度一一<em>受主电离</em>。</p><p>多数载流子一一空穴</p><p>少数载流子一一自由电子</p><p>但半导体仍保持电中性</p></li><li><p>本征半导体载流子受温度、光照影响大。杂质半导体载流子主要受掺杂浓度控制。</p></li></ul><h3 id="半导体电流"><a href="#半导体电流" class="headerlink" title="半导体电流"></a>半导体电流</h3><p>漂移电流：在电场的作用下，自由电子会逆着电场方向漂移，而空穴则顺着电场方向漂移，这样产生的电流称为漂移电流，该电流的大小主要取决于载流子的浓度，迁移率和电场强度。</p><p>扩散电流：半导体中载流子浓度不均匀分布时，载流子会从高浓度区向低浓度区扩散，从而形成扩散电流，该电流的大小正比于载流子的浓度差即浓度梯度的大小。</p><h3 id="PN结"><a href="#PN结" class="headerlink" title="PN结"></a>PN结</h3><p>通过掺杂工艺，把本征半导体的一边做成P型半导体，另一边做成N型半导体，则P型半导体和N型半导体的交接面处会形成一个有特殊物理性质的薄层，称为PN结。</p><p>空间电荷区又称为耗尽区或势垒区。在掺杂浓度不对称的PN结中，耗尽区在重掺杂一边延伸较小，而在轻掺杂一边延伸较大。</p><h2 id="MOS逻辑门电路"><a href="#MOS逻辑门电路" class="headerlink" title="MOS逻辑门电路"></a>MOS逻辑门电路</h2><p>MOS管是金属（metal）、氧化物（oxide）、半导体（semiconductor）场效应晶体管。</p><p>CMOS：金属-氧化物-半导体互补逻辑门电路（数字集成器件）。</p><p>TTL是晶体管-晶体管逻辑电路的英文缩写（Transistor-Transistor-Logic），是数字集成电路的一大门类；它采用双极型工艺制造，具有高速度低功耗和品种多等特点。</p><p>ECL（Emitter-Coupled Logic）：射极耦合逻辑门电路。</p><h2 id="CMOS逻辑门电路"><a href="#CMOS逻辑门电路" class="headerlink" title="CMOS逻辑门电路"></a>CMOS逻辑门电路</h2><p>非门：反相器？</p><h2 id="组合逻辑设计"><a href="#组合逻辑设计" class="headerlink" title="组合逻辑设计"></a>组合逻辑设计</h2><p>组合逻辑电路：对于一个逻辑电路，其输出状态在任何时刻<em>只取决于同一时刻的输入状态</em>，而与电路原来的状态无关。</p><ul><li>确定逻辑功能，列出真值表</li><li>画出卡诺图，列出表达式</li><li>设计电路</li></ul><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>在时钟脉冲边沿作用下的状态刷新称为<strong>触发</strong>。具有这种特性的存储单元电路称为<strong>触发器</strong>。</p><h3 id="触发器的逻辑功能"><a href="#触发器的逻辑功能" class="headerlink" title="触发器的逻辑功能"></a>触发器的逻辑功能</h3><ul><li><p>D触发器</p><p>特征方程：<script type="math/tex">Q^{n+1}=D</script></p><p>原理、变化也很简单，输出取决于D取值。</p></li><li><p>JK触发器</p><p>JK触发器是时钟边沿敏感的基本存储单元。</p><script type="math/tex; mode=display">Q^{n+1}=J\overline {Q^n}+\overline KQ^n</script><p>由其状态图分析得出：当上一状态为0时，输出取决于J，无论K为何值，J取0时，这次输出为0，J取1时下一状态就为1；若初始上一状态为1，输出取决于K，不论J取何值。</p></li><li><p>T触发器</p><script type="math/tex; mode=display">Q^{n+1}=T\overline {Q^n}+\overline TQ^n=T\bigoplus Q^n</script><p>计数功能的控制，当控制信号<script type="math/tex">T=1</script>时，每来一个时钟脉冲，它的状态翻转一次（即0变1,1变0）；而当<script type="math/tex">T=0</script>时，则不对时钟脉冲信号做出响应而<strong>保持状态不变</strong>。</p></li><li><p>SR触发器</p><script type="math/tex; mode=display">\begin{cases} Q^{n+1}=S+\overline RQ^n\\ SR=0(约束条件)\\ \end{cases}</script><p><script type="math/tex">S=R=1</script>时，触发器次态不确定，触发器将失去控制，</p></li><li><p>利用D触发器构成其他触发器</p></li></ul><h3 id="施密特触发器原理"><a href="#施密特触发器原理" class="headerlink" title="施密特触发器原理"></a>施密特触发器原理</h3><p>施密特触发电路（简称）是一种波形整形电路，当任何波形的信号<br>进入电路时，输出在正、负饱和之间跳动，产生方波或脉波输出。不同于比较器，施密特触发电路有两个临界电压且形成一个<strong>滞后区</strong>，可以防止在滞后范围内的噪声干扰电路的正常。如遥控接收线路，传感器输入电路都会用到它整形。</p><ul><li><p>施密特触发器</p><p>一般的比较器只有一个作比较的临界电压，若输入端有噪声来回多次穿越临界电压时，输出端即受到干扰，其正负状态产生不正常转换。</p><p>施密特触发器的输出电压经有两个电阻？分压后送回到运算放大器的非反相输入端形成正反馈。因为正反馈会产生滞后现象，所以只要噪声的大小在两个临界电压（上临界电压及下临界电压）形成的滞后电压范围内。即可避免噪声误触发电路。</p></li><li><p>特点</p><p>是能够把变化缓慢的输入信号整形成边沿陡峭的矩形脉冲。同时，施密特触发器还可利用其回差电压来提高电路的抗干扰能力。它是由两级直流放大器组成。</p></li><li><p>应用</p><p>利用施密特触发器可以将非矩形波变换成矩形波（用施密特触发器实现波形变换）</p><p>利用施密特触发器可以恢复波形（用施密特触发器对脉冲整形）</p><p>利用施密特触发器可以进行脉冲鉴幅（用施密特触发器鉴别脉冲幅度）</p></li></ul><h2 id="时序逻辑设计"><a href="#时序逻辑设计" class="headerlink" title="时序逻辑设计"></a>时序逻辑设计</h2><p>时序逻辑电路：电路在任一时刻的输出信号不仅与当时的输入信号有关，而且与电路原来的状态有关。</p><p>整个时序电路由<code>进行逻辑运算的组合电路</code>和<code>起记忆作用的存储电路</code>两部分构成。存储电路可用<code>触发器</code>或<code>锁存器</code>组成。</p><p>时序电路是状态依赖的，故又称<strong>状态机</strong>。</p><h3 id="时序电路具有以下主要特征："><a href="#时序电路具有以下主要特征：" class="headerlink" title="时序电路具有以下主要特征："></a>时序电路具有以下主要特征：</h3><ul><li>组成</li><li>时序电路的输出信号由输入信号和电路的状态共同决定。</li></ul><h3 id="异步时序电路"><a href="#异步时序电路" class="headerlink" title="异步时序电路"></a>异步时序电路</h3><p>定义：若电路中触发器的时钟输入端没有接在统一的时钟脉冲上，或电路中没有时钟脉冲，电路中各个存储单元的状态更新不是同时发生的。</p><p>根据电路是对脉冲边沿敏感还是对电平敏感，异步时序电路又分为：</p><ul><li>脉冲异步时序电路（由触发器构成）</li><li>电平异步时序电路（由锁存器构成）</li></ul><h2 id="分析同步时序逻辑电路的一般步骤"><a href="#分析同步时序逻辑电路的一般步骤" class="headerlink" title="分析同步时序逻辑电路的一般步骤"></a>分析同步时序逻辑电路的一般步骤</h2><ul><li>根据电路列出方程组</li><li>列出状态表</li><li>画出状态图</li><li>画出时序图</li><li>逻辑功能分析</li></ul><h2 id="数字器件的使用和设计"><a href="#数字器件的使用和设计" class="headerlink" title="数字器件的使用和设计"></a>数字器件的使用和设计</h2><h2 id="设计一个18进制计数器"><a href="#设计一个18进制计数器" class="headerlink" title="设计一个18进制计数器"></a>设计一个18进制计数器</h2><p>用CD4510（可同步加减计数器）、CD4511、数码管以及必要的逻辑门电路设计不同类型的18进制计数器</p><h2 id="数据选择器（多路选择器）的4选1原理图"><a href="#数据选择器（多路选择器）的4选1原理图" class="headerlink" title="数据选择器（多路选择器）的4选1原理图"></a>数据选择器（多路选择器）的4选1原理图</h2><p>数据选择器根据给定的输入地址代码，从一组输入信号中选出指定的一个送至输出端的组合逻辑电路。有时也把它叫做多路选择器或多路调制器。</p><p>在多路数据传送过程中，能够根据需要将其中任意一路选出来的电路，叫做数据选择器，也称多路选择器或多路开关。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;《(04)光电综合》考查目标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;考察物理光学和数字电路的基础知识。&lt;/li&gt;
&lt;li&gt;目的在于考察学生对物理光学基础知识和现代光电技术及仪器中所涉及的基本数字电路的了解情况和掌握程度。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;网络上搜索，自己准备，毕竟调剂。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Study" scheme="https://mysticalguest.github.io/categories/Study/"/>
    
    
      <category term="面试题集" scheme="https://mysticalguest.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>一志愿面试准备</title>
    <link href="https://mysticalguest.github.io/Study/56260.html"/>
    <id>https://mysticalguest.github.io/Study/56260.html</id>
    <published>2021-03-16T09:17:52.312Z</published>
    <updated>2021-04-08T13:03:29.054Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>考查目标：</p><ol><li>西工大复试的面试题集。</li><li>复试准备阶段，尽管分数尴尬，也要准备复试。</li><li>这里的题集以后会用得到的。</li></ol><p>许多计算机基础问题。</p></blockquote><a id="more"></a><h2 id="2019级面试问题汇总"><a href="#2019级面试问题汇总" class="headerlink" title="2019级面试问题汇总"></a>2019级面试问题汇总</h2><h3 id="一系"><a href="#一系" class="headerlink" title="一系"></a>一系</h3><blockquote><p>或与硬件相关方向和老师</p></blockquote><p>1.操作系统的目录（分别学了哪些东西？）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">(1)计算机操作系统基础知识：</span><br><span class="line">OS的概念、功能和目标</span><br><span class="line">OS的特征</span><br><span class="line">OS的发展与分类</span><br><span class="line">OS的运行机制和体系结构</span><br><span class="line">中断和异常</span><br><span class="line">系统调用</span><br><span class="line">(2)进程和调度：</span><br><span class="line">进程的定义、组成、组织形式和特征</span><br><span class="line">进程的状态和进程状态间的转换</span><br><span class="line">进程控制的基本概念和相关原语</span><br><span class="line">进程通信（共享存储，管道通信，消息传递）</span><br><span class="line">线程和多线程模型（定义，为什么，线程属性，实现方式）</span><br><span class="line">处理机调度（基本概念，三个层次，三层调度的联系、对比）</span><br><span class="line">进程调度的时机，切换与过程，方式</span><br><span class="line">调度算法及其评价指标</span><br><span class="line">进程同步，进程互斥</span><br><span class="line">进程互斥的软件实现方法（但标志法，双标志先检查，双标志后检查，Peterson算法）</span><br><span class="line">进程互斥的硬件实现方法（中断屏蔽方法，TestAndSet(TS指令&#x2F;TSL指令)，Swap指令(XCHG指令)）</span><br><span class="line">信号量机制类型（整型信号量，记录型信号量）</span><br><span class="line">信号量机制（实现进程互斥，实现进程同步，实现进程的前驱关系）</span><br><span class="line">生产者消费者问题、吸烟者问题、读者-写者问题、哲学家进餐问题</span><br><span class="line">管程（为什么引入管程，组成，基本特征，补充）</span><br><span class="line">死锁（定义，区别，必要条件，处理策略）</span><br><span class="line">预防死锁（破坏互斥条件，破坏不剥夺条件，破坏请求和保持条件，破坏循环等待条件）</span><br><span class="line">避免死锁（银行家算法）</span><br><span class="line">死锁的检测和解除</span><br><span class="line">（</span><br><span class="line">如何检测&#123;数据结构：资源分配图，死锁检测算法&#125;，</span><br><span class="line">如何解除&#123;资源剥夺法，撤销进程法，进程回退法&#125;</span><br><span class="line">）</span><br><span class="line">(3)内存（定义，基本原理）</span><br><span class="line">内存管理的概念（分配与回收，内存的扩充，地址转换，存储保护）</span><br><span class="line">覆盖与交换（覆盖技术，交换技术，覆盖与交换的区别）</span><br><span class="line">连续分配管理（单一连续分配，固定分区分配，动态分区分配）</span><br><span class="line">动态分区分配算法</span><br><span class="line">基本分页存储管理的基本概念（地址转换，页号、页内偏移量的计算，页表）</span><br><span class="line">基本地址变换机构（页表存储器的作用，地址变换过程）</span><br><span class="line">具有快表的地址变换机构（局部性原理，什么是快表(TLB)，引入快表后，地址的变换过程）</span><br><span class="line">两级页表（单级页表存在的问题，地址转换）</span><br><span class="line">基本分段存储管理（分段，段表，地址转换，分段VS分页）</span><br><span class="line">段页式管理（分段+分页，段表、页表，地址转换，访问一个逻辑地址所需访存次数）</span><br><span class="line">虚拟内存的基本概念（传统存储管理方式的特点、缺点，局部性原理，虚拟内存的定义和特征，虚拟内存技术）</span><br><span class="line">请求分页管理方式（页表机制，缺页中断机构，地址变换机构）</span><br><span class="line">页面置换算法（OPT，FIFO，LRU，CLOCK(NRU)，改进型CLOCK(改进型NRU)）</span><br><span class="line">页面分配策略（驻留集，页面分配、置换策略，何时调入页面，从何处调页，抖动(颠簸)现象，工作集）</span><br><span class="line">(4)I&#x2F;O和文件</span><br><span class="line">文件管理</span><br><span class="line">文件的逻辑结构（无结构文件，有结构文件）</span><br><span class="line">有结构文件（顺序文件，索引文件，索引顺序文件）</span><br><span class="line">文件目录（文件目录的实现(文件控制块)，目录结构，索引结点）</span><br><span class="line">文件的物理结构（文件分配方式&#123;连续分配，链接分配，索引分配&#125;）</span><br><span class="line">文件存储空间管理（存储空间的划分与初始化，空闲表法，空闲链表法，位示图法，成组链接法）</span><br><span class="line">文件的基本操作（创建，删除，打开，关闭，读写）</span><br><span class="line">文件共享（基于索引结点的共享方式(硬链接)，基于符号链的共享方式(软链接)）</span><br><span class="line">文件保护（口令保护，加密保护，访问控制）</span><br><span class="line">文件系统的层次结构</span><br><span class="line">磁盘的结构（磁盘、磁道、扇区，如何在磁盘中读&#x2F;写数据，盘面、柱面，磁盘的物理地址，磁盘的分类）</span><br><span class="line">磁盘调度算法（一次磁盘读&#x2F;写操作需要的时间，磁盘调度算法&#123;FCFS,SSTF,SCAN,C-SCAN&#125;）</span><br><span class="line">减少延迟时间的方法（交替编号，错位命名，磁盘地址结构的设计）</span><br><span class="line">磁盘的管理（磁盘初始化，引导块，坏块的管理）</span><br><span class="line">I&#x2F;O设备的基本概念和分类（按使用特性、传输速率、信息交换的单位分类）</span><br><span class="line">I&#x2F;O控制器（功能，组成，两种寄存器编址方式）</span><br><span class="line">I&#x2F;O控制方式（程序直接控制方式，中断驱动方式，DMA方式，通道控制方式）</span><br><span class="line">I&#x2F;O软件层次结构</span><br><span class="line">I&#x2F;O核心子系统</span><br><span class="line">假脱机技术（SPOOLing技术）（什么是脱机技术，解决问题，原理，共享打印机原理）</span><br><span class="line">设备的分配与回收</span><br><span class="line"> &#123;</span><br><span class="line"> 设备分配时应考虑的因素（设备的固有属性，设备分配算法，设备分配中的安全性）</span><br><span class="line"> 静态分配与动态分配</span><br><span class="line"> 设备分配管理中的数据结构</span><br><span class="line"> 设备分配的步骤</span><br><span class="line"> 设备分配步骤的改进</span><br><span class="line"> &#125;</span><br><span class="line">缓冲区管理（定义，作用，单缓冲，双缓冲，循环缓冲，缓冲池）</span><br></pre></td></tr></table></figure><p>2.什么是进程，进程调度是调度谁，进程的工作状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</span><br><span class="line">进程调度即低级调度，按照某种规则，从就绪队列中选择一个进程为其分配处理机。</span><br><span class="line">进程的状态：运行，就绪，阻塞，创建，终止</span><br></pre></td></tr></table></figure><p>2.死锁，解除死锁的方法？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</span><br><span class="line">死锁的处理策略：</span><br><span class="line">预防死锁，破坏死锁产生的四个必要条件中的一个或几个。</span><br><span class="line">避免死锁，用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）。</span><br><span class="line">死锁的检测和解除，允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</span><br></pre></td></tr></table></figure><p>3.死锁已经发生，如何解决？解决的时候需要注意什么？</p><blockquote><p><strong>资源剥夺法</strong>。挂起（暂时放在外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他进程。但是应<strong>防止</strong>被挂起的进程长时间得不到资源而饥饿。</p><p><strong>撤销进程法</strong>（<strong>终止进程法</strong>）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止就会功亏一篑，之后还得从头再来。</p><p><strong>进程回退法</strong>。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</p></blockquote><p>4.存储的方式有几种？各自优劣性？</p><div class="table-container"><table><thead><tr><th>分类</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>数组</td><td>连续存储，遍历快，随机访问，长度固定</td><td>移动或添加的时间复杂度O(n)</td></tr><tr><td>链表</td><td>离散存储，添加删除方便，空间消耗大</td><td>不能随机访问</td></tr><tr><td>Hash表</td><td>离散存储，利用哈希算法决定存储位置</td><td>遍历不方便</td></tr><tr><td>二叉树</td><td>多种遍历方式</td><td></td></tr><tr><td>图</td><td></td></tr></tbody></table></div><p>5.调度什么时候发生？及调度算法，堆栈，均值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">需要进行进程调度与切换的情况：</span><br><span class="line">1.当前运行的进程主动放弃处理机：</span><br><span class="line">（1）进程正常终止；</span><br><span class="line">（2）运行过程中发生异常而终止；</span><br><span class="line">（3）进程主动请求阻塞（如，等待I&#x2F;O）</span><br><span class="line">2.当前运行的进程被动放弃处理机：</span><br><span class="line">（1）分给进程的时间片用完；</span><br><span class="line">（2）有更紧急的事需要处理（如，I&#x2F;O中断）；</span><br><span class="line">（3）有更高优先级的进程进入就绪队列</span><br><span class="line">调度算法：</span><br><span class="line">先来先服务(FCFS)，</span><br><span class="line">最短作业优先(SJF)，</span><br><span class="line">最高响应比优先(HRRN)，</span><br><span class="line">时间片轮转调度算法(RR)，</span><br><span class="line">优先级调度算法，</span><br><span class="line">多级反馈队列调度算法。</span><br></pre></td></tr></table></figure><p>6.网络的七层结构，哪几层用硬件实现，为什么其他层不用硬件？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">自顶向下：</span><br><span class="line">应用层</span><br><span class="line">表示层</span><br><span class="line">会话层</span><br><span class="line">传输层（四层交换机、也有工作在四层的路由器）</span><br><span class="line">网络层（路由器、三层交换机）</span><br><span class="line">数据链路层（网桥、交换机）</span><br><span class="line">物理层（网卡、网线、集线器、中继器、调制解调器）</span><br></pre></td></tr></table></figure><blockquote><p>由于OSI是一个理想的模型，因此一般网络系统只涉及其中的几层，很少有系统能够具有所有的7层，并完全遵循它的规定。<br>在7层模型中，每一层都提供一个特殊的网络功能。从网络功能的角度观察：下面4层（物理层、数据链路层、网络层和传输层）主要提供数据传输和交换功能，即以节点到节点之间的通信为主；第4层作为上下两部分的桥梁，是整个网络体系结构中最关键的部分；而上3层（会话层、表示层和应用层）则以提供用户与应用程序之间的信息和数据处理功能为主。简言之，下4层主要完成通信子网的功能，上3层主要完成资源子网的功能。</p></blockquote><p>7.RARP的作用，相对应的协议是什么，地址解析的过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RARP是逆地址解析协议</span><br></pre></td></tr></table></figure><blockquote><p>其作用是完成Mac地址到IP地址的映射。主要用于无盘工作站，因为无盘工作站配置的IP地址不能保存。其过程是：在网络中配置一台RARP服务器。当RARP服务器启动后，就会将Mac地址封装成一个RARP数据包，然后广播到网络上去，当服务器接收到请求包后，就会查找对应Mac地址的IP地址，装入响应报文中发回请求者。</p><p>因为需要广播数据包，因此RARP只能适用于具有广播能力的网络。</p></blockquote><p>8.发微信用的是TCP还是UDP，为什么？</p><blockquote><p>（1）登陆过程，客户端client 采用TCP协议向服务器server发送信息，HTTP协议下载信息。登陆之后，会有一TCP连接来保持在线状态。<br>（2）和好友发消息，客户端client采用UDP协议，但是需要通过服务器转发。腾讯为了确保传输消息的可靠，采用上层协议来保证可靠传输。如果消息发送失败，客户端会提示消息发送失败，并可重新发送。<br>（3）如果是在内网里面的两个客户端传文件，QQ采用的是P2P技术，不需要服务器中转。</p></blockquote><p>9.数据结构的顺序结构有哪些？（两种存储结构：顺序，链式）（4种逻辑结构：线性、树形、图状结构、集合）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>10.专业课学了什么？嵌入式课程教了什么？能不能设计CPU？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">软件工程</span><br></pre></td></tr></table></figure><p>11.嵌入式系统和普通系统区别在哪？</p><blockquote><p>嵌入式操作系统（Embedded Operating System，简称EOS）是相对于一般操作系统而言的，它除了具备一般操作系统的最基本功能，如任务调度、同步机制、中断处理、文件功能外，还有以下特点：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（1）具有开放性、可伸缩性的体系结构；</span><br><span class="line">（2）强实时性；</span><br><span class="line">（3）操作方便、简单、提供友好的图形GUI；</span><br><span class="line">（4）统一的接口；</span><br><span class="line">（5）提供强大的网络功能；</span><br><span class="line">（6）强稳定性，弱交互性；</span><br><span class="line">（7）固化代码；</span><br><span class="line">（8）良好的移植性。</span><br></pre></td></tr></table></figure><p>12.数组和指针的区别是什么？</p><p><code>概念</code></p><blockquote><p><strong>数组</strong>：数组是用于储存多个相同类型数据的集合。</p><p><strong>指针</strong>：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在内存中的地址。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（1）赋值方式（同类型指针变量可以相互赋值，数组只能一个个元素地赋值或拷贝）</span><br><span class="line">（2）存储方式</span><br><span class="line">&#123;数组内存连续存放，下标访问，多维数组也是按照一位数组存放&#125;</span><br><span class="line">&#123;灵活，指向任意类型的数据&#125;</span><br><span class="line">（3）所占字节数(sizeof)</span><br><span class="line">&#123;数组所占空间和存储元素类型有关&#125;</span><br><span class="line">&#123;32位平台下，指针所占字节数是4,64位下为8&#125;</span><br><span class="line">（4）初始化方式</span><br></pre></td></tr></table></figure><blockquote><p>指针数组（存放指针类型的数组）和数组指针（指针指向一个数组）</p></blockquote><p>13.嵌入式系统用什么语言写，什么是嵌入式？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">汇编语言，C语言，Java</span><br></pre></td></tr></table></figure><blockquote><p>嵌入式即嵌入式系统，就是在其他电子产品或设备中，嵌入一个小型计算机，目的是为了，人机交互、采集传感器数据、处理数据、控制执行机构和通信。这个小型计算机就是嵌入式系统，它由各种单片机或微控制器加上外围电路组成。</p><p>嵌入式系统的学习中，要掌握几种微控制器MCU，如51单片机，ARM微控制器等，种类很多，要根据实际项目要求，使用不同的微控制器。</p><p>硬件设计：利用多种设计工具、利用微控制器和外围芯片，设计产品原理图，设计印刷电路板，PCB，制版，焊接，调试。电子系学生擅长。</p><p>软件设计：C/C++开发，懂点汇编语言，可以开发与操作系统的裸机的程序？</p><p>所以，搞嵌入式系统，既要懂硬件，也要懂软件，还要懂通信。即电子、通信、计算机的融合。人工智能？边缘计算？</p></blockquote><p>14.编码，信道，码分多址与频分多址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>15.数电（数字电路）主要学了哪些东西，组合逻辑电路和时序逻辑电路区别（电路图的区别和性能特性的区别）</p><div class="table-container"><table><thead><tr><th>比较</th><th>组合逻辑电路</th><th>时序逻辑电路（状态机）（同步）</th></tr></thead><tbody><tr><td>输入输出关系</td><td>任意时刻的输出仅仅取决于该时刻的输入，与电路原来的转态无关</td><td>不仅仅取决于当前的输入信号，而且还取决于电路原来的状态，即与之前的输入有关</td></tr><tr><td>有无存储（记忆）单元</td><td>无（不能包含）</td><td>包含</td></tr><tr><td>结构特点</td><td>只包含门电路</td><td><strong>组合逻辑电路+存储电路</strong><br />输出状态必须反馈到组合电路的输入端，与输入信号共同决定组合逻辑的输出</td></tr><tr><td>分析方法</td><td>从电路的输入到输出逐级写出逻辑函数式，最后得到表示输出与输入关系的逻辑函数式。然后用公式化简法或者卡诺图化简法得到函数式的化简或变换，以使逻辑关系简单明了。<br />有时还可以将逻辑函数式转换为真值表的形式。</td><td>（1）写出每个触发器的驱动方程<br />（2）将驱动方程带入触发器的特性方程的到状态方程组<br />（3）根据逻辑图写出电路的输出方程<br />状态转换过程描述：<br />状态转换表、状态转换图、状态机流程图、时序图</td></tr><tr><td>设计方法</td><td>（1）逻辑抽象<br />（2）写出逻辑函数式<br />（3）选定器件类型<br />（4）将逻辑函数式化简或者变换成适当的形式<br />（5）画出逻辑电路的连接图<br />（6）工艺设计</td><td>（1）逻辑抽象得到状态转换图或者状态转换表<br />（2）状态化简<br />（3）状态分配(状态编码)<br />（4）选触发器求出状态方程、驱动方程和输出方程<br />（5）根据方程式画出逻辑图<br />（6）检查设计的电路能否自启动</td></tr><tr><td>常用组合逻辑电路</td><td>编码器、译码器、数据选择器、加法器、数值比较器</td><td>锁存器、触发器、寄存器、移位寄存器、存储器</td></tr></tbody></table></div><p>16.动态存储和静态存储的区别（<code>变量的存储方式可分为：静态存储和动态存储</code>）</p><div class="table-container"><table><thead><tr><th>区别</th><th>静态存储</th><th>动态存储</th></tr></thead><tbody><tr><td>概念</td><td>在程序运行期间分配固定的存储空间的方式</td><td>在程序执行过程中，使用它时才分配，使用完毕立即释放</td></tr><tr><td>例子</td><td>全局变量</td><td>形式参数</td></tr><tr><td>特点</td><td>在变量定义时就分定存储单元并一直保持不变，直至整个程序结束</td><td>如果一个函数被多次调用时，则反复地分配、释放变量的存储单元</td></tr><tr><td>生存期</td><td>一直存在的</td><td>时而存在时而消失</td></tr><tr><td>总结</td><td>（1）编译时完成，不占用CPU<br />（2）栈（stack）上分配<br />（3）不需要<br />（4）按计划分配，由编译器负责</td><td>（1）运行时分配，分配和释放都占用CPU<br />（2）堆上分配<br />（3）分配时需要指针和引用类型支持<br />（4）按需分配，由程序员负责</td></tr></tbody></table></div><p>17.大信号和小信号的区别</p><p>18.模电分析方法应该先分析交流还是直流，为什么，怎么进行分析？</p><p>19.递归的含义，递归能不能替代循环，递归需要做什么？堆栈需要用的什么？</p><p><code>含义</code></p><blockquote><p>递归就是本身调用自己或者间接调用自己的函数，是一种栈的使用，递归调用是入栈，之后的结果输出是出栈！</p></blockquote><p><code>所有递归能否替代循环</code></p><blockquote><p>可以。有些递归只需要一个循环就可以替代，而有些递归的改写需要循环+栈，即要利用一定的辅助空间记录过程中的某些数据才可以。</p></blockquote><p><code>所有循环能否改写成递归</code></p><blockquote><p>可以但没必要。循环和递归的共同特点是，它们都是会不断重复执行相同代码，每次重复执行时所使用的数据不一样。</p></blockquote><p><code>区别</code></p><blockquote><p>循环的时间复杂度和空间复杂度都要优于递归，但递归的优越性在于条理清晰，可读性强，比较适宜于问题本身是递归性质的、用循环难于解决的问题。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">递归的三大要素：</span><br><span class="line">（1）明确函数功能；</span><br><span class="line">（2）寻找递归结束条件；</span><br><span class="line">（3）找出函数的等价关系式。</span><br></pre></td></tr></table></figure><p><code>运行时堆栈</code></p><blockquote><p>递归发生的函数调用从底向上进入堆栈，最先进入的是栈底的主程序。当最上层的递归函数满足终止条件，这时一些列终止条件开始执行堆栈顶部的活动记录被弹出，程序控制被交给返回位置处。</p></blockquote><p>20.中断嵌套是什么？</p><blockquote><p>当CPU响应某一中断时，若有优先权高的中断源发出中断请求，则CPU能中断正在进行的中断服务程序，并保留这个程序的断点（类似于子程序嵌套），响应高级中断，高级中断处理结束以后，再继续进行被中断的中断服务程序，这个过程称为中断嵌套。</p></blockquote><p>21.printf函数在汇编中怎么实现？printf函数的参数格式，长度等等、在汇编中怎么表示？</p><p>22.机器人的定义是啥？人工智能是啥？机器学习？数据挖掘？</p><blockquote><p>机器人包括一切模拟人类行为或思想与模拟其他生物的机械。机器人是一种能够半自主或全自主工作的智能机器。机器人具有感知、决策、执行等基本特征。<br>人工智能是计算机科学的一个分支，它是研究开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。<br>机器学习是一门多领域交叉学科，专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。它是人工智能核心，是使计算机具有智能的根本途径。<br>数据挖掘是指从大量的数据中通过算法搜索隐藏于其中信息的过程。</p></blockquote><p>23.单片机为啥叫单片机？</p><p>24.人工智能的避障算法是啥</p><p>25.单片机的引导过程</p><p>26.DMA控制器是主设备还是从设备，什么时候做主设备，8259的中断过程</p><p>27.计网做实验在哪个仿真软件，傅里叶变换作用，非归零码与归零码区别、曼彻斯特是归零码还是非归零码。</p><blockquote><p>winpcap(windows packet capture)是，公共的网络访问系统。为win32应用程序提供访问网络底层的能力。很多不同的工具软件使用Winpcap于网络分析，故障排除，网络安全监控等方面。<br>Ethereal可以用来从网络上抓包，并能对包进行分析。</p></blockquote><p>28.公猫母猫问题</p><p>29.一个饼分两份怎么分才公平，枪打树上的十只鸟有哪些情况，一块钱的面包买五个<br>和买五个一块钱的面包选哪种等</p><blockquote><p>其中有一个人把饼分成两份的权利，另一个人有优先的挑选权利。这样就能做到公平了。</p><p>1：一只都没有，一只被打死掉了下来，其他的飞走了；<br>2：有一只，被打死的那只挂在了树上，其他的飞走了；<br>3：有九只，被打死的那只掉了下了，其他的吓死了，挂在了树上；<br>4：有十只，被打死的那只挂在了树上，其他的吓死了，也挂在了树上。<br>还有很多很多，比如被打死的那只挂在了树上，其他的吓死了，5只掉了下来……</p></blockquote><p>30.一个方形桌子砍一刀后有几个角？</p><h3 id="二系"><a href="#二系" class="headerlink" title="二系"></a>二系</h3><blockquote><p>或软件、数据库与大数据相关的方向和老师</p></blockquote><p>1.操作系统的定义</p><blockquote><p>操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。</p></blockquote><p>2.进程和线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程是一个基本的CPU执行单元，也是程序执行流的最小单位。</span><br></pre></td></tr></table></figure><p>3.一个文件在磁盘上，如何访问到</p><p>4.内存管理有哪些方法？</p><p>5.虛拟存储的作用？为什么虛拟存储可以实现？</p><p>6.多级存储系统的作用？</p><p>7.寄存器和存储器的区别？</p><p>8.请求分页页面置换算法列举</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">页面置换算法：</span><br><span class="line">最佳置换算法（OPT）</span><br><span class="line">先进先出置换算法（FIFO）</span><br><span class="line">最近最久未使用置换算法（LRU）</span><br><span class="line">时钟置换算法（CLOCK）</span><br><span class="line">改进型的时钟置换算法</span><br></pre></td></tr></table></figure><p><code>最佳置换算法（OPT）</code></p><blockquote><p>每次选择淘汰的页面将是<strong>以后永不使用</strong>，或者<strong>在最长时间内不再被访问的页面</strong>，这样可以保证最低的缺页率。</p></blockquote><p><code>先进先出置换算法（FIFO）</code></p><blockquote><p>每次选择淘汰的页面是<strong>最早进入内存的页面</strong>。</p></blockquote><p><code>最近最久未使用置换算法（LRU）</code></p><blockquote><p>每次淘汰的页面是<strong>最近最久未使用的页面</strong>。</p></blockquote><p>9.叙述clock（时钟）置换算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">时钟置换算法是一种性能和开销较均衡的算法，又叫“最近位使用算法（NRU）”</span><br></pre></td></tr></table></figure><blockquote><p>简单的CLOCK算法实现方法：为每个页面设置一个<strong>访问位</strong>，再将<strong>内存中的页面</strong>都通过链接指针链接成一个<strong>循环队列</strong>。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将其置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多经过两轮扫描）</p><p>访问位为1，表示最近访问过；</p><p>访问位为0，表示最近没访问过。</p></blockquote><p><code>改进型的时钟置换算法</code></p><blockquote><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。<strong>只有被淘汰的页面被修改过时，才需要写回外存</strong>。</p><p>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作。这就是改进型的时钟置换算法的思想。</p><p>修改位=0，表示页面没有被修改过；</p><p>修改位=1，表示页面被修改过。</p><p>用<strong>（访问位，修改位）</strong>的形式表示各页面状态。改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描。</p></blockquote><p>10.C语言中你习惯定义全局变量还是局部变量</p><blockquote><p>看情况吧，有需要使用全局变量的时候，我会选择去定义全局变量；如果局部变量可以解决的问题，我就会去定义局部变量。应为全局变量的生命周期长，会占用更多的内存，且由于其全局性，所有代码都可以修改它，对这个变量的最终就很困难。</p></blockquote><p>11.编译的过程是什么？</p><p>12.给一个链表，如何确定这个链表有环？</p><blockquote><p>采用“快慢指针”的方法。就是有两个指针fast和slow，开始的时候两个指针都指向链表头head，然后在每一步操作中slow向前走一步,即：slow = slow-&gt;next，而fast每一步向前两步即：fast = fast-&gt;next-&gt;next。由于fast要比slow移动的快，如果有环，fast一定会先进入环，而slow后进入环。当两个指针都进入环之后，经过一定步的操作之后二者一定能够在环上相遇，并且此时slow还没有绕环一圈，也就是说一定是在slow走完第一圈之前相遇。</p></blockquote><p><code>如果存在环，找出环的入口点</code></p><blockquote><p>从链表起点head开始到入口点的距离a,与从slow和fast的相遇点（如图）到入口点的距离相等？<br>因此我们就可以分别用一个指针（ptr1, prt2），同时从head与slow和fast的相遇点出发，每一次操作走一步，直到ptr1 == ptr2，此时的位置也就是入口点！</p></blockquote><p><code>如果存在环，求出环上节点的个数</code></p><p><code>如果存在环，求出链表的长度</code></p><p><code>如果存在环，求出环上距离任意一个节点最远的点（对面节点）</code></p><p><code>（扩展）如何判断两个无环链表是否相交</code></p><p><code>（扩展）如果相交，求出第一个相交的节点</code></p><p>13.线性表的定义</p><p>14.设计算法统计一个二进制数中1的个数？</p><p>15.斐波那契递归和迭代区别是啥？</p><p>16.描述斐波拉契序列算法和和汉诺塔算法</p><p>17.数据库范式的定义以及区别？</p><p>18.数据库第一二三四范式是啥？</p><p>19.数据挖掘有什么应用</p><p>20.数据库有几和锁？数据库的事务？常用的数据库？数据库的主码外码？</p><p>21.用离散数学解释下主成分分析是啥？</p><p>22.学过哪些前沿课程？课程内容是什么？人工智能是什么？（这种问题别给自己挖坑这种属于典型的开放式问题开头然后步步深入，甚至可以问的很深入。注意挑选自己擅长的科目，一知半解的课程不如不说）</p><p>23.项目是什么，自己做了什么</p><p>24.有10框苹果，有9框每个半斤重。有一筐每个四两,如何通过只称重一次，找出那个不一样的</p><p>25.有10筐苹果，9筐半斤、1筐4两，只用一杆秤，只能称一次找出4两的那筐苹果（问了多次）</p><h3 id="三系"><a href="#三系" class="headerlink" title="三系"></a>三系</h3><blockquote><p>或机器学习、深度学习和图像处理相关的方向和老师，多涉及到一些数学相关知识</p></blockquote><p>1.你能描述一下数据结构具体有哪几种吗？解释机器学习</p><p>2.面向对象中的封装、多态和继承</p><p>3.数据结构中的链表的逆置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法1：头插法建立新的链表，从头顺序遍历，遍历的每个结点都用头插法插入到新的链表中；</span><br><span class="line">时间和空间复杂度都为O(n)，好处是不用修改原来的链表，坏处就是多了空间复杂度。</span><br><span class="line">方法2：原地逆置法是每每修改两个相邻结点p,q的前后关系，增加一个指针保存下一次的修改目标结点；</span><br><span class="line">空间复杂度为O(1)，时间同样为O(n)，但是这种方法修改了原来的链表。</span><br><span class="line">方法3：使用递归，reverse(head),出口设置为head&#x3D;&#x3D;null 和head.next&#x3D;&#x3D;null。</span><br><span class="line">方法4：库函数</span><br></pre></td></tr></table></figure><p>4.一个链表里面有循环，怎么确定循环的头尾相交结点？</p><p>5.优先级反转是什么？怎么解决这个问题？</p><p>6.为什么要有泰勒展开式？对计算机学科的意义是什么？</p><p>7.泰勒展开式的n取到多少？怎么确定？</p><p>8.线性代数中坐标变换的意义是什么？能解决什么问题？</p><p>9.空间解析几何中的维空间与空间解析几何讲的是什么？</p><p>10.怎么求sin01?</p><p>11.极大似然函数的作用</p><p>12.描述下贝叶斯定理</p><p>13.特卡洛求不规则图形面积。答：比如一张纸上有不规则图形。可以用散列法（知特卡洛），如在上面撤芝妹，然后通过比例求面积（注：答案非标准答案，是考生当时的回答）</p><p>14.复变函数中的若积公式。答：应该是有两个函数，然后求关于第一个函数，表征意思是求这两个高数平滑后的面积，即翻续平移后量誉的部分。</p><p>15.傅卫叶变化。答：把一个函数分解成sin和cos，可以大大减少运算次数。</p><p>15.特征值是什么？</p><p>17.双聚关启发式搜宗k均值聚关</p><p>18.蚁群算法。答∶用正反馈机制寻求最优解，这个最优解是全局最优解。可以和运筹学结合起来用，比如运筹学里的指派问题、旅行商问题。</p><p>19.你学过这个方向的相关专业课有哪些？</p><p>20.人脸对比的时候，对比的是哪些信息？</p><p>21.图像处理的项目里你觉得有那些槟块？</p><p>22.计算机视觉的看法，评价报考老师的论文。</p><p>23.讲下你的毕设</p><blockquote><p>我的毕业论文题目是《FTP代理机制研究》。</p><p>（1）科研方法：<strong>文献研究法</strong>。通过专业的文摘、索引、工具书、光盘以及网络资源等文献的检索来发挥文献价值与创造性的利用文献的方法。</p><p>（2）研究对象：计算机网络领域的一个重要协议，FTP文件传输协议。</p><p>（3）科研目的：代理服务器是缓解网络安全问题的有效方法之一。</p><p>（4）研究内容：通过实现FTP协议的控制连接和数据连接来实现代理服务器的功能。</p></blockquote><p>24.一个桶装有8斤油，另有一个3斤与一个5斤桶，怎么分成两桶4斤油？（基本没有思考的时间）</p><div class="table-container"><table><thead><tr><th></th><th>8斤的桶</th><th>3斤的桶</th><th>5斤的桶</th></tr></thead><tbody><tr><td>初始</td><td>8</td><td>0</td><td>0</td></tr><tr><td>第一次</td><td>3</td><td>0</td><td>5</td></tr><tr><td>第二次</td><td>3</td><td>3</td><td>2</td></tr><tr><td>第三次</td><td>6</td><td>0</td><td>2</td></tr><tr><td>第四次</td><td>6</td><td>2</td><td>0</td></tr><tr><td>第五次</td><td>1</td><td>2</td><td>5</td></tr><tr><td>第六次</td><td>1</td><td>3</td><td>4</td></tr><tr><td>第七次</td><td>4</td><td>0</td><td>4</td></tr></tbody></table></div><p>25.一个箱子，放了一个白球，一个黑球，每次取一个便放回去，问至少有一次是红球的率是多少？</p><h3 id="四系"><a href="#四系" class="headerlink" title="四系"></a>四系</h3><blockquote><p>或网络安全、密码学相关方向和老师</p></blockquote><p>1.路由器和交换机的功能然后他们的区别</p><p>2.TCP拥塞的解决方式，分别解释一下</p><p>3.TCP为什么三次握手</p><h3 id="专业课公共知识"><a href="#专业课公共知识" class="headerlink" title="专业课公共知识"></a>专业课公共知识</h3><blockquote><p>以下考生回忆的问题没有明显的方向性，属于基础知识的，放在下面这个目录</p></blockquote><p>1.为什么要有系统调用？</p><blockquote><p>“系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。<br>有何作用：<br>    应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</p></blockquote><p>2.调度是什么？内存怎么管理</p><blockquote><p>CPU作为一种系统资源，是唯一的，而在多任务的OS中，每个任务都需要使用CPU，因此需要为任务对CPU的使用提供一种同步机制，这就是调度（Scheduling）。<br>在并发程序设计中，各进程对公共变量的访问必须加以制约，这种制约称为同步。</p></blockquote><p>3.进程和线程的区别</p><p>4.什么是死锁</p><p>5.描述一下你学过的排序算法</p><div class="table-container"><table><thead><tr><th>分类</th><th>算法</th><th></th></tr></thead><tbody><tr><td>交换排序</td><td>冒泡排序</td><td></td></tr><tr><td></td><td>希尔排序</td><td></td></tr><tr><td></td><td>快速排序</td><td></td></tr><tr><td>选择排序</td><td>简单选择排序</td><td></td></tr><tr><td></td><td>插入排序</td><td></td></tr><tr><td></td><td>堆排序</td><td></td></tr><tr><td>归并排序</td><td></td><td></td></tr><tr><td>基数排序</td><td></td></tr></tbody></table></div><p>6.操作系统中用来表示内存已被占用的数据结构是什么？</p><p>7.操作系统提供给程序员创建进程的接口有哪些？</p><p>8.说一下内存管建方式有哪些？</p><p>9.全局变量和局部变量分别存储在哪里？（变量的存储类型及性质）</p><blockquote><p>局部变量存在于（栈）中，只有当所在函数被调用时才动态地为变量分配存储单元。<br>全局变量和静态变量存在于（静态区/全局存储区）中，占用静态的存储单元。<br>动态申请数据存在于（堆）中（new的对象存在于堆区，malloc的对象存在于自由存储区）。<br>常量存在于常量区。</p><p>C语言经过编译之后将内存分为以下几个区域：<br>    （1）栈（stack）：由编译器进行管理，自动分配和释放，存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址。操作方式类似数据结构中的栈。<br>    （2）堆（heap）：用于程序动态申请分配和释放空间。C语言中的malloc和free，C++中的new和delete均是在堆中进行的。正常情况下，程序员申请的空间在使用结束后应该释放，若程序员没有释放空间，则程序结束时系统自动回收。注意：这里的“堆”并不是数据结构中的“堆”。<br>    （3）全局（静态）存储区：分为DATA段和BSS段。DATA段（全局初始化区）存放初始化的全局变量和静态变量；BSS段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。<br>    （4）文字常量区：存放常量字符串。程序结束后由系统释放。<br>    （5）程序代码区：存放程序的二进制代码。</p></blockquote><p>10.外部中断CPU该如何处理</p><p>11.快排和冒泡的原理自己他们的空间复杂度是多少？</p><p>12.佛洛依德算法？迪杰斯特拉算法？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">都是求最短路径的算法。</span><br></pre></td></tr></table></figure><p>13.DHCP协议的作用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>14.一个访问网络的过程</p><p>15.用自己的话讲TCP连接到底是什么</p><p>16.设计web服务器</p><p>17.几种方法写阶乘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1)循环；（2）库函数；（3）递归</span><br></pre></td></tr></table></figure><p>18.定义一个结构体，里面一个int类型成员，一个char，int占四位，char占一位，那么在Linux占几位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">核心：</span><br><span class="line">(1)每个元素的首地址偏移量必须能整除该元素的长度？</span><br><span class="line">(2)整个结构体的长度必须能整除最长元素的字节数。</span><br><span class="line">涉及到内存字节对齐的问题。</span><br><span class="line">Windows和Linux的区别只有double不同，以后会整理</span><br><span class="line">这题答案应该是8位</span><br></pre></td></tr></table></figure><h3 id="C-方面"><a href="#C-方面" class="headerlink" title="C++方面"></a>C++方面</h3><blockquote><p>（或编程语言，这类问题一般建立在简历中提到了相关技能，或老师提问你会什么语言）</p></blockquote><p>1.最擅长哪种语言?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java</span><br></pre></td></tr></table></figure><p>2.请简述C，C++语言有何区别和联系？</p><p><code>区别：</code></p><blockquote><p>C语言是面向过程语言，而C++是面向对象语言<br>1.面向过程和面向对象的区别<br>（1）面向过程：面向过程编程就是分析出解决问题的步骤，然后把这些步骤一步一步的实现，使用的时候一个一个的依次调用就可以了。<br>（2）面向对象：面向对象编程就是把问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。<br>面向过程就是自顶向下的编程（步骤划分），面向对象就是高度实物抽象化（功能划分）<br>2.具体语言的区别<br>（1）关键字不同<br>（2）文件后缀名不同<br>（3）返回值<br>    C语言中，如果一个函数没有指定返回值类型，默认返回int类型；C++中，如果一个函数没有返回值则必须指定为void。<br>（4）参数列表<br>    在C语言中，函数没有指定参数列表时，默认可以接收任意多个参数；但在C++中，因为严格的参数类型检测，没有参数列表的函数，默认为 void，不接收任何参数。<br>（5）默认参数（C语言不支持默认参数，C++支持默认参数）<br>（6）函数重载（C语言没有函数重载，C++支持函数重载）</p></blockquote><p><code>联系：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++ 由C语言发展而来，几乎完全兼容C语言；也就是说C语言代码几乎可以不加修改地用于 C++。</span><br></pre></td></tr></table></figure><p><code>相关扩展：C语言中struct和union的区别是什么？</code></p><blockquote><p>struct (结构体）与union (联合体）是C语言中两种不同的数据结构，两者都是常见的复合结构，其区别主要表现在以下两个方面：<br>(1) 结构体与联合体虽然都是由多个不同的数据类型成员组成的，但不同之处在于联合体中所有成员共用一块地址空间，即联合体只存放了一个被选中的成员，而结构体中所有成员占用空间是累加的，其所有成员都存在，不同成员会存放在不同的地址。所以结构体在计算一个结构型变量的总长度时，其内存空间大小等于所有成员长度之和（需要考虑字节对齐），而在联合体中， 所有成员不能同时占用内存空间，它们不能同时存在，所以一个联合型变量的长度等于其最长的成员的长度。<br>(2) 对于联合体的不同成员赋值，将会对它的其他成员重写，原来成员的值就不存在了， 而对结构体的不同成员赋值是互不影响的。</p></blockquote><p><code>相关扩展：C和C++中struct的区别是什么？</code></p><blockquote><p>C语言中的struct与C++中的struct的区别表现在以下3个方面：<br>    (1) C语言的struct不能有函数成员，而C++的struct可以有。<br>    (2) C语言的struct中数据成员没有private、public和protected访问权限的设定，而C++的struct的成员有访问权限设定。<br>    (3) C语言的struct是没有继承关系的，而C++的struct却有丰富的继承关系。<br>C语言中的struct是用户自定义数据类型，它是没有权限设置的，它只能是一些变量的集合体，虽然可以封装数据却不可以隐藏数据，而且成员不可以是函数。为了和C语言兼容，C++中就引入了struct关键字。C++语言中的struct是抽象数据类型 (ADT)，它支持成员函数的定义，同时它增加了访问权限，它的成员函数默认访问权限为public。</p></blockquote><p><code>相关扩展：C++中的 struct与class的区别是什么？</code></p><blockquote><p>具体而言，在C++中，class和struct做类型定义时只有两点区别：<br>    (1) 默认继承权限不同。class继承默认是private继承，而struct继承默认是public继承；<br>    (2) class还用于定义模板参数，就像typename，但关键字struct不用于定义模板参数。</p></blockquote><p><code>相关扩展：简单描述一下你认为的C语言的优点和缺点？</code></p><blockquote><p>优点：<br>    （1）编写的程序可读性强，编译效率高。<br>    （2）具有简洁紧凑、使用灵活的语法机制。<br>    （3）数据结构丰富，满足多种数据开发要求。<br>    （4）允许直接访问物理地址，对硬件进行操作。<br>    （5）具有出色的可移植性，能在多种不同体系结构的软/硬件平台上运行。<br>缺点：<br>    （1） C语言的缺点主要表现在数据的封装性上，这一点使得C在数据的安全性上有很大缺陷，这也是C和C++的一大区别。<br>    （2） C语言的语法限制不太严格，对变量的类型约束不严格，影响程序的安全性，对数组下标越界不作检查等。从应用的角度，C语言比其他高级语言较难掌握。也就是说，对用C语言的人，要求对程序设计更熟练一些。<br>    （3） C语言的简洁性与其丰富的运算符相结合，使其可能会编写出极难理解的代码。<br>    （4） C语言表达方面的自由会增加风险。尤其是C语言对指针的使用。</p></blockquote><p><code>相关扩展：C++是不是类型安全的？</code></p><blockquote><p>不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的。<br>类型安全代码指访问被授权可以访问的内存位置。类型安全的代码不会试图访问自己没被授权的内存区域。</p></blockquote><p><code>相关扩展：谈谈你是怎么认识 C++ 中的模板的？</code></p><blockquote><p>模板使程序员能够快速建立具有类型安全的类库集合和函数集合，它的实现，方便了大规模的软件开发。（结合stl更好）<br>STL是“Standard Template Library”的缩写，中文译为“标准模板库”。STL是C++标准库的一部分，不用单独安装。<br>C++对模板（Template）支持得很好，STL就是借助模板把常用的数据结构及其算法都实现了一遍，并且做到了数据结构和算法的分离。例如，vector的底层为顺序表（数组），list的底层为双向链表，deque的底层为循环队列，set的底层为红黑树，hash_set的底层为哈希表。</p></blockquote><p><code>相关扩展：C++中所有的运算符都能重载吗？</code></p><blockquote><p>在C++运算符集合中，有一些运算符是不允许被重载的。这种限制是出于安全方面的考虑，可防止错误和混乱。<br>    （1）不能改变C++内部数据类型（如int,float等）的运算符。<br>    （2）不能重载‘.’，因为‘.’在类中对任何成员都有意义，已经成为标准用法。<br>    （3）不能重载目前C++运算符集合中没有的符号，如#,@,$等。原因有两点，一是难以理解，二是难以确定优先级。<br>    （4）对已经存在的运算符进行重载时，不能改变优先级规则，否则将引起混乱。</p></blockquote><p>3.简述面向对象有哪些好处？</p><p>4.简述类和对象</p><div class="table-container"><table><thead><tr><th>类</th><th>对象</th></tr></thead><tbody><tr><td>类是现实世界在计算机中的反映，它将数据和对这些数据的操作封装在一起</td><td>类的实例</td></tr><tr><td>并没有开辟空间<br />类的大小：类的成员函数放在公共代码区，所有该类的对象共享这些成员函数，每个对象的大小为类内成员变量的大小之和，遵循内存对齐原则</td><td>占有实际的空间（用来存储成员变量）<br />对象的大小为类中<strong>所有成员变量的大小之和</strong>，当然这里也遵循内存对齐原则</td></tr><tr><td>三大特性：封装、继承、多态<br />访问限定符</td></tr></tbody></table></div><p><code>为什么要内存对齐（前面也遇到过这种问题）</code></p><blockquote><p>为了提高程序的性能，方便CPU访问内存，处理器并不是一个字节一个字节来访问内存，一般是4个字节或8个字节</p></blockquote><p><code>空类占多少个字节？为什么？</code></p><blockquote><p>空类占1个字节，占位用，告诉系统我这里定义了一个类，虽然它是空的</p></blockquote><p>5.什么是重载？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">重载的定义：</span><br><span class="line">（1）同一个类；</span><br><span class="line">（2）多个方法的方法名字相同；</span><br><span class="line">（3）参数列表不同、参数个数不同、参数的数据类型不同，不同数据类型的参数顺序不同</span><br><span class="line">和修饰符无关、和有无返回值无关、和返回值类型无关、和参数名无关</span><br></pre></td></tr></table></figure><p><code>什么是多态？</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">多态就是同一个接口，使用不同的实例而执行不同操作。</span><br><span class="line">函数的多种不同的实现方式即为多态。</span><br></pre></td></tr></table></figure><p>6.C++里什么是friend？</p><blockquote><p>C++中的友元机制允许类的非公有成员被一个类或者函数访问</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">友元按类型分为三种：</span><br><span class="line">(1)普通非类成员函数作为友元；</span><br><span class="line">(2)类的成员函数作为友元；</span><br><span class="line">(3)类作为友元。</span><br><span class="line">友元函数的实现可以在类外定义，但必须在类内部声明。</span><br><span class="line">友元函数是可以直接访问类的私有成员的非成员函数。</span><br><span class="line">它是定义在类外的普通函数，它不属于任何类。</span><br><span class="line">但需要在类的定义中加以声明，声明时只需在友元的名称前加上关键字friend。</span><br><span class="line">注意：</span><br><span class="line">(1)友元不具有相互性，只具有单项性；</span><br><span class="line">(2)友元不能被继承；</span><br><span class="line">(3)友元不具有传递性。</span><br></pre></td></tr></table></figure><p>7.C++的继承方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">继承是类的重要特性。</span><br><span class="line">三种继承方式：公有、私有、保护继承。</span><br><span class="line">多态（虚函数，虚函数表？）</span><br><span class="line">和Java的继承并无二致。</span><br></pre></td></tr></table></figure><p>8.python的学习</p><p>9.python特殊的数据类型</p><div class="table-container"><table><thead><tr><th>6种特殊数据类型</th><th>概念</th></tr></thead><tbody><tr><td>list：列表</td><td>是一种有序的数据集合，在列表数据结构中的类型并不唯一</td></tr><tr><td>tuple：元组</td><td>是一种有序的列表，但是其一旦创立完毕就不能够更改，即不能插入，删除里面的元素，访问的方式跟List结构一致。</td></tr><tr><td>dict：字典</td><td>类似JSON，键值对</td></tr><tr><td>set：集合</td><td>无序但是所有元素唯一，不重复</td></tr><tr><td>Unicode编码</td><td>支持显示中文</td></tr><tr><td>raw</td><td>一个“raw”字符串，里面的字符就不需要转义</td></tr></tbody></table></div><p>10.Java和C++的异同</p><p>11.Java与C++的类、继承有什么相同和不同？</p><h3 id="跨考、在职考研的考生"><a href="#跨考、在职考研的考生" class="headerlink" title="跨考、在职考研的考生"></a>跨考、在职考研的考生</h3><p>为什么跨专业考研。为什么辞联考研。为什么当时毕业不考研。在工作的时候有没有和本专业相关的知识运用。研究生规划。在公司的职业情况。机器人的定义。人工智能的定义。这两都跟老师的研究方向相关,会问本科专业的一些问题。PLC与FPGA的中文名称。数据结构中线性表有哪些?</p><h3 id="考查英语口语方面"><a href="#考查英语口语方面" class="headerlink" title="考查英语口语方面"></a>考查英语口语方面</h3><blockquote><p>一般也是英语提问，考查考生的听、说能力</p></blockquote><p>1.自我介绍+家乡介绍？</p><p>2.介绍自己的家？</p><p>3.本科学校，专业是啥，专业多少人，排名多少？</p><p>4.为什么选择这个研究方向？</p><p>5.为什么来nwpu？怎么知道nwpu？nwpu全拼是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Northwestern Polytechnical University</span><br></pre></td></tr></table></figure><p>6.什么时候来的西工大，感觉西工大怎么样，以后想在哪个公司？</p><p>7.西工大绘你印象最深的地方。</p><p>8.学过什么程序语言</p><p>9.做过什么项目？</p><p>10.问了队列和链表相比的缺点。</p><p>11.你最喜欢的专业课是什么？</p><p>12.和门外等着的人，你觉得你的优势是什么？</p><h2 id="2019年夏令营面试问题汇总"><a href="#2019年夏令营面试问题汇总" class="headerlink" title="2019年夏令营面试问题汇总"></a>2019年夏令营面试问题汇总</h2><h3 id="一系-1"><a href="#一系-1" class="headerlink" title="一系"></a>一系</h3><blockquote><p>考察内容涉及数电、模电、嵌入式、SOC相关知识，以及软工、操作系统、C语言、计算机组成原理的相关知识。</p></blockquote><p>同学A：先是英语白我介绍；然后主要就是项目。没问专业问题。</p><p>同学B：银行家算法。数学知识。</p><p>三系：偏向于数据与图像处理，考察数学知识较多，而且有英语提问。</p><p>同学C：问到数学知识，专业课问题较多。</p><h3 id="四系-1"><a href="#四系-1" class="headerlink" title="四系"></a>四系</h3><blockquote><p>主要考察计算机网络、操作系统、网络安全相关知识。会询问是否做过网络的一些实验</p></blockquote><p>同学D：英文自我介绍。说说自己做过的项目，我是网络的，问了计网的，四层结构，mac英文意思，用过什么操作系统，Linux中创建文件的指令，同组有问操作系统的，概率论，高数的。</p><h2 id="2018年夏令营面试问题汇总"><a href="#2018年夏令营面试问题汇总" class="headerlink" title="2018年夏令营面试问题汇总"></a>2018年夏令营面试问题汇总</h2><h3 id="二系-1"><a href="#二系-1" class="headerlink" title="二系"></a>二系</h3><blockquote><p>主要负责老师未到场，面试的是今年刚任职的老师，参考意义不大，剧开始有自我介绍和英文提问。研究方向为数据库方面，主要是算法</p></blockquote><p>英文介绍，用英文描述你喜欢的运动</p><p>做的具体项目，会步步深入</p><p>最欢的专业课，对本专业理解，给你三分钟的时间说服老师留下你、和舍友关系如何。</p><h3 id="三系-1"><a href="#三系-1" class="headerlink" title="三系"></a>三系</h3><blockquote><p>偏向于数据与图像处理，考察数学知识较多，而且有英语提问</p></blockquote><p>线性代数知阵的特征值和特征向量计算方式及意义。</p><p>高数：梯度。</p><p>说几种排序算法的复杂度。</p><p>编程相关经历。</p><p>是否了解意愿导师的方向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">智能计算系统系：副高职称王党辉</span><br><span class="line">主要研究方向：</span><br><span class="line">高性能处理器体系结构、人工智能加速器架构、</span><br><span class="line">高可靠计算机系统、多核&#x2F;众核系统的资源调度、</span><br><span class="line">新型存储系统、嵌入式系统设计、数字系统设计与测试等</span><br></pre></td></tr></table></figure><p>是否有接触CV、NLP或机器学习等方向的工作</p><h2 id="2017年夏令营面试问题汇总"><a href="#2017年夏令营面试问题汇总" class="headerlink" title="2017年夏令营面试问题汇总"></a>2017年夏令营面试问题汇总</h2><h3 id="1系"><a href="#1系" class="headerlink" title="1系"></a>1系</h3><blockquote><p>考察涉及数电、椟电、嵌入式、SOC知识、软件工程、澡作系统、C言、计算机组成原理</p></blockquote><p>三八编译器的设计原理</p><p>放大器的设计原理</p><p>lts系统有哪些算法</p><p>嵌入式系统的计数器如何使用</p><p>8255如何用</p><p>操作系统进程</p><p>CPU工作模式</p><h3 id="2系"><a href="#2系" class="headerlink" title="2系"></a>2系</h3><blockquote><p>刚开始有白我介绍和英语提问，研究方向为数据库方向，主要是算法</p></blockquote><p>进程死锁（概念、避免、预防）</p><p>数据库基本知识（外键、查询语句）</p><p>算法（如从两串中查找相同元素的所有方法）</p><p>模式匹配</p><p>C语言些一简单的输入输出格式</p><h3 id="3系"><a href="#3系" class="headerlink" title="3系"></a>3系</h3><blockquote><p>考察数学知识较多、会用英运提问</p></blockquote><p>高数、线代、概率等的相关知识（如高斯模型、矩阵的转换、矩阵的逆等）</p><p>编程最好的语言</p><p>C语言的主要内容</p><p>概率论相关和独立的区别</p><p>发表论文的意义</p><h3 id="4系"><a href="#4系" class="headerlink" title="4系"></a>4系</h3><blockquote><p>主要着察计算机网络、操作系统、网络安余等知识，是否做过一些网络的实验，本科学过什么特色课程</p></blockquote><p>WLAN定义</p><p>WiFi、3G和蓝牙使用的是什么协议</p><p>为什么WiFi比3G便宜</p><p>HTTP是什么，Https是什么，区别</p><p>死锁的原因，接触；进程线程</p><p>IPV4和IPV6的地址位数</p><p>网络安全；攻击方式</p><p>会做网线吗？怎么做；网线由几根线组成？那几根不能用</p><p>cookie的原理</p><h2 id="2017级面试问题汇总"><a href="#2017级面试问题汇总" class="headerlink" title="2017级面试问题汇总"></a>2017级面试问题汇总</h2><h3 id="3系："><a href="#3系：" class="headerlink" title="3系："></a>3系：</h3><blockquote><p>图像与语音处理，主要以数学问题为主，所以建议报考三系的同学考完研不要松懈复习专业课（数学课）基本知识，二系今年与其他组的不同之处在于没有英话介绍，背了半天竟没用上，反之是问了一个特别长的问题，好像是介绍家乡</p></blockquote><p>高斯滤波、傅里叶变换、采样定理</p><p>正态分布要素</p><p>一条曲线怎么证明在一个平面上</p><p>a投影至b上，求投影长度</p><p>举一个连续分布的例子。还有什么分布</p><p>安卓和IOS区别</p><p>int在winxp和wn10区别</p><p>发送邮件用到了什么协议</p><h3 id="②4系-网络"><a href="#②4系-网络" class="headerlink" title="②4系:网络:"></a>②4系:网络:</h3><p>HTTPS和HTTP区别</p><p>死锁的必要条件等</p><h2 id="2016级面试问题汇总"><a href="#2016级面试问题汇总" class="headerlink" title="2016级面试问题汇总"></a>2016级面试问题汇总</h2><p>1.英语自我介绍</p><blockquote><p>Good morning! Teachers and professors. I am very glad to be here for this interview. </p><p>First, let me introduce myself. My name is XiaoMengjie. I have finished my undergraduate education in Northwest University, majoring in Software Engineering.</p><p>I am open-minded, willing and have broad interests like basketball and web development. For example, during the past four years, I have accomplished several website. (What impresses me most is the Hotel Management System that I developed for my father.) Furthermore, I am intrested in Java programming language and have written some websites with Springboot.</p><p>This year, I finished my graduate project with FTP.</p><p>Although I have broad interests in many aspects and grasp the essential konwledge of the major, but I think at present, I want to do many things, but not be competent to do things professionally owing to lack of ample knowledge and ability. So I think further study is still urgent for me to realize selfvalue.</p></blockquote><p><code>我认为可以短一点</code></p><blockquote><p>Good morning/afternoon! Teachers. I am very glad to be here for this interview. </p><p>First, let me introduce myself. My name is XiaoMengjie. I come from Northwest University, majoring in Software Engineering.</p><p>I am open-minded and I like web development and am interested in Artificial intelligence field.</p><p>So I think further study is still urgent for me to realize selfvalue.</p></blockquote><p>2.英语描述操作系统</p><p>3.这个IP地址192.168.45.3是什么地址？</p><p>4.百度IP和电脑IP有什么不同</p><p>5.浏览一个网页都用到了哪些协议?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>6.离散数学中什么是蕴含</p><p>7.什么时候用到递归</p><p>8.做过什么项目</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;考查目标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;西工大复试的面试题集。&lt;/li&gt;
&lt;li&gt;复试准备阶段，尽管分数尴尬，也要准备复试。&lt;/li&gt;
&lt;li&gt;这里的题集以后会用得到的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;许多计算机基础问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Study" scheme="https://mysticalguest.github.io/categories/Study/"/>
    
    
      <category term="面试题集" scheme="https://mysticalguest.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>复试准备</title>
    <link href="https://mysticalguest.github.io/Study/53646.html"/>
    <id>https://mysticalguest.github.io/Study/53646.html</id>
    <published>2021-02-28T03:11:48.265Z</published>
    <updated>2021-04-08T13:04:13.039Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>考查目标：</p><ol><li>西工大初试结束后。</li><li>分数出来后，联系导师等事宜准备。</li></ol><p>网络上搜索，自己准备。</p></blockquote><a id="more"></a><h1 id="1-邮件模板"><a href="#1-邮件模板" class="headerlink" title="1.邮件模板"></a>1.邮件模板</h1><p>研究生博士生考试给导师发邮件模板</p><h2 id="开头-基本情况-写信目的"><a href="#开头-基本情况-写信目的" class="headerlink" title="开头+基本情况+写信目的"></a>开头+基本情况+写信目的</h2><p>尊敬的某老师：</p><p>您好！</p><p>不好意思打扰您了！我是来自某某大学某某专业的2017级本科的应届考生某某（来自某某省某某市的往届考生某某，本科毕业于某某大学），今年硕士统考报考某某大学某某专业学术/专业硕士，总分XXX分，政治XX分，英语XX分，数学XXX分，专业课XXX分。参考往年的复试分数线，我有机会进入复试。在网上查阅到您的相关资料和研究，一直以来对某某某某方向很感兴趣，所以很希望能够有机会师从于您，在您的课题组攻读硕士学位，所以冒昧写信给您，一方面希望了解您的招生情况，另一方面希望得到您关于复试准备的相关建议。</p><h2 id="本科成绩-综合能力专业能力"><a href="#本科成绩-综合能力专业能力" class="headerlink" title="本科成绩+综合能力专业能力"></a>本科成绩+综合能力专业能力</h2><p>本科期间，我学习认真刻苦，绩点XX，专业排名XX/XXX，位于专业前XX%，曾X次获得校X等奖学金；曾担任某某组织的某某干部，工作认真负责；同时，我也具有扎实良好的专业能力，曾在某某比赛(考试)中，获得某级别X等奖(取得XX分的成绩)。</p><h2 id="读研目的-展望"><a href="#读研目的-展望" class="headerlink" title="读研目的+展望"></a>读研目的+展望</h2><p>在过去的学习和实践中，我渐渐对<strong>某某某某方向</strong>产生了非常浓厚的兴趣，希望能更为深入的了解和学习<strong>某某某某方向</strong>的知识。在网上了解到您的相关资料，真心对您的研究方向非常感兴趣，能在众多学校众多优秀的老师中找到您对我来说真的是非常幸运。如果有机会能够师从于您，我定当加倍努力有所作为，不负老师的栽培。</p><h2 id="提问-祝福-结尾"><a href="#提问-祝福-结尾" class="headerlink" title="提问+祝福+结尾"></a>提问+祝福+结尾</h2><p>希望老师能为我在对<strong>某某某某方向</strong>学习道路上给予一些建议与指期待能够与您进一步探讨！感谢您在百忙之中阅读我的邮件，冒昧致信，恳请海涵，切盼回音。</p><p>祝老师身体健康，工作顺利！</p><p>​                                                                                          学生：某某</p><p>​                                                                                          时间：XXXX年XX月XX日</p><h1 id="2-英语介绍"><a href="#2-英语介绍" class="headerlink" title="2.英语介绍"></a>2.英语介绍</h1><blockquote><p>Good morning/afternoon! Teachers. I am very glad to be here for this interview. </p><p>First, let me introduce myself. My name is XiaoMengjie. I come from Northwest University, majoring in Software Engineering.</p><p>I am open-minded and I like web development and am interested in Artificial intelligence field.</p><p>So I think further study is still urgent for me to realize selfvalue.</p></blockquote><h1 id="3-专业介绍"><a href="#3-专业介绍" class="headerlink" title="3.专业介绍"></a>3.专业介绍</h1><h2 id="3-1-软件工程"><a href="#3-1-软件工程" class="headerlink" title="3.1 软件工程"></a>3.1 软件工程</h2><blockquote><p><strong><em>Software engineering is an engineering discipline that is concerned with all aspects of software production. Software development is a difficult activity that requires careful planning and execution. Through the learning of software development process and process management technology, I can effectively plan and manage software development activities.</em></strong></p></blockquote><p>软件工程是一门涉及软件生产各个方面的工程学科。软件的开发是一个很困难的活动，要求很仔细的计划和执行。通过对软件开发过程和过程管理技术的学习，能够有效地策划和管理软件开发活动。</p><h2 id="3-2-计算机组成原理"><a href="#3-2-计算机组成原理" class="headerlink" title="3.2 计算机组成原理"></a>3.2 计算机组成原理</h2><blockquote><p><strong><em>The principle of computer organization introduces the basic organization principle and internal working mechanism of the computer.</em></strong></p></blockquote><p>计算机组成原理介绍了计算机的基本组成原理和内部工作机制。</p><h2 id="3-3-操作系统"><a href="#3-3-操作系统" class="headerlink" title="3.3 操作系统"></a>3.3 操作系统</h2><blockquote><p><strong><em>The operating system course describes the internal structure, working principle and the realization of typical technologies of the operating system.</em></strong></p></blockquote><p>操作系统课程讲述了操作系统的内部结构、工作原理及典型技术的实现。</p><h2 id="3-4-计算机网络"><a href="#3-4-计算机网络" class="headerlink" title="3.4 计算机网络"></a>3.4 计算机网络</h2><blockquote><p><strong><em>The computer network course comprehensively and systematically introduces the development and principle of computer network architecture, physical layer, data link layer and other content.</em></strong></p></blockquote><p>计算机网络课程全面系统地介绍了计算机网络的发展和原理体系结构、物理层、数据链路层等内容。</p><h1 id="4-未来规划"><a href="#4-未来规划" class="headerlink" title="4.未来规划"></a>4.未来规划</h1><p>学习、实践、日常生活</p><p>学业进步，学术方面发表论文，实践方面，工作经验，正式工作基础，社团活动</p><p>在硕士期间，我除了完成学院要求的课程学分之外，我还将在老师指导下从两个方面来规划自己，分别为学术研究和工程实践，在学术研究方面，我会从阅读很多文献开始，和师兄师姐一起学习，编写论文争取发表，我的目标是在毕业之前发表一篇合格的论文，积极参与实验室的项目，锻炼自己的实践能力。</p><blockquote><p>During my master’s degree, in addition to completing the credits required by the college, I will also plan myself from two aspects, namely academic research and engineering practice. In academic research, I will read a lot of literature, study with my senior, write papers and strive for publication. My goal is to publish a qualified paper before graduation, and in practice I will actively participate in project in the laboratory, exercise my practical ability.</p></blockquote><p>老师的指导：Teacher’s guidance</p><h1 id="5-家乡"><a href="#5-家乡" class="headerlink" title="5.家乡"></a>5.家乡</h1><p>我的家乡是湖北襄阳，它是一个历史悠久的城市。孕育了许多有名之辈，比如郭靖黄蓉，诗人孟浩然等。来到襄阳，尝尝牛肉面，欣赏气势磅礴的汉江，感受这座城市深厚的历史底蕴。</p><blockquote><p>My hometown is Xiangyang, Hubei, which is a city with a long history. It gave birth to many famous people, such as Zhu Geliang, Guo Jing, Huang Rong and poet Meng Haoran. Come to Xiangyang, taste beef noodles, appreciate the majestic Hanjiang River, and feel the profound historical details of the city.</p></blockquote><h1 id="6-华南师范大学"><a href="#6-华南师范大学" class="headerlink" title="6.华南师范大学"></a>6.华南师范大学</h1><p>South China Normal University（SCNU）</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;考查目标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;西工大初试结束后。&lt;/li&gt;
&lt;li&gt;分数出来后，联系导师等事宜准备。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;网络上搜索，自己准备。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Study" scheme="https://mysticalguest.github.io/categories/Study/"/>
    
    
      <category term="复试" scheme="https://mysticalguest.github.io/tags/%E5%A4%8D%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>英语积累</title>
    <link href="https://mysticalguest.github.io/Study/45733.html"/>
    <id>https://mysticalguest.github.io/Study/45733.html</id>
    <published>2021-01-08T14:20:55.009Z</published>
    <updated>2021-08-18T02:35:00.687Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>考查目标：</p><ol><li>考研时期真题词汇和作文积累。</li><li>并且以后的英语积累也会记到这里。</li></ol><p>以我考的英语二为基础</p></blockquote><a id="more"></a><h2 id="积累"><a href="#积累" class="headerlink" title="积累"></a>积累</h2><h3 id="1-词汇量"><a href="#1-词汇量" class="headerlink" title="1.词汇量"></a>1.词汇量</h3><div class="table-container"><table><thead><tr><th>真题词汇集锦</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>2020年</td><td></td><td></td><td></td></tr><tr><td>（完形）tedious</td><td>单调乏味的</td><td>instructive</td><td>增长知识的，富有教益的</td></tr><tr><td>harsh</td><td>严厉的，残酷的</td><td>vague</td><td>含糊的，粗略的</td></tr><tr><td>fatigue</td><td>疲乏，疲劳</td><td>confront</td><td>面对遭遇</td></tr><tr><td>trying</td><td>令人厌烦的</td><td></td><td></td></tr><tr><td>（Text1）asocial</td><td>不合群的</td><td>trait</td><td>特点</td></tr><tr><td>perceive</td><td>认为，感觉</td><td>reciprocal</td><td>互惠的，相应的</td></tr><tr><td>readiness</td><td>乐意</td><td></td><td></td></tr><tr><td>（Text2）rigorous</td><td>谨慎的，严格的</td><td>justified</td><td>有充分理由的，合理地</td></tr><tr><td>（Text3）yet</td><td>用于否定</td><td>Its fate is yet to be decided.</td><td>它的命运尚未确定。</td></tr><tr><td>deem</td><td>认为，视为</td><td>vulunerable</td><td>易受攻击的</td></tr><tr><td>2019年</td><td></td><td></td><td></td></tr><tr><td>（完形）obsess</td><td>使痴迷</td><td>solely</td><td>仅仅，只</td></tr><tr><td>depict</td><td>v.描写</td><td>depiction</td><td>n.描写</td></tr><tr><td>aside from</td><td>除…以外</td><td>rigid</td><td>严格死板的，（人）不通融的</td></tr><tr><td>conceal</td><td>隐藏</td><td>hold onto</td><td>抓紧，保存</td></tr><tr><td>account for</td><td>解释，了解，查明</td><td>confirm</td><td>证实，确认</td></tr><tr><td>triumph</td><td>战胜，获胜</td><td>fluctuation</td><td>波动，起伏</td></tr><tr><td>zeal</td><td>热情</td><td></td><td></td></tr><tr><td>（Text1）appease</td><td>安抚</td><td>guilt still gets a bad rap</td><td>内疚感可不是件好事</td></tr><tr><td>deceptive</td><td>欺骗性的</td><td>addictive</td><td>使人上瘾的</td></tr><tr><td>inexcusable</td><td>不可原谅的</td><td>rein</td><td>控制</td></tr><tr><td>nasty</td><td>极差的</td><td>nastier impulses</td><td>恶意冲动</td></tr><tr><td>vice versa</td><td>反之亦然</td><td>rate</td><td>v.评估 n.速率</td></tr><tr><td>（Text2）count on</td><td>依赖，指望</td><td>soak up</td><td>吸收</td></tr><tr><td>consume</td><td>消耗，烧毁</td><td>be accustomed to sth</td><td>习惯于</td></tr><tr><td>（Text3）obstruct</td><td>阻碍</td><td>no numerical cap</td><td>没有数量限制</td></tr><tr><td>implausible</td><td>不合理的</td><td>plausible</td><td>可信的</td></tr><tr><td>cumbersome</td><td>缓慢冗长的</td><td>slow granting procedures</td><td>签发过程缓慢</td></tr><tr><td>curb</td><td>抑制</td><td>aggressive</td><td>激进的</td></tr><tr><td>2018年</td><td></td><td></td><td></td></tr><tr><td>utterly</td><td>完全的，绝对的</td><td>insidious</td><td>潜伏的</td></tr><tr><td>inferiority</td><td>劣势，低等</td><td>evaporate</td><td>蒸发，消失</td></tr><tr><td>asset</td><td>资产</td><td>physical assets</td><td>有形资产</td></tr><tr><td>astonishing</td><td>令人惊讶</td><td>intricate</td><td>错综复杂</td></tr><tr><td>2017年</td><td></td><td></td><td></td></tr><tr><td>bidder</td><td>投标者</td><td>dual</td><td>双重的</td></tr><tr><td>wordy</td><td>话多的，冗长的</td><td>tricky</td><td>狡猾的，棘手的</td></tr><tr><td>compensation</td><td>补偿</td><td>scarce</td><td>不足的，稀少的</td></tr><tr><td>2012年</td><td></td><td></td><td></td></tr><tr><td>ritual</td><td>惯例，礼节，仪式的</td><td>revise</td><td>修改，校订</td></tr><tr><td>scorn</td><td>蔑视</td><td>it has been particularly scorned</td><td>饱受诟病</td></tr><tr><td>mandate</td><td>强制执行，委托书</td><td>inflexible</td><td>僵化的</td></tr><tr><td>undermine</td><td>削弱</td><td>restrict</td><td>限制</td></tr><tr><td>impoverish</td><td>使贫穷</td><td>impoverished</td><td>贫乏的</td></tr><tr><td>chaotic</td><td>混乱的</td><td>faulty</td><td>不完美的，错误的</td></tr><tr><td>thorny</td><td>棘手的</td><td>empower</td><td>授权</td></tr></tbody></table></div><h3 id="2-句子"><a href="#2-句子" class="headerlink" title="2.句子"></a>2.句子</h3><div class="table-container"><table><thead><tr><th>小作文集锦</th></tr></thead><tbody><tr><td>Forbidden City is <strong>a great magnet for</strong> foreign tourists.</td></tr><tr><td>The hope of living a better life is his impetus to study.</td></tr><tr><td>I’ve come to the conclusion that …</td></tr><tr><td>take the initiative to do 积极主动做某事</td></tr><tr><td>of even greater concern is the fact that … 更加需要关注的是</td></tr><tr><td>It is far better to do 远不如做某事，最好做某事？</td></tr><tr><td>In short 简言之</td></tr><tr><td>As sb notes, …  正如某人所指出</td></tr><tr><td>exert onself to do sth 努力做某事</td></tr><tr><td>in this hour of need 紧要关头</td></tr><tr><td>hold temporary jobs 兼职</td></tr><tr><td>jumped markedlly 很大，急剧地，显著地</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>图表作文</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>address</td><td>处理，应对</td><td>supply</td><td>供应</td></tr><tr><td>pose</td><td>引起，产生</td><td>decelerate</td><td>减速</td></tr><tr><td></td><td></td><td></td></tr></tbody></table></div><blockquote><p>图表作文:<br>This argument has attracted a lot of attention. 这一观点已受到广泛关注。<br>This phenomenon can be attributed to the following reasons. 之所以出现这种现象，原因可能有以下几点。<br>However, this encouraging sign also presents challenges, like how to address the supply <strong>deficientcy</strong> posed by decelerated growth of <strong>museum</strong>s and people’s increasingly diverse need for exhibitions. 如何应对博物馆增长放缓带来的供不应求问题以及人们日益多样化的观展需求问题等。</p></blockquote><h2 id="小作文范文"><a href="#小作文范文" class="headerlink" title="小作文范文"></a>小作文范文</h2><h3 id="1-范文一"><a href="#1-范文一" class="headerlink" title="1.范文一"></a>1.范文一</h3><blockquote><p>Dear Li Ming,<br>    I’d like to congratulate you for winning the fierce competition for admission to a prestigious university. This success means that you have acquired extraoridinary learning capacity and if this capacity can be further developed in university, you will be competent to build your career.<br>    However, I must also warn you that the approaching university life is different to you previous school life. You should make adjustment for it. That is, you should mentally and practically prepare to be indepent and learn not for examination but for your life purpose. I wish you could learn to manage life and study by yourself in the following four years.<br>                                                                                                                                                    Sincerely yours,<br>                                                                                                                                                    Zhang Wei</p></blockquote><p>范文赏析：</p><div class="table-container"><table><thead><tr><th>短语部分</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>fierce competition</td><td>激烈竞争</td><td>admission</td><td>入场费</td></tr><tr><td>prestigious university</td><td>名校</td><td>prestigious</td><td>声誉高的，有威望的</td></tr><tr><td>extraordinary learning capacity</td><td>卓越的学习能力</td><td>previous school life</td><td></td></tr><tr><td>be competent to build your career</td><td>有能力创造一番事业</td><td>mentally</td><td>心理方面</td></tr><tr><td>make adjustment for it</td><td>做出调整</td><td>practically</td><td>实际层面</td></tr><tr><td>it counts much in schooling</td><td>对教学重要</td><td></td></tr></tbody></table></div><blockquote><p>长句部分：<br>learn not for examination but for your life purpose 不是为考试学习，而是为自己的人生目标学习。</p></blockquote><h3 id="2-范文二（2020小作文）"><a href="#2-范文二（2020小作文）" class="headerlink" title="2.范文二（2020小作文）"></a>2.范文二（2020小作文）</h3><blockquote><p>Dear Friends,<br>    I’m so delighted that you trust me to arrange your trip. I’m writing to inform you of the historical attraction to visit the Terracotta. Army, one of the greastest archaeological discoveries of all time and share some travel trips.<br>    Located to the east of downtown Xi’an, the Terracotta Army is a massive collection of life-size clay warriors and horses buried in the tomb of China’s First Emperor. It offers a fascinating glimpse into the country’s glorious past. To get a better view of these breathtaking sculpture, you may consider avoiding public holidays in China or setting out early if you have to visit the mesume on those days. In addition, it’s also advisable to rent a multilingual audio guide at the ticket office, which will certainly make your trip informative.<br>    Hope this trip suits your taste and that you all enjoy it.<br>                                                                                                                                                    Yours sincerely,<br>                                                                                                                                                    Li Ming</p></blockquote><p>范文赏析：</p><div class="table-container"><table><thead><tr><th>短语部分</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>be so delighted that …</td><td></td><td>arrange your trip</td><td></td></tr><tr><td>Terracotta</td><td>兵马俑</td><td>the greatest archaeological discoveries</td><td>最伟大的考古发现</td></tr><tr><td></td><td></td><td></td></tr></tbody></table></div><h2 id="大作文范文"><a href="#大作文范文" class="headerlink" title="大作文范文"></a>大作文范文</h2><h3 id="1-范文一-1"><a href="#1-范文一-1" class="headerlink" title="1.范文一"></a>1.范文一</h3><blockquote><p>​    China’s auto market was still dominated by Japanese, Chinese and American brands. American cars remained the third most popular int the market with a slight increase in market share. A noticeable change occurred concerning Japanese and Chinese brands. With its market share slipping by almost 10%, Japanese brands were displaced from their leading position by Chinese brands which expanded their share by around 10%.<br>​    The performance of American brand cars is to be expexted, given their worldwide fame and reliable quality. The big change in the performance of Japanese and Chinese brands seems sudden but is not unexpected. Chinese auto producers had narrowed the technology gap between themselves and foreign competitors, and cleverly switched their promotion strategies to satisfy Chinese customers’ appetite for a bargin. While Chinese brands were growing, Japanese brands were hit by a reputation crisis caused by frequent quality compliants.<br>​    The plight of Japanese brands is a reminder that quality is the soul of products. Hopefully, Chinese automakers will consistently guarantee high quality, thereby protecting their own reputation so as to maintain market popularity.</p></blockquote><p>范文赏析：</p><div class="table-container"><table><thead><tr><th>短语部分</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>auto</td><td>汽车</td><td>was still dominated by Japanese</td><td>被控制，被占据</td></tr><tr><td>remained the third most popular</td><td></td><td>a slight increase</td><td></td></tr><tr><td>share</td><td>股份，份额</td><td>noticeable</td><td>显著的</td></tr><tr><td>slipping</td><td>下降</td><td>but is not unexpected</td><td>也在预料之中</td></tr><tr><td>expanded</td><td>扩大，增加</td><td>narrowed the technology gap</td><td>缩小了技术差距</td></tr><tr><td>plight</td><td>困境，苦难</td><td>thereby</td><td>从而</td></tr></tbody></table></div><blockquote><p>长句部分：</p><p>were displaced from their leading position 主导地位被取代</p><p>The performance of American brand cars is to be expexted, given their worldwide fame and reliable quality. 鉴于美国品牌汽车的世界声誉和可信赖的质量，其表现预料之中。</p><p>and cleverly switched their promotion strategies to satisfy Chinese customers’ appetite for a bargin. 并聪明地改变了其推广策略一满足中国消费者对便宜商品的喜好。</p><p>Japanese brands were hit by a reputation crisis caused by frequent quality compliants. 日本品牌因频繁的质量投诉遭到信誉危机的打击。</p><p>The plight of Japanese brands is a reminder that quality is the soul of products. 日本品牌的困境提醒一个事实，质量是产品的灵魂。</p><p>Chinese automakers will consistently guarantee high quality, 希望中国汽车制造商能一贯保证好的质量</p></blockquote><h3 id="2-范文二"><a href="#2-范文二" class="headerlink" title="2.范文二"></a>2.范文二</h3><blockquote><p>​     Employees aged above 50 years were most likely to report satisfaction, with 40% of them indicating they were content. Employees aged 40 years or younger were less willing to declare satisfaction. Employees aged between 41 and 50 were surely the unhappiest; none of them felt satisfied and the proportion of respondents reporting dissatisfaction was as high as 64%.<br>​    The significant different in job satisfaction relates to employees’ career situation. Employees aged between 41 and 50, less energetic than younger crowd and less competent than older professionals, reach a career plateau, showing deep job dissatisfaction. In contrast, younger colleages, in spite of occasional confusion, are mostly in an upward spiral, and understandably feel happier. As for older colleagues, many of them have achieved career maturity and their careers are going to be crowned with a relaxing retirement life. Not surprisingly, they are the happiest.<br>​    Career trouble may afflict people at all ages. For lasting happiness with our jobs, positive attitude is necessary.</p></blockquote><p>范文赏析：</p><div class="table-container"><table><thead><tr><th>短语部分</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>aged above 50 years</td><td>定语</td><td>they were content</td><td></td></tr><tr><td>proportion</td><td>比例</td><td>as high as</td><td>as…as 句型</td></tr><tr><td>significant difference</td><td></td><td>In contrast</td><td>比较而言</td></tr><tr><td>inspite of occasional confusion</td><td>不管（除了）偶尔感到困惑</td><td>in an upward spiral</td><td></td></tr><tr><td>understandably</td><td>正常地</td><td>career maturity</td><td>职业成熟</td></tr><tr><td>be crowned with</td><td>获得，被冠以</td><td>Not surprisinly</td><td></td></tr><tr><td>afflict</td><td>困扰，困惑</td><td></td></tr></tbody></table></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">长句部分：</span><br><span class="line"></span><br><span class="line">were less willing to declare satisfaction 更不愿意宣称对工作满意</span><br><span class="line"></span><br><span class="line">were surely the unhappiest</span><br><span class="line"></span><br><span class="line">less competent than older professionals</span><br><span class="line"></span><br><span class="line">reach a career plateau 进入职场高原（停滞不前的局面）</span><br></pre></td></tr></table></figure><h2 id="专业英语"><a href="#专业英语" class="headerlink" title="专业英语"></a>专业英语</h2><h3 id="1-词汇量-1"><a href="#1-词汇量-1" class="headerlink" title="1.词汇量"></a>1.词汇量</h3><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>20ns(20 nanoseconds)</td><td>20纳秒</td><td>sensor</td><td>传感器</td></tr><tr><td>subcarrier</td><td>副载波，子信道</td><td>hybrid</td><td>混合的；混合物</td></tr><tr><td>intensity</td><td>强度</td><td>adopt</td><td>收养，采用(某方法)，采取(某态度)</td></tr><tr><td>modulation [ˌmɒdjʊˈleɪʃən]</td><td>调制</td><td>exponentiate</td><td>指数</td></tr><tr><td>Weibull</td><td><a href="https://baike.baidu.com/item/%E9%9F%A6%E5%B8%83%E5%B0%94%E5%88%86%E5%B8%83">韦布尔分布</a></td><td>turbulence</td><td>湍流</td></tr><tr><td>channel</td><td>通道，信道</td><td>postdoctoral</td><td>博士后</td></tr><tr><td>robust</td><td>强健的</td><td>dynamics</td><td>动力学</td></tr></tbody></table></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">长句部分：</span><br><span class="line">data-driven predictive reduced-order-modeling 数据驱动的预测降序建模</span><br><span class="line"></span><br><span class="line">computational turbulence 计算湍流</span><br><span class="line"></span><br><span class="line">Robust and Interpretable Learning for Operator-Theoretic Modeling of Non-linear Dynamics</span><br><span class="line">非线性动力学算子理论建模的鲁棒性和可解释性学习</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;考查目标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;考研时期真题词汇和作文积累。&lt;/li&gt;
&lt;li&gt;并且以后的英语积累也会记到这里。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以我考的英语二为基础&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Study" scheme="https://mysticalguest.github.io/categories/Study/"/>
    
    
      <category term="English" scheme="https://mysticalguest.github.io/tags/English/"/>
    
  </entry>
  
</feed>
