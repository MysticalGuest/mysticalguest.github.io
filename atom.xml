<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Longing(MysteryGuest的博客)</title>
  
  <subtitle>心向星光</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mysticalguest.github.io/"/>
  <updated>2021-05-13T10:07:53.167Z</updated>
  <id>https://mysticalguest.github.io/</id>
  
  <author>
    <name>MysticalGuest</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>笔试和面经</title>
    <link href="https://mysticalguest.github.io/Interview/48d83c99.html"/>
    <id>https://mysticalguest.github.io/Interview/48d83c99.html</id>
    <published>2021-04-20T00:00:00.000Z</published>
    <updated>2021-05-13T10:07:53.167Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>面试Java研发实习生所做的知识准备，及以后的积累</p></blockquote><a id="more"></a><h2 id="面试MindCoord过程"><a href="#面试MindCoord过程" class="headerlink" title="面试MindCoord过程"></a>面试MindCoord过程</h2><p>邮件通知时间也挺准（2021/4/20 – 15:10-15:25, UTC+8），我大概15:08进腾讯会议的，里面只有我一个人。到了10分钟会进来一个小姐姐，确认身份后，会问你对公司的了解，也没有自我介绍。说完自己的了解后，她会以很快且口齿清楚的方式快速介绍MindCoord公司的一些情况。介绍完就开始问问题了，题量和时间都是有限的，如果思考一会儿还是回答不出，就会跳过。下面是我印象中所有问题（不分先后）：</p><h3 id="技术类问题"><a href="#技术类问题" class="headerlink" title="技术类问题"></a>技术类问题</h3><ul><li>进程和线程</li><li>什么是Java深拷贝和浅拷贝</li><li>Java基本数据类型，枚举（穷举？），除了基本类型，其他叫什么类型（引用类型）</li><li>编程遇到的错误类型，除0是什么错误类型（RuntimeException）</li><li>Java四种引用类型</li><li>finally的用法，fianl的用法</li><li>创建多线程的方法（这里问的就是线程创建的方法！！我就只以为是单线程！！）</li><li>Spring的设计模式</li><li>静态方法能不能调用非静态方法，并说明（不能！！我以为能）</li><li>数据库的范式（），并详细说一下第一范式</li><li>什么是索引，为什么有索引，优点及缺点</li></ul><h3 id="非技术类问题"><a href="#非技术类问题" class="headerlink" title="非技术类问题"></a>非技术类问题</h3><ul><li>平时娱乐去哪些场所，消费如何</li><li>工作中不喜欢和什么样的人合作</li><li>对于工作中任务较多，压力较大，怎么看的</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>面试都是Java基础，MindCoord是美国的一个创业公司，国内信息很少，我也是从官网上收集的信息。</p><blockquote><p>MindCoord Inc. 是一家成立于美国波士顿的新科技企业,拥有自由、开放、包容、多元的全球化团队,囊括了来自世界各地的智慧人才。公司致力于为所有人提供更简单的虚拟空间创作方案,业务涵盖VR、AR、XR等虚拟成像领域,旗下拥有3D动画快速制作短视频APP——PortalHiker、HereFounder等软件产品和机器宠物等硬件产品。我们欢迎想挑战全新领域的科技人才一同加入,在未知的道路上尽情探索,享受发明创造的乐趣。</p><p><strong>产品</strong></p><ul><li>3D广告：我们通过桌面软件PortalHiker为AR内容制作解决方案提供帮助，该软件可以帮助企业产生可在其网站和移动应用程序上使用的交互式AR体验。</li><li>PortalHiker是3D和AR内容制作应用程序，既是内容创建引擎又是3D / AR内容社交媒体。作为在移动设备上生成3D内容的最简单方法，PortalHiker允许用户通过将虚拟元素与现实世界相结合来创建和共享他们的创造力。</li><li>在各个平台的视频游戏中插入无干扰的品牌广告，为游戏开发人员提供了通过其游戏获利的可能性。</li></ul><p>使用增强现实技术来训练患有帕金森氏病的患者再次行走。</p><p><strong>技术</strong></p><ul><li>捕捉运动：以人为中心的计算机视觉的基础是机器看到和理解人的运动的能力。3D / AR体验或虚拟实时流的形式制作动画内容。将易用性和性能作为重中之重的原因。</li><li>3D内容编辑器：生成3D和AR内容。</li><li>3D检视器：我们基于网络的3D查看器可在网站上高质量显示3D内容。</li></ul></blockquote><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><ul><li>每日一个Java学习视频</li><li>每日刷题，力扣，牛客等</li></ul><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><ul><li><p>自动类型提升</p><p>结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>/<span class="keyword">char</span>/<span class="keyword">short</span>--&gt;<span class="keyword">int</span>--&gt;<span class="keyword">long</span>--&gt;<span class="keyword">float</span>-&gt;<span class="keyword">double</span></span><br></pre></td></tr></table></figure><p>特别的：当<code>byte、char、short</code>三种类型的变量做运算时，结果为int型。String特殊</p></li></ul><h3 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h3><ul><li>强引用（StrongReference）<ul><li>强引用可以直接访问目标对象。</li><li>强引用所指向的对象在任何时候都不会被系统回收。JVM宁愿抛出OOM异常，也不会回收强引用所指向的对象。</li><li>可能导致内存泄露？</li></ul></li><li>软引用（SoftReference）<ul><li>一个持有软引用的对象不会被JVM很快回收，JVM会根据当前堆的使用情况来判断何时回收。当堆使用率临近阈值时，才会回收软引用的对象。因此，软引用可以用于实现对内存敏感的高速缓存。</li></ul></li><li>弱引用（WeakReference）<ul><li>在系统GC时，只要<strong>发现弱引用</strong>，不管系统堆空间是否足够，都会将对象<strong>进行回收</strong>。</li></ul></li><li>虚引用（PhantomReference）<ul><li>一个持有虚引用的对象，和没有引用几乎是一样的，<strong>随时可能被垃圾回收器回收</strong>。当试图通过虚引用的get()方法取得强引用时，总是会失败。并且，虚引用必须和引用队列一起使用，它的作用在于跟踪垃圾回收过程。</li></ul></li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li><p><code>sleep</code>方法与<code>wait</code>方法的区别</p><ul><li><p>wait：此方法来自于Object类，必须由<strong>锁对象</strong>进行调用（不是任意对象调用）</p><p>注意：</p><ul><li>锁对象需要在哪里存在？锁对象必须在同步中出现。</li><li>同步方法的锁对象默认就是字节码对象。</li></ul></li><li><p>sleep：此方法来自于Thread类，是Thread类的静态方法，可以类名加点调用</p></li><li><p>wait方法：</p><ul><li>空参数：会让线程进入无限等待状态，进入了无限等待状态后，必须由（其他线程的）notify方法对其进行唤醒。</li><li>有参数：效果和sleep类似</li></ul></li><li><p>区别：wait方法在等待的过程中，释放锁对象；sleep方法在休眠的过程中不会释放锁对象。</p></li></ul></li></ul><ul><li><p><code>ConcurrentHashMap</code>与<code>HashMap</code>底层数据结构</p><ul><li><code>JDK1.7</code>中HashMap由<strong>数组</strong>+<strong>链表</strong>组成，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。</li><li><code>JDK1.8</code>中HashMap由<strong>数组</strong>+<strong>链表/红黑树</strong>组成，当链表长度大于<strong>阈值</strong>（默认为8）时，将链表转化为红黑树，以减少搜索时间。转为红黑树后，链表的结构仍然会存在，通过next属性维持，红黑树节点在进行操作时都会维护链表的结构。</li><li>原理<ul><li>如何实现扩容：初始容量16和加载因子0.75。每次扩容都为原来的两倍。当达到其容量的3/4时，会自动进行扩容，如初始为16，存储第12个元素时，这时候会扩容为32，同时，这时需要创建一张新表，将原表的数据移到新表，可以看<code>resize()</code>和<code>transfer()</code>方法。表？<code>Entry[] newTable = new Entry[newCapacity];</code></li><li>如何实现存取：HashMap存取时，都需要<strong>计算</strong>当前key应该对应Entry[]数组哪个元素，通过调用<code>hash()</code>方法，得到<strong>hash值</strong>，再调用<code>indexFor()</code>得到Entry[]数组<strong>下标</strong>。如果有两个相同的结果，如果<strong>hash相同且key对象为同一个</strong>，则为同一个对象，直接在该位置替换原对象；否则为不同对象，这时候发生<strong>碰撞</strong>了，我们通过链表来存储，可以分析<code>createEntry()</code>方法。</li></ul></li><li><code>JDK1.7</code>中ConcurrentHashMap由<strong>分段数组</strong>+<strong>链表</strong>组成。ConcurrentHashMap是由<em>Segment数据结构</em>和<em>HashEntry数据结构</em>组成。</li><li><code>JDK1.8</code>中ConcurrentHashMap<em>取消了Segment分段锁</em>，采用CAS算法和<em>synchronized</em>来保证并发安全。数据结构跟HashMap1.8的结构类似， 是<strong>数组</strong>+<strong>链表/红黑树</strong>。（jdk1.6以后对synchronized锁做了很多优化，比如偏向锁、轻量级锁、自旋锁、锁消除、锁粗化等）</li><li>如何实现同步：<ul><li>HashEntry用于存储键值对数据，HashEntry内部类里的value ，以及链表next都是<code>volatile</code>修饰的，能保证获取时的可见性。</li><li><strong>Segment数组</strong>中的每个元素包含一个<strong>HashEntry数组</strong>，HashEntry数组中的每个元素是一个链表结构的元素。Segment数组的每个元素各守护着一个HashEntry数组中的素有元素。当对HashEntry数组的数据进行修改时，必须首先获得对应的Segment数组元素的锁。</li><li><code>JDK1.7</code>时实现线程安全的方式：首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问，提高并发访问率。</li><li><code>JDK1.8</code>时实现线程安全的方式：synchronized只锁定当前链表或者红黑树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</li></ul></li></ul></li><li><p>volatile和synchronized区别</p><ul><li>线程安全性包括两个方面：可见性，原子性。</li><li>volatile轻量级，只能<strong>修饰变量</strong>；只保证数据的<strong>可见性</strong>，不能用来同步，多个线程并发访问volatile修饰的变量<strong>不会阻塞</strong>。</li><li>synchronized重量级，可以修饰类、方法、代码段；保证可见性和原子性，多个线程争取synchronized锁对象时，会出现阻塞。</li></ul></li></ul><p>多线程访问这个方法（类方法）就存在线程不安全的问题</p><p>指令重排</p><p>11没看</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="六大范式（Normal-form）"><a href="#六大范式（Normal-form）" class="headerlink" title="六大范式（Normal form）"></a>六大范式（Normal form）</h3><p>关系数据库中的关系是满足一定要求的，满足不同程度要求的称为<em>不同的范式</em>。满足最低要求的称为<em>第一范式</em>，简称<strong>1NF</strong>；在第一范式的基础上满足进一步要求的称为第二范式，简称2NF，其余范式以此类推。一般来说，数据库只需满足第三范式就行了。</p><p>对于各范式之间有如下关系：<script type="math/tex">1NF\supset2NF\supset3NF\supset BCNF\supset4NF\supset5NF</script></p><ul><li><p>第一范式</p><ul><li><p>定义：属于第一范式关系的所有属性都不可再分，即数据项不可分。</p></li><li><p>理解：1NF强调数据表的原子性，是其他范式的基础</p></li><li><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|  商品  |</span><br><span class="line">|名称|数量|</span><br></pre></td></tr></table></figure><p>上表将<em>商品</em>这一数据项又划分为<em>名称</em>和<em>数量</em>两个数据项，不符合1NF。应改为如下表所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|商品名称|商品数量|</span><br></pre></td></tr></table></figure><p>但日常生活中仅用第一范式来规范表格是远远不够的，依然会存在数据冗余过大、删除异常、插入异常、修改异常的问题，此时就需要引入<em>规范化</em>概念，将其转化为更标准化的表格，减少数据依赖。</p></li><li><p>规范化：一个低一级的<em>关系模式</em>通过模式分解可以转化为若干个高一级范式的关系模式的集合，这个过程叫做规范化。</p></li></ul></li><li><p>第二范式</p><ul><li><p>候选码：若关系中的某一<em>属性组</em>的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码。若一个关系中有<em>多个候选码</em>，则选定其中一个为<em>主码</em>。</p></li><li><p>主属性：所有候选码的属性称为主属性。不包含在任何候选码中的属性称为<em>非主属性</em>或<em>非码属性</em>。</p></li><li><p>函数依赖：设R(U)是属性集U上的关系模式，X、Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称Y函数依赖于X或X函数确定Y。</p><script type="math/tex; mode=display">X\rightarrow Y \ \ Y函数依赖于X</script></li><li><p>完全函数依赖： 设R(U)是属性集U上的关系模式，X、Y是U的子集。如果Y函数依赖于X，且对于X的任何一个真子集X’，都有Y不函数依赖于X’，则称Y对X完全函数依赖。记作：如果Y函数依赖于X，但Y不完全函数依赖于X，则称Y对X部分函数依赖。</p><script type="math/tex; mode=display">X\stackrel{F}{\longrightarrow} Y \quad\quad\quad\quad Y对X完全函数依赖</script><script type="math/tex; mode=display">X\stackrel{P}{\longrightarrow} Y \quad\quad\quad\quad Y对X部分函数依赖</script></li><li><p>定义：若某关系R属于第一范式，且每一个非主属性<strong>完全函数依赖于</strong>任何一个<em>候选码</em>，则关系R属于第二范式。</p></li><li><p>理解：第二范式是指每个表必须有一个（有且仅有一个）数据项作为主键（primary key），其他数据项与关键字或者主键一一对应，即其他数据项完全依赖于关键字或主键。由此可知单主属性的关系均属于第二范式。</p></li></ul></li><li><p>第三范式</p><ul><li>定义：非主属性既不<strong>传递依赖于</strong>码，也不<strong>部分依赖于</strong>码。</li><li>传递函数依赖的概念：在<script type="math/tex">R(U)</script>中，若<script type="math/tex">X\rightarrow Y,Y\nrightarrow X,Y\rightarrow Z</script>，Z不属于Y，则称Z对X传递函数依赖。记作<script type="math/tex">X \stackrel{传递}{\longrightarrow}Z</script> 。</li><li>理解：第三范式要求在满足第二范式的基础上，<em>任何非主属性**</em>不依赖于<em>*其他非主属性，即在第二范式的基础上，</em>消除了传递依赖*。</li></ul></li><li><p>BC范式（巴斯-科德范式）</p><ul><li>定义：关系模式<script type="math/tex">R(U,F)</script>中，若每一个决定因素都包含码，则<script type="math/tex">R(U,F)</script>属于BCFN。</li><li>理解：根据定义我们可以得到结论，一个满足BC范式的关系模式有<ul><li>所有非主属性对每一个码都是完全函数依赖</li><li>所有主属性对每一个不包含它的码也是完全函数依赖</li><li>没有任何属性完全函数依赖于非码的任何一组属性</li></ul></li><li>举例：有关系模式C(Cno, Cname, Pcno)，Cno, Cname, Pcno依次表示课程号、课程名、先修课。可知关系C只有一个码Cno，且没有任何属性对Cno部分函数依赖或传递函数依赖，所以关系C属于第三范式，同时Cno是C中的唯一决定因素，所以C也属于BC范式。</li></ul></li><li><p>第四范式</p><ul><li>定义：限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。</li><li>理解：显然一个关系模式是4NF，则必为BCNF。也就是说，当一个表中的非主属性互相独立时（3NF），这些非主属性不应该有多值，若有多值就违反了4NF。</li></ul></li><li><p>第五范式（完美范式）</p><ul><li>第五范式有以下要求：<ul><li>必须满足第四范式</li><li>表必须可以分解为较小的表，除非那些表在逻辑上拥有与原始表相同的主键。</li></ul></li><li>第五范式是在第四范式的基础上做的进一步规范化。第四范式处理的是相互独立的多值情况，而第五范式则处理相互依赖的多值情况。</li></ul></li></ul><h3 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h3><p><strong>关系模式是对关系的描述</strong>，或者说二维表的表头，设有关系R，属性A1、A2、A3，则表示为<script type="math/tex">R(A1,A2,A3)</script>，关系数据库中的关系模式是型，关系的值。</p><ul><li><p>什么是关系？</p><p>关系实质上是<em>一张二维表</em>，并满足以下条件：</p><ul><li>列不可分性（1NF）</li><li>行列无序性（交换列的前后顺序不影响关系模型的语义表达）</li><li>实体完整性（唯一）</li></ul></li><li><p>属性：二维表中的每一列称为属性</p></li><li><p>值域（域）：属性的取值范围</p></li><li><p>元组（记录）：二维表中的一行数据。</p></li><li><p>关系模式可用五元组表示</p><p><script type="math/tex">R(U,D,Dom,F)</script>，其中R：表示关系名，U：表示属性集合，D为U中属性对应域的集合（数据域？），Dom：表示属性域，F：表示函数依赖。</p></li><li><p>关系模型完整性约束</p><ul><li>实体完整性</li><li>参照完整性</li><li>用户自定义完整性</li></ul></li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul><li><p>定义：索引是定义在数据库表基础之上，有助于<em>无需检查所有记录</em>而<em>快速定位</em>所需记录的一种辅助存储结构，由一系列存储在磁盘上的索引项组成，每一种索引项由<em>索引字段</em>和<em>行指针</em>构成。</p></li><li><p>优点：</p><ul><li>提高查询效率</li><li>通过创建唯一索引，可以保证数据库中每一行数据的<em>唯一性</em></li><li>在使用分组和排序子句进行数据检索时，可以减少查询中<em>分组和排序</em>的时间</li></ul></li><li><p>缺点：</p><ul><li>创建索引和维护索引<em>耗费时间</em>，且时间随数据量增大而增大</li><li><em>占用物理内存</em>，如果建立聚簇索引，所需空间更大</li><li>在对表中的数据进行增删改时需要耗费较多的时间，因为索引也要<em>动态地维护</em></li></ul></li><li><p>概念：</p><ul><li>聚簇索引：将数据存储与索引<em>放到一块</em>，找到索引也就找到了数据，主文件按照对应字段排序存储，索引文件无重复排序存储。</li><li>非聚簇索引：将数据存储于索引分开存储，索引结构的叶子节点指向了数据的对应行，主文件并没有按照对应字段排序存储，索引文件有重复排序存储。</li></ul></li><li><p><em>索引用于快速找出在某个列中有一特定值的行。不使用索引，MySQL必须从第1条记录开始然后读完整个表直到找出相关的行，还需要考虑每次读入数据页的IO开销。</em></p><p><em>大多数情况下都（默认）采用B树来构建索引。只是空间列类型的索引使用R-树，并且MEMORY表还支持hash索引。B树是平衡多叉树，每个节点存放多少个值取决于值所占的空间，这与每一张数据页存放多少条记录与记录信息量有关同理。节点中的值是以非降序进行排列的，节点中的值总是小于等于指向它的结点中的值。</em></p><p><em>MySQL使用B树构造索引的情况下，是由叶子指向具体的页和记录的。并且一个叶子有一个指针指向下一个叶子。</em></p></li><li><p>使用索引时需要注意：</p><ul><li>只对<code>WHERE</code>和<code>ORDER BY</code>需要查询的字段设置索引，避免无意义的硬盘开销</li><li>组合索引支持<em>前缀索引</em></li><li>更新表的时候，如增删记录，MySQL会自动更新索引，保持树的平衡；因此更多的索引意味着<strong>更多的维护成本</strong></li></ul></li><li><p>索引分四类：</p><ul><li>index：普通的索引，数据可以重复</li><li>fulltext：全文索引，用来对大表的文本域(char，varchar，text)进行索引。语法和普通索引一样</li><li>unique：唯一索引，唯一索引，要求所有记录都唯一</li><li>primary key：主键索引，也就是在唯一索引的基础上相应的列必须为主键</li></ul></li></ul><h3 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h3><ul><li>为什么要使用联合索引？<ul><li>减少开销：建立一个组合索引<code>(A,B,C)</code>，实际相当于建立了<code>(A),(A,B),(A,B,C)</code>三个索引。<em>每多一个索引，都会增加写操作的开销和磁盘空间的开销</em>。但对于大量数据的表，使用组合索引会大大减小开销！</li><li>覆盖索引：如果有查询操作，可以直接通过遍历索引取数据，无需查询表，这会减少随机IO操作。减少随机操作是DBA主要优化策略。</li><li>效率高：多条件筛选数据。</li></ul></li><li>使用方法：<ul><li>最左原则（<em>带头大哥不能死，中间兄弟不能断</em>）：从前往后依次使用生效，如果中间某个索引没有使用，那么断点前面的索引部分起作用，断点后面的索引<em>没有起作用</em>。上面的组合索引可以支持<code>(A),(A,B),(A,B,C)</code>三种组合进行查找。两个或更多个列上的索引被称作复合索引。</li></ul></li></ul><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><ul><li><p>悲观锁</p><p>总是<strong>假设最坏的情况</strong>，每次<em>当前线程</em>去拿数据的时候都认为<em>其他线程</em>会修改，所以每次在拿数据的时候<strong>都会上锁</strong>，这样<em>其他线程</em>想拿这个数据就会阻塞直到<em>其他线程</em>拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<code>synchronized</code>和<code>ReentrantLock</code>等<em>独占锁</em>就是悲观锁思想的实现。</p></li><li><p>乐观锁</p><p>总是<strong>假设最好的情况</strong>，每次<em>当前线程</em>去拿数据的时候都认为<em>其他线程</em>不会修改，所以<strong>不会上锁</strong>，但是在更新的时候会判断一下在此期间<em>其他线程</em>有没有去更新这个数据，可以使用<em>版本号机制</em>和<em>CAS算法</em>实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于<em>write_condition机制</em>，其实都是提供的乐观锁。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式<em>CAS</em>实现的。</p></li><li><p>两种锁的使用场景</p><p>两种锁<strong>各有优缺点</strong>，不可认为一种好于另一种，乐观锁适用于<strong>写比较少</strong>的情况下（<strong>多读少写场景</strong>），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个<strong>吞吐量</strong>。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的<em>进行retry</em>，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适（<strong>多写场景</strong>）。</p></li><li><p>乐观锁常见的两种实现方式</p><ul><li><p>版本号机制</p><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值<strong>相等时</strong>才更新，否则重试更新操作，直到更新成功。</p></li><li><p>CAS算法（compare and swap，比较与交换）</p><p>有名的<strong>无锁算法</strong>。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。<strong>CAS算法</strong>涉及到三个操作数</p><ul><li>需要读写的变量值 V</li><li>进行比较的值 A</li><li>拟写入的新值 B</li></ul><p>当且仅当 V 的值等于A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个<strong>自旋操作</strong>，即<strong>不断的重试</strong>。</p></li></ul></li><li><p>乐观锁的缺点</p><ul><li><p><strong>ABA问题</strong>：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。</p><p><code>JDK 1.5</code>以后的<code>AtomicStampedReference</code>类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p></li><li><p><strong>循环时间长开销大</strong>：<strong>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销</strong>。<em>如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</em></p></li><li><p><strong>只能保证一个共享变量的原子操作</strong>：CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference</code>类把多个共享变量合并成一个共享变量来操作。</p></li></ul></li></ul><h3 id="数据库事务特性（Transaction）"><a href="#数据库事务特性（Transaction）" class="headerlink" title="数据库事务特性（Transaction）"></a>数据库事务特性（Transaction）</h3><ul><li><p>事务</p><ul><li>定义：所谓事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。</li><li>四个特点ACID：<ul><li>原子性Atomicity</li><li>一致性Consistency</li><li>隔离性Isolation</li><li>耐久性Durability</li></ul></li></ul></li><li><p>原子性</p><ul><li><p>定义：原子性是指事务是一个<em>不可再分割</em>的工作单位，事务中的操作要么都发生，要么都不发生。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/MySQL/atomicity.jpg" style="zoom:60%;" /></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">begin transaction</span><br><span class="line">  select ... from ...;</span><br><span class="line">  ...;</span><br><span class="line">  update account set ... where ...;</span><br><span class="line">  if Error then</span><br><span class="line">    rollback</span><br><span class="line">  else</span><br><span class="line">    commit</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>分析：在事务中的增删改查语句，要么都执行，要么就都不执行。</p></li><li><p>解决方法：在DBMS中，默认情况下一条SQL就是一个单独事务，事务是自动提交的。只有显式地使用<code>start transaction</code>开启一个事务，才能将一个代码块放在事务中执行。保障事务的原子性是DBMS的责任，为此许多数据源采用日志机制。<em>例如，SQL Server使用一个预写事务日志，在将数据提交到实际数据页面前，先写在事务日志上。</em></p></li></ul><ul><li><p>一致性</p><ul><li><p>定义：一致性是指在事务开始之前和事务结束以后，数据库的<strong>完整性约束没有被破坏</strong>。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。</p></li><li><p>解决方法：保障事务的一致性，可以从以下两个层面入手</p><ul><li><p>数据库机制层面</p><p>在一个事务执行之前和之后，数据会符合你设置的约束（唯一约束，外键约束，Check约束等）和触发器设置。这一点是由<code>SQL SERVER</code>进行保证的。比如<em>转账</em>，则可以使用CHECK约束两个账户之和等于2000来达到一致性目的。</p></li><li><p>业务层面</p><p>对于业务层面来说，一致性是保持业务的一致性。这个业务一致性需要由<em>开发人员进行保证</em>。当然，很多业务方面的一致性，也可以通过转移到数据库机制层面进行保证。</p></li></ul></li></ul></li><li><p>隔离性</p><ul><li><p>定义：多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。（Java多线程锁对象）</p></li><li><p>分析：这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它<em>之前的状态</em>，要么是另一事务修改它<em>之后的状态</em>，事务不会查看到<em>中间状态</em>的数据。</p><p>当多个事务并发时，SQL Server利用<strong>加锁和阻塞</strong>来保证事务之间不同等级的隔离性。一般情况下，完全的隔离性是不现实的，完全的隔离性要求数据库同一时间只执行一条事务，这样会严重<em>影响性能</em>。想要理解SQL Server中对于隔离性的保障，首先要了解并发事务之间是如何干扰的。</p></li><li><p>事务之间的互相影响：<strong>脏读</strong>，<strong>不可重复读</strong>，<strong>幻读</strong>，<strong>丢失更新</strong>。</p></li><li><p>脏读：一个事务读取了另一个事务<strong>未提交的数据</strong>，而这个数据是有可能回滚的。</p></li><li><p>不可重复读：在数据库访问中，一个事务范围内两个<strong>相同的查询却返回了不同数据</strong>。这是由于查询时系统中其他事务修改的提交而引起的。</p></li><li><p>幻读（虚读）：当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种<strong>修改</strong>涉及到表中的<strong>全部数据行</strong>。同时，第二个事务也修改这个表中的数据，这种修改是向表中<strong>插入</strong>一行<strong>新数据</strong>。那么，以后就会发生操作第一个事务的用户发现表中还有<strong>没有修改的数据行</strong>，就好象发生了幻觉一样。</p></li><li><p>丢失更新：两个事务同时读取同一条记录，A先修改记录，B也修改记录（B是不知道A修改过），B提交数据后B的修改结果<strong>覆盖了</strong>A的<strong>修改结果</strong>。</p></li><li><p>理解SQL SERVER中的隔离级别</p><p>数据库的事务隔离级别（TRANSACTION ISOLATION LEVEL）是一个数据库上很基本的一个概念。为什么会有事务隔离级别，SQL Server上实现了哪些事务隔离级别？事务隔离级别的前提是一个多用户、多进程、多线程的并发系统，在这个系统中为了保证数据的一致性和完整性，我们引入了事务隔离级别这个概念，对一个单用户、单线程的应用来说则不存在这个问题。</p><p>为了避免上述几种事务之间的影响，SQL Server通过设置不同的隔离级别来进行不同程度的避免。因为高的隔离等级意味着更多的锁，从而牺牲性能。所以这个选项开放给了用户根据具体的需求进行设置。不过默认的隔离级别Read Commited符合了多数的实际需求。</p><p>SQL Server隔离事务之间的影响是通过锁来实现的，通过阻塞来阻止上述影响。不同的隔离级别是通过加不同的锁，造成阻塞来实现的，所以会以付出性能作为代价；安全级别越高，处理效率越低；安全级别越低，效率高。</p><p>使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET TRANSACTIONISOLATION LEVEL REPEATABLE READ</span><br></pre></td></tr></table></figure></li></ul></li></ul><div class="table-container"><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th>丢失更新</th><th>并发模型</th><th>更新冲突检测</th><th>内容</th></tr></thead><tbody><tr><td>未提交读：Read Uncommited</td><td>是</td><td>是</td><td>是</td><td>是</td><td>悲观</td><td>否</td><td>在读数据时不会检查或使用任何锁。因此，在这种隔离级别中可能读取到没有提交的数据</td></tr><tr><td>已提交读：Read commited</td><td>否</td><td>是</td><td>是</td><td>是</td><td>悲观</td><td>否</td><td>只读取提交的数据并等待其他事务释放排他锁。读数据的共享锁在读操作完成后立即释放。已提交读是SQL Server的默认隔离级别</td></tr><tr><td>可重复读：Repeatable Read</td><td>否</td><td>否</td><td>是</td><td>否</td><td>悲观</td><td>否</td><td>像已提交读级别那样读数据，但会保持共享锁直到事务结束</td></tr><tr><td>可串行读：Serializable</td><td>否</td><td>否</td><td>否</td><td>否</td><td>悲观</td><td>否</td><td>工作方式类似于可重复读。但它不仅会锁定受影响的数据，还会锁定这个范围。这就阻止了新数据插入查询所涉及的范围</td></tr></tbody></table></div><ul><li><p>持久性</p><ul><li>定义：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。即使出现了任何事故比如断电等，事务一旦提交，则持久化保存在数据库中。</li><li><code>SQL SERVER</code>通过<code>write-ahead transaction log</code>来保证持久性。<code>write-ahead transaction log</code>的意思是，事务中对数据库的改变在写入到数据库之前，首先写入到事务日志中。而事务日志是按照顺序排号的（LSN）。当数据库崩溃或者服务器断点时，重启动<code>SQL SERVER</code>，<code>SQL SERVER</code>首先会<strong>检查日志顺序号</strong>，将本应对数据库做更改而<strong>未做的部分持久化到数据库</strong>，从而保证了持久性。</li></ul></li><li><p>总结：</p><p>事务的（ACID）特性是由关系数据库管理系统（RDBMS，数据库系统）来实现的。数据库管理系统采用日志来保证事务的原子性、一致性和持久性。日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。</p><p>　　数据库管理系统采用锁机制来实现事务的隔离性。当多个事务同时更新数据库中相同的数据时，只允许持有锁的事务能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。</p></li></ul><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul><li>TCP和UDP的区别</li></ul><div class="table-container"><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>可靠性</td><td>可靠</td><td>不可靠</td></tr><tr><td>思想</td><td>面向字节流</td><td>面向报文</td></tr><tr><td>拥塞控制</td><td>慢启动、快速恢复、拥塞避免</td><td>不提供拥塞控制</td></tr><tr><td>双工性</td><td>全双工</td><td>一对一、多对一、一对多、多对多</td></tr><tr><td>效率</td><td>传输效率低</td><td>传输效率高</td></tr><tr><td>应用场景</td><td>准确率要求高，效率要求低</td><td>效率要求高，准确率要求低</td></tr></tbody></table></div><ul><li><p>HTTPS握手过程</p><ul><li><p>HTTPS简介</p><ul><li><p>HTTP：直接通过明文在浏览器和服务器之间传递信息</p></li><li><p>HTTPS：<code>Hypertext Transfer Protocol Secure</code>，超文本传输安全协议。采用<strong>对称加密</strong>和<strong>非对称加密</strong>结合的方式来保护浏览器和服务端之间的通信安全。</p><p><em>对称加密算法加密数据+非对称加密算法交换密钥+数字证书验证身份=安全</em></p></li><li><p>HTTP是运行在TCP层之上的，而HTTPS则是在HTTP和TCP层之间多加了一个SSL/TSL层，SSL层向上提供加密和解密的服务，对 HTTP来说是透明的。</p></li><li><p>Secure Socket Layer，安全套接字层。TLS（Transport Layer Security）安全网络传输协议。HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p></li></ul></li><li><p>对称加密与非对称加密</p><ul><li>定义：加密和解密都使用<em>同一种算法</em>的加密方法，称之为对称加密。加密和解密使用<em>不同的算法</em>，则为非对称加密。</li><li>分析：对称加密需要一把钥匙就够了。非对称加密算法需要两把钥匙，公钥和私钥，它们是一对。用公钥加密的密文只能用相应的私钥解开，用私钥加密的密文只能用相应的公钥解开。其中，公钥是公开的，私钥是不对外公开的。</li><li>对比：两者的主要区别在于密钥的<em>长度不同</em>，长度越长，相应的加/解密花费的时间就会更长，对称加密使用的密钥长度会短一些。SSL结合了这两种加密算法的优点，利用非对称加密算法来协商<em>生成对称加密的密钥</em>，然后之后就用<em>对称加密来进行通信</em>。</li></ul></li><li><p>握手过程（关于HTTP的三次握手，其实就是使用三次TCP握手确认建立一个HTTP连接）</p><ol><li>客户端提交HTTPS请求</li><li>服务器响应客户，并把<em>服务器公钥</em>发送给客户端</li><li>客户端<em>验证公钥</em>的有效性</li><li>客户端验证有效后，会生成一个<em>会话密钥</em>（一个随机数）</li><li>客户端用<em>服务器公钥</em>加密这个<em>会话密钥</em>后，发送给服务器</li><li>服务器收到<em>公钥加密</em>的密钥后，用<em>私钥解密</em>，获取<em>会话密钥</em></li><li>客户端与服务器利用<em>会话密钥</em>对传输数据进行对称加密通信</li></ol><p>下图为<strong>HTTPS加密请求（一次握手）过程</strong></p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/computernetwork/https_handshake.png" style="zoom:80%;" /></p></li><li><p>CA证书</p><p>CA（Certificate Authority）是负责管理和签发证书的第三方权威机构，是所有行业和公众都信任的、认可的。</p><p>CA证书，就是CA颁发的证书，可用于验证网站是否可信（针对HTTPS）、验证某文件是否可信（是否被篡改）等，也可以用一个证书来证明另一个证书是真实可信，最顶级的证书称为根证书。除了根证书（自己证明自己是可靠），其它证书都要依靠上一级的证书，来证明自己。</p></li><li><p>HTTPS和HTTP的区别</p><ul><li>HTTPS协议需要到CA申请证书或自制<em>证书</em>。</li><li>HTTP的信息是明文传输，HTTPS则是具有安全性的SSL<em>加密</em>。</li><li>HTTP是直接与TCP进行数据传输，而HTTPS是经过一层SSL（OSI表示层），用的<em>端口</em>也不一样，前者是80（需要国内备案），后者是443。</li><li>HTTP的连接很简单，是<em>无状态</em>的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。</li></ul></li><li><p>注意</p><ul><li>HTTPS报文在被包装成TCP报文的时候完成加密的过程，无论是HTTPS的<code>header</code>域也好，<code>body</code>域也罢都是会被加密的。</li><li>当使用<code>tcpdump</code>或者<code>wireshark</code>之类的TCP层工具抓包，获取是加密的内容，而如果用应用层抓包，使用<code>Charels(Mac)</code>、<code>Fildder(Windows)</code>抓包工具，那当然看到是明文的。</li></ul></li><li><p>HTTPS一般使用的加密与HASH算法如下：</p><ul><li>非对称加密算法：RSA，DSA/DSS</li><li>对称加密算法：AES，RC4，3DES</li><li>HASH算法：MD5，SHA1，SHA256</li></ul></li></ul></li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>在应用这个模式时，单例对象的类必须保证只有一个实例存在，整个系统只能使用一个对象实例。</p><p>优点：不会频繁地创建和销毁对象，浪费系统资源。</p><p>使用场景：IO 、数据库连接、Redis 连接等。</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式又叫静态工厂方法模式，就是建立一个工厂类，<strong>对实现了同一接口的一些类进行实例的创建</strong>，不需要管它内部的具体实现，只要告诉它需求即可得到对应想要的产品实例。</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂模式是在简单工厂的基础上<strong>将未来可能需要修改的代码抽象出来</strong>，通过继承的方式让<strong>子类去做</strong>决定。抽象工厂里只声明方法，具体的实现交给子类（子工厂）去实现，这个时候再有新增品类的需求，只需要新创建代码即可。</p><p>软件设计的“开闭原则”？</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式是定义对象间的一对多依赖关系，使得每当一个<strong>对象状态发生改变</strong>时，其相关<strong>依赖对象皆得到通知</strong>并被自动<strong>更新</strong>。</p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>装饰器模式是指<strong>动态地给一个对象增加</strong>一些额外的功能，同时又<strong>不改变其结构</strong>。</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器模式是将一个类的接口<strong>变成客户端所期望的另一种接口</strong>，从而使原本因接口不匹配而无法一起工作的两个类能够<strong>在一起工作</strong>。</p><h3 id="Spring中都使用的设计模式"><a href="#Spring中都使用的设计模式" class="headerlink" title="Spring中都使用的设计模式"></a>Spring中都使用的设计模式</h3><ul><li>代理模式：在AOP中使用</li><li>单例模式：bean默认是单例模式</li><li>模板方法模式：JDBCTemplate</li><li>工厂模式：BeanFactory</li><li>观察者模式：Spring事件驱动模型就是观察者模式很经典的一个应用</li><li>适配器模式：SpringMVC中用到适配器模式适配Controller</li></ul><h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><ul><li><p>查看日志文件后100行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail <span class="operator">-f</span> <span class="literal">-n</span> <span class="number">100</span> 日志文件名</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;面试Java研发实习生所做的知识准备，及以后的积累&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Interview" scheme="https://mysticalguest.github.io/categories/Interview/"/>
    
    
      <category term="实习校招" scheme="https://mysticalguest.github.io/tags/%E5%AE%9E%E4%B9%A0%E6%A0%A1%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>Hexo之SEO优化</title>
    <link href="https://mysticalguest.github.io/Hexo/32054.html"/>
    <id>https://mysticalguest.github.io/Hexo/32054.html</id>
    <published>2021-04-08T09:07:41.221Z</published>
    <updated>2021-04-22T13:47:43.601Z</updated>
    
    <content type="html"><![CDATA[<p>SEO（Search Engine Optimization），即搜索引擎优化。简单来说，SEO就是您可以使用提升网站排名的所有方法的总称，SEO用于确保您的网站及其内容在搜索引擎结果页面（SERP）上的可见性。</p><a id="more"></a><h2 id="验证网站"><a href="#验证网站" class="headerlink" title="验证网站"></a>验证网站</h2><p>验证自己的网站，让博客被搜索引擎找到，查看博客是否被收入。</p><p>在谷歌或者百度的搜索链接中，使用以下格式可以直接搜索自己的域名， 如果能搜索到就说明已经被收录，反之则没有。可以直接搜索自己的域名，或者加一些关键词来更好地判断，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site: https://mysticalguest.github.io/</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Configuration/hexo/site.png" style="zoom:80%;" /></p><h2 id="提交博客网站"><a href="#提交博客网站" class="headerlink" title="提交博客网站"></a>提交博客网站</h2><p>若未被搜索引擎收录，则需进行以下配置，首先要让搜索引擎先验证我们对网站的所有权，两个搜索引擎提交的入口分别为：<a href="https://www.google.com/webmasters/tools/home?hl=zh-CN">Google Search Console</a>和<a href="http://ziyuan.baidu.com/site/siteadd">百度站长平台</a></p><h3 id="首先介绍谷歌"><a href="#首先介绍谷歌" class="headerlink" title="首先介绍谷歌"></a>首先介绍谷歌</h3><ul><li><p>当然需要登录谷歌账号，然后访问出现以下界面。选择第二个，输入博客的网址。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Configuration/hexo/enter_domain.png" style="zoom:80%;" /></p></li><li><p>点击继续，弹出以下对话框。点击下载这个指定文件即可。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Configuration/hexo/download_html.png" style="zoom:75%;" /></p></li><li><p>处理这个html文件</p><p>有多种验证方式，这里推荐 <code>HTML</code> 文件上传方式。下载 <code>HTML</code> 验证文件，拷贝到 <code>../sources/</code> 文件夹下，为了使 hexo 不处理这两个验证文件，并且不生成关于这两个文件的 <code>sitemap</code>，我们需要打开验证文件，在最上面添加以下代码，html变为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">layout: false</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">google-site-verification: google************.html</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>然后执行 hexo 部署命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>回到刚才的页面点击继续，完成验证</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Configuration/hexo/Google_verification.png" alt=""></p></li></ul><h3 id="然后介绍百度"><a href="#然后介绍百度" class="headerlink" title="然后介绍百度"></a>然后介绍百度</h3><ul><li><p>输入博客网址，选择属性，验证网站</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Configuration/hexo/baidu_verification.png" alt=""></p></li><li><p>如何添加标签验证</p><p>根据自己的主题情况选择，可以直接写在<code>jsx</code>文件中；我是写在了我的主题的配置文件<code>_config.yml</code>中：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Page metadata configurations</span></span><br><span class="line"><span class="attr">head:</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">    <span class="comment"># https://hexo.io/docs/helpers.html#open-graph</span></span><br><span class="line">    <span class="attr">open_graph:</span></span><br><span class="line">        <span class="comment"># Page title (og:title) (optional)</span></span><br><span class="line">        <span class="comment"># You should leave this blank for most of the time</span></span><br><span class="line">        <span class="attr">title:</span> </span><br><span class="line">        <span class="string">...</span></span><br><span class="line">    <span class="comment"># Structured data of the page</span></span><br><span class="line">    <span class="comment"># https://developers.google.com/search/docs/guides/intro-structured-data</span></span><br><span class="line">    <span class="attr">structured_data:</span></span><br><span class="line">        <span class="comment"># Page title (optional)</span></span><br><span class="line">        <span class="comment"># You should leave this blank for most of the time</span></span><br><span class="line">        <span class="attr">title:</span> </span><br><span class="line">        <span class="string">...</span></span><br><span class="line">    <span class="comment"># Additional HTML meta tags in an array</span></span><br><span class="line">    <span class="attr">meta:</span></span><br><span class="line">        <span class="comment"># Meta tag specified in &lt;attribute&gt;=&lt;value&gt; style</span></span><br><span class="line">        <span class="comment"># E.g., name=theme-color;content=#123456 =&gt; </span></span><br><span class="line">        <span class="comment"># &lt;meta name="theme-color" content="#123456"&gt;=</span></span><br><span class="line">        <span class="comment"># - ''</span></span><br><span class="line">        <span class="bullet">-</span></span><br><span class="line">            <span class="comment"># baidu SEO</span></span><br><span class="line">            <span class="string">name=baidu-site-verification;content=code-kyGo8s2mM1</span></span><br><span class="line">    <span class="comment"># URL or path to the website's RSS atom.xml</span></span><br><span class="line">    <span class="attr">rss:</span> <span class="string">/atom.xml</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>然后执行 hexo 部署命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>最后返回验证页面，就可以查看验证是否通过了</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Configuration/hexo/verification_passed.png" style="zoom:80%;" /></p></li></ul><h2 id="生成Sitemap"><a href="#生成Sitemap" class="headerlink" title="生成Sitemap"></a>生成Sitemap</h2><p>Sitemap即网站地图，它的作用在于便于搜索引擎更加智能地抓取网站。最简单和常见的sitemap形式，是XML文件，在其中列出网站中的网址以及关于每个网址的其他元数据</p><h3 id="安装sitemap生成插件"><a href="#安装sitemap生成插件" class="headerlink" title="安装sitemap生成插件"></a>安装sitemap生成插件</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo<span class="literal">-generator</span><span class="literal">-sitemap</span> -<span class="literal">-save</span></span><br><span class="line">npm install hexo<span class="literal">-generator</span><span class="literal">-baidu</span><span class="literal">-sitemap</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure><h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><p>站点目录下的_config.yml，添加以下字段，直接放在最末就可以了</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#hexo sitemap</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure><h3 id="向百度提交"><a href="#向百度提交" class="headerlink" title="向百度提交"></a>向百度提交</h3><p>直接向百度交<code>sitemap.xml</code>，登录 <a href="http://ziyuan.baidu.com/linksubmit/index">百度站长平台</a>，点击 <code>资源提交</code>下的<code>普通收录</code>，在 <code>资源提交</code>中选择 <code>sitemap</code>标签，输入自己的<strong>域名加 baidusitemap.xml</strong> 即可，之后可查看 url 提取是否成功。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Configuration/hexo/baidusitemap.png" style="zoom:80%;" /></p><p>由于 GitHub 屏蔽了百度的爬虫，即使提交成功，百度知道这里有可供抓取的链接，也不一定能抓取成功。 首先我们先检测一下百度爬虫是否可以抓取网页。在百度站长平台<code>数据统计</code>下的<code>抓取诊断</code> 中，选择<code>PC UA</code>点击抓取 , 查看抓取状态， 如果显示 <code>抓取失败</code>， 则需要进一步的配置。我的直接抓取成功了。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Configuration/hexo/crawl_diagnosis.png" alt=""></p><h3 id="添加robots-txt"><a href="#添加robots-txt" class="headerlink" title="添加robots.txt"></a>添加robots.txt</h3><p>robots.txt（统一小写）是一种存放于网站根目录下的ASCII编码的文本文件，它的作用是告诉搜索引擎此网站中哪些内容是可以被爬取的，哪些是禁止爬取的。</p><ul><li><p>在 <code>source</code> 目录下增加 <code>rebots.txt</code> 文件，网站生成后在网站的根目录（<code>站点目录/public/</code>）下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /archives/</span><br><span class="line">Allow: /categories/</span><br><span class="line">Allow: /tags/</span><br><span class="line"></span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br><span class="line"></span><br><span class="line">Sitemap: https://你的域名/sitemap.xml</span><br><span class="line">Sitemap: https://你的域名/baidusitemap.xml</span><br></pre></td></tr></table></figure><blockquote><p><code>Allow</code>表示允许被访问的，<code>Disallow</code>是不允许的意思。注意后面两个Sitemap就是网站地图了。而网站地图前面说了是给爬虫用的。这里配置在robots中。</p></blockquote></li><li><p>验证robots文件</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Configuration/hexo/robots.png" alt=""></p></li></ul><h3 id="向谷歌提交"><a href="#向谷歌提交" class="headerlink" title="向谷歌提交"></a>向谷歌提交</h3><p>向谷歌提交 sitemap 比较简单，登录 <a href="https://www.google.com/webmasters/tools/home?hl=zh-CN">Google Search Console</a> ，选择已经验证过的站点，在<code>站点地图</code> 中，可看到 <code>添加新的站点地图</code>，添加 <code>sitemap.xml</code> 的链接即可，谷歌效率较高，一般当天或者第二天就能收到结果吧。如图：</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Configuration/hexo/Google_sitemap.png" style="zoom:80%;" /></p><p>结果，等到第二天百度还没有结果，谷歌已经有了结果：</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Configuration/hexo/Google_result.png" style="zoom:80%;" /></p><h2 id="Url持久化"><a href="#Url持久化" class="headerlink" title="Url持久化"></a>Url持久化</h2><p>我们可以发现hexo默认生成的文章地址路径是{网站名称／年／月／日／文章名称}。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Configuration/hexo/permalink_origin.png" alt=""></p><p>这种链接对搜索爬虫是很不友好的，第一它的url结构超过了三层，太深了。<br>下面我推荐一种方式：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo<span class="literal">-abbrlink</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure><p>根目录下配置_config.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># permalink: :year/:month/:day/:title/</span></span><br><span class="line"><span class="comment"># 可选 permalink: abbrlink 短链接模式</span></span><br><span class="line"><span class="comment"># permalink: :title.html #文章的url 如 http://localhost:4000/theme/博客源码分享.html</span></span><br><span class="line"><span class="comment"># permalink: posts/:abbrlink/ #文章的永久链接</span></span><br><span class="line"><span class="comment"># permalink: posts/:abbrlink.html 如：http://localhost:4000/post/article.html</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:category/:abbrlink.html</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>  <span class="comment"># 算法：crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>    <span class="comment"># 进制：dec(default) and hex</span></span><br></pre></td></tr></table></figure><p>之后部署一下，就看到你的链接变成了这样：</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Configuration/hexo/permalink_addrlink.png" alt=""></p><h2 id="添加-nofollow-标签"><a href="#添加-nofollow-标签" class="headerlink" title="添加 nofollow 标签"></a>添加 nofollow 标签</h2><p>给非友情链接的出站链接添加「nofollow」标签，nofollow 标签是由谷歌领头创新的一个「反垃圾链接」的标签，并被百度、yahoo 等各大搜索引擎广泛支持，引用 nofollow 标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有 nofollow 属性的任何出站链接，以减少垃圾链接的分散网站权重。</p><p>有意者可以查看noopener与之区别。</p><p>无论主题的区别，在<code>footer.*</code>文件中做如下修改：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a ... rel=<span class="string">"noopener"</span>&gt;Hexo&lt;<span class="regexp">/a&gt;&amp;nbsp;&amp;&amp;nbsp;</span></span><br><span class="line"><span class="regexp">&lt;a ... target="_blank" rel="noopener"&gt;Icarus&lt;/</span>a&gt;</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a ... rel=<span class="string">"noopener nofollow"</span>&gt;Hexo&lt;<span class="regexp">/a&gt;&amp;nbsp;&amp;&amp;nbsp;</span></span><br><span class="line"><span class="regexp">&lt;a ... target="_blank" rel="noopener nofollow"&gt;Icarus&lt;/</span>a&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SEO（Search Engine Optimization），即搜索引擎优化。简单来说，SEO就是您可以使用提升网站排名的所有方法的总称，SEO用于确保您的网站及其内容在搜索引擎结果页面（SERP）上的可见性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="https://mysticalguest.github.io/categories/Hexo/"/>
    
    
      <category term="配置" scheme="https://mysticalguest.github.io/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>软件工程课程复习</title>
    <link href="https://mysticalguest.github.io/Study/56860.html"/>
    <id>https://mysticalguest.github.io/Study/56860.html</id>
    <published>2021-03-31T15:26:50.884Z</published>
    <updated>2021-04-08T13:04:19.630Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>整理目的：</p><ol><li>我还是认为基础知识不能丢，也是对以前知识的回顾。</li><li>考研软件工程方向考软件工程这门学科的并不多，我选择了两所学校来进行整理。</li></ol><p>以中南大学944软件工程考试大纲和复旦961软件工程专业基础综合考试大纲为基础。</p></blockquote><a id="more"></a><h2 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h2><h3 id="0-1-考试性质"><a href="#0-1-考试性质" class="headerlink" title="0.1 考试性质"></a>0.1 考试性质</h3><p>《软件工程》考试是为高等院校和科研院所招收硕士研究生而设置的具有选拔性质的全国统一入学考试科目，其目的是科学、公平、有效地测试学生掌握大学本科阶段软件工程课程的基本概念、原理、方法与技术，以及分析和解决问题的能力，评价的标准是高等学校本科毕业生能达到的及格以上水平，以保证被录取者具有基本的软件工程专业素质，并有利于各高等院校和科研院所在专业上择优选拔。</p><h3 id="0-2-考察目标"><a href="#0-2-考察目标" class="headerlink" title="0.2 考察目标"></a>0.2 考察目标</h3><p>掌握：软件工程的产生、软件工程学的研究对象与原则、软件开发方法、软件工程的生存周期模型以及软件工程发展的新方向；软件需求分析的任务和要求、可行性研究的任务以及系统建模方法；软件开发阶段的仼务、过程、方法和技术。<br>理解：软件质量的概念、分析技术；软件维护阶段的活动、提高软件可维护性的策略；软件工程的相关管理技术。</p><h2 id="一、软件工程与软件过程"><a href="#一、软件工程与软件过程" class="headerlink" title="一、软件工程与软件过程"></a>一、软件工程与软件过程</h2><p>边际成本，1968年NATO首次提出。</p><p>软件工程是用工程，科学和数学的原则与方法研制、维护计算机软件的有关技术及管理方法，它由<strong>方法</strong>、<strong>工具</strong>和<strong>过程</strong>三部分组成。</p><h3 id="1-1-软件工程的产生"><a href="#1-1-软件工程的产生" class="headerlink" title="1.1 软件工程的产生"></a>1.1 软件工程的产生</h3><p>软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题。</p><p>产生软件危机的原因：一方面与软件本身的特点有关，另一方面也和软件开发与维护的方法不正确有关。</p><p>要缓解软件危机，既要有先进的技术和方法，又需要高水平的组织管理措施。而软件工程正是综合了管理和技术两方面，研究如何更好地开发软件的一门新兴学科。所以，就目前而言，软件工程是缓解软件危机的最好途径。</p><p>软件工程是指导计算机软件开发和维护的一门工程学科。采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的<strong>管理技术</strong>和当前能够得到的最好的技术方法结合起来，以经济地开发出高质量的软件并有效地维护它，这就是软件工程。</p><h3 id="1-2-软件工程的研究对象与基本原理"><a href="#1-2-软件工程的研究对象与基本原理" class="headerlink" title="1.2 软件工程的研究对象与基本原理"></a>1.2 软件工程的研究对象与基本原理</h3><h3 id="1-3-软件开发方法"><a href="#1-3-软件开发方法" class="headerlink" title="1.3 软件开发方法"></a>1.3 软件开发方法</h3><h3 id="1-4-软件工程工具和环境"><a href="#1-4-软件工程工具和环境" class="headerlink" title="1.4 软件工程工具和环境"></a>1.4 软件工程工具和环境</h3><p>什么是软件工程环境:</p><p>方法与工具的结合，加上配套的软、硬件支持称为软件工程环境。它能支持开发者按照软件工程的方法,全面完成生存周期中的各项任务。</p><p>软件工具是什么？按照软件生存周期可将其分为几类？</p><p>　　软件工具是指为支持计算机软件及其文档的开发、维护、模拟、移植或管理而研制的程序系统。按照软件生存周期可将其分为如下几类： </p><p>　　(1) 需求分析：如数据流图绘制与分析工具、状态转换图绘制与分析工具、面向对象的模型和分析工具、快速原型构造工具、数据字典与数据库工具等。</p><p>　　(2) 软件设计：如HIPO图、PDL(程序设计语言)或PAD(问题分析图)支持工具等。</p><p>　　(3) 编码：集成化的程序员工作平台。如各种正文编辑器和常规的编译程序、汇编程序、连结程序及符号调试器等。</p><p>　　(4) 软件测试：如静态分析器、动态覆盖率测试器、测试用例生成器、测试报告生成器及环境模拟器等。</p><p>　　(5) 软件维护：如反汇编程序、反编译程序、程序结构分析器、源程序格式化工具、文档生成工具、源程序至PAD(问题分析图)或流程图的自动转换工具等。</p><p>软件工程的基本原理</p><p>​     1、用分阶段的生命周期计划严格管理</p><p>​     2、坚持进行阶段评审</p><p>​     3、实行严格的产品控制</p><p>​     4、采用现代程序设计技术</p><p>​     5、结果应能清楚地审查</p><p>​     6、开发小组应该少而精</p><p>​     7、承认不断改进软件工程实践的必要性</p><h3 id="1-5-软件生存期过程"><a href="#1-5-软件生存期过程" class="headerlink" title="1.5 软件生存期过程"></a>1.5 软件生存期过程</h3><p>三个时期八个阶段</p><p>软件生命期瀑布模型分为六个阶段：</p><ul><li><p>可行性研究与计划（确定系统的目标和规模，分析项目的可行性）；</p></li><li><p>需求分析与规格说明（明确系统的规格和要求）</p></li><li>设计（包括概要设计和详细设计，将系统分解为模块）</li><li>编程（用程序语言实现每个模块，简单容易）；</li><li>测试（发现并改正错误，分为模块测试、集成测试和系统联调三级）；</li><li>运行维护（扩充功能、纠错等）。</li></ul><p>WBS work breakdown structure 工作分解结构</p><p>软件生命周期由软件定义、软件开发和运行维护（也成软件维护）3个时期组成。</p><h3 id="1-6-软件工程常用生存周期模型"><a href="#1-6-软件工程常用生存周期模型" class="headerlink" title="1.6 软件工程常用生存周期模型"></a>1.6 软件工程常用生存周期模型</h3><p>软件生存周期模型是描述软件开发过程中各种活动如何执行的模型。</p><p>八种经典软件过程模型的特点（瀑布模型、增量和迭代模型、演化模型、统一过程模型、V模型、原型模型、操作规范、转换模型、螺旋模型、敏捷模型）</p><p>V-V原则：validation（核实）：确保系统实现了所有的需求。 verification（验收）：确保每个功能正确运行。</p><h4 id="1-6-1-瀑布模型"><a href="#1-6-1-瀑布模型" class="headerlink" title="1.6.1 瀑布模型"></a>1.6.1 瀑布模型</h4><p>传统瀑布模型特点：</p><p>1、 阶段间具有顺序性与依赖性</p><p>2、 推迟实现的观点</p><p>3、 质量保证的观点</p><p>瀑布模型</p><p>优点：</p><p>1、 可强迫开发人员使用规范的方法（例如：结构化技术）；</p><p>2、 严格规定每个阶段必须提交的文档；</p><p>3、 要求每个阶段交出的所有产品都必须通过验证。</p><p>缺点：</p><p>1、“瀑布模型是由文档驱动的”成为主要缺点</p><p>适用范围：</p><p>​     适合于<strong>用户需求明确、完整、无重大变化</strong>的软件项目开发。</p><h4 id="1-6-2-增量和迭代模型"><a href="#1-6-2-增量和迭代模型" class="headerlink" title="1.6.2 增量和迭代模型"></a>1.6.2 增量和迭代模型</h4><p>特点：</p><p>1、反复的应用瀑布模型的基本成分和原型模型的迭代特征，每一个线型过程产生一个“增量”的发布或提交，该增量均是一个可运行的产品。</p><p>​            2、 早期的版本实现用户的基本需求，并提供给用户评估的平台。</p><p>​          优点：</p><p>1、 在较短时间内向用户提交可完成部分工作的产品；</p><p>2、 逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击；</p><p>缺点：</p><p>1、 软件体系结构必须是开放的；</p><p>2、 开发人员既要把软件系统看作整体。又要看成可独立的构件，相互矛盾；</p><p>3、 多个构件并行开发，具有无法集成的风险。</p><h4 id="1-6-3-演化模型"><a href="#1-6-3-演化模型" class="headerlink" title="1.6.3 演化模型"></a>1.6.3 演化模型</h4><h4 id="1-6-4-（Rational）统一过程模型"><a href="#1-6-4-（Rational）统一过程模型" class="headerlink" title="1.6.4 （Rational）统一过程模型"></a>1.6.4 （Rational）统一过程模型</h4><p>RUP重复一系列周期，每个周期由一个交付给用户的产品结束。每个周期划分为初始、细化、构造和移交四个阶段，每个阶段围绕着五个核心工作流（需求、分析、设计、实现、测试）分别迭代。</p><h4 id="1-6-5-V模型"><a href="#1-6-5-V模型" class="headerlink" title="1.6.5 V模型"></a>1.6.5 V模型</h4><h4 id="1-6-6-（快速）原型模型"><a href="#1-6-6-（快速）原型模型" class="headerlink" title="1.6.6 （快速）原型模型"></a>1.6.6 （快速）原型模型</h4><p>适用范围：</p><p>用户不能给出完整、准确的需求说明，或者开发者不能确定算法的有效性、操作系统的适应性或人机交互的形式等情况。</p><h4 id="1-6-7-操作规范"><a href="#1-6-7-操作规范" class="headerlink" title="1.6.7 操作规范"></a>1.6.7 操作规范</h4><h4 id="1-6-8-转换模型"><a href="#1-6-8-转换模型" class="headerlink" title="1.6.8 转换模型"></a>1.6.8 转换模型</h4><h4 id="1-6-9-螺旋模型"><a href="#1-6-9-螺旋模型" class="headerlink" title="1.6.9 螺旋模型"></a>1.6.9 螺旋模型</h4><p>基本思想：</p><p>​          使用原型或其他方法来降低风险。</p><p>​     适用范围：</p><p>​          适用于内部开发大规模软件项目。</p><p>​     优点：</p><p>1、对可选方案和约束条件的强调有利于已有软件的重用，也有助于把软件质量作为软件发的一个重要目标</p><p>2、减少了过多测试或测试不足</p><p>3、维护和开发之间并没有本质区别</p><p>​          缺点：</p><p>1、 风险驱动，需要相当丰富的风险评估经验和专门知识，否则风险更大</p><p>2、 随着迭代次数的增加，工作量加大，软件开发成本增加</p><h4 id="1-6-10-敏捷模型"><a href="#1-6-10-敏捷模型" class="headerlink" title="1.6.10 敏捷模型"></a>1.6.10 敏捷模型</h4><h4 id="1-6-11-喷泉模型"><a href="#1-6-11-喷泉模型" class="headerlink" title="1.6.11 喷泉模型"></a>1.6.11 喷泉模型</h4><p>特点：</p><p>喷泉模型是一种以用户需求为动力，以对象为驱动的模型，主要用于采用对象技术的软件开发项目。该模型认为软件开发过程自下而上周期的各阶段是相互迭代和无间隙的特性</p><h3 id="1-7-软件过程的概念"><a href="#1-7-软件过程的概念" class="headerlink" title="1.7 软件过程的概念"></a>1.7 软件过程的概念</h3><h3 id="1-8-过程评估与CMM-CMMI的基本概念"><a href="#1-8-过程评估与CMM-CMMI的基本概念" class="headerlink" title="1.8 过程评估与CMM/CMMI的基本概念"></a>1.8 过程评估与CMM/CMMI的基本概念</h3><h3 id="1-9-敏捷宣言与敏捷过程的特点"><a href="#1-9-敏捷宣言与敏捷过程的特点" class="headerlink" title="1.9 敏捷宣言与敏捷过程的特点"></a>1.9 敏捷宣言与敏捷过程的特点</h3><h2 id="二、需求分析"><a href="#二、需求分析" class="headerlink" title="二、需求分析"></a>二、需求分析</h2><p>需求分析中应该建立哪三种模型：数据模型、功能模型、行为模型</p><h3 id="2-1-软件需求的概念"><a href="#2-1-软件需求的概念" class="headerlink" title="2.1 软件需求的概念"></a>2.1 软件需求的概念</h3><p>四种类型的需求（用两种文档表示）：1：功能需求      2：质量（性能需求）      3：设计约束      4：过程约束</p><p>两种描述需求的文档：</p><ul><li><p>需求定义：客户想要实现的所有内容的完整列表。</p></li><li><p>需求规格说明书 设计建模UML：要求重新表述为所提出的系统应如何表现的规范</p></li></ul><p>RTM 需求跟踪矩阵：</p><ul><li>系统怎么做什么的订需求定义</li><li>根据需求生成的设计模块</li><li>实现设计的程序代码</li><li>验证系统功能的测试</li><li>描述系统的文档</li></ul><p>从哪些方面验证软件需求的正确性？</p><p>答: （1）一致性，即所有需求必须是一致的，任何一条需求不能和其他需求互相矛盾。</p><p>（2）完整性，需求必须是完整的，规格说明书应该包括用户需要的每一个功能或性能。</p><p>（3）现实性，指定的需求应该是用现有的硬件技术和软件技术基本上可以实现的。</p><p>（4）有效性，必须证明需求是正确有效的，确实能解决用户面对的问题。</p><h3 id="2-2-需求工程的基本过程"><a href="#2-2-需求工程的基本过程" class="headerlink" title="2.2 需求工程的基本过程"></a>2.2 需求工程的基本过程</h3><p>需求工程过程包括如下主要活动：获取需求、需求分析与建模、需求规格说明、确认需求、需求管理。</p><h3 id="2-3-需求分析的目标"><a href="#2-3-需求分析的目标" class="headerlink" title="2.3 需求分析的目标"></a>2.3 需求分析的目标</h3><p>需求分析阶段的基本任务是要准确的定义新系统的目标，为了满足用户需要，回答系统必须“做什么”的问题。</p><p>本阶段要进行以下几方面的工作：问题识别、分析与综合，导出软件的逻辑模型、编写文档</p><p>基本任务：（1）问题识别：双方确定对问题的综合需求，这些需求包括功能需求，性能需求，环境需求，用户界面需求。 </p><p>（2）分析与综合，导出软件的逻辑模型 </p><p>（3）编写文档：包括编写”需求规格说明书”,”初步用户使用手册”,”确认测试计划”,”修改完善软件开发计划”</p><h3 id="2-4-可行性分析"><a href="#2-4-可行性分析" class="headerlink" title="2.4 可行性分析"></a>2.4 可行性分析</h3><p>了解可行性研究中的任务和过程</p><p><strong>任务：</strong>用最小的代价在尽可能短的时间内确定问题是否能够解决. </p><p><strong>过程：</strong>（1）复查系统规模和目标    （2）研究目前正在使用的系统（3）导出新系统的高层逻辑模型 （4）进一步定义问题（5）导出和评价供选择的解法  （6）推荐进行方针（7）草拟开发计划       （8）书写文档提交审查</p><p>可行性研究目的?确定在问题定义中所提出的问题是否值得去解，在限制条件下，问题能否解决。</p><p>可行性研究的任务？</p><p>(1) 进一步分析和澄清问题的定义，在澄清问题的基础上，导出系统的逻辑模型；</p><p>　　(2) 从系统逻辑模型中，选择问题的若干种主要解法，研究每一种解法的可行性，为以后的行动提出建议；</p><p>　　(3) 如果问题没有可行的解，建议停止系统开发；如果问题有可行的解，应该推荐一个较好的解决方案，并为工程制定一个初步的计划。</p><p>可行性研究包括哪几方面的内容？</p><p>　　(1)技术可行性：现有技术能否实现本系统，现有技术人员能否胜任，开发系统的资源能否满足；</p><p>　　(2)经济可行性：经济效益是否超出开发成本；</p><p>　　(3)操作可行性：系统操作在用户内部行得通吗？</p><p>　　(4)法律可行性：新系统开发是否会侵犯他人、集体或国家利益，是否违反国家法律。</p><p>可行性研究的步骤?</p><p>　　(1)复查系统的规模和目标；</p><p>　　(2)研究目前正在使用的系统，总结现有系统的优劣，提出新系统的雏形；</p><p>　　(3)导出新系统的高层逻辑模型；</p><p>　　(4)推荐建议方案； </p><p>　　(5)推荐行动方针；</p><p>　　(6)书写计划任务书(可行性报告)； </p><p>　　(7)提交审查。</p><p>可行性研究报告的主要内容？</p><p>　　可行性分析的结果是可行性研究报告,内容包括：</p><p>　　(1) 系统概述：说明开发的系统名称,提出单位和开发单位。</p><p>　　(2) 可行性研究的前提:系统目标；要求；约束和限制；可行性研究的基本准则等。</p><p>　　(3) 对现有系统的分析:处理流程，图示说明现有系统的处理流程和数据流程；现有系统存在的问题。 </p><p>　　(4) 系统需求:主要功能；主要性能及其要求；操作要求；信息要求；限制性要求。</p><p>　　(5) 建议系统:系统目标；处理流程；系统结构,功能,性能；系统技术可行性；投资和效益分析；操作可行性；法律可行性。</p><p>　　(6) 其它可选方案:与国内外同类型方案的比较；提出一两个可行性方案供论证和探讨。</p><p>　　(7) 制定下一阶段的预算。</p><p>　　(8) 结论性意见：由用户方、设计方和投资方共同签署意见。</p><h3 id="2-5-需求收集"><a href="#2-5-需求收集" class="headerlink" title="2.5 需求收集"></a>2.5 需求收集</h3><h3 id="2-6-需求规格说明"><a href="#2-6-需求规格说明" class="headerlink" title="2.6 需求规格说明"></a>2.6 需求规格说明</h3><p>简述软件需求说明书（软件规格说明书）中包含的内容？（每项1分）</p><p>答：（1）软件系统的开发背景资料（主要相关人、财、物或设备）；</p><p>（2）所开发软件的功能、性能、用户界面及运行环境等作出详细的说明；</p><p>（3）软件系统详细的逻辑模型：数据流图(DFD)+数据词典（DD）或面向对象的三大模型（对象模型、动态模型和功能模型）等</p><p>（4）系统开发计划表</p><p>（5）所有附加文档：调查问卷信息、BPFD等</p><p>软件需求规格说明书由哪些部分组成?</p><p>　　组成包括：</p><p>　　(1) 引言：编写目的、背景说明、术语定义及参考资料等。</p><p>　　(2) 概述主要功能、约束条件或特殊需求。</p><p>　　(3) 数据流图与数据字典。</p><p>　　(4) 用户接口、硬件接口及软件接口。</p><p>　　(5) 性能需求、属性等。</p><p>　　(6) 其它需求，如数据库、操作及故障处理等。</p><h3 id="2-7-数据流建模"><a href="#2-7-数据流建模" class="headerlink" title="2.7 数据流建模"></a>2.7 数据流建模</h3><p>（分层数据流模型）</p><h3 id="2-8-实体一关系建模"><a href="#2-8-实体一关系建模" class="headerlink" title="2.8 实体一关系建模"></a>2.8 实体一关系建模</h3><p>用例和场景建模及其UML表达（用例图、活动图、泳道图、顺序图）</p><h3 id="2-9-系统行为建模"><a href="#2-9-系统行为建模" class="headerlink" title="2.9 系统行为建模"></a>2.9 系统行为建模</h3><p>（数据模型建模及其UML表达（类图））（行为模型建模及其UML表达（状态机图））</p><h3 id="2-10-IDEF0功能建模"><a href="#2-10-IDEF0功能建模" class="headerlink" title="2.10 IDEF0功能建模"></a>2.10 IDEF0功能建模</h3><h3 id="2-11-IDEF1x数据建模"><a href="#2-11-IDEF1x数据建模" class="headerlink" title="2.11 IDEF1x数据建模"></a>2.11 IDEF1x数据建模</h3><h2 id="三、软件设计"><a href="#三、软件设计" class="headerlink" title="三、软件设计"></a>三、软件设计</h2><h3 id="3-1-软件体系结构及体系结构风格的概念"><a href="#3-1-软件体系结构及体系结构风格的概念" class="headerlink" title="3.1 软件体系结构及体系结构风格的概念"></a>3.1 软件体系结构及体系结构风格的概念</h3><p>软件体系结构为软件系统提供了一个结构、行为和属性的高级抽象，由构成系统的元素的描述、元素间的相互作用、指导元素集成的模式以及这些模式的约束组成。软件体系结构不仅指定了系统的组织结构和拓扑结构，并且显示了系统需求和构成系统的元素之间的对应关系，提供了一些设计决策的基本原理。良好的体系结构是普遍适用的，它可以高效地处理各种各样的个体需求。</p><p>软件架构也有通用的解决方案，叫做体系结构风格</p><p>体系结构风格提供有关如何将问题分解为软件单元以及这些单元应如何相互交互的建议</p><p>使用体系结构风格的六种方法：</p><ul><li>去理解系统：他能做什么和怎么做</li><li>去判断多少系统可以去复用先前就建立好的系统，多少系统在以后将不能复用。</li><li>提供构建系统的蓝图，提供构建系统的蓝图，包括系统的“承载”部分可能在哪里     </li><li>推断系统如何发展，包括表现，成本，原型设计</li><li>去分析依赖，选择最合适的设计，实现，和测试技术</li><li>支持管理厥词，理解实施和维护中固有的风险</li></ul><h3 id="3-2-设计模式的概念"><a href="#3-2-设计模式的概念" class="headerlink" title="3.2 设计模式的概念"></a>3.2 设计模式的概念</h3><h3 id="3-3-模块化设计的基本思想及概念"><a href="#3-3-模块化设计的基本思想及概念" class="headerlink" title="3.3 模块化设计的基本思想及概念"></a>3.3 模块化设计的基本思想及概念</h3><p>（抽象、分解、模块化、封装、信息隐藏、功能独立）</p><p>什么是模块？模块具有哪几个特征？总体设计主要考虑什么特征？</p><p>　　模块是数据说明、可执行语句等程序对象的集合，可以单独命名且可通过名字来访问。</p><p>　　模块具有输入和输出(参数传递)、功能、内部数据结构(局部变量)和程序代码四个特性。</p><p>　　概要设计主要考虑输入、输出(参数传递)和功能两个特性。</p><p>什么是模块化？模块设计的准则？</p><p>　　模块化是按规定的原则将一个大型软件划分为一个个较小的、相对独立但又相关的模块。</p><p>　　模块设计的准则：</p><p>　　(1) 改进软件结构, 提高模块独立性:在对初步模块进行合并、分解和移动的分析、精化过程中力求提高模块的内聚，降低藕合。</p><p>　　(2) 模块大小要适中:大约50行语句的代码，过大的模块应分解以提高理解性和可维护性;过小的模块,合并到上级模块中。</p><p>　　(3) 软件结构图的深度、宽度、扇入和扇出要适当。一般模块的调用个数不要超过5个。</p><p>　　(4) 尽量降低模块接口的复杂程度；</p><p>　　(5) 设计单入口、单出口的模块。</p><p>　　(6) 模块的作用域应在控制域之内。</p><h3 id="3-4-软件重构的概念"><a href="#3-4-软件重构的概念" class="headerlink" title="3.4 软件重构的概念"></a>3.4 软件重构的概念</h3><h3 id="3-5-软件体系结构的UML建模"><a href="#3-5-软件体系结构的UML建模" class="headerlink" title="3.5 软件体系结构的UML建模"></a>3.5 软件体系结构的UML建模</h3><p>软件开发的过程犹如雕琢一件工艺品，由无形到有形，由粗到细。鉴于软件系统的复杂性和规模的不断增大，项目失败的可能性也相应增加。需要建立不同的模型对系统的各个层次进行描述。在长期的研究与实践中，人们越来越深刻地认识到，建立简明准确的表示模型是把握复杂系统的关键。模型是对事物的一种抽象，在软件开发过程中，建立各种模型，以便更透彻地了解系统的本质。由于UML以图形模型为主，模型的直观性及丰富的信息描述便于开发人员与用户的交流。建立的模型也为以后的系统维护和升级提供了文档。总的来说，使用模型可以使人们从全局上把握系统的全貌及其相关部件之间的关系，可以防止过早地陷入各个模块的细节。因此，面向对象的分析与设计应该从建模开始。UML 是一种标准的图形化、可视化的建模型语言，UML的核心是建立系统的各类模型。</p><h4 id="3-5-1-包图"><a href="#3-5-1-包图" class="headerlink" title="3.5.1 包图"></a>3.5.1 包图</h4><h4 id="3-5-2-类图"><a href="#3-5-2-类图" class="headerlink" title="3.5.2 类图"></a>3.5.2 类图</h4><h4 id="3-5-3-构件图"><a href="#3-5-3-构件图" class="headerlink" title="3.5.3 构件图"></a>3.5.3 构件图</h4><h4 id="3-5-4-活动图（Activity-Diagram）"><a href="#3-5-4-活动图（Activity-Diagram）" class="headerlink" title="3.5.4 活动图（Activity Diagram）"></a>3.5.4 活动图（Activity Diagram）</h4><p>是由状态图变化而来的，从系统任务的观点来看，系统的执行过程是由一系列有序活动组成的。活动图可以有效地描述整个系统的流程，描述了系统的全局的动态行为，且只有活动图是唯一能够描述并发活动的UML图</p><h4 id="3-5-4-顺序图（Sequence-Diagram）"><a href="#3-5-4-顺序图（Sequence-Diagram）" class="headerlink" title="3.5.4 顺序图（Sequence Diagram）"></a>3.5.4 顺序图（Sequence Diagram）</h4><p>清晰地描述一组对象之间动态的交互关系、时间的约束关系，着重描述对象间消息传递的时间顺序，所以顺序图在实时系统中被大量使用。当参与交互的对象数目增加，交互关系复杂时用顺序图描述会显得杂乱。</p><h4 id="3-5-5-协作图（Collaboration-Diagram）"><a href="#3-5-5-协作图（Collaboration-Diagram）" class="headerlink" title="3.5.5 协作图（Collaboration Diagram）"></a>3.5.5 协作图（Collaboration Diagram）</h4><p>从另一个角度来更好地描述相互协作的对象间的交互关系和链接（Link）关系。着重体现交互对象间的静态链接关系和协作关系。协作图也可以从顺序图生成</p><h4 id="3-5-6-部署图"><a href="#3-5-6-部署图" class="headerlink" title="3.5.6 部署图"></a>3.5.6 部署图</h4><h4 id="3-5-7-状态图（State-Diagram）"><a href="#3-5-7-状态图（State-Diagram）" class="headerlink" title="3.5.7 状态图（State Diagram）"></a>3.5.7 状态图（State Diagram）</h4><p>用来描述一个特定对象在其生存周期或在某段时间内的所有可能的状态及其引起状态转移的事件。一个状态图包括一系列的状态以及状态之间的改变。例如订单的状态变化等，在实时系统中用得较多，还可以用于辅助设计用户界面。</p><h3 id="3-6-接口的概念"><a href="#3-6-接口的概念" class="headerlink" title="3.6 接口的概念"></a>3.6 接口的概念</h3><h3 id="3-7-面向对象设计原则"><a href="#3-7-面向对象设计原则" class="headerlink" title="3.7 面向对象设计原则"></a>3.7 面向对象设计原则</h3><p>（开闭原则、Liskov替换原则、依赖转置原则、接口隔离原则）</p><h3 id="3-8-内聚与耦合的概念、常见的内聚和耦合类型"><a href="#3-8-内聚与耦合的概念、常见的内聚和耦合类型" class="headerlink" title="3.8 内聚与耦合的概念、常见的内聚和耦合类型"></a>3.8 内聚与耦合的概念、常见的内聚和耦合类型</h3><p>耦合包含了哪些类型？每个类型的具体内容是什么？要求能通过程序代码识别出耦合类型。</p><p>（1）非直接耦合：就是没有耦合。 </p><p>（2）数据耦合：就是参数传递耦合，它属于低级别耦合。  </p><p>（3）标记耦合：标记耦合指两个模块之间传递的是数据结构。 </p><p>（4）控制耦合：它属于中级别耦合，比如调度程序与进程之间的耦合，就是控制耦合。  </p><p>（5）外部耦合：属于高级别耦合 </p><p>（6）公共耦合：指通过一个公共数据环境相互作用的那些模块间的耦合。 </p><p>（7）内容耦合：属于最高级别耦合，例如，一个模块利用分支或跳转技术，转入到另一个模块中去执行，就是内容耦合。</p><h3 id="3-9-软件设计的任务和过程"><a href="#3-9-软件设计的任务和过程" class="headerlink" title="3.9 软件设计的任务和过程"></a>3.9 软件设计的任务和过程</h3><p>系统设计包括哪两个阶段?系统设计包括总体设计与详细设计两个阶段</p><p>总体设计的主要任务是什么？总体设计的主要任务是完成软件结构的设计,确定系统的模块及其模块之间的关系。</p><p>详细设计的目的?</p><p>为软件结构图(SC图或HC图)中的每一个模块确定采用的算法和块内数据结构,用某种选定的表达工具给出清晰的描述.</p><p>详细设计的主要任务?</p><p>编写软件的“详细设计说明书”.软件人员要完成的工作:</p><p>(1) 为每一个模块确定采用的算法, 选择某种适当的工具表达算法的过程,写出模块的详细过程描述.</p><p>(2) 确定每一模块使用的数据结构.</p><p>(3) 确定模块结构的细节,包括对系统外部的接口和用户界面,对系统内部其它模块的接口,以及关于模块输入数据、输出数据及局部数据的全部细节.</p><p>(4) 为每一个模块设计出一组测试用例,以便在编码阶段对模块代码(即程序)进行预定的测试.</p><p>l  概要设计（结构设计）：把一个软件需求转换为软件表示时，首先设计出软件总的体系结构。</p><p>基本任务：</p><p>1)  设计软件系统结构</p><p>2)  进行数据结构及数据库的设计</p><p>3)  编写概要设计的文档</p><p>4)  评审</p><p>l  详细设计：为SC图中的每个模块确定采用的算法和块内数据结构，用选定的表达工具（流程图、N-S图、PAD图、伪代码）给出清晰的描述。</p><p>基本任务：</p><p>1)  为每个模块进行详细的算法设计</p><p>2)  为模块内的数据结构进行设计</p><p>3)  对数据库进行物理设计</p><p>4)  其他设计</p><p>5)  编写详细设计说明书</p><p>6)  评审</p><h3 id="3-10-软件设计基本原则"><a href="#3-10-软件设计基本原则" class="headerlink" title="3.10 软件设计基本原则"></a>3.10 软件设计基本原则</h3><p>设计原则定义：将我们的系统需要的功能和行为分解为模块的指南（设计原理？）</p><p> 六个主导原则：</p><ul><li>模块化：耦合和类聚       我们说两个模块紧耦合，当他们彼此依赖很多。低耦合模块有一些依赖，但是他们的关联很微弱。解耦模块没有耦合<ul><li>内聚：cohesion ： 去测量多个模块的相互依赖程度，内聚指来自模块内部的依赖。最糟糕的情况，巧合：一个模块和另一个没有关系</li><li>内聚种类：巧合内聚，逻辑类聚，时间类聚，过程类聚，通信类聚，功能类聚，信息类据。</li><li>耦合是影响软件复杂程度的一个重要因素。设计时力争做到高内聚，并且能够辨认出低内聚的模块，有能力通过修改设计提高模块的内聚程度并且降低模块间的耦合程度，从而获得较高的模块独立性。</li></ul></li><li>接口      定义了软件单元给剩余的系统提供什么服务，其他单元如何访问那些服务。</li><li>信息隐藏（和局部化？）      使得软件系统更易于维护       它以分解系统的指导来区分：每个软件单元都包含了一个可以在未来改变的分离设计决策</li><li>增量开发</li><li>抽象      是一种模型或者表示，忽略一些细节从而可以专注其他细节。</li><li>泛化      使技术通用       泛化是一个设计原则，使得软件单元尽可能普遍接受，增加在未来别的系统复用的可能性</li></ul><h3 id="3-11-面向数据流图的设计方法"><a href="#3-11-面向数据流图的设计方法" class="headerlink" title="3.11 面向数据流图的设计方法"></a>3.11 面向数据流图的设计方法</h3><p>掌握面向数据流的设计方法，了解其中涉及到的概念（变换流，事务流），结合例子理解变换分析的具体过程。</p><p>面向数据流的设计方法把信息映射成软件结构，信息流的类型决定了映射的方法。信息流有两种：（1）变换流  （2）事务流 </p><p><strong>变换流：</strong>信息沿输入通路进入系统，同时由外部形式变换成内部形式，进入系统的信息通过变换中心，经加处理以后再沿输出通路变换成外部形式离开软件系统。</p><p><strong>事务流</strong>：以事务为中心，事务型数据流图中存在一个事务中心（也就是数据处理、加工中心），它将输入分离成若干个发散的数据流，形成许多活动路径，并根据输入值选择其中一条路径，这类数据流就是事务流。</p><h3 id="3-12-面向对象的设计方法"><a href="#3-12-面向对象的设计方法" class="headerlink" title="3.12 面向对象的设计方法"></a>3.12 面向对象的设计方法</h3><p>三种编程范型的特点</p><p>(1) 过程式编程范型：把程序理解为一组被动的数据和一组能动的过程所构成；程序=数据结构+算法；着眼于程序的过程和基本控制结构，粒度最小</p><p>(2) 面向对象编程范型：数据及其操作被封装在对象中；程序=对象+消息；着眼于程序中的对象，粒度比较大</p><p>(3) 基于构件技术的编程范型：构件是通用的、可复用的对象类；程序=构件+架构；眼于适合整个领域的类对象，粒度最大</p><p>用面向对象方法开发软件时，通常需要建立哪三种形式的模型？</p><p>（1）描述系统数据结构的对象模型。</p><p>（2）描述系统控制结构的动态模型。</p><p>（3）描述系统功能的功能模型。</p><p>面向对象方法学的出发点和基本原则，是尽可能模拟人类思维方法，是开发软件尽可能接近人类认识世界解决问题的方法与过程。</p><p>对象模型表示静态的，结构化的系统的“数据”性质。它是对模拟客观世界实体的对象以及对象彼此之间的关系的映射，描述了系统的静态结构。</p><p>动态模型表示瞬时的、行为化的系统的”控制“性质，它规定了对象模型中的对象的合法序列。</p><p>功能模型表示变化的系统的”功能“性质，他指明了系统应该”做什么”，因此更直接反映了用户对目标系统的需求。</p><h3 id="3-13-面向对象软件设计模式"><a href="#3-13-面向对象软件设计模式" class="headerlink" title="3.13 面向对象软件设计模式"></a>3.13 面向对象软件设计模式</h3><h3 id="3-14-模型-视图-控制器框架"><a href="#3-14-模型-视图-控制器框架" class="headerlink" title="3.14 模型-视图-控制器框架"></a>3.14 模型-视图-控制器框架</h3><h2 id="四、软件验证技术（软件测试）"><a href="#四、软件验证技术（软件测试）" class="headerlink" title="四、软件验证技术（软件测试）"></a>四、软件验证技术（软件测试）</h2><p>软件失败：软件不能做我们描述的需求。</p><h3 id="4-1-软件测试基础（软件测试及测试用例的概念）"><a href="#4-1-软件测试基础（软件测试及测试用例的概念）" class="headerlink" title="4.1 软件测试基础（软件测试及测试用例的概念）"></a>4.1 软件测试基础（软件测试及测试用例的概念）</h3><p>测试的目的是判断和发现软件是否有错误 , 调试的目的是定位软件错误并纠正错误。 </p><p>软件测试是按照特定的规则，发现软件错误的过程；好的测试方案是尽可能发现迄今尚未发现错误的测试；成功的测试方案是发现迄今尚未发现错误的测试</p><p>软件测试的一般步骤?单元测试、子系统测试、系统测试、验收测试、平行测试。</p><h3 id="4-2-代码复审"><a href="#4-2-代码复审" class="headerlink" title="4.2 代码复审"></a>4.2 代码复审</h3><h3 id="4-3-白盒测试"><a href="#4-3-白盒测试" class="headerlink" title="4.3 白盒测试"></a>4.3 白盒测试</h3><p>根据程序内部逻辑结构进行测试，来检验程序内部动作是否按照规格说明书的规定正常进行</p><p>软件的白盒测试是对软件的过程性细节做细致的检查。这种方法是把测试对象看做一个打开的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。通过在不同点检查程序状态，确定实际状态是否与预期的状态一致。因此白盒测试又称为结构测试或逻辑驱动测试。</p><p><strong>8</strong>个覆盖点：语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖、点覆盖、边覆盖、路径覆盖</p><p>白盒测试主要采用的技术有：路径测试技术和事务处理流程技术，对包含有大量逻辑判断或条件组合的程序采用基于逻辑的测试技术。</p><h3 id="4-4-黑盒测试"><a href="#4-4-黑盒测试" class="headerlink" title="4.4 黑盒测试"></a>4.4 黑盒测试</h3><p>根据程序外部特征来进行测试，着重测试软件功能，它并不能取代白盒测试，它是与白盒测试互补的测试方法</p><p>黑盒测试着重测试软件功能。这种方法是把测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。因此黑盒测试又叫功能测试或数据驱动测试。</p><p>黑盒测试主要采用的技术有:等价分类法、边沿值分析法、错误推测法和因果图等技术。</p><p>黑盒测试力图发现下述类型的错误：</p><p>(1)  功能不正确或遗漏了功能。</p><p>(2)  界面错误。</p><p>(3)  数据结构错误或外部访问数据库错误</p><p>(4)  性能错误</p><p>(5)  初始化和终止错误</p><h3 id="4-5-单元测试"><a href="#4-5-单元测试" class="headerlink" title="4.5 单元测试"></a>4.5 单元测试</h3><p>单元测试集中监测软件设计的最小单元—模块。</p><p>从这些方面对模块进行测试：（1）模块接口（2）局部数据结构（3）重要的执行通路（4）出错处理通路（5）边界条件</p><h3 id="4-6-集成测试"><a href="#4-6-集成测试" class="headerlink" title="4.6 集成测试"></a>4.6 集成测试</h3><p>是测试和组装软件的系统化技术。</p><p>测试方法：（1）非渐增式测试  （2）渐增式测试</p><p>当使用渐增方式把模块结合到程序中去时，有<strong>自顶向下</strong>和<strong>自底向上</strong>的两种集成策略</p><p>比较集成试的两种方式的优劣?</p><p>非渐增式测试方式：分别测试模块,再把所有模块按设计要求放在一起组成所要的程序。该方法编写测试软件工作量大，模块间的接口错误发现得晚，错误定位较难诊断，总体测试有的错误容易漏掉，测试时间相对较少，可以并行测试所有模块，能充分利用人力，加快工程进度。。</p><p>渐增式测试方式：把下一个要测试的模块,同已经测试好的那些模块结合起来进行测试。该方法利用已测试过的模块作测试软件,开销小，较早发现模块间的接口错误，错误定位往往和最近入的模块相关，对已测试好的模块可在新加入模块的条件下受到新的检验，测试更彻底，需要较多的测试时间，不能并行测试。</p><p>总的来说，渐增式测试方法比较好。</p><h3 id="4-7-确认测试"><a href="#4-7-确认测试" class="headerlink" title="4.7 确认测试"></a>4.7 确认测试</h3><p>什么是确认测试？该阶段有哪些工作？</p><p>答：确认测试又称有效性测试。它的任务是检查软件的功能与性能是否与需求规格说明书中确定的指标相符合 。</p><p>确认测试阶段有两项工作，进行确认测试与软件配置审查：</p><p>（1）确认测试一般是在模拟环境中运用黑盒测试方法，由专门测试人员和用户参加的测试。</p><p>（2）软件配置审查的任务是检查软件的所有文档资料的完整性、正确性。如果发现遗漏和错误，应补充和改正，同时要编排好目录，为以后的软件维护工作奠定基础。 </p><h3 id="4-8-系统测试"><a href="#4-8-系统测试" class="headerlink" title="4.8 系统测试"></a>4.8 系统测试</h3><h3 id="4-9-回归测试的概念"><a href="#4-9-回归测试的概念" class="headerlink" title="4.9 回归测试的概念"></a>4.9 回归测试的概念</h3><h3 id="4-10-程序正确性证明"><a href="#4-10-程序正确性证明" class="headerlink" title="4.10 程序正确性证明"></a>4.10 程序正确性证明</h3><h3 id="4-11调试"><a href="#4-11调试" class="headerlink" title="4.11调试"></a>4.11调试</h3><p>（调试的概念、调试与测试的关系）</p><p>测试与调试的主要区别？</p><p>(1) (1) 测试从一个侧面证明程序员的失败；调试证明程序员的正确；</p><p>(2) (2) 测试从已知条件开始，使用预先定义的程序，且有预知的结果，不可预见的仅是程序是否通过测试；调试从不可知内部条件开始，除统计性调试外，结果是不可预见的；</p><p>(3) (3) 测试有计划并且要进行测试设计；调试不受时间约束；</p><p>(4) (4) 测试是发现错误、改正错误、重新测试的过程；调试是一个推理的过程；</p><p>(5) (5) 测试执行是有规程的；调试执行要求程序员进行必要的推理；</p><p>(6) (6) 测试由独立的测试组在不了解软件设计的件下完成；调试由了解详细设计的程序员完成；</p><p>(7) (7) 大多数测试的执行和设计可由工具支持；调试用的工具主要是调试器。</p><h3 id="4-12-测试覆盖度的概念"><a href="#4-12-测试覆盖度的概念" class="headerlink" title="4.12 测试覆盖度的概念"></a>4.12 测试覆盖度的概念</h3><h3 id="4-13-代码圈复杂度的计算方法"><a href="#4-13-代码圈复杂度的计算方法" class="headerlink" title="4.13 代码圈复杂度的计算方法"></a>4.13 代码圈复杂度的计算方法</h3><h3 id="4-14-白盒测试中的基本路径测试方法"><a href="#4-14-白盒测试中的基本路径测试方法" class="headerlink" title="4.14 白盒测试中的基本路径测试方法"></a>4.14 白盒测试中的基本路径测试方法</h3><p>路径测试技术中几种主要覆盖的含义?举例说明?</p><p>语句覆盖:至少执行程序中所有语句一次。  </p><p>判定覆盖:使被测程序中的每一个分支至少执行一次。故也称为分支覆盖。</p><p>条件覆盖:执行所有可能的穿过程序的控制路流程。</p><p>条件组合测试:设计足够的测试用例，使每个判定中的所有可能条件取值组合至少执行一次</p><h3 id="4-15-黑盒测试中的等价类划分方法"><a href="#4-15-黑盒测试中的等价类划分方法" class="headerlink" title="4.15 黑盒测试中的等价类划分方法"></a>4.15 黑盒测试中的等价类划分方法</h3><p>等价分类法的测试技术采用的一般方法?举例说明?</p><p>(1) (1) 为每个等价类编号；</p><p>(2) (2) 设计一个新的测试方案,以尽可能多的覆盖尚未被覆盖的有效等价类,重复这一步骤,直到所有有效等价类被覆盖为止。</p><p>(3) (3) 设计一个新的测试方案,使它覆盖一个尚未被覆盖的无效等价类, 重复这一步骤,直到所有无效等价类被覆盖为止。</p><h3 id="4-16-Alpha和Beta测试"><a href="#4-16-Alpha和Beta测试" class="headerlink" title="4.16 Alpha和Beta测试"></a>4.16 Alpha和Beta测试</h3><p><strong>Alpha</strong>测试：由用户在开发者的场所进行，并且在开发者对用户的”指导”下进行测试。开发者负责记录发现的错误和使用中遇到的问题. </p><p><strong>Beta</strong>测试：由软件的最终用户在一个或多个客户场所进行。与Alpha测试不同，开发者通常不在Beta测试的现场，因此，Bate测试时软件在开发者不能控制的环境中的”真实”应用。</p><h2 id="五、软件维护技术"><a href="#五、软件维护技术" class="headerlink" title="五、软件维护技术"></a>五、软件维护技术</h2><h3 id="5-1-软件维护的基本概念"><a href="#5-1-软件维护的基本概念" class="headerlink" title="5.1 软件维护的基本概念"></a>5.1 软件维护的基本概念</h3><p>软件维护是指软件系统交付使用以后，为了改正错误或满足新的需求而修改软件的过程一个中等规模的软件，如果其开发过程需要一两年时间，则它投入使用以后，其运行时间可能持续5~10年之久。在这个维护阶段中，人们需要着手解决开发阶段尚未解决的问题，同时，还解决维护工作本身所产生的问题。做好软件的维护工作不仅能够排除软件中存在的错误，使它能够正常工作，而且还可以使它扩充功能，提高性能，为用户带来新的效益。维护阶段的花费约占整个软件生存周期花费的67%。 因此，应充分认识到维护现有软件的重要意义。</p><p>就是在软件已经交付使用之后，为了改正错误或满足新的需要而修改的过程。</p><p>软件的维护一般分为哪几类？</p><p>　　改正性维护：满足用户对已开发产品的性能与运行环境不断提高的要求，进而达到延长软件寿命的目的。</p><p>　　适应性维护：对程序使用期间发现的程序错误进行诊断和改正的过程，配合变化了的环境进行修改软件的活动；</p><p>　　完善性维护：满足用户在使用过程中提出增加新的功能或修改已有功能的建议而进行的工作； </p><p>　　预防性维护：为了改善未来的可维护性或可靠性而修改软件的工作。</p><p>软件维护的最终目的，是满足用户对已开发产品的性能与运行环境的不断提高的需求，进而延长软件的寿命。</p><h3 id="5-2-软件维护过程"><a href="#5-2-软件维护过程" class="headerlink" title="5.2 软件维护过程"></a>5.2 软件维护过程</h3><p>1、维护组织2、维护报告3、维护的事件流4、保存维护记录5、评价维护活动。</p><p>为什么说软件的维护是不可避免的？</p><p>　　因为软件的开发过程中，一般很难检测到所有的错误，其次软件在应用过程中需要随用户新的要求或运行环境的变化而进行软件的修改或完成功能的增删等，为了提高软件的应用水平和使用寿命，软件的维护是不可避免的。</p><h3 id="5-3-软件可维护性"><a href="#5-3-软件可维护性" class="headerlink" title="5.3 软件可维护性"></a>5.3 软件可维护性</h3><p>软件的可维护性是指维护人员为纠正软件系统出现的错误或缺陷，以及为满足新的要求而理解、修改和完善软件系统的难易程度。可维护性是所有软件系统都应具备的特点。在软件工程的每一-阶段都应该努力提高系统的可维护性，在每个阶段结束前的审查和复审中，应着重对可维护性进行复审。</p><p>决定软件可维护性的因素？</p><p>　　(1) 软件的可理解性、可测试性、可修改性； </p><p>　　(2) 文档描述符合要求、用户文档简洁明确、系统文档完整并且标准。</p><h4 id="5-3-1-可维护性度量的特性"><a href="#5-3-1-可维护性度量的特性" class="headerlink" title="5.3.1 可维护性度量的特性"></a>5.3.1 可维护性度量的特性</h4><p>主要有可理解性、可测试性和可修改性可理解性被定义为人们通过阅读源代码和文档了解软件系统的结构、接口、功能、内部过程以及如何运行的难易程度；可测试性被定义为诊断和测试系统的难易程度；可修改性被定义为修改软件系统的难易程度；它们是密切相关的。</p><h4 id="5-3-2-提高可维护性的方法有哪些"><a href="#5-3-2-提高可维护性的方法有哪些" class="headerlink" title="5.3.2 提高可维护性的方法有哪些"></a>5.3.2 提高可维护性的方法有哪些</h4><p>在软件工程的每一阶段都应该努力提高系统的可维护性，在每个阶段结束前的审查和复审中，应着重对可维护性进行复审。在需求分析阶段的复审中，应对将来要扩充和修改的部分加以注明。在讨论软件可移植性问题时，要考虑可能要影响软件维护的系统界面。在软件设计的复审中，应从便于修改、模块化和功能独立的目标出发，评价软件的结构和过程，还应对将来可能修改的部分预先做准备。在软件代码复审中，应强调编码风格和内部说明这两个影响可维护性的因素。在软件系统交付使用前的每一测试步骤中都应给出需要进行预防性维护部分的提示。在完成每项维护工作后，都应对软件维护本身进行仔细认真的复审。为了从根本上提高软件系统的可维护性，人们正试图通过直接维护软件规格说明来维护软件，同时也在大力发展软件重用技术。</p><p>简述提高软件可维护性的方法。（每项1分）</p><p>明确的质量标准、先进的技术和工具、明确的质量保证工作、可维护性的设计语言、改进程序文档</p><p>（1）建立明确的软件质量标准；</p><p>（2）使用先进软件开发技术和工具；</p><p>（3）建立明确的软件质量保证工作；</p><p>（4）选择可维护的程序设计语言；</p><p>（5）改进程序文档。</p><h3 id="5-4-软件再工程技术"><a href="#5-4-软件再工程技术" class="headerlink" title="5.4 软件再工程技术"></a>5.4 软件再工程技术</h3><p>简述软件再工程的过程（无解释给3分，有解释满分）？</p><p>答：（1）库存目录分析；</p><p>  包含每个应用系统的信息，如：名称、构建日期、修改次数、过去18个月报告的错误、用户数量、文档质量、预期寿命，等。从中选出再工程的候选者。</p><p>（2）文档重构；</p><p> ①如果一个程序走向生命终点，不再经历变化，则保持现状；</p><p> ②重构只针对当前正在修改的软件部分。</p><p>（3）逆向工程；</p><p> 逆向工程是一个恢复设计结果的过程，从程序代码中抽取数据结构、体系结构和处理过程的设计信息。</p><p>（4）代码重构；</p><p>  分析源代码，标注出与结构化程序设计概念不符的部分，重构它的代码，测试重构代码并更新代码。</p><p>（5）数据重构；</p><p>  当数据结构较差时，进行再工程。如以文件方式保存数据变为以数据库方式存储。</p><p>（6）正向工程。</p><p>  也称革新或改造，即应用软件工程的原理、概念、技术和方法来重新开发现有系统。</p><h2 id="六、软件项目管理"><a href="#六、软件项目管理" class="headerlink" title="六、软件项目管理"></a>六、软件项目管理</h2><h3 id="6-1-成本估计"><a href="#6-1-成本估计" class="headerlink" title="6.1 成本估计"></a>6.1 成本估计</h3><p>软件开发成本估算方法有哪几种？ </p><p>自顶向下、自底向上、差别估算、专家估算、类推估算、经验公式估算</p><p>答：（1）自顶向下估算方法。估算人员参照以前完成的项目所耗费的总成本（或总工作量），来推算将要开发的软件的总成本（或总工作量），然后把它们按阶段、步骤和工作单元进行分配，这样方法称为自顶向下的估算方法。（1分）</p><p>（2）自底向上估算方法。自底向上估算方法是将待开发的软件细分，分别估算每一个子任务所需要的开发工作量，然后将它们加起来，得到软件的总开发量。（1分）</p><p>（3）差别估算方法。差别估算是将开发项目与一个或多个已完成的类似项目进行比较，找出与某个相类似项目的若干不同之处，并估算每个不同之处对成本的影响，导出开发项目的总成本。（1分）</p><p>（4）专家估算法。依靠一个或多个专家对要求的项目做出估算。（1分）</p><p>（5）类推估算法。（0.5分）</p><p>（6）经验公式估算法。（0.5分）  </p><p>为什么在软件开发中，不能用简单增加人员的方法来缩短开发时间？ 大量软件开发实践说明:向一个已经延迟的项目追加开发人员,可能使它完成得更晚。因为当开发人员以算术级数增长时，而人员之间的通信将以几何级数增长，往往”得不偿失”。</p><h3 id="6-2-效益分析"><a href="#6-2-效益分析" class="headerlink" title="6.2 效益分析"></a>6.2 效益分析</h3><h3 id="6-3-风险分析"><a href="#6-3-风险分析" class="headerlink" title="6.3 风险分析"></a>6.3 风险分析</h3><h3 id="6-4-进度安排"><a href="#6-4-进度安排" class="headerlink" title="6.4 进度安排"></a>6.4 进度安排</h3><h3 id="6-5-项目组织与计划"><a href="#6-5-项目组织与计划" class="headerlink" title="6.5 项目组织与计划"></a>6.5 项目组织与计划</h3><h3 id="6-6-软件质量保证与分析"><a href="#6-6-软件质量保证与分析" class="headerlink" title="6.6 软件质量保证与分析"></a>6.6 软件质量保证与分析</h3><p>影响软件质量的主要因素有哪些？</p><p>　　(1) 产品运行:正确性、风险性、效率、完整性、健壮性和可用性；</p><p>　　(2) 产品修改:可理解性、可维护性、灵活性、可测试性；</p><p>(3) 产品转移：可移植性、可重用性和互运行性。</p><p>如何做好软件质量保证工作？ </p><p>软件质量保证工作是软件工程管理的重要内容，软件质量保证应做好以下几个方面的工作：</p><p>（1）采用技术手段和工具。质量保证活动要贯彻开发过程始终，必须从采用技术手段和工具，尤其是使用软件开发环境来进行软件开发。</p><p>（2）组织正式技术评审，在软件开发的第一个阶段结束时，都要组织正式的技术评审。国家标准要求单位必须采用审查、文档评审、设计评审、审计和测试等具体手段来保证质量。</p><p>（3）加强软件测试。软件测试是质量保证的重要手段，因为测试可发现软件可发现软件中大多数潜在错误。</p><p>（4）推选软件工程规范（标准）。用户可以自己指定软件工程规范（标准），但标准一旦确认就应贯彻执行。</p><p>（5）对软件的变更进行控制。软件的修改和变更常常会引起潜伏的错误，因此必须严格控制软件的修改和变更。</p><p>（6）对软件质量进行度量。即对软件质量进行跟踪，及时记录和报告软件质量情况。</p><p>基线是一个软件配置管理概念，它有助于人们在不严重合理变化的前提下来控制变化，简而言之，基线就是通过了正式复审的软件配置项。。在软件配置项变成基线之前，可以迅速而非正式地修改它。        </p><h2 id="七、参考书目"><a href="#七、参考书目" class="headerlink" title="七、参考书目"></a>七、参考书目</h2><ul><li>《软件工程：实践者的研究方法》（英文版，第7版），Roger  Pressman，机械工业出版社，2010年10月</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;整理目的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我还是认为基础知识不能丢，也是对以前知识的回顾。&lt;/li&gt;
&lt;li&gt;考研软件工程方向考软件工程这门学科的并不多，我选择了两所学校来进行整理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以中南大学944软件工程考试大纲和复旦961软件工程专业基础综合考试大纲为基础。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Study" scheme="https://mysticalguest.github.io/categories/Study/"/>
    
    
      <category term="计算机基础" scheme="https://mysticalguest.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>数字逻辑课程复习</title>
    <link href="https://mysticalguest.github.io/Study/60189.html"/>
    <id>https://mysticalguest.github.io/Study/60189.html</id>
    <published>2021-03-31T03:05:21.936Z</published>
    <updated>2021-04-08T13:02:52.446Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>考查目标</p><p>1、掌握逻辑代数的基础知识、基本概念及运算规律；</p><p>2、掌握半导体器件、门电路、组合逻辑、时序逻辑等电路基础知识、基本概念及工作原理；</p><p>3、掌握数字系统设计基本方法、逻辑函数优化实现及逻辑电路测试方法。</p><p>以西北工业大学801计算机专业基础为考纲，虽然当时考试未选这门课，但可以以此作为作为学习基础。</p></blockquote><a id="more"></a><h2 id="一、逻辑代数"><a href="#一、逻辑代数" class="headerlink" title="一、逻辑代数"></a>一、逻辑代数</h2><h3 id="1-1-逻辑代数的基本运算、基本定理、基本法则"><a href="#1-1-逻辑代数的基本运算、基本定理、基本法则" class="headerlink" title="1.1 逻辑代数的基本运算、基本定理、基本法则"></a>1.1 逻辑代数的基本运算、基本定理、基本法则</h3><h3 id="1-2-利用逻辑代数和卡诺图对逻辑函数进行转换与化简"><a href="#1-2-利用逻辑代数和卡诺图对逻辑函数进行转换与化简" class="headerlink" title="1.2 利用逻辑代数和卡诺图对逻辑函数进行转换与化简"></a>1.2 利用逻辑代数和卡诺图对逻辑函数进行转换与化简</h3><h3 id="1-3-各种形式的逻辑函数的相互转换方法"><a href="#1-3-各种形式的逻辑函数的相互转换方法" class="headerlink" title="1.3 各种形式的逻辑函数的相互转换方法"></a>1.3 各种形式的逻辑函数的相互转换方法</h3><h3 id="1-4-卡诺图化简方法"><a href="#1-4-卡诺图化简方法" class="headerlink" title="1.4 卡诺图化简方法"></a>1.4 卡诺图化简方法</h3><h3 id="1-5-不完全确定的逻辑函数的化简方法"><a href="#1-5-不完全确定的逻辑函数的化简方法" class="headerlink" title="1.5 不完全确定的逻辑函数的化简方法"></a>1.5 不完全确定的逻辑函数的化简方法</h3><h3 id="1-6-多输出逻辑函数的化简方法"><a href="#1-6-多输出逻辑函数的化简方法" class="headerlink" title="1.6 多输出逻辑函数的化简方法"></a>1.6 多输出逻辑函数的化简方法</h3><h2 id="二、门电路"><a href="#二、门电路" class="headerlink" title="二、门电路"></a>二、门电路</h2><h3 id="2-1-了解PN结的结构与原理，掌握PN结的伏安特性"><a href="#2-1-了解PN结的结构与原理，掌握PN结的伏安特性" class="headerlink" title="2.1 了解PN结的结构与原理，掌握PN结的伏安特性"></a>2.1 了解PN结的结构与原理，掌握PN结的伏安特性</h3><h3 id="2-2-掌握双极型晶体管和场效应晶体管的结构及工作原理"><a href="#2-2-掌握双极型晶体管和场效应晶体管的结构及工作原理" class="headerlink" title="2.2 掌握双极型晶体管和场效应晶体管的结构及工作原理"></a>2.2 掌握双极型晶体管和场效应晶体管的结构及工作原理</h3><h3 id="2-3-掌握CMOS门电路结构和工作原理；"><a href="#2-3-掌握CMOS门电路结构和工作原理；" class="headerlink" title="2.3 掌握CMOS门电路结构和工作原理；"></a>2.3 掌握CMOS门电路结构和工作原理；</h3><h3 id="2-4-掌握TTL门电路结构和工作原理"><a href="#2-4-掌握TTL门电路结构和工作原理" class="headerlink" title="2.4 掌握TTL门电路结构和工作原理"></a>2.4 掌握TTL门电路结构和工作原理</h3><h2 id="三、组合逻辑电路"><a href="#三、组合逻辑电路" class="headerlink" title="三、组合逻辑电路"></a>三、组合逻辑电路</h2><h3 id="3-1-掌握组合逻辑电路的分析方法"><a href="#3-1-掌握组合逻辑电路的分析方法" class="headerlink" title="3.1 掌握组合逻辑电路的分析方法"></a>3.1 掌握组合逻辑电路的分析方法</h3><h3 id="3-2-熟悉常用组合逻辑电路模块的结构和逻辑功能"><a href="#3-2-熟悉常用组合逻辑电路模块的结构和逻辑功能" class="headerlink" title="3.2 熟悉常用组合逻辑电路模块的结构和逻辑功能"></a>3.2 熟悉常用组合逻辑电路模块的结构和逻辑功能</h3><h3 id="3-3-掌握组合逻辑电路的设计过程"><a href="#3-3-掌握组合逻辑电路的设计过程" class="headerlink" title="3.3 掌握组合逻辑电路的设计过程"></a>3.3 掌握组合逻辑电路的设计过程</h3><h3 id="3-4-基于门电路的设计"><a href="#3-4-基于门电路的设计" class="headerlink" title="3.4 基于门电路的设计"></a>3.4 基于门电路的设计</h3><h3 id="3-5-基于常用组合逻辑电路模块的组合逻辑电路设计"><a href="#3-5-基于常用组合逻辑电路模块的组合逻辑电路设计" class="headerlink" title="3.5 基于常用组合逻辑电路模块的组合逻辑电路设计"></a>3.5 基于常用组合逻辑电路模块的组合逻辑电路设计</h3><h3 id="3-6-了解组合逻辑电路中的冒险现象及其消除方法"><a href="#3-6-了解组合逻辑电路中的冒险现象及其消除方法" class="headerlink" title="3.6 了解组合逻辑电路中的冒险现象及其消除方法"></a>3.6 了解组合逻辑电路中的冒险现象及其消除方法</h3><h2 id="四、触发器及时序逻辑电路"><a href="#四、触发器及时序逻辑电路" class="headerlink" title="四、触发器及时序逻辑电路"></a>四、触发器及时序逻辑电路</h2><h3 id="4-1-掌握常用触发器的结构和工作原理；"><a href="#4-1-掌握常用触发器的结构和工作原理；" class="headerlink" title="4.1 掌握常用触发器的结构和工作原理；"></a>4.1 掌握常用触发器的结构和工作原理；</h3><h3 id="4-2-掌握触发器的逻辑功能及描述方法；"><a href="#4-2-掌握触发器的逻辑功能及描述方法；" class="headerlink" title="4.2 掌握触发器的逻辑功能及描述方法；"></a>4.2 掌握触发器的逻辑功能及描述方法；</h3><h3 id="4-3-熟悉触发器及其简单应用电路；"><a href="#4-3-熟悉触发器及其简单应用电路；" class="headerlink" title="4.3 熟悉触发器及其简单应用电路；"></a>4.3 熟悉触发器及其简单应用电路；</h3><h3 id="4-4-掌握同步时序逻辑电路的分析和设计方法；"><a href="#4-4-掌握同步时序逻辑电路的分析和设计方法；" class="headerlink" title="4.4 掌握同步时序逻辑电路的分析和设计方法；"></a>4.4 掌握同步时序逻辑电路的分析和设计方法；</h3><h3 id="4-5-掌握异步时序电路的分析和设计方法；"><a href="#4-5-掌握异步时序电路的分析和设计方法；" class="headerlink" title="4.5 掌握异步时序电路的分析和设计方法；"></a>4.5 掌握异步时序电路的分析和设计方法；</h3><h3 id="4-6-掌握时序逻辑电路中的竞争-冒险现象和消除方法；"><a href="#4-6-掌握时序逻辑电路中的竞争-冒险现象和消除方法；" class="headerlink" title="4.6 掌握时序逻辑电路中的竞争-冒险现象和消除方法；"></a>4.6 掌握时序逻辑电路中的竞争-冒险现象和消除方法；</h3><h2 id="五、半导体存储器"><a href="#五、半导体存储器" class="headerlink" title="五、半导体存储器"></a>五、半导体存储器</h2><h3 id="5-1-掌握只读存储器结构和工作原理；"><a href="#5-1-掌握只读存储器结构和工作原理；" class="headerlink" title="5.1 掌握只读存储器结构和工作原理；"></a>5.1 掌握只读存储器结构和工作原理；</h3><h3 id="5-2-掌握随机存储器结构和工作原理；"><a href="#5-2-掌握随机存储器结构和工作原理；" class="headerlink" title="5.2 掌握随机存储器结构和工作原理；"></a>5.2 掌握随机存储器结构和工作原理；</h3><h3 id="5-3-掌握存储器容量扩展方法；"><a href="#5-3-掌握存储器容量扩展方法；" class="headerlink" title="5.3 掌握存储器容量扩展方法；"></a>5.3 掌握存储器容量扩展方法；</h3><h3 id="5-4-熟悉用存储器实现组合逻辑函数的方法；"><a href="#5-4-熟悉用存储器实现组合逻辑函数的方法；" class="headerlink" title="5.4 熟悉用存储器实现组合逻辑函数的方法；"></a>5.4 熟悉用存储器实现组合逻辑函数的方法；</h3><h2 id="六、可编程逻辑器件"><a href="#六、可编程逻辑器件" class="headerlink" title="六、可编程逻辑器件"></a>六、可编程逻辑器件</h2><h3 id="6-1-掌握复杂的可编程逻辑器件的结构和工作原理；"><a href="#6-1-掌握复杂的可编程逻辑器件的结构和工作原理；" class="headerlink" title="6.1 掌握复杂的可编程逻辑器件的结构和工作原理；"></a>6.1 掌握复杂的可编程逻辑器件的结构和工作原理；</h3><h3 id="6-2-掌握现场可编程逻辑阵列的基本结构、工作原理；"><a href="#6-2-掌握现场可编程逻辑阵列的基本结构、工作原理；" class="headerlink" title="6.2 掌握现场可编程逻辑阵列的基本结构、工作原理；"></a>6.2 掌握现场可编程逻辑阵列的基本结构、工作原理；</h3><h3 id="6-3-熟悉可编程逻辑器件的编程和数据下载方法；"><a href="#6-3-熟悉可编程逻辑器件的编程和数据下载方法；" class="headerlink" title="6.3 熟悉可编程逻辑器件的编程和数据下载方法；"></a>6.3 熟悉可编程逻辑器件的编程和数据下载方法；</h3><h2 id="七、Verilog硬件描述语言"><a href="#七、Verilog硬件描述语言" class="headerlink" title="七、Verilog硬件描述语言"></a>七、Verilog硬件描述语言</h2><h3 id="7-1-掌握Verilog基本程序结构；"><a href="#7-1-掌握Verilog基本程序结构；" class="headerlink" title="7.1 掌握Verilog基本程序结构；"></a>7.1 掌握Verilog基本程序结构；</h3><h3 id="7-2-掌握Verilog词法构成；"><a href="#7-2-掌握Verilog词法构成；" class="headerlink" title="7.2 掌握Verilog词法构成；"></a>7.2 掌握Verilog词法构成；</h3><h3 id="7-3-熟悉模块的描述方式；"><a href="#7-3-熟悉模块的描述方式；" class="headerlink" title="7.3 熟悉模块的描述方式；"></a>7.3 熟悉模块的描述方式；</h3><h3 id="7-4-掌握采用Verilog描述简单的组合逻辑电路和时序逻辑电路；"><a href="#7-4-掌握采用Verilog描述简单的组合逻辑电路和时序逻辑电路；" class="headerlink" title="7.4 掌握采用Verilog描述简单的组合逻辑电路和时序逻辑电路；"></a>7.4 掌握采用Verilog描述简单的组合逻辑电路和时序逻辑电路；</h3><h2 id="八、脉冲波形的产生和整形"><a href="#八、脉冲波形的产生和整形" class="headerlink" title="八、脉冲波形的产生和整形"></a>八、脉冲波形的产生和整形</h2><h3 id="8-1-掌握施密特触发器的结构和工作原理；"><a href="#8-1-掌握施密特触发器的结构和工作原理；" class="headerlink" title="8.1 掌握施密特触发器的结构和工作原理；"></a>8.1 掌握施密特触发器的结构和工作原理；</h3><h3 id="8-2-掌握单稳态触发器类型、结构和工作原理；"><a href="#8-2-掌握单稳态触发器类型、结构和工作原理；" class="headerlink" title="8.2 掌握单稳态触发器类型、结构和工作原理；"></a>8.2 掌握单稳态触发器类型、结构和工作原理；</h3><h3 id="8-3-掌握多谐振荡器类型、结构和工作原理；"><a href="#8-3-掌握多谐振荡器类型、结构和工作原理；" class="headerlink" title="8.3 掌握多谐振荡器类型、结构和工作原理；"></a>8.3 掌握多谐振荡器类型、结构和工作原理；</h3><h3 id="8-4-熟悉555定时器及其应用；"><a href="#8-4-熟悉555定时器及其应用；" class="headerlink" title="8.4 熟悉555定时器及其应用；"></a>8.4 熟悉555定时器及其应用；</h3><h2 id="九、逻辑电路测试"><a href="#九、逻辑电路测试" class="headerlink" title="九、逻辑电路测试"></a>九、逻辑电路测试</h2><h3 id="9-1-掌握容错模型"><a href="#9-1-掌握容错模型" class="headerlink" title="9.1 掌握容错模型"></a>9.1 掌握容错模型</h3><h3 id="9-2-掌握树形结构电路；"><a href="#9-2-掌握树形结构电路；" class="headerlink" title="9.2 掌握树形结构电路；"></a>9.2 掌握树形结构电路；</h3><h3 id="9-3-掌握随机测试方法；"><a href="#9-3-掌握随机测试方法；" class="headerlink" title="9.3 掌握随机测试方法；"></a>9.3 掌握随机测试方法；</h3><h3 id="9-4-掌握时序电路测试方法；"><a href="#9-4-掌握时序电路测试方法；" class="headerlink" title="9.4 掌握时序电路测试方法；"></a>9.4 掌握时序电路测试方法；</h3><h3 id="9-5-掌握内建自测试方法；"><a href="#9-5-掌握内建自测试方法；" class="headerlink" title="9.5 掌握内建自测试方法；"></a>9.5 掌握内建自测试方法；</h3><h2 id="十、参考书目"><a href="#十、参考书目" class="headerlink" title="十、参考书目"></a>十、参考书目</h2><ul><li>《数字电子技术基础》（第5版），阎石，高等教育出版社，2011年。</li><li>《数字逻辑与Verilog设计》（第3版），(美)布朗(Stephen Brown)，(美)弗兰民斯克(Zvonko Vran)，罗荣选译，清华大学出版社，2014年。  </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;考查目标&lt;/p&gt;
&lt;p&gt;1、掌握逻辑代数的基础知识、基本概念及运算规律；&lt;/p&gt;
&lt;p&gt;2、掌握半导体器件、门电路、组合逻辑、时序逻辑等电路基础知识、基本概念及工作原理；&lt;/p&gt;
&lt;p&gt;3、掌握数字系统设计基本方法、逻辑函数优化实现及逻辑电路测试方法。&lt;/p&gt;
&lt;p&gt;以西北工业大学801计算机专业基础为考纲，虽然当时考试未选这门课，但可以以此作为作为学习基础。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Study" scheme="https://mysticalguest.github.io/categories/Study/"/>
    
    
      <category term="计算机基础" scheme="https://mysticalguest.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>操作系统课程复习</title>
    <link href="https://mysticalguest.github.io/Study/4919.html"/>
    <id>https://mysticalguest.github.io/Study/4919.html</id>
    <published>2021-03-31T03:02:35.511Z</published>
    <updated>2021-04-19T10:13:44.983Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>考查目标：</p><ol><li><strong>掌握</strong>操作系统的基本概念、基本原理和基本功能，理解操作系统的整体运行过程。</li><li><p><strong>掌握</strong>操作系统进程、内存、文件和I/O管理的策略、算法、机制以及相互关系。</p></li><li><p>能够运用所学的操作系统原理、方法与技术分析问题和解决问题，并能利用C语言或其他高级语言描述相关算法。 </p></li></ol><p>以西北工业大学801计算机专业基础为考纲，虽然当时考试未选这门课，但可以以此作为作为学习基础。</p></blockquote><a id="more"></a><h2 id="一、操作系统概述"><a href="#一、操作系统概述" class="headerlink" title="一、操作系统概述"></a>一、操作系统概述</h2><h3 id="1-1-操作系统的概念、特征、功能和提供的服务"><a href="#1-1-操作系统的概念、特征、功能和提供的服务" class="headerlink" title="1.1 操作系统的概念、特征、功能和提供的服务"></a>1.1 操作系统的概念、特征、功能和提供的服务</h3><h3 id="1-2-操作系统的发展与分类"><a href="#1-2-操作系统的发展与分类" class="headerlink" title="1.2 操作系统的发展与分类"></a>1.2 操作系统的发展与分类</h3><h3 id="1-3-操作系统的运行环境"><a href="#1-3-操作系统的运行环境" class="headerlink" title="1.3 操作系统的运行环境"></a>1.3 操作系统的运行环境</h3><p>（内核态与用户态、中断、异常、系统调用）</p><h3 id="1-4-操作系统体系结构"><a href="#1-4-操作系统体系结构" class="headerlink" title="1.4 操作系统体系结构"></a>1.4 操作系统体系结构</h3><h2 id="二、进程管理"><a href="#二、进程管理" class="headerlink" title="二、进程管理"></a>二、进程管理</h2><h3 id="2-1-进程与线程"><a href="#2-1-进程与线程" class="headerlink" title="2.1 进程与线程"></a>2.1 进程与线程</h3><h4 id="2-1-1-进程概念、进程的状态与转换、进程控制、进程组织"><a href="#2-1-1-进程概念、进程的状态与转换、进程控制、进程组织" class="headerlink" title="2.1.1 进程概念、进程的状态与转换、进程控制、进程组织"></a>2.1.1 进程概念、进程的状态与转换、进程控制、进程组织</h4><h4 id="2-1-2-进程通信"><a href="#2-1-2-进程通信" class="headerlink" title="2.1.2 进程通信"></a>2.1.2 进程通信</h4><p>（共享存储、消息传递、、信箱通信、管道通信）</p><h4 id="2-1-3-线程概念与多线程模型"><a href="#2-1-3-线程概念与多线程模型" class="headerlink" title="2.1.3 线程概念与多线程模型"></a>2.1.3 线程概念与多线程模型</h4><h3 id="2-2-处理机调度"><a href="#2-2-处理机调度" class="headerlink" title="2.2 处理机调度"></a>2.2 处理机调度</h3><h4 id="2-2-1-调度的基本概念，调度的基本准则，调度时机、切换与过程、调度方式"><a href="#2-2-1-调度的基本概念，调度的基本准则，调度时机、切换与过程、调度方式" class="headerlink" title="2.2.1 调度的基本概念，调度的基本准则，调度时机、切换与过程、调度方式"></a>2.2.1 调度的基本概念，调度的基本准则，调度时机、切换与过程、调度方式</h4><h4 id="2-2-2-典型调度算法"><a href="#2-2-2-典型调度算法" class="headerlink" title="2.2.2 典型调度算法"></a>2.2.2 典型调度算法</h4><p>先来先服务、短作业（短进程、短线程）优先、时间片轮转、优先级、最高响应比优先、多级反馈队列调度算法</p><h3 id="2-3-进程同步与互斥"><a href="#2-3-进程同步与互斥" class="headerlink" title="2.3 进程同步与互斥"></a>2.3 进程同步与互斥</h3><h4 id="2-3-1-进程同步的基本概念"><a href="#2-3-1-进程同步的基本概念" class="headerlink" title="2.3.1 进程同步的基本概念"></a>2.3.1 进程同步的基本概念</h4><h4 id="2-3-2-实现临界区互斥的基本方法：软件实现方法、硬件实现方法"><a href="#2-3-2-实现临界区互斥的基本方法：软件实现方法、硬件实现方法" class="headerlink" title="2.3.2 实现临界区互斥的基本方法：软件实现方法、硬件实现方法"></a>2.3.2 实现临界区互斥的基本方法：软件实现方法、硬件实现方法</h4><h4 id="2-3-3-信号量、管程"><a href="#2-3-3-信号量、管程" class="headerlink" title="2.3.3 信号量、管程"></a>2.3.3 信号量、管程</h4><h4 id="2-3-4-经典同步问题：生产者-消费者问题、读者-写者问题、哲学家进餐问题等"><a href="#2-3-4-经典同步问题：生产者-消费者问题、读者-写者问题、哲学家进餐问题等" class="headerlink" title="2.3.4 经典同步问题：生产者-消费者问题、读者-写者问题、哲学家进餐问题等"></a>2.3.4 经典同步问题：生产者-消费者问题、读者-写者问题、哲学家进餐问题等</h4><h3 id="2-4-死锁"><a href="#2-4-死锁" class="headerlink" title="2.4 死锁"></a>2.4 死锁</h3><h4 id="2-4-1-死锁的概念、死锁处理策略"><a href="#2-4-1-死锁的概念、死锁处理策略" class="headerlink" title="2.4.1 死锁的概念、死锁处理策略"></a>2.4.1 死锁的概念、死锁处理策略</h4><h4 id="2-4-2-死锁预防"><a href="#2-4-2-死锁预防" class="headerlink" title="2.4.2 死锁预防"></a>2.4.2 死锁预防</h4><h4 id="2-4-3-死锁避免：系统安全状态、银行家算法"><a href="#2-4-3-死锁避免：系统安全状态、银行家算法" class="headerlink" title="2.4.3 死锁避免：系统安全状态、银行家算法"></a>2.4.3 死锁避免：系统安全状态、银行家算法</h4><h4 id="2-4-4-死锁检测和解除"><a href="#2-4-4-死锁检测和解除" class="headerlink" title="2.4.4 死锁检测和解除"></a>2.4.4 死锁检测和解除</h4><h2 id="三、内存管理"><a href="#三、内存管理" class="headerlink" title="三、内存管理"></a>三、内存管理</h2><h3 id="3-1-内存管理基础"><a href="#3-1-内存管理基础" class="headerlink" title="3.1 内存管理基础"></a>3.1 内存管理基础</h3><p>程序执行前<strong>需要先放到内存中才能被CPU处理</strong>——缓和CPU与硬件之间的速度矛盾。</p><ul><li><p>给内存的存储单元编地址</p><p>每个地址对应一个存储单元</p></li></ul><div class="table-container"><table><thead><tr><th>按字节编址</th><th>按字编址（设字长16位）</th></tr></thead><tbody><tr><td>每个存储单元大小为1字节</td><td>每个存储单元大小为1个字</td></tr><tr><td>1B，即8个二进制位</td><td>16个二进制位</td></tr><tr><td>字节是寻址的最小单位</td><td>字长是计算机一次处理数据的最大单位</td></tr></tbody></table></div><ul><li><p>补充知识</p><script type="math/tex; mode=display">2^{10}=1K, 2^{20}=1M, 2^{30}=1G</script></li><li><p>指令的工作原理</p><p>指令的工作基于‘地址’。每个地址对应一个数据的存储单元。</p><p>我们写的代码要翻译成CPU能识别的指令，这些指令会告诉CPU应该去内存的哪个地址读写数据。（所以引入程序装入？）</p></li></ul><h4 id="3-1-1-内存管理概念"><a href="#3-1-1-内存管理概念" class="headerlink" title="3.1.1 内存管理概念"></a>3.1.1 内存管理概念</h4><ul><li><p>内存空间的分配与回收</p><ul><li>连续分配管理方式</li><li>非连续分配管理方式</li></ul></li><li><p>内存空间的扩充</p><ul><li>覆盖技术（解决“程序大小超过物理内存总和”的问题）</li><li>交换（对换）技术</li><li>虚拟存储技术</li></ul></li><li><p>地址转换</p><blockquote><p><strong>逻辑地址到物理地址</strong>的转换（这个过程称为<strong>地址重定位</strong>，有3种装入方式）应该有操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。</p></blockquote></li><li><p>存储保护（内存保护），保证各进程在各自存储空间内运行，互不干扰</p><p>内存保护可采取两种方法：</p><ul><li>方法一：在CPU中<strong>设置一对上、下限寄存器</strong>，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。</li><li>方法二：采用<strong>重定位寄存器</strong>（又称<strong>基址寄存器</strong>）和<strong>界地址寄存器</strong>（又称<strong>限长寄存器</strong>）进行越界检查。重定位寄存器中存放的是进程的<strong>起始物理地址</strong>。界地址寄存器中存放的是进程的<strong>最大逻辑地址</strong>。</li></ul></li></ul><h4 id="3-1-2-程序装入与链接、逻辑地址与物理地址空间、内存保护"><a href="#3-1-2-程序装入与链接、逻辑地址与物理地址空间、内存保护" class="headerlink" title="3.1.2 程序装入与链接、逻辑地址与物理地址空间、内存保护"></a>3.1.2 程序装入与链接、逻辑地址与物理地址空间、内存保护</h4><ul><li>装入的三种方式</li></ul><div class="table-container"><table><thead><tr><th>方式</th><th>内容</th><th>特点</th><th>区别</th></tr></thead><tbody><tr><td>绝对装入</td><td>在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。</td><td>只适用于单道程序环境</td><td>程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。</td></tr><tr><td>静态重定位（可重定位装入）</td><td>编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的<strong>逻辑地址</strong>。根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）</td><td>在一个作业装入内存时，<strong>必须分配其要求的全部内存空间</strong>，如果没有足够的内存，就不能装入该作业。<br />用于早期的多道批处理操作系统</td><td>作业一旦进入内存后，在运行期间就不能移动，也不能再申请内存空间。</td></tr><tr><td>动态重定位（动态运行时装入）</td><td>编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是<strong>把地址转换推迟到程序真正要执行时才进行</strong>。因此装入内存后所有的地址依然是逻辑地址。</td><td>需要一个<strong>重定位寄存器</strong>的支持，用来装入模块存放的<strong>起始位置</strong>。<br />现代操作系统</td><td><strong>允许程序在内存中发生移动</strong>。并且可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，可动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间</td></tr></tbody></table></div><ul><li><p>编译</p><p>由编译程序将用户源代码编译成若干个<strong>目标模块</strong>（将高级语言翻译为机器语言）</p></li><li><p>链接</p><p>由<strong>链接程序</strong>将编译后形成的一组<strong>目标模块</strong>，以及所需库函数链接在一起，形成一个完整的<strong>装入模块</strong></p></li><li><p>装入（装载）</p><p>由<strong>装入程序</strong>将装入模块装入内存运行</p></li><li><p>链接的三种方式</p></li></ul><div class="table-container"><table><thead><tr><th>方式</th><th>内容</th></tr></thead><tbody><tr><td>静态链接</td><td>在程序运行之前，先将各目标模块及它们所需的库函数连接成一个<strong>完整</strong>的可执行文件（装入模块），之后不在拆开</td></tr><tr><td>装入时动态链接将</td><td>将各目标模块装入内存时，边装入边链接。（在内存中连续吗？）</td></tr><tr><td>运行时动态链接</td><td>在程序执行中<strong>需要</strong>该目标模块<strong>时</strong>，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。（如何共享？）</td></tr></tbody></table></div><h4 id="3-1-3-交换与覆盖"><a href="#3-1-3-交换与覆盖" class="headerlink" title="3.1.3 交换与覆盖"></a>3.1.3 交换与覆盖</h4><ul><li><p>覆盖技术（解决“程序大小超过物理内存总和”的问题）</p><p>思想：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。</p><p>内存中分为一个“固定区”和若干个“覆盖区”。</p><p>需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）；不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存。</p><blockquote><p>按照自身逻辑结构，让那些不可能同时被访问的程序段共享同一个覆盖区。必须由程序员声明覆盖结构，操作系统完成西大覆盖。缺点：对用户不透明，增加了用户编程复旦。覆盖技术只用于早期的操所系统。</p></blockquote></li><li><p>交换（对换）技术</p><p>思想：内存空间紧张时，系统将内存中某些进程暂时<strong>换出</strong>外存，把外存中某些已具备运行条件的进程<strong>换入</strong>内存（进程在内存与磁盘间动态调度）</p><p>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。</p><p>暂时换出外存等待的进程状态为<strong>挂起状态（Suspend）</strong>，挂起态又可以进一步细分为<strong>就绪挂起、阻塞挂起</strong>两种状态。</p><p><code>应该在外存（磁盘）的什么位置保存被换出的进程？</code></p><blockquote><p>具有对换功能的操作系统中，通常把磁盘空间分为<strong>文件区</strong>和<strong>对换区</strong>两部分。<strong>文件区</strong>主要用于存放文件，<strong>主要追求存储空间的利用率</strong>，因此对文件区空间的管理<strong>采用离散分配方式</strong>；<strong>对换区</strong>空间只占磁盘空间的小部分，<strong>被换出的进程数据就存放在对换区</strong>。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理<strong>主要追求换入换出速度</strong>，因此通常对换区<strong>采用连续分配方式</strong>（学过文件管理章节后即可理解）。总之，<strong>对换区的I/O速度比文件区的更快</strong>。</p></blockquote><p><code>什么时候应该交换？</code></p><blockquote><p>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程：如果缺页率明显下降，就可以暂停换出。</p></blockquote><p><code>应该换出哪些进程？</code></p><blockquote><p>可优先换出阻塞进程；可换出优先级低的进程：为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间。（注意：<strong>PCB会常驻内存</strong>，不会被换出外存）</p></blockquote></li></ul><h4 id="3-1-4-连续分配管理方式"><a href="#3-1-4-连续分配管理方式" class="headerlink" title="3.1.4 连续分配管理方式"></a>3.1.4 连续分配管理方式</h4><p>连续分配：指为用户进程分配的必须是一个连续的内存空间。</p><ul><li><p>单一连续分配</p></li><li><p>固定分区分配</p></li><li><p>动态分区分配</p><p>动态分区分配算法</p><ul><li>首次适应算法（First Fit）</li><li>最佳适应算法（Best Fit）</li><li>最坏适应算法（Worst Fit）</li><li>邻近适应算法（Next Fit）</li></ul></li></ul><h4 id="3-1-5-非连续（离散）分配管理方式"><a href="#3-1-5-非连续（离散）分配管理方式" class="headerlink" title="3.1.5 非连续（离散）分配管理方式"></a>3.1.5 非连续（离散）分配管理方式</h4><p>分页管理方式、分段管理方式、段页式管理方式</p><ul><li>基本分页存储管理的基本概念</li><li>基本分段存储管理</li><li>段页式存储管理</li></ul><h3 id="3-2-虚拟内存管理"><a href="#3-2-虚拟内存管理" class="headerlink" title="3.2 虚拟内存管理"></a>3.2 虚拟内存管理</h3><h4 id="3-2-1-虚拟内存基本概念"><a href="#3-2-1-虚拟内存基本概念" class="headerlink" title="3.2.1 虚拟内存基本概念"></a>3.2.1 虚拟内存基本概念</h4><h4 id="3-2-2-请求分页管理方式"><a href="#3-2-2-请求分页管理方式" class="headerlink" title="3.2.2 请求分页管理方式"></a>3.2.2 请求分页管理方式</h4><h4 id="3-2-3-页面置换算法"><a href="#3-2-3-页面置换算法" class="headerlink" title="3.2.3 页面置换算法"></a>3.2.3 页面置换算法</h4><p>最佳置换算法（OPT）、先进先出置换算法（FIFO）、最近最少使用置换算法（LRU）、时钟置换算法（CLOCK）等</p><h4 id="3-2-4-页面分配策略"><a href="#3-2-4-页面分配策略" class="headerlink" title="3.2.4 页面分配策略"></a>3.2.4 页面分配策略</h4><h4 id="3-2-5-工作集、抖动"><a href="#3-2-5-工作集、抖动" class="headerlink" title="3.2.5 工作集、抖动"></a>3.2.5 工作集、抖动</h4><h2 id="四、文件管理"><a href="#四、文件管理" class="headerlink" title="四、文件管理"></a>四、文件管理</h2><h3 id="4-1-文件系统基础"><a href="#4-1-文件系统基础" class="headerlink" title="4.1 文件系统基础"></a>4.1 文件系统基础</h3><h4 id="4-1-1-文件概念、文件的逻辑结构"><a href="#4-1-1-文件概念、文件的逻辑结构" class="headerlink" title="4.1.1 文件概念、文件的逻辑结构"></a>4.1.1 文件概念、文件的逻辑结构</h4><h4 id="4-1-2-文件的结构：顺序文件、索引文件、索引顺序文件"><a href="#4-1-2-文件的结构：顺序文件、索引文件、索引顺序文件" class="headerlink" title="4.1.2 文件的结构：顺序文件、索引文件、索引顺序文件"></a>4.1.2 文件的结构：顺序文件、索引文件、索引顺序文件</h4><h4 id="4-1-3-目录结构：文件控制块和索引节点，单级、两级和树形目录结构，图形目录结构"><a href="#4-1-3-目录结构：文件控制块和索引节点，单级、两级和树形目录结构，图形目录结构" class="headerlink" title="4.1.3 目录结构：文件控制块和索引节点，单级、两级和树形目录结构，图形目录结构"></a>4.1.3 目录结构：文件控制块和索引节点，单级、两级和树形目录结构，图形目录结构</h4><h4 id="4-1-4-文件共享"><a href="#4-1-4-文件共享" class="headerlink" title="4.1.4 文件共享"></a>4.1.4 文件共享</h4><h4 id="4-1-5-文件保护：访问类型、访问控制"><a href="#4-1-5-文件保护：访问类型、访问控制" class="headerlink" title="4.1.5 文件保护：访问类型、访问控制"></a>4.1.5 文件保护：访问类型、访问控制</h4><h3 id="4-2-文件系统实现"><a href="#4-2-文件系统实现" class="headerlink" title="4.2 文件系统实现"></a>4.2 文件系统实现</h3><h4 id="4-2-1-文件系统层次结构"><a href="#4-2-1-文件系统层次结构" class="headerlink" title="4.2.1 文件系统层次结构"></a>4.2.1 文件系统层次结构</h4><h4 id="4-2-2-目录实现"><a href="#4-2-2-目录实现" class="headerlink" title="4.2.2 目录实现"></a>4.2.2 目录实现</h4><h4 id="4-2-3-文件实现"><a href="#4-2-3-文件实现" class="headerlink" title="4.2.3 文件实现"></a>4.2.3 文件实现</h4><h3 id="4-3-磁盘组织与管理"><a href="#4-3-磁盘组织与管理" class="headerlink" title="4.3 磁盘组织与管理"></a>4.3 磁盘组织与管理</h3><h4 id="4-3-1-磁盘的结构"><a href="#4-3-1-磁盘的结构" class="headerlink" title="4.3.1 磁盘的结构"></a>4.3.1 磁盘的结构</h4><h4 id="4-3-2-磁盘调度算法"><a href="#4-3-2-磁盘调度算法" class="headerlink" title="4.3.2 磁盘调度算法"></a>4.3.2 磁盘调度算法</h4><p>先来先服务（FCFS）、最短寻道时间优先（SSTF）、电梯算法（SCAN）</p><h4 id="4-3-3-磁盘的管理"><a href="#4-3-3-磁盘的管理" class="headerlink" title="4.3.3.磁盘的管理"></a>4.3.3.磁盘的管理</h4><h2 id="五、输入输出（I-O）管理"><a href="#五、输入输出（I-O）管理" class="headerlink" title="五、输入输出（I/O）管理"></a>五、输入输出（I/O）管理</h2><h3 id="5-1-I-O管理概述"><a href="#5-1-I-O管理概述" class="headerlink" title="5.1 I/O管理概述"></a>5.1 I/O管理概述</h3><h4 id="5-1-1-I-O控制方式"><a href="#5-1-1-I-O控制方式" class="headerlink" title="5.1.1 I/O控制方式"></a>5.1.1 I/O控制方式</h4><h4 id="5-1-2-I-O软件层次结构"><a href="#5-1-2-I-O软件层次结构" class="headerlink" title="5.1.2 I/O软件层次结构"></a>5.1.2 I/O软件层次结构</h4><h3 id="5-2-I-O核心子系统"><a href="#5-2-I-O核心子系统" class="headerlink" title="5.2 I/O核心子系统"></a>5.2 I/O核心子系统</h3><h4 id="5-2-1-I-O调度概念"><a href="#5-2-1-I-O调度概念" class="headerlink" title="5.2.1 I/O调度概念"></a>5.2.1 I/O调度概念</h4><h4 id="5-2-2-出错处理"><a href="#5-2-2-出错处理" class="headerlink" title="5.2.2 出错处理"></a>5.2.2 出错处理</h4><h4 id="5-2-3-高速缓存与缓冲区"><a href="#5-2-3-高速缓存与缓冲区" class="headerlink" title="5.2.3 高速缓存与缓冲区"></a>5.2.3 高速缓存与缓冲区</h4><h4 id="5-2-4-假脱机技术（SPOOLing）"><a href="#5-2-4-假脱机技术（SPOOLing）" class="headerlink" title="5.2.4 假脱机技术（SPOOLing）"></a>5.2.4 假脱机技术（SPOOLing）</h4><h3 id="5-3-设备分配与回收"><a href="#5-3-设备分配与回收" class="headerlink" title="5.3 设备分配与回收"></a>5.3 设备分配与回收</h3><h2 id="六、参考书目"><a href="#六、参考书目" class="headerlink" title="六、参考书目"></a>六、参考书目</h2><ul><li><p>《计算机操作系统》汤子瀛等主编 西安电子科技大学出版社；</p></li><li><p>《操作系统教程》徐甲同、陆丽娜等编 西安电子科技大学出版社。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;考查目标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;掌握&lt;/strong&gt;操作系统的基本概念、基本原理和基本功能，理解操作系统的整体运行过程。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;掌握&lt;/strong&gt;操作系统进程、内存、文件和I/O管理的策略、算法、机制以及相互关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;能够运用所学的操作系统原理、方法与技术分析问题和解决问题，并能利用C语言或其他高级语言描述相关算法。 &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以西北工业大学801计算机专业基础为考纲，虽然当时考试未选这门课，但可以以此作为作为学习基础。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Study" scheme="https://mysticalguest.github.io/categories/Study/"/>
    
    
      <category term="计算机基础" scheme="https://mysticalguest.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理课程复习</title>
    <link href="https://mysticalguest.github.io/Study/57764.html"/>
    <id>https://mysticalguest.github.io/Study/57764.html</id>
    <published>2021-03-31T02:57:32.012Z</published>
    <updated>2021-04-08T13:04:02.130Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>考查目标</p><ol><li><p>深入理解单处理器计算机系统的组织结构、工作原理、互连结构，具有完整的计算机系统整机的概念；</p></li><li><p>掌握各部件的组成结构、工作原理、软硬件设计的舍取、以及硬件实现；</p></li><li><p>综合运用计算机组成的基本原理和基本方法，对有关计算机硬件系统中的理论和实际问题进行计算、分析，并能对一些基本部件进行逻辑设计。</p></li></ol><p>以西北工业大学801计算机专业基础为考纲，虽然当时考试未选这门课，但可以以此作为作为学习基础。</p></blockquote><a id="more"></a><h2 id="一、总线"><a href="#一、总线" class="headerlink" title="一、总线"></a>一、总线</h2><h3 id="1-1-总线的组成、分类、特性和性能指标"><a href="#1-1-总线的组成、分类、特性和性能指标" class="headerlink" title="1.1 总线的组成、分类、特性和性能指标"></a>1.1 总线的组成、分类、特性和性能指标</h3><h3 id="1-2-总线的层次结构"><a href="#1-2-总线的层次结构" class="headerlink" title="1.2 总线的层次结构"></a>1.2 总线的层次结构</h3><h3 id="1-3-总线定时、传送、仲裁"><a href="#1-3-总线定时、传送、仲裁" class="headerlink" title="1.3 总线定时、传送、仲裁"></a>1.3 总线定时、传送、仲裁</h3><h2 id="二、内存储器"><a href="#二、内存储器" class="headerlink" title="二、内存储器"></a>二、内存储器</h2><h3 id="2-1-存储器的基本概念、分类、层次结构"><a href="#2-1-存储器的基本概念、分类、层次结构" class="headerlink" title="2.1 存储器的基本概念、分类、层次结构"></a>2.1 存储器的基本概念、分类、层次结构</h3><h3 id="2-2-半导体主存储器"><a href="#2-2-半导体主存储器" class="headerlink" title="2.2 半导体主存储器"></a>2.2 半导体主存储器</h3><h3 id="2-3-高速缓冲存储器（Cache）"><a href="#2-3-高速缓冲存储器（Cache）" class="headerlink" title="2.3 高速缓冲存储器（Cache）"></a>2.3 高速缓冲存储器（Cache）</h3><h3 id="2-4-差错检测。"><a href="#2-4-差错检测。" class="headerlink" title="2.4 差错检测。"></a>2.4 差错检测。</h3><h2 id="三、输入-输出"><a href="#三、输入-输出" class="headerlink" title="三、输入/输出"></a>三、输入/输出</h2><h3 id="3-1-I-O编制的方法"><a href="#3-1-I-O编制的方法" class="headerlink" title="3.1 I/O编制的方法"></a>3.1 I/O编制的方法</h3><h3 id="3-2-编程I-O"><a href="#3-2-编程I-O" class="headerlink" title="3.2 编程I/O"></a>3.2 编程I/O</h3><h3 id="3-3-程序中断"><a href="#3-3-程序中断" class="headerlink" title="3.3 程序中断"></a>3.3 程序中断</h3><h3 id="3-4-DMA的原理及控制机制。"><a href="#3-4-DMA的原理及控制机制。" class="headerlink" title="3.4 DMA的原理及控制机制。"></a>3.4 DMA的原理及控制机制。</h3><h2 id="四、运算方法与运算器"><a href="#四、运算方法与运算器" class="headerlink" title="四、运算方法与运算器"></a>四、运算方法与运算器</h2><h3 id="4-1-计算机中的数制系统"><a href="#4-1-计算机中的数制系统" class="headerlink" title="4.1 计算机中的数制系统"></a>4.1 计算机中的数制系统</h3><h3 id="4-2-数的表示方法"><a href="#4-2-数的表示方法" class="headerlink" title="4.2 数的表示方法"></a>4.2 数的表示方法</h3><h3 id="4-3-定点数四则运算方法"><a href="#4-3-定点数四则运算方法" class="headerlink" title="4.3 定点数四则运算方法"></a>4.3 定点数四则运算方法</h3><h3 id="4-4-浮点数四则运算方法"><a href="#4-4-浮点数四则运算方法" class="headerlink" title="4.4 浮点数四则运算方法"></a>4.4 浮点数四则运算方法</h3><h3 id="4-5-定点加减法器设计。"><a href="#4-5-定点加减法器设计。" class="headerlink" title="4.5 定点加减法器设计。"></a>4.5 定点加减法器设计。</h3><h2 id="五、指令系统"><a href="#五、指令系统" class="headerlink" title="五、指令系统"></a>五、指令系统</h2><h3 id="5-1-指令格式"><a href="#5-1-指令格式" class="headerlink" title="5.1 指令格式"></a>5.1 指令格式</h3><h3 id="5-2-数据类型"><a href="#5-2-数据类型" class="headerlink" title="5.2 数据类型"></a>5.2 数据类型</h3><h3 id="5-3-寻址方式"><a href="#5-3-寻址方式" class="headerlink" title="5.3 寻址方式"></a>5.3 寻址方式</h3><h3 id="5-4-指令类型"><a href="#5-4-指令类型" class="headerlink" title="5.4 指令类型"></a>5.4 指令类型</h3><h3 id="5-5-指令系统设计与优化。"><a href="#5-5-指令系统设计与优化。" class="headerlink" title="5.5 指令系统设计与优化。"></a>5.5 指令系统设计与优化。</h3><h2 id="六、处理器技术"><a href="#六、处理器技术" class="headerlink" title="六、处理器技术"></a>六、处理器技术</h2><h3 id="6-1-CPU的结构"><a href="#6-1-CPU的结构" class="headerlink" title="6.1 CPU的结构"></a>6.1 CPU的结构</h3><h3 id="6-2-CPU中的寄存器组织"><a href="#6-2-CPU中的寄存器组织" class="headerlink" title="6.2 CPU中的寄存器组织"></a>6.2 CPU中的寄存器组织</h3><h3 id="6-3-控制器的结构和工作原理"><a href="#6-3-控制器的结构和工作原理" class="headerlink" title="6.3 控制器的结构和工作原理"></a>6.3 控制器的结构和工作原理</h3><h3 id="6-4-微程序设计技术。"><a href="#6-4-微程序设计技术。" class="headerlink" title="6.4 微程序设计技术。"></a>6.4 微程序设计技术。</h3><h2 id="七、参考书目"><a href="#七、参考书目" class="headerlink" title="七、参考书目"></a>七、参考书目</h2><ul><li><p>唐朔飞编著.计算机组成原理（第二版）.高等教育出版社，2008</p></li><li><p>白中英主编.计算机组成原理（第四版）.科学出版社，2009</p></li><li><p>蒋本珊编著.计算机组成原理（第二版）.清华大学出版社，2008</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;考查目标&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;深入理解单处理器计算机系统的组织结构、工作原理、互连结构，具有完整的计算机系统整机的概念；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;掌握各部件的组成结构、工作原理、软硬件设计的舍取、以及硬件实现；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;综合运用计算机组成的基本原理和基本方法，对有关计算机硬件系统中的理论和实际问题进行计算、分析，并能对一些基本部件进行逻辑设计。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以西北工业大学801计算机专业基础为考纲，虽然当时考试未选这门课，但可以以此作为作为学习基础。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Study" scheme="https://mysticalguest.github.io/categories/Study/"/>
    
    
      <category term="计算机基础" scheme="https://mysticalguest.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>尘埃落定</title>
    <link href="https://mysticalguest.github.io/Study/29260.html"/>
    <id>https://mysticalguest.github.io/Study/29260.html</id>
    <published>2021-03-30T01:45:04.270Z</published>
    <updated>2021-04-08T13:04:32.991Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>阶段总结：</p><ol><li>从20年9月底开始，到12月22号，进入西工大考场。</li><li>从12月23号下午五点放下手中的笔走出考场，到21年2月27号早上9点出成绩。</li><li>从等到3月25号西工大官网出计算机学院院线，到28号中午接到华南师大的复试通知。</li><li>从29号早上8点面试，11点结束，到29号晚上7点接到研招网的待录取通知。</li></ol><p>结束后停下来整理一下自己，总结分享经验</p></blockquote><a id="more"></a><h2 id="1-等成绩"><a href="#1-等成绩" class="headerlink" title="1.等成绩"></a>1.等成绩</h2><p>考研的点点滴滴就没有必要分享啥经验了，我其实开始复习挺晚的9月底才开始，也是因为个人原因，加之疫情影响，自己在家总是没有足够的约束力来逼迫自己复习。也是匆忙选择了一个学校。</p><h3 id="择校"><a href="#择校" class="headerlink" title="择校"></a>择校</h3><ul><li>目标院校（985，211，顶尖双非也是不错的选择，北上广深）</li><li>考学硕（数一英一）还是香啊，专业课2最好选择统考学科，特别是好调剂，研究所也是只收学术型硕士，深有体会。比如好多学校计算机调剂只接受408</li><li>有些学校保一志愿，有的不管的，比如北京的好多学校调剂要求就是只收一志愿报考这所学校才行</li><li>考完试修整一段时间就可以提前联系导师了，无论是一志愿还是调剂都是需要导师滴，导师的确好像有推荐</li><li>调剂本校也别大意，我就是大意了，联系的导师有点边沿人物，复试测试环境了，才说我被刷了</li><li>调剂总有不如人意，如果能和本科专业挂钩，已经是最好的了，起码有个学上啊</li></ul><p>知道自己一志愿过不了线挺难受的，加之本校也回不来更不好过了，调剂是真的难。</p><h2 id="2-远程网络复试"><a href="#2-远程网络复试" class="headerlink" title="2.远程网络复试"></a>2.远程网络复试</h2><p>调剂志愿的远程网络复试，其实挺简单，老师估计也知道是调剂生，不会太为难，没问专业问题，就谈了下规划，考察你对这个方向的认识，读一段有关方向的文献，并翻译。其实感觉自己回答的不是老师想听到的，但还是收到了待录取通知。</p><p>乾坤未定，你我皆是黑马！</p><p>调剂到信息光电子，是我很纠结的，偏材料，相对以后不学计算机了，还是伤感，争取和计算机相关的方向吧。</p><p>研究生的生涯还未开始，一切都是未知数，希望不会后悔！</p><h2 id="3-未雨绸缪"><a href="#3-未雨绸缪" class="headerlink" title="3.未雨绸缪"></a>3.未雨绸缪</h2><h4 id="知乎问题"><a href="#知乎问题" class="headerlink" title="知乎问题"></a>知乎问题</h4><blockquote><p>研究生期间能学到什么？对未来工作帮助大吗？下面是他们的见解：</p></blockquote><ul><li>我觉得读研期间最宝贵的看不到的收获，是思维方式的改变，是发现问题解决问题的能力，一段踏实刻苦的学术生涯，会在以后的生活工作中时刻鞭挞自己。</li><li>如果你觉得研究方向不很对胃口，那么首先考虑是否能换一个方向（通常不可能）。其次，在能够确保毕业的前提下（每天至少认真整三个小时），学你想学的，做你想做的，尽快让自己成熟起来，融入这个社会。</li><li>读个研做个工作能力提升缓冲。我本身工作能力（写代码）很强，但是在本科期间必须以学习及成绩为重点，无暇顾及竞赛，所以潜力没有发挥出来。假如我本科就去就业，我的能力根本无法变现。</li><li>研究生期间对你思维的训练，心志的磨砺，学历能力的培养都能让你在工作中快速的成长，快速的适应。</li><li>首先专业上，主要还是要养成本学科的思维方式吧，我本来也觉得本科学了四年专业没学到啥，但是读研之后观察一下跨专业进来的同学感觉思维上还是不一样，毕竟四年潜移默化还是具备一定本专业的思维能力的；然后就是生活、工作上，可以有意识地去锻炼自己处理和解决问题的能力，不要怕事～有的人遇到事就自乱阵脚，感觉这个对将来工作生活都还是挺重要的。</li><li>能学到什么知识不知道，个人能力会提升。</li><li>要问研究生能学到什么，那你学到的可能是书本没有的，比如我们学理工科的，多的是动手能力和思维方式，你开始学会质疑了，学会去探索了，学会改进方法了，再宽一点，学会了如何和老板沟通了，如何最大化节约时间了。要问有什么用，那现实一点，虽然研究生遍地走，但找工作绝对优势，进去也有学历优势。比如师兄出去，在部门因为只有一个研究生，所以主管可以为他专门买一台仪器，给他提供良好的科研环境。</li></ul><p>用武侠小说做比喻，算法是“内功”，而编程的各种框架，就犹如各种“招式”，内功不扎实，再多招式也只是花拳绣腿。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;阶段总结：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从20年9月底开始，到12月22号，进入西工大考场。&lt;/li&gt;
&lt;li&gt;从12月23号下午五点放下手中的笔走出考场，到21年2月27号早上9点出成绩。&lt;/li&gt;
&lt;li&gt;从等到3月25号西工大官网出计算机学院院线，到28号中午接到华南师大的复试通知。&lt;/li&gt;
&lt;li&gt;从29号早上8点面试，11点结束，到29号晚上7点接到研招网的待录取通知。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;结束后停下来整理一下自己，总结分享经验&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Study" scheme="https://mysticalguest.github.io/categories/Study/"/>
    
    
      <category term="考研" scheme="https://mysticalguest.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>调剂面试准备</title>
    <link href="https://mysticalguest.github.io/Study/1918.html"/>
    <id>https://mysticalguest.github.io/Study/1918.html</id>
    <published>2021-03-27T12:07:03.754Z</published>
    <updated>2021-04-08T13:03:56.894Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《(04)光电综合》考查目标：</p><ol><li>考察物理光学和数字电路的基础知识。</li><li>目的在于考察学生对物理光学基础知识和现代光电技术及仪器中所涉及的基本数字电路的了解情况和掌握程度。</li></ol><p>网络上搜索，自己准备，毕竟调剂。</p></blockquote><a id="more"></a><h2 id="光的干涉衍射和偏振"><a href="#光的干涉衍射和偏振" class="headerlink" title="光的干涉衍射和偏振"></a>光的干涉衍射和偏振</h2><h3 id="光的衍射"><a href="#光的衍射" class="headerlink" title="光的衍射"></a>光的衍射</h3><p>光离开直线路径绕到障碍物或小孔后面传播的现象。</p><p>发生明显衍射的条件：只有在障碍物或孔的尺寸比光的波长小或者跟波长差不多的条件下，才能发生明显的衍射现象。</p><p>常见的衍射现象有单缝衍射，圆孔衍射和泊松亮斑等。</p><h3 id="光的干涉"><a href="#光的干涉" class="headerlink" title="光的干涉"></a>光的干涉</h3><p>产生稳定干涉的条件：只有两列光波的频率相同，位相差恒定，振动方向一致的相干光源，才能产生光的干涉。由两个普通独立光源发出的光，不可能具有相同的频率，更不可能存在固定的相差，因此，不能产生干涉现象。</p><h4 id="双缝干涉"><a href="#双缝干涉" class="headerlink" title="双缝干涉"></a>双缝干涉</h4><p>两列或几列光波在空间相遇时相互叠加，在某些区域始终加强，在另一些区域则始终削弱，形成稳定的强弱分布的现象，证实了光具有波动性。</p><h3 id="光的偏振"><a href="#光的偏振" class="headerlink" title="光的偏振"></a>光的偏振</h3><p>太阳或灯泡所发出的光波，其方向很多，可能是水平的，竖直的，对角线的，如上图左下角红色的线，这是<strong>非偏振光</strong>。</p><p>偏振过滤器，即图中黑色方框，有一个偏振角，即图中蓝色线，只能让某一个方向的光波通过。如左边第一个蓝线只能让竖直方向的光波通过。多种方向的光波通过后只剩下一个方向，变成了<strong>偏振光</strong>。</p><p>但如果第二个偏振过滤器的偏振角并非垂直于剩下的电磁波，而是有一个角度呢？平行四边形法则，将剩下的光波分解成水平和垂直于偏振角的两个分量，垂直于偏振角的的被过滤掉了，剩下的就是水平的了。</p><h2 id="数字逻辑电路的基本知识"><a href="#数字逻辑电路的基本知识" class="headerlink" title="数字逻辑电路的基本知识"></a>数字逻辑电路的基本知识</h2><h2 id="半导体器件原理和输入输出特性"><a href="#半导体器件原理和输入输出特性" class="headerlink" title="半导体器件原理和输入输出特性"></a>半导体器件原理和输入输出特性</h2><p>另有一类物质的导电特性处于导体和绝缘体之间，称为半导体，如锗、硅、砷化镓和一些硫化物、氧化物等。</p><ul><li>物体导电性能取决于由自由电子浓度</li></ul><p>导体原子核对电子的束缚较小，自由电子浓度高，导电性能好</p><p>绝缘体中大多数电子都被原子核束缚，自由电子浓度很低，导电性能差</p><p>半导体则介于两者之间，且易受外界因数的影响</p><ul><li>价电子：半导体材料原子最外层的电子由于受原子核的束缚较小，比较容易变成自由电子。</li></ul><p>现代电子学中，用的最多的半导体是硅和锗，它们的最外层电子（价电子）都是四个。</p><p><strong>半导体的导电能力随<code>温度</code>、<code>光照</code>和<code>掺杂</code>等因素发生显著变化，这些特点使它们成为制作半导体元器件的重要材料</strong>。</p><p>本征半导体：纯净的单晶半导体。</p><p>价电子可以获得足够大的能量，挣脱共价键的束缚，游离出去，成为自由电子，并在共价键处留下带有一个单位的正电荷的空穴。这个过程称为<strong>本征激发</strong>。本征激发产生成对的自由电子和空穴，所以本征半导体中自由电子和空穴的数量相等。</p><p>价电子的反向递补运动<em>等价为</em>空穴在半导体中自由移动。因此，在本征激发的作用下，本征半导体中出现了带负电的自由电子和带正电的空穴，二者都可以参与导电，统称为载流子。</p><p>自由电子和空穴在自由移动过程中相遇时，自由电子填入空穴，释放出能量，从而消失一对载流子，这个过程称为<strong>复合</strong>。</p><p>自由电子（负电荷）：部分价电子挣脱共价键束缚离开原子而成为自由电子。自由电子可以在单晶体中自由移动。</p><p>空穴（正电荷）：失去价电子的共价键处留下一个空位，即空穴。</p><p>空穴的移动：相邻共价键中的电子在空位正电荷的吸引下会填补这个空位，即空位发生了移动。</p><p>空穴的移动实际上是束缚电子的反移动。</p><p>自由电子和空穴都可以参与导电，这是半导体不同于金属（只有自由电子）的区别之一。</p><p>本征激发：本征半导体受外界能量（热、电和光等）激发，同时产生电子、空穴对的过程。</p><p>本征半导体导电性能对温度的变化很敏感。本征载流子浓度随温度升高近似指数上升。本征半导体导电能力弱。禁带宽度越大，导电性能越差（绝缘性能越好)</p><h3 id="N型半导体和P型半导体"><a href="#N型半导体和P型半导体" class="headerlink" title="N型半导体和P型半导体"></a>N型半导体和P型半导体</h3><p>本征激发产生的自由电子和空穴的数量相对很少，这说明本征半导体的导电能力很弱。</p><p>我们可以人工少量掺杂某些元素的原子，从而显著提高半导体的导电能力，这样获得的半导体称为杂质半导体。根据掺杂元素的不同，杂质半导体分为N型半导体和P型半导体。</p><ul><li><p>N型半导体</p><p>在本征半导体中掺入五价原子，即构成N型半导体。N型半导体中每掺杂一个杂质元素的原子，就提供一个自由电子，从而大量增加了自由电子的浓度一一<em>施主电离</em>。</p><p>多数载流子一一自由电子</p><p>少数载流子一一空穴</p><p>但半导体仍保持电中性</p></li><li><p>P型半导体</p><p>在本征半导体中掺入三价原子，即构成P型半导体。P型半导体中每掺杂一个杂质元素的原子,就提供一个空穴,从而大量增加了空穴的浓度一一<em>受主电离</em>。</p><p>多数载流子一一空穴</p><p>少数载流子一一自由电子</p><p>但半导体仍保持电中性</p></li><li><p>本征半导体载流子受温度、光照影响大。杂质半导体载流子主要受掺杂浓度控制。</p></li></ul><h3 id="半导体电流"><a href="#半导体电流" class="headerlink" title="半导体电流"></a>半导体电流</h3><p>漂移电流：在电场的作用下，自由电子会逆着电场方向漂移，而空穴则顺着电场方向漂移，这样产生的电流称为漂移电流，该电流的大小主要取决于载流子的浓度，迁移率和电场强度。</p><p>扩散电流：半导体中载流子浓度不均匀分布时，载流子会从高浓度区向低浓度区扩散，从而形成扩散电流，该电流的大小正比于载流子的浓度差即浓度梯度的大小。</p><h3 id="PN结"><a href="#PN结" class="headerlink" title="PN结"></a>PN结</h3><p>通过掺杂工艺，把本征半导体的一边做成P型半导体，另一边做成N型半导体，则P型半导体和N型半导体的交接面处会形成一个有特殊物理性质的薄层，称为PN结。</p><p>空间电荷区又称为耗尽区或势垒区。在掺杂浓度不对称的PN结中，耗尽区在重掺杂一边延伸较小，而在轻掺杂一边延伸较大。</p><h2 id="MOS逻辑门电路"><a href="#MOS逻辑门电路" class="headerlink" title="MOS逻辑门电路"></a>MOS逻辑门电路</h2><p>MOS管是金属（metal）、氧化物（oxide）、半导体（semiconductor）场效应晶体管。</p><p>CMOS：金属-氧化物-半导体互补逻辑门电路（数字集成器件）。</p><p>TTL是晶体管-晶体管逻辑电路的英文缩写（Transistor-Transistor-Logic），是数字集成电路的一大门类；它采用双极型工艺制造，具有高速度低功耗和品种多等特点。</p><p>ECL（Emitter-Coupled Logic）：射极耦合逻辑门电路。</p><h2 id="CMOS逻辑门电路"><a href="#CMOS逻辑门电路" class="headerlink" title="CMOS逻辑门电路"></a>CMOS逻辑门电路</h2><p>非门：反相器？</p><h2 id="组合逻辑设计"><a href="#组合逻辑设计" class="headerlink" title="组合逻辑设计"></a>组合逻辑设计</h2><p>组合逻辑电路：对于一个逻辑电路，其输出状态在任何时刻<em>只取决于同一时刻的输入状态</em>，而与电路原来的状态无关。</p><ul><li>确定逻辑功能，列出真值表</li><li>画出卡诺图，列出表达式</li><li>设计电路</li></ul><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>在时钟脉冲边沿作用下的状态刷新称为<strong>触发</strong>。具有这种特性的存储单元电路称为<strong>触发器</strong>。</p><h3 id="触发器的逻辑功能"><a href="#触发器的逻辑功能" class="headerlink" title="触发器的逻辑功能"></a>触发器的逻辑功能</h3><ul><li><p>D触发器</p><p>特征方程：<script type="math/tex">Q^{n+1}=D</script></p><p>原理、变化也很简单，输出取决于D取值。</p></li><li><p>JK触发器</p><p>JK触发器是时钟边沿敏感的基本存储单元。</p><script type="math/tex; mode=display">Q^{n+1}=J\overline {Q^n}+\overline KQ^n</script><p>由其状态图分析得出：当上一状态为0时，输出取决于J，无论K为何值，J取0时，这次输出为0，J取1时下一状态就为1；若初始上一状态为1，输出取决于K，不论J取何值。</p></li><li><p>T触发器</p><script type="math/tex; mode=display">Q^{n+1}=T\overline {Q^n}+\overline TQ^n=T\bigoplus Q^n</script><p>计数功能的控制，当控制信号<script type="math/tex">T=1</script>时，每来一个时钟脉冲，它的状态翻转一次（即0变1,1变0）；而当<script type="math/tex">T=0</script>时，则不对时钟脉冲信号做出响应而<strong>保持状态不变</strong>。</p></li><li><p>SR触发器</p><script type="math/tex; mode=display">\begin{cases} Q^{n+1}=S+\overline RQ^n\\ SR=0(约束条件)\\ \end{cases}</script><p><script type="math/tex">S=R=1</script>时，触发器次态不确定，触发器将失去控制，</p></li><li><p>利用D触发器构成其他触发器</p></li></ul><h3 id="施密特触发器原理"><a href="#施密特触发器原理" class="headerlink" title="施密特触发器原理"></a>施密特触发器原理</h3><p>施密特触发电路（简称）是一种波形整形电路，当任何波形的信号<br>进入电路时，输出在正、负饱和之间跳动，产生方波或脉波输出。不同于比较器，施密特触发电路有两个临界电压且形成一个<strong>滞后区</strong>，可以防止在滞后范围内的噪声干扰电路的正常。如遥控接收线路，传感器输入电路都会用到它整形。</p><ul><li><p>施密特触发器</p><p>一般的比较器只有一个作比较的临界电压，若输入端有噪声来回多次穿越临界电压时，输出端即受到干扰，其正负状态产生不正常转换。</p><p>施密特触发器的输出电压经有两个电阻？分压后送回到运算放大器的非反相输入端形成正反馈。因为正反馈会产生滞后现象，所以只要噪声的大小在两个临界电压（上临界电压及下临界电压）形成的滞后电压范围内。即可避免噪声误触发电路。</p></li><li><p>特点</p><p>是能够把变化缓慢的输入信号整形成边沿陡峭的矩形脉冲。同时，施密特触发器还可利用其回差电压来提高电路的抗干扰能力。它是由两级直流放大器组成。</p></li><li><p>应用</p><p>利用施密特触发器可以将非矩形波变换成矩形波（用施密特触发器实现波形变换）</p><p>利用施密特触发器可以恢复波形（用施密特触发器对脉冲整形）</p><p>利用施密特触发器可以进行脉冲鉴幅（用施密特触发器鉴别脉冲幅度）</p></li></ul><h2 id="时序逻辑设计"><a href="#时序逻辑设计" class="headerlink" title="时序逻辑设计"></a>时序逻辑设计</h2><p>时序逻辑电路：电路在任一时刻的输出信号不仅与当时的输入信号有关，而且与电路原来的状态有关。</p><p>整个时序电路由<code>进行逻辑运算的组合电路</code>和<code>起记忆作用的存储电路</code>两部分构成。存储电路可用<code>触发器</code>或<code>锁存器</code>组成。</p><p>时序电路是状态依赖的，故又称<strong>状态机</strong>。</p><h3 id="时序电路具有以下主要特征："><a href="#时序电路具有以下主要特征：" class="headerlink" title="时序电路具有以下主要特征："></a>时序电路具有以下主要特征：</h3><ul><li>组成</li><li>时序电路的输出信号由输入信号和电路的状态共同决定。</li></ul><h3 id="异步时序电路"><a href="#异步时序电路" class="headerlink" title="异步时序电路"></a>异步时序电路</h3><p>定义：若电路中触发器的时钟输入端没有接在统一的时钟脉冲上，或电路中没有时钟脉冲，电路中各个存储单元的状态更新不是同时发生的。</p><p>根据电路是对脉冲边沿敏感还是对电平敏感，异步时序电路又分为：</p><ul><li>脉冲异步时序电路（由触发器构成）</li><li>电平异步时序电路（由锁存器构成）</li></ul><h2 id="分析同步时序逻辑电路的一般步骤"><a href="#分析同步时序逻辑电路的一般步骤" class="headerlink" title="分析同步时序逻辑电路的一般步骤"></a>分析同步时序逻辑电路的一般步骤</h2><ul><li>根据电路列出方程组</li><li>列出状态表</li><li>画出状态图</li><li>画出时序图</li><li>逻辑功能分析</li></ul><h2 id="数字器件的使用和设计"><a href="#数字器件的使用和设计" class="headerlink" title="数字器件的使用和设计"></a>数字器件的使用和设计</h2><h2 id="设计一个18进制计数器"><a href="#设计一个18进制计数器" class="headerlink" title="设计一个18进制计数器"></a>设计一个18进制计数器</h2><p>用CD4510（可同步加减计数器）、CD4511、数码管以及必要的逻辑门电路设计不同类型的18进制计数器</p><h2 id="数据选择器（多路选择器）的4选1原理图"><a href="#数据选择器（多路选择器）的4选1原理图" class="headerlink" title="数据选择器（多路选择器）的4选1原理图"></a>数据选择器（多路选择器）的4选1原理图</h2><p>数据选择器根据给定的输入地址代码，从一组输入信号中选出指定的一个送至输出端的组合逻辑电路。有时也把它叫做多路选择器或多路调制器。</p><p>在多路数据传送过程中，能够根据需要将其中任意一路选出来的电路，叫做数据选择器，也称多路选择器或多路开关。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;《(04)光电综合》考查目标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;考察物理光学和数字电路的基础知识。&lt;/li&gt;
&lt;li&gt;目的在于考察学生对物理光学基础知识和现代光电技术及仪器中所涉及的基本数字电路的了解情况和掌握程度。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;网络上搜索，自己准备，毕竟调剂。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Study" scheme="https://mysticalguest.github.io/categories/Study/"/>
    
    
      <category term="面试题集" scheme="https://mysticalguest.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>一志愿面试准备</title>
    <link href="https://mysticalguest.github.io/Study/56260.html"/>
    <id>https://mysticalguest.github.io/Study/56260.html</id>
    <published>2021-03-16T09:17:52.312Z</published>
    <updated>2021-04-08T13:03:29.054Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>考查目标：</p><ol><li>西工大复试的面试题集。</li><li>复试准备阶段，尽管分数尴尬，也要准备复试。</li><li>这里的题集以后会用得到的。</li></ol><p>许多计算机基础问题。</p></blockquote><a id="more"></a><h2 id="2019级面试问题汇总"><a href="#2019级面试问题汇总" class="headerlink" title="2019级面试问题汇总"></a>2019级面试问题汇总</h2><h3 id="一系"><a href="#一系" class="headerlink" title="一系"></a>一系</h3><blockquote><p>或与硬件相关方向和老师</p></blockquote><p>1.操作系统的目录（分别学了哪些东西？）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">(1)计算机操作系统基础知识：</span><br><span class="line">OS的概念、功能和目标</span><br><span class="line">OS的特征</span><br><span class="line">OS的发展与分类</span><br><span class="line">OS的运行机制和体系结构</span><br><span class="line">中断和异常</span><br><span class="line">系统调用</span><br><span class="line">(2)进程和调度：</span><br><span class="line">进程的定义、组成、组织形式和特征</span><br><span class="line">进程的状态和进程状态间的转换</span><br><span class="line">进程控制的基本概念和相关原语</span><br><span class="line">进程通信（共享存储，管道通信，消息传递）</span><br><span class="line">线程和多线程模型（定义，为什么，线程属性，实现方式）</span><br><span class="line">处理机调度（基本概念，三个层次，三层调度的联系、对比）</span><br><span class="line">进程调度的时机，切换与过程，方式</span><br><span class="line">调度算法及其评价指标</span><br><span class="line">进程同步，进程互斥</span><br><span class="line">进程互斥的软件实现方法（但标志法，双标志先检查，双标志后检查，Peterson算法）</span><br><span class="line">进程互斥的硬件实现方法（中断屏蔽方法，TestAndSet(TS指令&#x2F;TSL指令)，Swap指令(XCHG指令)）</span><br><span class="line">信号量机制类型（整型信号量，记录型信号量）</span><br><span class="line">信号量机制（实现进程互斥，实现进程同步，实现进程的前驱关系）</span><br><span class="line">生产者消费者问题、吸烟者问题、读者-写者问题、哲学家进餐问题</span><br><span class="line">管程（为什么引入管程，组成，基本特征，补充）</span><br><span class="line">死锁（定义，区别，必要条件，处理策略）</span><br><span class="line">预防死锁（破坏互斥条件，破坏不剥夺条件，破坏请求和保持条件，破坏循环等待条件）</span><br><span class="line">避免死锁（银行家算法）</span><br><span class="line">死锁的检测和解除</span><br><span class="line">（</span><br><span class="line">如何检测&#123;数据结构：资源分配图，死锁检测算法&#125;，</span><br><span class="line">如何解除&#123;资源剥夺法，撤销进程法，进程回退法&#125;</span><br><span class="line">）</span><br><span class="line">(3)内存（定义，基本原理）</span><br><span class="line">内存管理的概念（分配与回收，内存的扩充，地址转换，存储保护）</span><br><span class="line">覆盖与交换（覆盖技术，交换技术，覆盖与交换的区别）</span><br><span class="line">连续分配管理（单一连续分配，固定分区分配，动态分区分配）</span><br><span class="line">动态分区分配算法</span><br><span class="line">基本分页存储管理的基本概念（地址转换，页号、页内偏移量的计算，页表）</span><br><span class="line">基本地址变换机构（页表存储器的作用，地址变换过程）</span><br><span class="line">具有快表的地址变换机构（局部性原理，什么是快表(TLB)，引入快表后，地址的变换过程）</span><br><span class="line">两级页表（单级页表存在的问题，地址转换）</span><br><span class="line">基本分段存储管理（分段，段表，地址转换，分段VS分页）</span><br><span class="line">段页式管理（分段+分页，段表、页表，地址转换，访问一个逻辑地址所需访存次数）</span><br><span class="line">虚拟内存的基本概念（传统存储管理方式的特点、缺点，局部性原理，虚拟内存的定义和特征，虚拟内存技术）</span><br><span class="line">请求分页管理方式（页表机制，缺页中断机构，地址变换机构）</span><br><span class="line">页面置换算法（OPT，FIFO，LRU，CLOCK(NRU)，改进型CLOCK(改进型NRU)）</span><br><span class="line">页面分配策略（驻留集，页面分配、置换策略，何时调入页面，从何处调页，抖动(颠簸)现象，工作集）</span><br><span class="line">(4)I&#x2F;O和文件</span><br><span class="line">文件管理</span><br><span class="line">文件的逻辑结构（无结构文件，有结构文件）</span><br><span class="line">有结构文件（顺序文件，索引文件，索引顺序文件）</span><br><span class="line">文件目录（文件目录的实现(文件控制块)，目录结构，索引结点）</span><br><span class="line">文件的物理结构（文件分配方式&#123;连续分配，链接分配，索引分配&#125;）</span><br><span class="line">文件存储空间管理（存储空间的划分与初始化，空闲表法，空闲链表法，位示图法，成组链接法）</span><br><span class="line">文件的基本操作（创建，删除，打开，关闭，读写）</span><br><span class="line">文件共享（基于索引结点的共享方式(硬链接)，基于符号链的共享方式(软链接)）</span><br><span class="line">文件保护（口令保护，加密保护，访问控制）</span><br><span class="line">文件系统的层次结构</span><br><span class="line">磁盘的结构（磁盘、磁道、扇区，如何在磁盘中读&#x2F;写数据，盘面、柱面，磁盘的物理地址，磁盘的分类）</span><br><span class="line">磁盘调度算法（一次磁盘读&#x2F;写操作需要的时间，磁盘调度算法&#123;FCFS,SSTF,SCAN,C-SCAN&#125;）</span><br><span class="line">减少延迟时间的方法（交替编号，错位命名，磁盘地址结构的设计）</span><br><span class="line">磁盘的管理（磁盘初始化，引导块，坏块的管理）</span><br><span class="line">I&#x2F;O设备的基本概念和分类（按使用特性、传输速率、信息交换的单位分类）</span><br><span class="line">I&#x2F;O控制器（功能，组成，两种寄存器编址方式）</span><br><span class="line">I&#x2F;O控制方式（程序直接控制方式，中断驱动方式，DMA方式，通道控制方式）</span><br><span class="line">I&#x2F;O软件层次结构</span><br><span class="line">I&#x2F;O核心子系统</span><br><span class="line">假脱机技术（SPOOLing技术）（什么是脱机技术，解决问题，原理，共享打印机原理）</span><br><span class="line">设备的分配与回收</span><br><span class="line"> &#123;</span><br><span class="line"> 设备分配时应考虑的因素（设备的固有属性，设备分配算法，设备分配中的安全性）</span><br><span class="line"> 静态分配与动态分配</span><br><span class="line"> 设备分配管理中的数据结构</span><br><span class="line"> 设备分配的步骤</span><br><span class="line"> 设备分配步骤的改进</span><br><span class="line"> &#125;</span><br><span class="line">缓冲区管理（定义，作用，单缓冲，双缓冲，循环缓冲，缓冲池）</span><br></pre></td></tr></table></figure><p>2.什么是进程，进程调度是调度谁，进程的工作状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</span><br><span class="line">进程调度即低级调度，按照某种规则，从就绪队列中选择一个进程为其分配处理机。</span><br><span class="line">进程的状态：运行，就绪，阻塞，创建，终止</span><br></pre></td></tr></table></figure><p>2.死锁，解除死锁的方法？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</span><br><span class="line">死锁的处理策略：</span><br><span class="line">预防死锁，破坏死锁产生的四个必要条件中的一个或几个。</span><br><span class="line">避免死锁，用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）。</span><br><span class="line">死锁的检测和解除，允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</span><br></pre></td></tr></table></figure><p>3.死锁已经发生，如何解决？解决的时候需要注意什么？</p><blockquote><p><strong>资源剥夺法</strong>。挂起（暂时放在外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他进程。但是应<strong>防止</strong>被挂起的进程长时间得不到资源而饥饿。</p><p><strong>撤销进程法</strong>（<strong>终止进程法</strong>）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止就会功亏一篑，之后还得从头再来。</p><p><strong>进程回退法</strong>。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</p></blockquote><p>4.存储的方式有几种？各自优劣性？</p><div class="table-container"><table><thead><tr><th>分类</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>数组</td><td>连续存储，遍历快，随机访问，长度固定</td><td>移动或添加的时间复杂度O(n)</td></tr><tr><td>链表</td><td>离散存储，添加删除方便，空间消耗大</td><td>不能随机访问</td></tr><tr><td>Hash表</td><td>离散存储，利用哈希算法决定存储位置</td><td>遍历不方便</td></tr><tr><td>二叉树</td><td>多种遍历方式</td><td></td></tr><tr><td>图</td><td></td></tr></tbody></table></div><p>5.调度什么时候发生？及调度算法，堆栈，均值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">需要进行进程调度与切换的情况：</span><br><span class="line">1.当前运行的进程主动放弃处理机：</span><br><span class="line">（1）进程正常终止；</span><br><span class="line">（2）运行过程中发生异常而终止；</span><br><span class="line">（3）进程主动请求阻塞（如，等待I&#x2F;O）</span><br><span class="line">2.当前运行的进程被动放弃处理机：</span><br><span class="line">（1）分给进程的时间片用完；</span><br><span class="line">（2）有更紧急的事需要处理（如，I&#x2F;O中断）；</span><br><span class="line">（3）有更高优先级的进程进入就绪队列</span><br><span class="line">调度算法：</span><br><span class="line">先来先服务(FCFS)，</span><br><span class="line">最短作业优先(SJF)，</span><br><span class="line">最高响应比优先(HRRN)，</span><br><span class="line">时间片轮转调度算法(RR)，</span><br><span class="line">优先级调度算法，</span><br><span class="line">多级反馈队列调度算法。</span><br></pre></td></tr></table></figure><p>6.网络的七层结构，哪几层用硬件实现，为什么其他层不用硬件？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">自顶向下：</span><br><span class="line">应用层</span><br><span class="line">表示层</span><br><span class="line">会话层</span><br><span class="line">传输层（四层交换机、也有工作在四层的路由器）</span><br><span class="line">网络层（路由器、三层交换机）</span><br><span class="line">数据链路层（网桥、交换机）</span><br><span class="line">物理层（网卡、网线、集线器、中继器、调制解调器）</span><br></pre></td></tr></table></figure><blockquote><p>由于OSI是一个理想的模型，因此一般网络系统只涉及其中的几层，很少有系统能够具有所有的7层，并完全遵循它的规定。<br>在7层模型中，每一层都提供一个特殊的网络功能。从网络功能的角度观察：下面4层（物理层、数据链路层、网络层和传输层）主要提供数据传输和交换功能，即以节点到节点之间的通信为主；第4层作为上下两部分的桥梁，是整个网络体系结构中最关键的部分；而上3层（会话层、表示层和应用层）则以提供用户与应用程序之间的信息和数据处理功能为主。简言之，下4层主要完成通信子网的功能，上3层主要完成资源子网的功能。</p></blockquote><p>7.RARP的作用，相对应的协议是什么，地址解析的过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RARP是逆地址解析协议</span><br></pre></td></tr></table></figure><blockquote><p>其作用是完成Mac地址到IP地址的映射。主要用于无盘工作站，因为无盘工作站配置的IP地址不能保存。其过程是：在网络中配置一台RARP服务器。当RARP服务器启动后，就会将Mac地址封装成一个RARP数据包，然后广播到网络上去，当服务器接收到请求包后，就会查找对应Mac地址的IP地址，装入响应报文中发回请求者。</p><p>因为需要广播数据包，因此RARP只能适用于具有广播能力的网络。</p></blockquote><p>8.发微信用的是TCP还是UDP，为什么？</p><blockquote><p>（1）登陆过程，客户端client 采用TCP协议向服务器server发送信息，HTTP协议下载信息。登陆之后，会有一TCP连接来保持在线状态。<br>（2）和好友发消息，客户端client采用UDP协议，但是需要通过服务器转发。腾讯为了确保传输消息的可靠，采用上层协议来保证可靠传输。如果消息发送失败，客户端会提示消息发送失败，并可重新发送。<br>（3）如果是在内网里面的两个客户端传文件，QQ采用的是P2P技术，不需要服务器中转。</p></blockquote><p>9.数据结构的顺序结构有哪些？（两种存储结构：顺序，链式）（4种逻辑结构：线性、树形、图状结构、集合）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>10.专业课学了什么？嵌入式课程教了什么？能不能设计CPU？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">软件工程</span><br></pre></td></tr></table></figure><p>11.嵌入式系统和普通系统区别在哪？</p><blockquote><p>嵌入式操作系统（Embedded Operating System，简称EOS）是相对于一般操作系统而言的，它除了具备一般操作系统的最基本功能，如任务调度、同步机制、中断处理、文件功能外，还有以下特点：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（1）具有开放性、可伸缩性的体系结构；</span><br><span class="line">（2）强实时性；</span><br><span class="line">（3）操作方便、简单、提供友好的图形GUI；</span><br><span class="line">（4）统一的接口；</span><br><span class="line">（5）提供强大的网络功能；</span><br><span class="line">（6）强稳定性，弱交互性；</span><br><span class="line">（7）固化代码；</span><br><span class="line">（8）良好的移植性。</span><br></pre></td></tr></table></figure><p>12.数组和指针的区别是什么？</p><p><code>概念</code></p><blockquote><p><strong>数组</strong>：数组是用于储存多个相同类型数据的集合。</p><p><strong>指针</strong>：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在内存中的地址。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（1）赋值方式（同类型指针变量可以相互赋值，数组只能一个个元素地赋值或拷贝）</span><br><span class="line">（2）存储方式</span><br><span class="line">&#123;数组内存连续存放，下标访问，多维数组也是按照一位数组存放&#125;</span><br><span class="line">&#123;灵活，指向任意类型的数据&#125;</span><br><span class="line">（3）所占字节数(sizeof)</span><br><span class="line">&#123;数组所占空间和存储元素类型有关&#125;</span><br><span class="line">&#123;32位平台下，指针所占字节数是4,64位下为8&#125;</span><br><span class="line">（4）初始化方式</span><br></pre></td></tr></table></figure><blockquote><p>指针数组（存放指针类型的数组）和数组指针（指针指向一个数组）</p></blockquote><p>13.嵌入式系统用什么语言写，什么是嵌入式？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">汇编语言，C语言，Java</span><br></pre></td></tr></table></figure><blockquote><p>嵌入式即嵌入式系统，就是在其他电子产品或设备中，嵌入一个小型计算机，目的是为了，人机交互、采集传感器数据、处理数据、控制执行机构和通信。这个小型计算机就是嵌入式系统，它由各种单片机或微控制器加上外围电路组成。</p><p>嵌入式系统的学习中，要掌握几种微控制器MCU，如51单片机，ARM微控制器等，种类很多，要根据实际项目要求，使用不同的微控制器。</p><p>硬件设计：利用多种设计工具、利用微控制器和外围芯片，设计产品原理图，设计印刷电路板，PCB，制版，焊接，调试。电子系学生擅长。</p><p>软件设计：C/C++开发，懂点汇编语言，可以开发与操作系统的裸机的程序？</p><p>所以，搞嵌入式系统，既要懂硬件，也要懂软件，还要懂通信。即电子、通信、计算机的融合。人工智能？边缘计算？</p></blockquote><p>14.编码，信道，码分多址与频分多址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>15.数电（数字电路）主要学了哪些东西，组合逻辑电路和时序逻辑电路区别（电路图的区别和性能特性的区别）</p><div class="table-container"><table><thead><tr><th>比较</th><th>组合逻辑电路</th><th>时序逻辑电路（状态机）（同步）</th></tr></thead><tbody><tr><td>输入输出关系</td><td>任意时刻的输出仅仅取决于该时刻的输入，与电路原来的转态无关</td><td>不仅仅取决于当前的输入信号，而且还取决于电路原来的状态，即与之前的输入有关</td></tr><tr><td>有无存储（记忆）单元</td><td>无（不能包含）</td><td>包含</td></tr><tr><td>结构特点</td><td>只包含门电路</td><td><strong>组合逻辑电路+存储电路</strong><br />输出状态必须反馈到组合电路的输入端，与输入信号共同决定组合逻辑的输出</td></tr><tr><td>分析方法</td><td>从电路的输入到输出逐级写出逻辑函数式，最后得到表示输出与输入关系的逻辑函数式。然后用公式化简法或者卡诺图化简法得到函数式的化简或变换，以使逻辑关系简单明了。<br />有时还可以将逻辑函数式转换为真值表的形式。</td><td>（1）写出每个触发器的驱动方程<br />（2）将驱动方程带入触发器的特性方程的到状态方程组<br />（3）根据逻辑图写出电路的输出方程<br />状态转换过程描述：<br />状态转换表、状态转换图、状态机流程图、时序图</td></tr><tr><td>设计方法</td><td>（1）逻辑抽象<br />（2）写出逻辑函数式<br />（3）选定器件类型<br />（4）将逻辑函数式化简或者变换成适当的形式<br />（5）画出逻辑电路的连接图<br />（6）工艺设计</td><td>（1）逻辑抽象得到状态转换图或者状态转换表<br />（2）状态化简<br />（3）状态分配(状态编码)<br />（4）选触发器求出状态方程、驱动方程和输出方程<br />（5）根据方程式画出逻辑图<br />（6）检查设计的电路能否自启动</td></tr><tr><td>常用组合逻辑电路</td><td>编码器、译码器、数据选择器、加法器、数值比较器</td><td>锁存器、触发器、寄存器、移位寄存器、存储器</td></tr></tbody></table></div><p>16.动态存储和静态存储的区别（<code>变量的存储方式可分为：静态存储和动态存储</code>）</p><div class="table-container"><table><thead><tr><th>区别</th><th>静态存储</th><th>动态存储</th></tr></thead><tbody><tr><td>概念</td><td>在程序运行期间分配固定的存储空间的方式</td><td>在程序执行过程中，使用它时才分配，使用完毕立即释放</td></tr><tr><td>例子</td><td>全局变量</td><td>形式参数</td></tr><tr><td>特点</td><td>在变量定义时就分定存储单元并一直保持不变，直至整个程序结束</td><td>如果一个函数被多次调用时，则反复地分配、释放变量的存储单元</td></tr><tr><td>生存期</td><td>一直存在的</td><td>时而存在时而消失</td></tr><tr><td>总结</td><td>（1）编译时完成，不占用CPU<br />（2）栈（stack）上分配<br />（3）不需要<br />（4）按计划分配，由编译器负责</td><td>（1）运行时分配，分配和释放都占用CPU<br />（2）堆上分配<br />（3）分配时需要指针和引用类型支持<br />（4）按需分配，由程序员负责</td></tr></tbody></table></div><p>17.大信号和小信号的区别</p><p>18.模电分析方法应该先分析交流还是直流，为什么，怎么进行分析？</p><p>19.递归的含义，递归能不能替代循环，递归需要做什么？堆栈需要用的什么？</p><p><code>含义</code></p><blockquote><p>递归就是本身调用自己或者间接调用自己的函数，是一种栈的使用，递归调用是入栈，之后的结果输出是出栈！</p></blockquote><p><code>所有递归能否替代循环</code></p><blockquote><p>可以。有些递归只需要一个循环就可以替代，而有些递归的改写需要循环+栈，即要利用一定的辅助空间记录过程中的某些数据才可以。</p></blockquote><p><code>所有循环能否改写成递归</code></p><blockquote><p>可以但没必要。循环和递归的共同特点是，它们都是会不断重复执行相同代码，每次重复执行时所使用的数据不一样。</p></blockquote><p><code>区别</code></p><blockquote><p>循环的时间复杂度和空间复杂度都要优于递归，但递归的优越性在于条理清晰，可读性强，比较适宜于问题本身是递归性质的、用循环难于解决的问题。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">递归的三大要素：</span><br><span class="line">（1）明确函数功能；</span><br><span class="line">（2）寻找递归结束条件；</span><br><span class="line">（3）找出函数的等价关系式。</span><br></pre></td></tr></table></figure><p><code>运行时堆栈</code></p><blockquote><p>递归发生的函数调用从底向上进入堆栈，最先进入的是栈底的主程序。当最上层的递归函数满足终止条件，这时一些列终止条件开始执行堆栈顶部的活动记录被弹出，程序控制被交给返回位置处。</p></blockquote><p>20.中断嵌套是什么？</p><blockquote><p>当CPU响应某一中断时，若有优先权高的中断源发出中断请求，则CPU能中断正在进行的中断服务程序，并保留这个程序的断点（类似于子程序嵌套），响应高级中断，高级中断处理结束以后，再继续进行被中断的中断服务程序，这个过程称为中断嵌套。</p></blockquote><p>21.printf函数在汇编中怎么实现？printf函数的参数格式，长度等等、在汇编中怎么表示？</p><p>22.机器人的定义是啥？人工智能是啥？机器学习？数据挖掘？</p><blockquote><p>机器人包括一切模拟人类行为或思想与模拟其他生物的机械。机器人是一种能够半自主或全自主工作的智能机器。机器人具有感知、决策、执行等基本特征。<br>人工智能是计算机科学的一个分支，它是研究开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。<br>机器学习是一门多领域交叉学科，专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。它是人工智能核心，是使计算机具有智能的根本途径。<br>数据挖掘是指从大量的数据中通过算法搜索隐藏于其中信息的过程。</p></blockquote><p>23.单片机为啥叫单片机？</p><p>24.人工智能的避障算法是啥</p><p>25.单片机的引导过程</p><p>26.DMA控制器是主设备还是从设备，什么时候做主设备，8259的中断过程</p><p>27.计网做实验在哪个仿真软件，傅里叶变换作用，非归零码与归零码区别、曼彻斯特是归零码还是非归零码。</p><blockquote><p>winpcap(windows packet capture)是，公共的网络访问系统。为win32应用程序提供访问网络底层的能力。很多不同的工具软件使用Winpcap于网络分析，故障排除，网络安全监控等方面。<br>Ethereal可以用来从网络上抓包，并能对包进行分析。</p></blockquote><p>28.公猫母猫问题</p><p>29.一个饼分两份怎么分才公平，枪打树上的十只鸟有哪些情况，一块钱的面包买五个<br>和买五个一块钱的面包选哪种等</p><blockquote><p>其中有一个人把饼分成两份的权利，另一个人有优先的挑选权利。这样就能做到公平了。</p><p>1：一只都没有，一只被打死掉了下来，其他的飞走了；<br>2：有一只，被打死的那只挂在了树上，其他的飞走了；<br>3：有九只，被打死的那只掉了下了，其他的吓死了，挂在了树上；<br>4：有十只，被打死的那只挂在了树上，其他的吓死了，也挂在了树上。<br>还有很多很多，比如被打死的那只挂在了树上，其他的吓死了，5只掉了下来……</p></blockquote><p>30.一个方形桌子砍一刀后有几个角？</p><h3 id="二系"><a href="#二系" class="headerlink" title="二系"></a>二系</h3><blockquote><p>或软件、数据库与大数据相关的方向和老师</p></blockquote><p>1.操作系统的定义</p><blockquote><p>操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。</p></blockquote><p>2.进程和线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程是一个基本的CPU执行单元，也是程序执行流的最小单位。</span><br></pre></td></tr></table></figure><p>3.一个文件在磁盘上，如何访问到</p><p>4.内存管理有哪些方法？</p><p>5.虛拟存储的作用？为什么虛拟存储可以实现？</p><p>6.多级存储系统的作用？</p><p>7.寄存器和存储器的区别？</p><p>8.请求分页页面置换算法列举</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">页面置换算法：</span><br><span class="line">最佳置换算法（OPT）</span><br><span class="line">先进先出置换算法（FIFO）</span><br><span class="line">最近最久未使用置换算法（LRU）</span><br><span class="line">时钟置换算法（CLOCK）</span><br><span class="line">改进型的时钟置换算法</span><br></pre></td></tr></table></figure><p><code>最佳置换算法（OPT）</code></p><blockquote><p>每次选择淘汰的页面将是<strong>以后永不使用</strong>，或者<strong>在最长时间内不再被访问的页面</strong>，这样可以保证最低的缺页率。</p></blockquote><p><code>先进先出置换算法（FIFO）</code></p><blockquote><p>每次选择淘汰的页面是<strong>最早进入内存的页面</strong>。</p></blockquote><p><code>最近最久未使用置换算法（LRU）</code></p><blockquote><p>每次淘汰的页面是<strong>最近最久未使用的页面</strong>。</p></blockquote><p>9.叙述clock（时钟）置换算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">时钟置换算法是一种性能和开销较均衡的算法，又叫“最近位使用算法（NRU）”</span><br></pre></td></tr></table></figure><blockquote><p>简单的CLOCK算法实现方法：为每个页面设置一个<strong>访问位</strong>，再将<strong>内存中的页面</strong>都通过链接指针链接成一个<strong>循环队列</strong>。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将其置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多经过两轮扫描）</p><p>访问位为1，表示最近访问过；</p><p>访问位为0，表示最近没访问过。</p></blockquote><p><code>改进型的时钟置换算法</code></p><blockquote><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。<strong>只有被淘汰的页面被修改过时，才需要写回外存</strong>。</p><p>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作。这就是改进型的时钟置换算法的思想。</p><p>修改位=0，表示页面没有被修改过；</p><p>修改位=1，表示页面被修改过。</p><p>用<strong>（访问位，修改位）</strong>的形式表示各页面状态。改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描。</p></blockquote><p>10.C语言中你习惯定义全局变量还是局部变量</p><blockquote><p>看情况吧，有需要使用全局变量的时候，我会选择去定义全局变量；如果局部变量可以解决的问题，我就会去定义局部变量。应为全局变量的生命周期长，会占用更多的内存，且由于其全局性，所有代码都可以修改它，对这个变量的最终就很困难。</p></blockquote><p>11.编译的过程是什么？</p><p>12.给一个链表，如何确定这个链表有环？</p><blockquote><p>采用“快慢指针”的方法。就是有两个指针fast和slow，开始的时候两个指针都指向链表头head，然后在每一步操作中slow向前走一步,即：slow = slow-&gt;next，而fast每一步向前两步即：fast = fast-&gt;next-&gt;next。由于fast要比slow移动的快，如果有环，fast一定会先进入环，而slow后进入环。当两个指针都进入环之后，经过一定步的操作之后二者一定能够在环上相遇，并且此时slow还没有绕环一圈，也就是说一定是在slow走完第一圈之前相遇。</p></blockquote><p><code>如果存在环，找出环的入口点</code></p><blockquote><p>从链表起点head开始到入口点的距离a,与从slow和fast的相遇点（如图）到入口点的距离相等？<br>因此我们就可以分别用一个指针（ptr1, prt2），同时从head与slow和fast的相遇点出发，每一次操作走一步，直到ptr1 == ptr2，此时的位置也就是入口点！</p></blockquote><p><code>如果存在环，求出环上节点的个数</code></p><p><code>如果存在环，求出链表的长度</code></p><p><code>如果存在环，求出环上距离任意一个节点最远的点（对面节点）</code></p><p><code>（扩展）如何判断两个无环链表是否相交</code></p><p><code>（扩展）如果相交，求出第一个相交的节点</code></p><p>13.线性表的定义</p><p>14.设计算法统计一个二进制数中1的个数？</p><p>15.斐波那契递归和迭代区别是啥？</p><p>16.描述斐波拉契序列算法和和汉诺塔算法</p><p>17.数据库范式的定义以及区别？</p><p>18.数据库第一二三四范式是啥？</p><p>19.数据挖掘有什么应用</p><p>20.数据库有几和锁？数据库的事务？常用的数据库？数据库的主码外码？</p><p>21.用离散数学解释下主成分分析是啥？</p><p>22.学过哪些前沿课程？课程内容是什么？人工智能是什么？（这种问题别给自己挖坑这种属于典型的开放式问题开头然后步步深入，甚至可以问的很深入。注意挑选自己擅长的科目，一知半解的课程不如不说）</p><p>23.项目是什么，自己做了什么</p><p>24.有10框苹果，有9框每个半斤重。有一筐每个四两,如何通过只称重一次，找出那个不一样的</p><p>25.有10筐苹果，9筐半斤、1筐4两，只用一杆秤，只能称一次找出4两的那筐苹果（问了多次）</p><h3 id="三系"><a href="#三系" class="headerlink" title="三系"></a>三系</h3><blockquote><p>或机器学习、深度学习和图像处理相关的方向和老师，多涉及到一些数学相关知识</p></blockquote><p>1.你能描述一下数据结构具体有哪几种吗？解释机器学习</p><p>2.面向对象中的封装、多态和继承</p><p>3.数据结构中的链表的逆置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法1：头插法建立新的链表，从头顺序遍历，遍历的每个结点都用头插法插入到新的链表中；</span><br><span class="line">时间和空间复杂度都为O(n)，好处是不用修改原来的链表，坏处就是多了空间复杂度。</span><br><span class="line">方法2：原地逆置法是每每修改两个相邻结点p,q的前后关系，增加一个指针保存下一次的修改目标结点；</span><br><span class="line">空间复杂度为O(1)，时间同样为O(n)，但是这种方法修改了原来的链表。</span><br><span class="line">方法3：使用递归，reverse(head),出口设置为head&#x3D;&#x3D;null 和head.next&#x3D;&#x3D;null。</span><br><span class="line">方法4：库函数</span><br></pre></td></tr></table></figure><p>4.一个链表里面有循环，怎么确定循环的头尾相交结点？</p><p>5.优先级反转是什么？怎么解决这个问题？</p><p>6.为什么要有泰勒展开式？对计算机学科的意义是什么？</p><p>7.泰勒展开式的n取到多少？怎么确定？</p><p>8.线性代数中坐标变换的意义是什么？能解决什么问题？</p><p>9.空间解析几何中的维空间与空间解析几何讲的是什么？</p><p>10.怎么求sin01?</p><p>11.极大似然函数的作用</p><p>12.描述下贝叶斯定理</p><p>13.特卡洛求不规则图形面积。答：比如一张纸上有不规则图形。可以用散列法（知特卡洛），如在上面撤芝妹，然后通过比例求面积（注：答案非标准答案，是考生当时的回答）</p><p>14.复变函数中的若积公式。答：应该是有两个函数，然后求关于第一个函数，表征意思是求这两个高数平滑后的面积，即翻续平移后量誉的部分。</p><p>15.傅卫叶变化。答：把一个函数分解成sin和cos，可以大大减少运算次数。</p><p>15.特征值是什么？</p><p>17.双聚关启发式搜宗k均值聚关</p><p>18.蚁群算法。答∶用正反馈机制寻求最优解，这个最优解是全局最优解。可以和运筹学结合起来用，比如运筹学里的指派问题、旅行商问题。</p><p>19.你学过这个方向的相关专业课有哪些？</p><p>20.人脸对比的时候，对比的是哪些信息？</p><p>21.图像处理的项目里你觉得有那些槟块？</p><p>22.计算机视觉的看法，评价报考老师的论文。</p><p>23.讲下你的毕设</p><blockquote><p>我的毕业论文题目是《FTP代理机制研究》。</p><p>（1）科研方法：<strong>文献研究法</strong>。通过专业的文摘、索引、工具书、光盘以及网络资源等文献的检索来发挥文献价值与创造性的利用文献的方法。</p><p>（2）研究对象：计算机网络领域的一个重要协议，FTP文件传输协议。</p><p>（3）科研目的：代理服务器是缓解网络安全问题的有效方法之一。</p><p>（4）研究内容：通过实现FTP协议的控制连接和数据连接来实现代理服务器的功能。</p></blockquote><p>24.一个桶装有8斤油，另有一个3斤与一个5斤桶，怎么分成两桶4斤油？（基本没有思考的时间）</p><div class="table-container"><table><thead><tr><th></th><th>8斤的桶</th><th>3斤的桶</th><th>5斤的桶</th></tr></thead><tbody><tr><td>初始</td><td>8</td><td>0</td><td>0</td></tr><tr><td>第一次</td><td>3</td><td>0</td><td>5</td></tr><tr><td>第二次</td><td>3</td><td>3</td><td>2</td></tr><tr><td>第三次</td><td>6</td><td>0</td><td>2</td></tr><tr><td>第四次</td><td>6</td><td>2</td><td>0</td></tr><tr><td>第五次</td><td>1</td><td>2</td><td>5</td></tr><tr><td>第六次</td><td>1</td><td>3</td><td>4</td></tr><tr><td>第七次</td><td>4</td><td>0</td><td>4</td></tr></tbody></table></div><p>25.一个箱子，放了一个白球，一个黑球，每次取一个便放回去，问至少有一次是红球的率是多少？</p><h3 id="四系"><a href="#四系" class="headerlink" title="四系"></a>四系</h3><blockquote><p>或网络安全、密码学相关方向和老师</p></blockquote><p>1.路由器和交换机的功能然后他们的区别</p><p>2.TCP拥塞的解决方式，分别解释一下</p><p>3.TCP为什么三次握手</p><h3 id="专业课公共知识"><a href="#专业课公共知识" class="headerlink" title="专业课公共知识"></a>专业课公共知识</h3><blockquote><p>以下考生回忆的问题没有明显的方向性，属于基础知识的，放在下面这个目录</p></blockquote><p>1.为什么要有系统调用？</p><blockquote><p>“系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。<br>有何作用：<br>    应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</p></blockquote><p>2.调度是什么？内存怎么管理</p><blockquote><p>CPU作为一种系统资源，是唯一的，而在多任务的OS中，每个任务都需要使用CPU，因此需要为任务对CPU的使用提供一种同步机制，这就是调度（Scheduling）。<br>在并发程序设计中，各进程对公共变量的访问必须加以制约，这种制约称为同步。</p></blockquote><p>3.进程和线程的区别</p><p>4.什么是死锁</p><p>5.描述一下你学过的排序算法</p><div class="table-container"><table><thead><tr><th>分类</th><th>算法</th><th></th></tr></thead><tbody><tr><td>交换排序</td><td>冒泡排序</td><td></td></tr><tr><td></td><td>希尔排序</td><td></td></tr><tr><td></td><td>快速排序</td><td></td></tr><tr><td>选择排序</td><td>简单选择排序</td><td></td></tr><tr><td></td><td>插入排序</td><td></td></tr><tr><td></td><td>堆排序</td><td></td></tr><tr><td>归并排序</td><td></td><td></td></tr><tr><td>基数排序</td><td></td></tr></tbody></table></div><p>6.操作系统中用来表示内存已被占用的数据结构是什么？</p><p>7.操作系统提供给程序员创建进程的接口有哪些？</p><p>8.说一下内存管建方式有哪些？</p><p>9.全局变量和局部变量分别存储在哪里？（变量的存储类型及性质）</p><blockquote><p>局部变量存在于（栈）中，只有当所在函数被调用时才动态地为变量分配存储单元。<br>全局变量和静态变量存在于（静态区/全局存储区）中，占用静态的存储单元。<br>动态申请数据存在于（堆）中（new的对象存在于堆区，malloc的对象存在于自由存储区）。<br>常量存在于常量区。</p><p>C语言经过编译之后将内存分为以下几个区域：<br>    （1）栈（stack）：由编译器进行管理，自动分配和释放，存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址。操作方式类似数据结构中的栈。<br>    （2）堆（heap）：用于程序动态申请分配和释放空间。C语言中的malloc和free，C++中的new和delete均是在堆中进行的。正常情况下，程序员申请的空间在使用结束后应该释放，若程序员没有释放空间，则程序结束时系统自动回收。注意：这里的“堆”并不是数据结构中的“堆”。<br>    （3）全局（静态）存储区：分为DATA段和BSS段。DATA段（全局初始化区）存放初始化的全局变量和静态变量；BSS段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。<br>    （4）文字常量区：存放常量字符串。程序结束后由系统释放。<br>    （5）程序代码区：存放程序的二进制代码。</p></blockquote><p>10.外部中断CPU该如何处理</p><p>11.快排和冒泡的原理自己他们的空间复杂度是多少？</p><p>12.佛洛依德算法？迪杰斯特拉算法？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">都是求最短路径的算法。</span><br></pre></td></tr></table></figure><p>13.DHCP协议的作用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>14.一个访问网络的过程</p><p>15.用自己的话讲TCP连接到底是什么</p><p>16.设计web服务器</p><p>17.几种方法写阶乘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1)循环；（2）库函数；（3）递归</span><br></pre></td></tr></table></figure><p>18.定义一个结构体，里面一个int类型成员，一个char，int占四位，char占一位，那么在Linux占几位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">核心：</span><br><span class="line">(1)每个元素的首地址偏移量必须能整除该元素的长度？</span><br><span class="line">(2)整个结构体的长度必须能整除最长元素的字节数。</span><br><span class="line">涉及到内存字节对齐的问题。</span><br><span class="line">Windows和Linux的区别只有double不同，以后会整理</span><br><span class="line">这题答案应该是8位</span><br></pre></td></tr></table></figure><h3 id="C-方面"><a href="#C-方面" class="headerlink" title="C++方面"></a>C++方面</h3><blockquote><p>（或编程语言，这类问题一般建立在简历中提到了相关技能，或老师提问你会什么语言）</p></blockquote><p>1.最擅长哪种语言?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java</span><br></pre></td></tr></table></figure><p>2.请简述C，C++语言有何区别和联系？</p><p><code>区别：</code></p><blockquote><p>C语言是面向过程语言，而C++是面向对象语言<br>1.面向过程和面向对象的区别<br>（1）面向过程：面向过程编程就是分析出解决问题的步骤，然后把这些步骤一步一步的实现，使用的时候一个一个的依次调用就可以了。<br>（2）面向对象：面向对象编程就是把问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。<br>面向过程就是自顶向下的编程（步骤划分），面向对象就是高度实物抽象化（功能划分）<br>2.具体语言的区别<br>（1）关键字不同<br>（2）文件后缀名不同<br>（3）返回值<br>    C语言中，如果一个函数没有指定返回值类型，默认返回int类型；C++中，如果一个函数没有返回值则必须指定为void。<br>（4）参数列表<br>    在C语言中，函数没有指定参数列表时，默认可以接收任意多个参数；但在C++中，因为严格的参数类型检测，没有参数列表的函数，默认为 void，不接收任何参数。<br>（5）默认参数（C语言不支持默认参数，C++支持默认参数）<br>（6）函数重载（C语言没有函数重载，C++支持函数重载）</p></blockquote><p><code>联系：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++ 由C语言发展而来，几乎完全兼容C语言；也就是说C语言代码几乎可以不加修改地用于 C++。</span><br></pre></td></tr></table></figure><p><code>相关扩展：C语言中struct和union的区别是什么？</code></p><blockquote><p>struct (结构体）与union (联合体）是C语言中两种不同的数据结构，两者都是常见的复合结构，其区别主要表现在以下两个方面：<br>(1) 结构体与联合体虽然都是由多个不同的数据类型成员组成的，但不同之处在于联合体中所有成员共用一块地址空间，即联合体只存放了一个被选中的成员，而结构体中所有成员占用空间是累加的，其所有成员都存在，不同成员会存放在不同的地址。所以结构体在计算一个结构型变量的总长度时，其内存空间大小等于所有成员长度之和（需要考虑字节对齐），而在联合体中， 所有成员不能同时占用内存空间，它们不能同时存在，所以一个联合型变量的长度等于其最长的成员的长度。<br>(2) 对于联合体的不同成员赋值，将会对它的其他成员重写，原来成员的值就不存在了， 而对结构体的不同成员赋值是互不影响的。</p></blockquote><p><code>相关扩展：C和C++中struct的区别是什么？</code></p><blockquote><p>C语言中的struct与C++中的struct的区别表现在以下3个方面：<br>    (1) C语言的struct不能有函数成员，而C++的struct可以有。<br>    (2) C语言的struct中数据成员没有private、public和protected访问权限的设定，而C++的struct的成员有访问权限设定。<br>    (3) C语言的struct是没有继承关系的，而C++的struct却有丰富的继承关系。<br>C语言中的struct是用户自定义数据类型，它是没有权限设置的，它只能是一些变量的集合体，虽然可以封装数据却不可以隐藏数据，而且成员不可以是函数。为了和C语言兼容，C++中就引入了struct关键字。C++语言中的struct是抽象数据类型 (ADT)，它支持成员函数的定义，同时它增加了访问权限，它的成员函数默认访问权限为public。</p></blockquote><p><code>相关扩展：C++中的 struct与class的区别是什么？</code></p><blockquote><p>具体而言，在C++中，class和struct做类型定义时只有两点区别：<br>    (1) 默认继承权限不同。class继承默认是private继承，而struct继承默认是public继承；<br>    (2) class还用于定义模板参数，就像typename，但关键字struct不用于定义模板参数。</p></blockquote><p><code>相关扩展：简单描述一下你认为的C语言的优点和缺点？</code></p><blockquote><p>优点：<br>    （1）编写的程序可读性强，编译效率高。<br>    （2）具有简洁紧凑、使用灵活的语法机制。<br>    （3）数据结构丰富，满足多种数据开发要求。<br>    （4）允许直接访问物理地址，对硬件进行操作。<br>    （5）具有出色的可移植性，能在多种不同体系结构的软/硬件平台上运行。<br>缺点：<br>    （1） C语言的缺点主要表现在数据的封装性上，这一点使得C在数据的安全性上有很大缺陷，这也是C和C++的一大区别。<br>    （2） C语言的语法限制不太严格，对变量的类型约束不严格，影响程序的安全性，对数组下标越界不作检查等。从应用的角度，C语言比其他高级语言较难掌握。也就是说，对用C语言的人，要求对程序设计更熟练一些。<br>    （3） C语言的简洁性与其丰富的运算符相结合，使其可能会编写出极难理解的代码。<br>    （4） C语言表达方面的自由会增加风险。尤其是C语言对指针的使用。</p></blockquote><p><code>相关扩展：C++是不是类型安全的？</code></p><blockquote><p>不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的。<br>类型安全代码指访问被授权可以访问的内存位置。类型安全的代码不会试图访问自己没被授权的内存区域。</p></blockquote><p><code>相关扩展：谈谈你是怎么认识 C++ 中的模板的？</code></p><blockquote><p>模板使程序员能够快速建立具有类型安全的类库集合和函数集合，它的实现，方便了大规模的软件开发。（结合stl更好）<br>STL是“Standard Template Library”的缩写，中文译为“标准模板库”。STL是C++标准库的一部分，不用单独安装。<br>C++对模板（Template）支持得很好，STL就是借助模板把常用的数据结构及其算法都实现了一遍，并且做到了数据结构和算法的分离。例如，vector的底层为顺序表（数组），list的底层为双向链表，deque的底层为循环队列，set的底层为红黑树，hash_set的底层为哈希表。</p></blockquote><p><code>相关扩展：C++中所有的运算符都能重载吗？</code></p><blockquote><p>在C++运算符集合中，有一些运算符是不允许被重载的。这种限制是出于安全方面的考虑，可防止错误和混乱。<br>    （1）不能改变C++内部数据类型（如int,float等）的运算符。<br>    （2）不能重载‘.’，因为‘.’在类中对任何成员都有意义，已经成为标准用法。<br>    （3）不能重载目前C++运算符集合中没有的符号，如#,@,$等。原因有两点，一是难以理解，二是难以确定优先级。<br>    （4）对已经存在的运算符进行重载时，不能改变优先级规则，否则将引起混乱。</p></blockquote><p>3.简述面向对象有哪些好处？</p><p>4.简述类和对象</p><div class="table-container"><table><thead><tr><th>类</th><th>对象</th></tr></thead><tbody><tr><td>类是现实世界在计算机中的反映，它将数据和对这些数据的操作封装在一起</td><td>类的实例</td></tr><tr><td>并没有开辟空间<br />类的大小：类的成员函数放在公共代码区，所有该类的对象共享这些成员函数，每个对象的大小为类内成员变量的大小之和，遵循内存对齐原则</td><td>占有实际的空间（用来存储成员变量）<br />对象的大小为类中<strong>所有成员变量的大小之和</strong>，当然这里也遵循内存对齐原则</td></tr><tr><td>三大特性：封装、继承、多态<br />访问限定符</td></tr></tbody></table></div><p><code>为什么要内存对齐（前面也遇到过这种问题）</code></p><blockquote><p>为了提高程序的性能，方便CPU访问内存，处理器并不是一个字节一个字节来访问内存，一般是4个字节或8个字节</p></blockquote><p><code>空类占多少个字节？为什么？</code></p><blockquote><p>空类占1个字节，占位用，告诉系统我这里定义了一个类，虽然它是空的</p></blockquote><p>5.什么是重载？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">重载的定义：</span><br><span class="line">（1）同一个类；</span><br><span class="line">（2）多个方法的方法名字相同；</span><br><span class="line">（3）参数列表不同、参数个数不同、参数的数据类型不同，不同数据类型的参数顺序不同</span><br><span class="line">和修饰符无关、和有无返回值无关、和返回值类型无关、和参数名无关</span><br></pre></td></tr></table></figure><p><code>什么是多态？</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">多态就是同一个接口，使用不同的实例而执行不同操作。</span><br><span class="line">函数的多种不同的实现方式即为多态。</span><br></pre></td></tr></table></figure><p>6.C++里什么是friend？</p><blockquote><p>C++中的友元机制允许类的非公有成员被一个类或者函数访问</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">友元按类型分为三种：</span><br><span class="line">(1)普通非类成员函数作为友元；</span><br><span class="line">(2)类的成员函数作为友元；</span><br><span class="line">(3)类作为友元。</span><br><span class="line">友元函数的实现可以在类外定义，但必须在类内部声明。</span><br><span class="line">友元函数是可以直接访问类的私有成员的非成员函数。</span><br><span class="line">它是定义在类外的普通函数，它不属于任何类。</span><br><span class="line">但需要在类的定义中加以声明，声明时只需在友元的名称前加上关键字friend。</span><br><span class="line">注意：</span><br><span class="line">(1)友元不具有相互性，只具有单项性；</span><br><span class="line">(2)友元不能被继承；</span><br><span class="line">(3)友元不具有传递性。</span><br></pre></td></tr></table></figure><p>7.C++的继承方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">继承是类的重要特性。</span><br><span class="line">三种继承方式：公有、私有、保护继承。</span><br><span class="line">多态（虚函数，虚函数表？）</span><br><span class="line">和Java的继承并无二致。</span><br></pre></td></tr></table></figure><p>8.python的学习</p><p>9.python特殊的数据类型</p><div class="table-container"><table><thead><tr><th>6种特殊数据类型</th><th>概念</th></tr></thead><tbody><tr><td>list：列表</td><td>是一种有序的数据集合，在列表数据结构中的类型并不唯一</td></tr><tr><td>tuple：元组</td><td>是一种有序的列表，但是其一旦创立完毕就不能够更改，即不能插入，删除里面的元素，访问的方式跟List结构一致。</td></tr><tr><td>dict：字典</td><td>类似JSON，键值对</td></tr><tr><td>set：集合</td><td>无序但是所有元素唯一，不重复</td></tr><tr><td>Unicode编码</td><td>支持显示中文</td></tr><tr><td>raw</td><td>一个“raw”字符串，里面的字符就不需要转义</td></tr></tbody></table></div><p>10.Java和C++的异同</p><p>11.Java与C++的类、继承有什么相同和不同？</p><h3 id="跨考、在职考研的考生"><a href="#跨考、在职考研的考生" class="headerlink" title="跨考、在职考研的考生"></a>跨考、在职考研的考生</h3><p>为什么跨专业考研。为什么辞联考研。为什么当时毕业不考研。在工作的时候有没有和本专业相关的知识运用。研究生规划。在公司的职业情况。机器人的定义。人工智能的定义。这两都跟老师的研究方向相关,会问本科专业的一些问题。PLC与FPGA的中文名称。数据结构中线性表有哪些?</p><h3 id="考查英语口语方面"><a href="#考查英语口语方面" class="headerlink" title="考查英语口语方面"></a>考查英语口语方面</h3><blockquote><p>一般也是英语提问，考查考生的听、说能力</p></blockquote><p>1.自我介绍+家乡介绍？</p><p>2.介绍自己的家？</p><p>3.本科学校，专业是啥，专业多少人，排名多少？</p><p>4.为什么选择这个研究方向？</p><p>5.为什么来nwpu？怎么知道nwpu？nwpu全拼是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Northwestern Polytechnical University</span><br></pre></td></tr></table></figure><p>6.什么时候来的西工大，感觉西工大怎么样，以后想在哪个公司？</p><p>7.西工大绘你印象最深的地方。</p><p>8.学过什么程序语言</p><p>9.做过什么项目？</p><p>10.问了队列和链表相比的缺点。</p><p>11.你最喜欢的专业课是什么？</p><p>12.和门外等着的人，你觉得你的优势是什么？</p><h2 id="2019年夏令营面试问题汇总"><a href="#2019年夏令营面试问题汇总" class="headerlink" title="2019年夏令营面试问题汇总"></a>2019年夏令营面试问题汇总</h2><h3 id="一系-1"><a href="#一系-1" class="headerlink" title="一系"></a>一系</h3><blockquote><p>考察内容涉及数电、模电、嵌入式、SOC相关知识，以及软工、操作系统、C语言、计算机组成原理的相关知识。</p></blockquote><p>同学A：先是英语白我介绍；然后主要就是项目。没问专业问题。</p><p>同学B：银行家算法。数学知识。</p><p>三系：偏向于数据与图像处理，考察数学知识较多，而且有英语提问。</p><p>同学C：问到数学知识，专业课问题较多。</p><h3 id="四系-1"><a href="#四系-1" class="headerlink" title="四系"></a>四系</h3><blockquote><p>主要考察计算机网络、操作系统、网络安全相关知识。会询问是否做过网络的一些实验</p></blockquote><p>同学D：英文自我介绍。说说自己做过的项目，我是网络的，问了计网的，四层结构，mac英文意思，用过什么操作系统，Linux中创建文件的指令，同组有问操作系统的，概率论，高数的。</p><h2 id="2018年夏令营面试问题汇总"><a href="#2018年夏令营面试问题汇总" class="headerlink" title="2018年夏令营面试问题汇总"></a>2018年夏令营面试问题汇总</h2><h3 id="二系-1"><a href="#二系-1" class="headerlink" title="二系"></a>二系</h3><blockquote><p>主要负责老师未到场，面试的是今年刚任职的老师，参考意义不大，剧开始有自我介绍和英文提问。研究方向为数据库方面，主要是算法</p></blockquote><p>英文介绍，用英文描述你喜欢的运动</p><p>做的具体项目，会步步深入</p><p>最欢的专业课，对本专业理解，给你三分钟的时间说服老师留下你、和舍友关系如何。</p><h3 id="三系-1"><a href="#三系-1" class="headerlink" title="三系"></a>三系</h3><blockquote><p>偏向于数据与图像处理，考察数学知识较多，而且有英语提问</p></blockquote><p>线性代数知阵的特征值和特征向量计算方式及意义。</p><p>高数：梯度。</p><p>说几种排序算法的复杂度。</p><p>编程相关经历。</p><p>是否了解意愿导师的方向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">智能计算系统系：副高职称王党辉</span><br><span class="line">主要研究方向：</span><br><span class="line">高性能处理器体系结构、人工智能加速器架构、</span><br><span class="line">高可靠计算机系统、多核&#x2F;众核系统的资源调度、</span><br><span class="line">新型存储系统、嵌入式系统设计、数字系统设计与测试等</span><br></pre></td></tr></table></figure><p>是否有接触CV、NLP或机器学习等方向的工作</p><h2 id="2017年夏令营面试问题汇总"><a href="#2017年夏令营面试问题汇总" class="headerlink" title="2017年夏令营面试问题汇总"></a>2017年夏令营面试问题汇总</h2><h3 id="1系"><a href="#1系" class="headerlink" title="1系"></a>1系</h3><blockquote><p>考察涉及数电、椟电、嵌入式、SOC知识、软件工程、澡作系统、C言、计算机组成原理</p></blockquote><p>三八编译器的设计原理</p><p>放大器的设计原理</p><p>lts系统有哪些算法</p><p>嵌入式系统的计数器如何使用</p><p>8255如何用</p><p>操作系统进程</p><p>CPU工作模式</p><h3 id="2系"><a href="#2系" class="headerlink" title="2系"></a>2系</h3><blockquote><p>刚开始有白我介绍和英语提问，研究方向为数据库方向，主要是算法</p></blockquote><p>进程死锁（概念、避免、预防）</p><p>数据库基本知识（外键、查询语句）</p><p>算法（如从两串中查找相同元素的所有方法）</p><p>模式匹配</p><p>C语言些一简单的输入输出格式</p><h3 id="3系"><a href="#3系" class="headerlink" title="3系"></a>3系</h3><blockquote><p>考察数学知识较多、会用英运提问</p></blockquote><p>高数、线代、概率等的相关知识（如高斯模型、矩阵的转换、矩阵的逆等）</p><p>编程最好的语言</p><p>C语言的主要内容</p><p>概率论相关和独立的区别</p><p>发表论文的意义</p><h3 id="4系"><a href="#4系" class="headerlink" title="4系"></a>4系</h3><blockquote><p>主要着察计算机网络、操作系统、网络安余等知识，是否做过一些网络的实验，本科学过什么特色课程</p></blockquote><p>WLAN定义</p><p>WiFi、3G和蓝牙使用的是什么协议</p><p>为什么WiFi比3G便宜</p><p>HTTP是什么，Https是什么，区别</p><p>死锁的原因，接触；进程线程</p><p>IPV4和IPV6的地址位数</p><p>网络安全；攻击方式</p><p>会做网线吗？怎么做；网线由几根线组成？那几根不能用</p><p>cookie的原理</p><h2 id="2017级面试问题汇总"><a href="#2017级面试问题汇总" class="headerlink" title="2017级面试问题汇总"></a>2017级面试问题汇总</h2><h3 id="3系："><a href="#3系：" class="headerlink" title="3系："></a>3系：</h3><blockquote><p>图像与语音处理，主要以数学问题为主，所以建议报考三系的同学考完研不要松懈复习专业课（数学课）基本知识，二系今年与其他组的不同之处在于没有英话介绍，背了半天竟没用上，反之是问了一个特别长的问题，好像是介绍家乡</p></blockquote><p>高斯滤波、傅里叶变换、采样定理</p><p>正态分布要素</p><p>一条曲线怎么证明在一个平面上</p><p>a投影至b上，求投影长度</p><p>举一个连续分布的例子。还有什么分布</p><p>安卓和IOS区别</p><p>int在winxp和wn10区别</p><p>发送邮件用到了什么协议</p><h3 id="②4系-网络"><a href="#②4系-网络" class="headerlink" title="②4系:网络:"></a>②4系:网络:</h3><p>HTTPS和HTTP区别</p><p>死锁的必要条件等</p><h2 id="2016级面试问题汇总"><a href="#2016级面试问题汇总" class="headerlink" title="2016级面试问题汇总"></a>2016级面试问题汇总</h2><p>1.英语自我介绍</p><blockquote><p>Good morning! Teachers and professors. I am very glad to be here for this interview. </p><p>First, let me introduce myself. My name is XiaoMengjie. I have finished my undergraduate education in Northwest University, majoring in Software Engineering.</p><p>I am open-minded, willing and have broad interests like basketball and web development. For example, during the past four years, I have accomplished several website. (What impresses me most is the Hotel Management System that I developed for my father.) Furthermore, I am intrested in Java programming language and have written some websites with Springboot.</p><p>This year, I finished my graduate project with FTP.</p><p>Although I have broad interests in many aspects and grasp the essential konwledge of the major, but I think at present, I want to do many things, but not be competent to do things professionally owing to lack of ample knowledge and ability. So I think further study is still urgent for me to realize selfvalue.</p></blockquote><p><code>我认为可以短一点</code></p><blockquote><p>Good morning/afternoon! Teachers. I am very glad to be here for this interview. </p><p>First, let me introduce myself. My name is XiaoMengjie. I come from Northwest University, majoring in Software Engineering.</p><p>I am open-minded and I like web development and am interested in Artificial intelligence field.</p><p>So I think further study is still urgent for me to realize selfvalue.</p></blockquote><p>2.英语描述操作系统</p><p>3.这个IP地址192.168.45.3是什么地址？</p><p>4.百度IP和电脑IP有什么不同</p><p>5.浏览一个网页都用到了哪些协议?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>6.离散数学中什么是蕴含</p><p>7.什么时候用到递归</p><p>8.做过什么项目</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;考查目标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;西工大复试的面试题集。&lt;/li&gt;
&lt;li&gt;复试准备阶段，尽管分数尴尬，也要准备复试。&lt;/li&gt;
&lt;li&gt;这里的题集以后会用得到的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;许多计算机基础问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Study" scheme="https://mysticalguest.github.io/categories/Study/"/>
    
    
      <category term="面试题集" scheme="https://mysticalguest.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>复试准备</title>
    <link href="https://mysticalguest.github.io/Study/53646.html"/>
    <id>https://mysticalguest.github.io/Study/53646.html</id>
    <published>2021-02-28T03:11:48.265Z</published>
    <updated>2021-04-08T13:04:13.039Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>考查目标：</p><ol><li>西工大初试结束后。</li><li>分数出来后，联系导师等事宜准备。</li></ol><p>网络上搜索，自己准备。</p></blockquote><a id="more"></a><h1 id="1-邮件模板"><a href="#1-邮件模板" class="headerlink" title="1.邮件模板"></a>1.邮件模板</h1><p>研究生博士生考试给导师发邮件模板</p><h2 id="开头-基本情况-写信目的"><a href="#开头-基本情况-写信目的" class="headerlink" title="开头+基本情况+写信目的"></a>开头+基本情况+写信目的</h2><p>尊敬的某老师：</p><p>您好！</p><p>不好意思打扰您了！我是来自某某大学某某专业的2017级本科的应届考生某某（来自某某省某某市的往届考生某某，本科毕业于某某大学），今年硕士统考报考某某大学某某专业学术/专业硕士，总分XXX分，政治XX分，英语XX分，数学XXX分，专业课XXX分。参考往年的复试分数线，我有机会进入复试。在网上查阅到您的相关资料和研究，一直以来对某某某某方向很感兴趣，所以很希望能够有机会师从于您，在您的课题组攻读硕士学位，所以冒昧写信给您，一方面希望了解您的招生情况，另一方面希望得到您关于复试准备的相关建议。</p><h2 id="本科成绩-综合能力专业能力"><a href="#本科成绩-综合能力专业能力" class="headerlink" title="本科成绩+综合能力专业能力"></a>本科成绩+综合能力专业能力</h2><p>本科期间，我学习认真刻苦，绩点XX，专业排名XX/XXX，位于专业前XX%，曾X次获得校X等奖学金；曾担任某某组织的某某干部，工作认真负责；同时，我也具有扎实良好的专业能力，曾在某某比赛(考试)中，获得某级别X等奖(取得XX分的成绩)。</p><h2 id="读研目的-展望"><a href="#读研目的-展望" class="headerlink" title="读研目的+展望"></a>读研目的+展望</h2><p>在过去的学习和实践中，我渐渐对<strong>某某某某方向</strong>产生了非常浓厚的兴趣，希望能更为深入的了解和学习<strong>某某某某方向</strong>的知识。在网上了解到您的相关资料，真心对您的研究方向非常感兴趣，能在众多学校众多优秀的老师中找到您对我来说真的是非常幸运。如果有机会能够师从于您，我定当加倍努力有所作为，不负老师的栽培。</p><h2 id="提问-祝福-结尾"><a href="#提问-祝福-结尾" class="headerlink" title="提问+祝福+结尾"></a>提问+祝福+结尾</h2><p>希望老师能为我在对<strong>某某某某方向</strong>学习道路上给予一些建议与指期待能够与您进一步探讨！感谢您在百忙之中阅读我的邮件，冒昧致信，恳请海涵，切盼回音。</p><p>祝老师身体健康，工作顺利！</p><p>​                                                                                          学生：某某</p><p>​                                                                                          时间：XXXX年XX月XX日</p><h1 id="2-英语介绍"><a href="#2-英语介绍" class="headerlink" title="2.英语介绍"></a>2.英语介绍</h1><blockquote><p>Good morning/afternoon! Teachers. I am very glad to be here for this interview. </p><p>First, let me introduce myself. My name is XiaoMengjie. I come from Northwest University, majoring in Software Engineering.</p><p>I am open-minded and I like web development and am interested in Artificial intelligence field.</p><p>So I think further study is still urgent for me to realize selfvalue.</p></blockquote><h1 id="3-专业介绍"><a href="#3-专业介绍" class="headerlink" title="3.专业介绍"></a>3.专业介绍</h1><h2 id="3-1-软件工程"><a href="#3-1-软件工程" class="headerlink" title="3.1 软件工程"></a>3.1 软件工程</h2><blockquote><p><strong><em>Software engineering is an engineering discipline that is concerned with all aspects of software production. Software development is a difficult activity that requires careful planning and execution. Through the learning of software development process and process management technology, I can effectively plan and manage software development activities.</em></strong></p></blockquote><p>软件工程是一门涉及软件生产各个方面的工程学科。软件的开发是一个很困难的活动，要求很仔细的计划和执行。通过对软件开发过程和过程管理技术的学习，能够有效地策划和管理软件开发活动。</p><h2 id="3-2-计算机组成原理"><a href="#3-2-计算机组成原理" class="headerlink" title="3.2 计算机组成原理"></a>3.2 计算机组成原理</h2><blockquote><p><strong><em>The principle of computer organization introduces the basic organization principle and internal working mechanism of the computer.</em></strong></p></blockquote><p>计算机组成原理介绍了计算机的基本组成原理和内部工作机制。</p><h2 id="3-3-操作系统"><a href="#3-3-操作系统" class="headerlink" title="3.3 操作系统"></a>3.3 操作系统</h2><blockquote><p><strong><em>The operating system course describes the internal structure, working principle and the realization of typical technologies of the operating system.</em></strong></p></blockquote><p>操作系统课程讲述了操作系统的内部结构、工作原理及典型技术的实现。</p><h2 id="3-4-计算机网络"><a href="#3-4-计算机网络" class="headerlink" title="3.4 计算机网络"></a>3.4 计算机网络</h2><blockquote><p><strong><em>The computer network course comprehensively and systematically introduces the development and principle of computer network architecture, physical layer, data link layer and other content.</em></strong></p></blockquote><p>计算机网络课程全面系统地介绍了计算机网络的发展和原理体系结构、物理层、数据链路层等内容。</p><h1 id="4-未来规划"><a href="#4-未来规划" class="headerlink" title="4.未来规划"></a>4.未来规划</h1><p>学习、实践、日常生活</p><p>学业进步，学术方面发表论文，实践方面，工作经验，正式工作基础，社团活动</p><p>在硕士期间，我除了完成学院要求的课程学分之外，我还将在老师指导下从两个方面来规划自己，分别为学术研究和工程实践，在学术研究方面，我会从阅读很多文献开始，和师兄师姐一起学习，编写论文争取发表，我的目标是在毕业之前发表一篇合格的论文，积极参与实验室的项目，锻炼自己的实践能力。</p><blockquote><p>During my master’s degree, in addition to completing the credits required by the college, I will also plan myself from two aspects, namely academic research and engineering practice. In academic research, I will read a lot of literature, study with my senior, write papers and strive for publication. My goal is to publish a qualified paper before graduation, and in practice I will actively participate in project in the laboratory, exercise my practical ability.</p></blockquote><p>老师的指导：Teacher’s guidance</p><h1 id="5-家乡"><a href="#5-家乡" class="headerlink" title="5.家乡"></a>5.家乡</h1><p>我的家乡是湖北襄阳，它是一个历史悠久的城市。孕育了许多有名之辈，比如郭靖黄蓉，诗人孟浩然等。来到襄阳，尝尝牛肉面，欣赏气势磅礴的汉江，感受这座城市深厚的历史底蕴。</p><blockquote><p>My hometown is Xiangyang, Hubei, which is a city with a long history. It gave birth to many famous people, such as Zhu Geliang, Guo Jing, Huang Rong and poet Meng Haoran. Come to Xiangyang, taste beef noodles, appreciate the majestic Hanjiang River, and feel the profound historical details of the city.</p></blockquote><h1 id="6-华南师范大学"><a href="#6-华南师范大学" class="headerlink" title="6.华南师范大学"></a>6.华南师范大学</h1><p>South China Normal University（SCNU）</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;考查目标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;西工大初试结束后。&lt;/li&gt;
&lt;li&gt;分数出来后，联系导师等事宜准备。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;网络上搜索，自己准备。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Study" scheme="https://mysticalguest.github.io/categories/Study/"/>
    
    
      <category term="复试" scheme="https://mysticalguest.github.io/tags/%E5%A4%8D%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>英语积累</title>
    <link href="https://mysticalguest.github.io/Study/45733.html"/>
    <id>https://mysticalguest.github.io/Study/45733.html</id>
    <published>2021-01-08T14:20:55.009Z</published>
    <updated>2021-04-08T13:03:06.305Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>考查目标：</p><ol><li>考研时期真题词汇和作文积累。</li><li>并且以后的英语积累也会记到这里。</li></ol><p>以我考的英语二为基础</p></blockquote><a id="more"></a><h2 id="积累"><a href="#积累" class="headerlink" title="积累"></a>积累</h2><h3 id="1-词汇量"><a href="#1-词汇量" class="headerlink" title="1.词汇量"></a>1.词汇量</h3><div class="table-container"><table><thead><tr><th>真题词汇集锦</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>2020年</td><td></td><td></td><td></td></tr><tr><td>（完形）tedious</td><td>单调乏味的</td><td>instructive</td><td>增长知识的，富有教益的</td></tr><tr><td>harsh</td><td>严厉的，残酷的</td><td>vague</td><td>含糊的，粗略的</td></tr><tr><td>fatigue</td><td>疲乏，疲劳</td><td>confront</td><td>面对遭遇</td></tr><tr><td>trying</td><td>令人厌烦的</td><td></td><td></td></tr><tr><td>（Text1）asocial</td><td>不合群的</td><td>trait</td><td>特点</td></tr><tr><td>perceive</td><td>认为，感觉</td><td>reciprocal</td><td>互惠的，相应的</td></tr><tr><td>readiness</td><td>乐意</td><td></td><td></td></tr><tr><td>（Text2）rigorous</td><td>谨慎的，严格的</td><td>justified</td><td>有充分理由的，合理地</td></tr><tr><td>（Text3）yet</td><td>用于否定</td><td>Its fate is yet to be decided.</td><td>它的命运尚未确定。</td></tr><tr><td>deem</td><td>认为，视为</td><td>vulunerable</td><td>易受攻击的</td></tr><tr><td>2019年</td><td></td><td></td><td></td></tr><tr><td>（完形）obsess</td><td>使痴迷</td><td>solely</td><td>仅仅，只</td></tr><tr><td>depict</td><td>v.描写</td><td>depiction</td><td>n.描写</td></tr><tr><td>aside from</td><td>除…以外</td><td>rigid</td><td>严格死板的，（人）不通融的</td></tr><tr><td>conceal</td><td>隐藏</td><td>hold onto</td><td>抓紧，保存</td></tr><tr><td>account for</td><td>解释，了解，查明</td><td>confirm</td><td>证实，确认</td></tr><tr><td>triumph</td><td>战胜，获胜</td><td>fluctuation</td><td>波动，起伏</td></tr><tr><td>zeal</td><td>热情</td><td></td><td></td></tr><tr><td>（Text1）appease</td><td>安抚</td><td>guilt still gets a bad rap</td><td>内疚感可不是件好事</td></tr><tr><td>deceptive</td><td>欺骗性的</td><td>addictive</td><td>使人上瘾的</td></tr><tr><td>inexcusable</td><td>不可原谅的</td><td>rein</td><td>控制</td></tr><tr><td>nasty</td><td>极差的</td><td>nastier impulses</td><td>恶意冲动</td></tr><tr><td>vice versa</td><td>反之亦然</td><td>rate</td><td>v.评估 n.速率</td></tr><tr><td>（Text2）count on</td><td>依赖，指望</td><td>soak up</td><td>吸收</td></tr><tr><td>consume</td><td>消耗，烧毁</td><td>be accustomed to sth</td><td>习惯于</td></tr><tr><td>（Text3）obstruct</td><td>阻碍</td><td>no numerical cap</td><td>没有数量限制</td></tr><tr><td>implausible</td><td>不合理的</td><td>plausible</td><td>可信的</td></tr><tr><td>cumbersome</td><td>缓慢冗长的</td><td>slow granting procedures</td><td>签发过程缓慢</td></tr><tr><td>curb</td><td>抑制</td><td>aggressive</td><td>激进的</td></tr><tr><td>2018年</td><td></td><td></td><td></td></tr><tr><td>utterly</td><td>完全的，绝对的</td><td>insidious</td><td>潜伏的</td></tr><tr><td>inferiority</td><td>劣势，低等</td><td>evaporate</td><td>蒸发，消失</td></tr><tr><td>asset</td><td>资产</td><td>physical assets</td><td>有形资产</td></tr><tr><td>astonishing</td><td>令人惊讶</td><td>intricate</td><td>错综复杂</td></tr><tr><td>2017年</td><td></td><td></td><td></td></tr><tr><td>bidder</td><td>投标者</td><td>dual</td><td>双重的</td></tr><tr><td>wordy</td><td>话多的，冗长的</td><td>tricky</td><td>狡猾的，棘手的</td></tr><tr><td>compensation</td><td>补偿</td><td>scarce</td><td>不足的，稀少的</td></tr></tbody></table></div><h3 id="2-句子"><a href="#2-句子" class="headerlink" title="2.句子"></a>2.句子</h3><div class="table-container"><table><thead><tr><th>小作文集锦</th></tr></thead><tbody><tr><td>Forbidden City is <strong>a great magnet for</strong> foreign tourists.</td></tr><tr><td>The hope of living a better life is his impetus to study.</td></tr><tr><td>I’ve come to the conclusion that …</td></tr><tr><td>take the initiative to do 积极主动做某事</td></tr><tr><td>of even greater concern is the fact that … 更加需要关注的是</td></tr><tr><td>It is far better to do 远不如做某事，最好做某事？</td></tr><tr><td>In short 简言之</td></tr><tr><td>As sb notes, …  正如某人所指出</td></tr><tr><td>exert onself to do sth 努力做某事</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>图表作文</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>address</td><td>处理，应对</td><td>supply</td><td>供应</td></tr><tr><td>pose</td><td>引起，产生</td><td>decelerate</td><td>减速</td></tr><tr><td></td><td></td><td></td></tr></tbody></table></div><blockquote><p>图表作文:<br>This argument has attracted a lot of attention. 这一观点已受到广泛关注。<br>This phenomenon can be attributed to the following reasons. 之所以出现这种现象，原因可能有以下几点。<br>However, this encouraging sign also presents challenges, like how to address the supply <strong>deficientcy</strong> posed by decelerated growth of <strong>museum</strong>s and people’s increasingly diverse need for exhibitions. 如何应对博物馆增长放缓带来的供不应求问题以及人们日益多样化的观展需求问题等。</p></blockquote><h2 id="小作文范文"><a href="#小作文范文" class="headerlink" title="小作文范文"></a>小作文范文</h2><h3 id="1-范文一"><a href="#1-范文一" class="headerlink" title="1.范文一"></a>1.范文一</h3><blockquote><p>Dear Li Ming,<br>    I’d like to congratulate you for winning the fierce competition for admission to a prestigious university. This success means that you have acquired extraoridinary learning capacity and if this capacity can be further developed in university, you will be competent to build your career.<br>    However, I must also warn you that the approaching university life is different to you previous school life. You should make adjustment for it. That is, you should mentally and practically prepare to be indepent and learn not for examination but for your life purpose. I wish you could learn to manage life and study by yourself in the following four years.<br>                                                                                                                                                    Sincerely yours,<br>                                                                                                                                                    Zhang Wei</p></blockquote><p>范文赏析：</p><div class="table-container"><table><thead><tr><th>短语部分</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>fierce competition</td><td>激烈竞争</td><td>admission</td><td>入场费</td></tr><tr><td>prestigious university</td><td>名校</td><td>prestigious</td><td>声誉高的，有威望的</td></tr><tr><td>extraordinary learning capacity</td><td>卓越的学习能力</td><td>previous school life</td><td></td></tr><tr><td>be competent to build your career</td><td>有能力创造一番事业</td><td>mentally</td><td>心理方面</td></tr><tr><td>make adjustment for it</td><td>做出调整</td><td>practically</td><td>实际层面</td></tr></tbody></table></div><blockquote><p>长句部分：<br>learn not for examination but for your life purpose 不是为考试学习，而是为自己的人生目标学习。</p></blockquote><h3 id="2-范文二（2020小作文）"><a href="#2-范文二（2020小作文）" class="headerlink" title="2.范文二（2020小作文）"></a>2.范文二（2020小作文）</h3><blockquote><p>Dear Friends,<br>    I’m so delighted that you trust me to arrange your trip. I’m writing to inform you of the historical attraction to visit the Terracotta. Army, one of the greastest archaeological discoveries of all time and share some travel trips.<br>    Located to the east of downtown Xi’an, the Terracotta Army is a massive collection of life-size clay warriors and horses buried in the tomb of China’s First Emperor. It offers a fascinating glimpse into the country’s glorious past. To get a better view of these breathtaking sculpture, you may consider avoiding public holidays in China or setting out early if you have to visit the mesume on those days. In addition, it’s also advisable to rent a multilingual audio guide at the ticket office, which will certainly make your trip informative.<br>    Hope this trip suits your taste and that you all enjoy it.<br>                                                                                                                                                    Yours sincerely,<br>                                                                                                                                                    Li Ming</p></blockquote><p>范文赏析：</p><div class="table-container"><table><thead><tr><th>短语部分</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>be so delighted that …</td><td></td><td>arrange your trip</td><td></td></tr><tr><td>Terracotta</td><td>兵马俑</td><td>the greatest archaeological discoveries</td><td>最伟大的考古发现</td></tr><tr><td></td><td></td><td></td></tr></tbody></table></div><h2 id="大作文范文"><a href="#大作文范文" class="headerlink" title="大作文范文"></a>大作文范文</h2><h3 id="1-范文一-1"><a href="#1-范文一-1" class="headerlink" title="1.范文一"></a>1.范文一</h3><blockquote><p>​    China’s auto market was still dominated by Japanese, Chinese and American brands. American cars remained the third most popular int the market with a slight increase in market share. A noticeable change occurred concerning Japanese and Chinese brands. With its market share slipping by almost 10%, Japanese brands were displaced from their leading position by Chinese brands which expanded their share by around 10%.<br>​    The performance of American brand cars is to be expexted, given their worldwide fame and reliable quality. The big change in the performance of Japanese and Chinese brands seems sudden but is not unexpected. Chinese auto producers had narrowed the technology gap between themselves and foreign competitors, and cleverly switched their promotion strategies to satisfy Chinese customers’ appetite for a bargin. While Chinese brands were growing, Japanese brands were hit by a reputation crisis caused by frequent quality compliants.<br>​    The plight of Japanese brands is a reminder that quality is the soul of products. Hopefully, Chinese automakers will consistently guarantee high quality, thereby protecting their own reputation so as to maintain market popularity.</p></blockquote><p>范文赏析：</p><div class="table-container"><table><thead><tr><th>短语部分</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>auto</td><td>汽车</td><td>was still dominated by Japanese</td><td>被控制，被占据</td></tr><tr><td>remained the third most popular</td><td></td><td>a slight increase</td><td></td></tr><tr><td>share</td><td>股份，份额</td><td>noticeable</td><td>显著的</td></tr><tr><td>slipping</td><td>下降</td><td>but is not unexpected</td><td>也在预料之中</td></tr><tr><td>expanded</td><td>扩大，增加</td><td>narrowed the technology gap</td><td>缩小了技术差距</td></tr><tr><td>plight</td><td>困境，苦难</td><td>thereby</td><td>从而</td></tr></tbody></table></div><blockquote><p>长句部分：</p><p>were displaced from their leading position 主导地位被取代</p><p>The performance of American brand cars is to be expexted, given their worldwide fame and reliable quality. 鉴于美国品牌汽车的世界声誉和可信赖的质量，其表现预料之中。</p><p>and cleverly switched their promotion strategies to satisfy Chinese customers’ appetite for a bargin. 并聪明地改变了其推广策略一满足中国消费者对便宜商品的喜好。</p><p>Japanese brands were hit by a reputation crisis caused by frequent quality compliants. 日本品牌因频繁的质量投诉遭到信誉危机的打击。</p><p>The plight of Japanese brands is a reminder that quality is the soul of products. 日本品牌的困境提醒一个事实，质量是产品的灵魂。</p><p>Chinese automakers will consistently guarantee high quality, 希望中国汽车制造商能一贯保证好的质量</p></blockquote><h3 id="2-范文二"><a href="#2-范文二" class="headerlink" title="2.范文二"></a>2.范文二</h3><blockquote><p>​     Employees aged above 50 years were most likely to report satisfaction, with 40% of them indicating they were content. Employees aged 40 years or younger were less willing to declare satisfaction. Employees aged between 41 and 50 were surely the unhappiest; none of them felt satisfied and the proportion of respondents reporting dissatisfaction was as high as 64%.<br>​    The significant different in job satisfaction relates to employees’ career situation. Employees aged between 41 and 50, less energetic than younger crowd and less competent than older professionals, reach a career plateau, showing deep job dissatisfaction. In contrast, younger colleages, in spite of occasional confusion, are mostly in an upward spiral, and understandably feel happier. As for older colleagues, many of them have achieved career maturity and their careers are going to be crowned with a relaxing retirement life. Not surprisingly, they are the happiest.<br>​    Career trouble may afflict people at all ages. For lasting happiness with our jobs, positive attitude is necessary.</p></blockquote><p>范文赏析：</p><div class="table-container"><table><thead><tr><th>短语部分</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>aged above 50 years</td><td>定语</td><td>they were content</td><td></td></tr><tr><td>proportion</td><td>比例</td><td>as high as</td><td>as…as 句型</td></tr><tr><td>significant difference</td><td></td><td>In contrast</td><td>比较而言</td></tr><tr><td>inspite of occasional confusion</td><td>不管（除了）偶尔感到困惑</td><td>in an upward spiral</td><td></td></tr><tr><td>understandably</td><td>正常地</td><td>career maturity</td><td>职业成熟</td></tr><tr><td>be crowned with</td><td>获得，被冠以</td><td>Not surprisinly</td><td></td></tr><tr><td>afflict</td><td>困扰，困惑</td><td></td></tr></tbody></table></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">长句部分：</span><br><span class="line"></span><br><span class="line">were less willing to declare satisfaction 更不愿意宣称对工作满意</span><br><span class="line"></span><br><span class="line">were surely the unhappiest</span><br><span class="line"></span><br><span class="line">less competent than older professionals</span><br><span class="line"></span><br><span class="line">reach a career plateau 进入职场高原（停滞不前的局面）</span><br></pre></td></tr></table></figure><h2 id="专业英语"><a href="#专业英语" class="headerlink" title="专业英语"></a>专业英语</h2><h3 id="1-词汇量-1"><a href="#1-词汇量-1" class="headerlink" title="1.词汇量"></a>1.词汇量</h3><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>20ns(20 nanoseconds)</td><td>20纳秒</td><td>sensor</td><td>传感器</td></tr><tr><td>subcarrier</td><td>副载波，子信道</td><td>hybrid</td><td>混合的；混合物</td></tr><tr><td>intensity</td><td>强度</td><td>adopt</td><td>收养，采用(某方法)，采取(某态度)</td></tr><tr><td>modulation [ˌmɒdjʊˈleɪʃən]</td><td>调制</td><td>exponentiate</td><td>指数</td></tr><tr><td>Weibull</td><td><a href="https://baike.baidu.com/item/%E9%9F%A6%E5%B8%83%E5%B0%94%E5%88%86%E5%B8%83">韦布尔分布</a></td><td>turbulence</td><td>湍流</td></tr><tr><td>channel</td><td>通道，信道</td><td>postdoctoral</td><td>博士后</td></tr><tr><td>robust</td><td>强健的</td><td>dynamics</td><td>动力学</td></tr></tbody></table></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">长句部分：</span><br><span class="line">data-driven predictive reduced-order-modeling 数据驱动的预测降序建模</span><br><span class="line"></span><br><span class="line">computational turbulence 计算湍流</span><br><span class="line"></span><br><span class="line">Robust and Interpretable Learning for Operator-Theoretic Modeling of Non-linear Dynamics</span><br><span class="line">非线性动力学算子理论建模的鲁棒性和可解释性学习</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;考查目标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;考研时期真题词汇和作文积累。&lt;/li&gt;
&lt;li&gt;并且以后的英语积累也会记到这里。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以我考的英语二为基础&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Study" scheme="https://mysticalguest.github.io/categories/Study/"/>
    
    
      <category term="English" scheme="https://mysticalguest.github.io/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>数据结构课程复习</title>
    <link href="https://mysticalguest.github.io/Study/40891.html"/>
    <id>https://mysticalguest.github.io/Study/40891.html</id>
    <published>2021-01-08T12:59:36.834Z</published>
    <updated>2021-04-08T13:02:47.101Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>考查目标：</p><ol><li>理解数椐结构的基本概念、掌握数椐的逻辑结构、存储结构及其差异，以及各种基本操作的实现。</li><li>掌握基本的数据处理原理和方法，在此基础上能够对算法进行设计与分析。</li><li>能够选择合适的数椐结构和方法进行问题求解。</li></ol><p>以西北工业大学801计算机专业基础为考纲</p></blockquote><a id="more"></a><h2 id="零、绪论"><a href="#零、绪论" class="headerlink" title="零、绪论"></a>零、绪论</h2><h3 id="0-1-基本概念"><a href="#0-1-基本概念" class="headerlink" title="0.1 基本概念"></a>0.1 基本概念</h3><h4 id="0-1-1-逻辑结构分类"><a href="#0-1-1-逻辑结构分类" class="headerlink" title="0.1.1 逻辑结构分类"></a>0.1.1 逻辑结构分类</h4><div class="table-container"><table><thead><tr><th>分类</th><th>线性存储结构</th><th>非线性存储结构</th></tr></thead><tbody><tr><td>特点</td><td>数据元素有序集合，“一对一”</td><td>“一对多”</td></tr><tr><td>举例</td><td>线性表</td><td>图形、网状、树形结构</td></tr></tbody></table></div><p>有序表和无序表是逻辑上有序无序，是逻辑结构。栈、队列也是逻辑结构。</p><h4 id="0-1-2-存储结构分类"><a href="#0-1-2-存储结构分类" class="headerlink" title="0.1.2 存储结构分类"></a>0.1.2 存储结构分类</h4><p><strong>存储结构也称物理结构</strong>：是数据逻辑结构在计算机中的表示（映像）。包括数据元素的表示和关系的表示。</p><p><strong>数据元素之间的表示方法分为顺序映像和非顺序映像？</strong></p><p>常用的存储结构：顺序存储、链式存储、索引存储、散列存储（散列是一种算法）。（存储结构的是：环形队列、散列表、单链表、顺序表。）</p><p><strong>顺序表、哈希表、单链表都是存储结构。</strong></p><blockquote><p>线索树是链式存储结构上的基础上对树进行线索；</p><p>双向链表是线性表以链式存储结构存储；</p><p>循环队列是建立在顺序存储结构上的；</p><p>栈是逻辑结构，顺序栈和链栈是存储结构。</p></blockquote><p>栈和队列是特殊的线性表，线性表的存储结构为：顺序表和链表。对应的栈为顺序栈和链栈；队为顺序队和链队。</p><h3 id="0-2-算法及其分析"><a href="#0-2-算法及其分析" class="headerlink" title="0.2 算法及其分析"></a>0.2 算法及其分析</h3><blockquote><p>算法的时间复杂度：</p><p>问题规模：<em>输入量的多少</em></p><p>算法时间分析的就是求出算法所有原子操作的执行次数（频度），它是问题规模n的函数，用T(n)表示。</p><p>原子操作的个数m，算法执行时间<script type="math/tex">t=m\times T(n)</script>.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;     <span class="comment">// 频度n+1，执行次数n</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;   <span class="comment">// 频度n(n+1)，执行次数n^2</span></span><br><span class="line">    <span class="comment">// 语句s                 // 频度1*n^1，执行次数n^2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">T(n)=n+1+n*(n+1)+n^2=2n^2+2n+1$$，用数量级表示，$$T(n)=o(n^2)</script><p><code>求和定理</code>：算法中while循环的if条件中包含的语句可以不考虑，因为它的执行次数不超过循环条件语句的频度。</p><p>求积定理</p><h4 id="0-2-1-题型总结"><a href="#0-2-1-题型总结" class="headerlink" title="0.2.1 题型总结"></a>0.2.1 题型总结</h4><ul><li>普通循环</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;    <span class="comment">// 设while循环执行次数为m，</span></span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>, s=<span class="number">0</span>;     <span class="comment">// i从1到m，s=1+2+...+m=m(m+1)/2</span></span><br><span class="line">  <span class="keyword">while</span>(s&lt;n)&#123;       <span class="comment">// 所以循环结束时有 s=m(m+1)&gt;=n</span></span><br><span class="line">    i++; s=s+i;     <span class="comment">// 总有常数k，使 m(m+1)/2+k=n</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>得<script type="math/tex">m=\frac{-1+\sqrt{8n-8k+1}}{2},\quad T(n)=m=o(\sqrt{n})</script></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;      <span class="comment">// 同理，执行m次后，i=2^m</span></span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">1</span>;            <span class="comment">// 循环结束时有： i&gt;n  得 m&gt;log_2&#123;n&#125;</span></span><br><span class="line">  <span class="keyword">while</span>(i&lt;=n) i=i*<span class="number">2</span>;  <span class="comment">// 总有常数k，使m=log_2&#123;n&#125;+k</span></span><br><span class="line">&#125;                     <span class="comment">// T(n)=m=O(log_2&#123;n&#125;)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;      <span class="comment">// 利用到上面的求和定理，p=p*f不考虑</span></span><br><span class="line">  <span class="keyword">int</span> p=<span class="number">1</span>, d=n, f=n;  <span class="comment">// 因为他的执行次数不超过d=d/2语句的频度</span></span><br><span class="line">  <span class="keyword">while</span>(d&gt;<span class="number">0</span>)&#123;         <span class="comment">// 同理，执行m次后，d=n/2^m&gt;=0</span></span><br><span class="line">    <span class="keyword">if</span>(d%<span class="number">2</span>==<span class="number">1</span>) p=p*f; <span class="comment">// 所以结束时，只能是d=0，计算机中当n=1时，才有d=0</span></span><br><span class="line">    f=f*f;            <span class="comment">// 则n/2^m&gt;=1， m&lt;=log_2&#123;n&#125;</span></span><br><span class="line">    d=d/<span class="number">2</span>;            <span class="comment">// T(n)=m=O(log_2&#123;n&#125;)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;            <span class="comment">// i=1时，j从n到2，执行n-2+1=n-1次</span></span><br><span class="line">  <span class="keyword">int</span> i, j, x=<span class="number">0</span>;            <span class="comment">// i=2时，j从n到3，执行n-2次</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;n; i++)        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span>(j=n; j&gt;=i+<span class="number">1</span>; j--)   <span class="comment">// i=n时，j从n到n，执行1次</span></span><br><span class="line">      x++;                  <span class="comment">// T(n)=n-1+n-2+...+1=(n-1)(n-1+1)/2=O(n^2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>算法的平均时间复杂度，最好时间复杂度，最坏时间复杂度</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*求前i(1&lt;=i&lt;=n)个元素的最大值*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span></span>&#123;    <span class="comment">// 1的取值可以是1~n，有n种情况，等概率1/n</span></span><br><span class="line">  <span class="keyword">int</span> j, <span class="built_in">max</span>=a[<span class="number">0</span>];                 <span class="comment">// 每种情况都要比(i-1)-1+1=i-1次</span></span><br><span class="line">  <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=i<span class="number">-1</span>; j++)            <span class="comment">// 则Tn=见下</span></span><br><span class="line">    <span class="keyword">if</span>(a[j]&gt;<span class="built_in">max</span>) <span class="built_in">max</span>=a[j];         <span class="comment">// 所以平均时间复杂度O(n)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span>;                      <span class="comment">// 最好情况i=1，O(1)；最坏情况i=n，O(n)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><script type="math/tex; mode=display">T_n=\sum_{i=1}^n \frac{1}{n}(i-1)=\frac{n-1}{2}=O(n)</script></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*递归算法时间复杂度分析*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> x, <span class="keyword">char</span> y, <span class="keyword">char</span> z)</span></span>&#123;   <span class="comment">// 设函数hanoi(n,...)的执行时间为T(n)</span></span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>)                                   <span class="comment">// 则hanoi(n-1,...)的执行时间为T(n-1)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"move %c to %c\n"</span>, x, z);         <span class="comment">// 当n=1有T(1)=1</span></span><br><span class="line">  <span class="keyword">else</span>&#123;                                      <span class="comment">// 根据代码：当n&gt;1时，T(n)=2T(n-1)+1</span></span><br><span class="line">    hanoi(n<span class="number">-1</span>, x, z, y);                     <span class="comment">// 所以，有</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"move %c to %c\n"</span>, x, z);         <span class="comment">// T(n)=2T(n-1)+1=2(2T(n-2)+1)+1</span></span><br><span class="line">    hanoi(n<span class="number">-1</span>, y, x, z);                     <span class="comment">//     =2^2T(n-2)+2+1</span></span><br><span class="line">  &#125;                                          <span class="comment">//     =...</span></span><br><span class="line">&#125;                                            <span class="comment">//     =2^2+1=O(2^2)</span></span><br></pre></td></tr></table></figure><ul><li>值得记的递归算法</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*假设非空二叉树bt采用二叉链存储，其中所有节点数据域为正数，设计一个递归算法求其中的最大值。*/</span></span><br><span class="line"><span class="comment">/*解：设二叉链表bt中最大值为f(bt)，推导得*/</span></span><br><span class="line"><span class="comment">/*[递归模型]：*/</span></span><br><span class="line"><span class="comment">/*f(bt)=0                                             若bt为空*/</span></span><br><span class="line"><span class="comment">/*f(bt)=bt-&gt;data                                 若bt是叶子节点*/</span></span><br><span class="line"><span class="comment">/*f(bt)=MAX(bt-&gt;data, f(bt-&gt;lchild), f(bt-&gt;rchild))   其他情况*/</span></span><br><span class="line"><span class="comment">// 递归算法如下：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(BTNode *bt)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m, n; <span class="comment">// m存放左子树最大值，n存放右子树最大值</span></span><br><span class="line">  <span class="keyword">if</span>(bt==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(bt-&gt;lchild==<span class="literal">NULL</span> &amp;&amp; bt-&gt;rchild)</span><br><span class="line">    <span class="keyword">return</span> bt-&gt;data;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    m=f(bt-&gt;lchild); <span class="comment">// 求左子树中最大值</span></span><br><span class="line">    n=f(bt-&gt;rchild); <span class="comment">// 求右子树中最大值</span></span><br><span class="line">    <span class="keyword">if</span>(m&lt;=n)</span><br><span class="line">      m=n; <span class="comment">// 左、右子树中的最大值放在m中</span></span><br><span class="line">    <span class="keyword">if</span>(m&gt;bt-&gt;data) <span class="comment">// 由于是个3值比较，先比较子树两个值，再与父父节点比较</span></span><br><span class="line">      <span class="keyword">return</span> m; <span class="comment">// 返回最大值</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> bt-&gt;data;</span><br><span class="line">  &#125; <span class="comment">// end else</span></span><br><span class="line">&#125; <span class="comment">// end function</span></span><br></pre></td></tr></table></figure><h2 id="一、线性表"><a href="#一、线性表" class="headerlink" title="一、线性表"></a>一、线性表</h2><h3 id="1-1-线性表的定义和基本操作"><a href="#1-1-线性表的定义和基本操作" class="headerlink" title="1.1 线性表的定义和基本操作"></a>1.1 线性表的定义和基本操作</h3><p> <strong>线性表（Linear List）</strong>描述：线性表是n个<strong>类型相同</strong>数据元素的有限序列，对n&gt;0，除第一个元素无直接前驱、最后一个元素无直接后继外，其余的每个元素只有一个直接前驱和一个直接后继，元素之间具有一对一的关系。</p><h3 id="1-2线性表的实现"><a href="#1-2线性表的实现" class="headerlink" title="1.2线性表的实现"></a>1.2线性表的实现</h3><h4 id="1-2-1-顺序存储结构"><a href="#1-2-1-顺序存储结构" class="headerlink" title="1.2.1 顺序存储结构"></a>1.2.1 顺序存储结构</h4><ul><li>顺序表的定义</li></ul><p>顺序表是一种顺序存储结构，是线性表在内存中的一种<strong>直接映射方式</strong>。</p><p>所谓随机存储特性指通过首地址和元素序号可以在<strong>O(1)</strong>时间内找到指定元素。</p><p>顺序表的插入删除操作时间复杂度为O(n)。通过计算平均移动次数（平均时间复杂度）</p><script type="math/tex; mode=display">存储密度=\frac{节点数据本身占用的存储量}{节点结构占用的存储量}</script><p>顺序表的存储密度为1，而链表小于1。</p><ul><li>有序表的定义</li></ul><p>元素有序排列，逻辑结构，顺序链式进行存储，不能随意指定插入元素的位置。</p><h4 id="1-2-2-链式存储结构"><a href="#1-2-2-链式存储结构" class="headerlink" title="1.2.2 链式存储结构"></a>1.2.2 链式存储结构</h4><ul><li><p>单链表的定义</p><p><em>单链表中用任意一组存储单元存放线性表中的元素，每个节点通过一个指针指向后继节点。</em></p><p>头结点和首节点的区别，首节点是有值的。头插法、尾插法建单链表的时间复杂度O(n)</p></li><li><p>双链表的定义（双向链表）</p><p><em>每个节点通过两个指针分别指向前驱和后继节点。</em></p></li><li><p>循环链表的定义</p><p><em>循环单链表是将原单链表中尾节点的next域由NULL改为指向头节点。</em></p><p><em>循环双链表是将原双链表中尾结点的next域由NULL改为指向头节点，再将头节点的prior域改为指向为节点。</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带头结点的循环链表L中，某节点*p为尾结点的条件是</span></span><br><span class="line">p-&gt;next==L;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-线性表的应用"><a href="#1-3-线性表的应用" class="headerlink" title="1.3 线性表的应用"></a>1.3 线性表的应用</h3><h2 id="二、栈、队列和数组"><a href="#二、栈、队列和数组" class="headerlink" title="二、栈、队列和数组"></a>二、栈、队列和数组</h2><h3 id="2-1-栈和队列的基本概念"><a href="#2-1-栈和队列的基本概念" class="headerlink" title="2.1 栈和队列的基本概念"></a>2.1 栈和队列的基本概念</h3><p>都是插入和删除操作受限的线性表。</p><h4 id="2-1-1-栈的定义"><a href="#2-1-1-栈的定义" class="headerlink" title="2.1.1 栈的定义"></a>2.1.1 栈的定义</h4><p>栈顶进行插入和删除，另一端叫栈底。（先进后出，后进先出）</p><h4 id="2-1-2-队列的定义"><a href="#2-1-2-队列的定义" class="headerlink" title="2.1.2 队列的定义"></a>2.1.2 队列的定义</h4><p>队尾插入，对头删除。（先进先出，后进后出）</p><h3 id="2-2-栈和队列的顺序存储结构"><a href="#2-2-栈和队列的顺序存储结构" class="headerlink" title="2.2 栈和队列的顺序存储结构"></a>2.2 栈和队列的顺序存储结构</h3><h4 id="2-2-1-顺序栈"><a href="#2-2-1-顺序栈" class="headerlink" title="2.2.1 顺序栈"></a>2.2.1 顺序栈</h4><ul><li><p>顺序栈s的4要素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈空条件</span></span><br><span class="line">s.top==<span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 栈满条件</span></span><br><span class="line">s.top==MaxSize<span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 元素e进栈</span></span><br><span class="line">s.top++; s.data[s.top]=e;</span><br><span class="line"><span class="comment">// 元素出栈</span></span><br><span class="line">e=s.data[s.top]; s.top--;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2-2-共享栈"><a href="#2-2-2-共享栈" class="headerlink" title="2.2.2 共享栈"></a>2.2.2 共享栈</h4><p>两个栈共享一个数组空间，两端固定，即两栈栈底固定。<em>下标0的一段作为栈1的栈底，其栈顶指针top1；将下标MaxSize-1的一端作为栈2的栈底，其栈顶指针为top2。</em></p><ul><li><p>栈1的4要素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈空条件</span></span><br><span class="line">s.top1==<span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 栈满条件</span></span><br><span class="line">s.top1==s.top2<span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 元素e进栈</span></span><br><span class="line">s.top1++; s.data[s.top1]=e;</span><br><span class="line"><span class="comment">// 元素出栈</span></span><br><span class="line">e=s.data[s.top1]; s.top1--;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>栈2的4要素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈空条件</span></span><br><span class="line">s.top2==MaxSize;</span><br><span class="line"><span class="comment">// 栈满条件</span></span><br><span class="line">s.top2==s.top1+<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 元素e进栈</span></span><br><span class="line">s.top2--; s.data[s.top2]=e;</span><br><span class="line"><span class="comment">// 元素出栈</span></span><br><span class="line">e=s.data[s.top2]; s.top2++;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2-3-顺序队"><a href="#2-2-3-顺序队" class="headerlink" title="2.2.3 顺序队"></a>2.2.3 顺序队</h4><p>数组存放队中元素，用front和rear两个变量分别指示队头和队尾，front指向队列中队首元素的<strong>前一个位置</strong>，rear指向队尾元素的位置。（也就是front指向的空间没有值，像这样的队列最多只能进队MaxSize-1个元素）</p><ul><li><p>“假溢出”现象</p><p>当队列中实际元素个数远远小于数组大小时，也可能由于队尾指针已超过数组上界而不能做进队操作。</p><p>为此，将数组通过逻辑方法改为首尾相连，这样的队列称为环形队列（或循环队列）。</p></li><li><p>环形队列q的4要素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队空条件</span></span><br><span class="line">q.front==q.rear;    <span class="comment">// rear指向的空间也可能没有值</span></span><br><span class="line"><span class="comment">// 队满条件</span></span><br><span class="line">(q.rear+<span class="number">1</span>)%MaxSize==q.front;</span><br><span class="line"><span class="comment">// 元素e进队</span></span><br><span class="line">q.rear=(q.rear+<span class="number">1</span>)%MaxSize;  q.data[q.rear]=e;</span><br><span class="line"><span class="comment">// 元素出队</span></span><br><span class="line">q.front=(q.front+<span class="number">1</span>)%MaxSize;  e=q.data[q.front];</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-栈和队列的链式存储结构"><a href="#2-3-栈和队列的链式存储结构" class="headerlink" title="2.3 栈和队列的链式存储结构"></a>2.3 栈和队列的链式存储结构</h3><h4 id="2-3-1-链栈"><a href="#2-3-1-链栈" class="headerlink" title="2.3.1 链栈"></a>2.3.1 链栈</h4><p>可以采用带头结点的单链表表示，也可以采用不带头结点的单链表表示。</p><ul><li><p>链栈s的4要素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈空条件</span></span><br><span class="line">s-&gt;==<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 栈满条件</span></span><br><span class="line">不存在;</span><br><span class="line"><span class="comment">// 元素e进栈</span></span><br><span class="line">建立值为e的节点*p，采用头插法插入到链栈中;</span><br><span class="line"><span class="comment">// 元素出栈</span></span><br><span class="line">取出首节点的data值并删除之;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-2-链队"><a href="#2-3-2-链队" class="headerlink" title="2.3.2 链队"></a>2.3.2 链队</h4><p>通常链队用不带头结点的单链表表示？其中有两种类型的节点，一是存放队列中数据元素的节点，另一种是存放对头、队尾指针的<em>链队节点</em>，一个链队只有一个链队节点。</p><ul><li><p>链队q的4要素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队空条件</span></span><br><span class="line">q-&gt;front==<span class="literal">NULL</span>&amp;&amp;q-&gt;rear==<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 队满条件</span></span><br><span class="line">不存在;</span><br><span class="line"><span class="comment">// 元素e进队</span></span><br><span class="line">建立一个data域为e的数据节点*s，将*s插入到队尾并让q-&gt;rear指向它;</span><br><span class="line"><span class="comment">// 元素出队</span></span><br><span class="line">取出队首节点的data值，将其删除并让q-&gt;front指向下一个节点;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-3-双端队列"><a href="#2-3-3-双端队列" class="headerlink" title="2.3.3 双端队列"></a>2.3.3 双端队列</h4><p>两端（前端和后端）都可以入队和出队。其元素的逻辑结构仍是线性结构。</p><h3 id="2-4-栈和队列的应用"><a href="#2-4-栈和队列的应用" class="headerlink" title="2.4 栈和队列的应用"></a>2.4 栈和队列的应用</h3><h4 id="2-4-1-栈的应用"><a href="#2-4-1-栈的应用" class="headerlink" title="2.4.1 栈的应用"></a>2.4.1 栈的应用</h4><ul><li>将算术表达式exp转换为后缀表达式postexp</li></ul><p><code>法一：算法基本思想</code></p><p>采用运算符栈是为了比较运算符的优先级，所有的运算符必须进栈。只将大于栈顶元素优先级的运算符直接进栈，否则需要退栈栈顶运算符（先退栈的运算符先计算，同优先级的运算符在栈中计算）</p><p><code>法二：手工加括号</code></p><p>过程：先根据中缀表达式的求值次序加上括号，将右括号用相应的运算符替换，再除掉所有左括号。</p><blockquote><p>例如：中缀表达式<script type="math/tex">5+2*(1+6)-8/2</script>，加括号变为：<script type="math/tex">((5+(2*(1+6)))-(8/2))</script></p><p>用这种对应关系<script type="math/tex">((5\underbrace{+(2{\underbrace{*(1\underbrace{+6)})}})}\underbrace{-(8\underbrace{/2)})}</script>，往回找，就近原则。</p><p>将右括号用对应的运算符替换，变为：<script type="math/tex">((\ 5\ (\ 2\ (\ 1\ 6\ +\ *\ +\ (\ 8\ 2\ /\ -</script></p><p>最后除掉所有左括号得到后缀表达式为<script type="math/tex">5\ 2\ 1\ 6\ +\ *\ +\ 8\ 2\ /\ -</script></p></blockquote><ul><li>对后缀表达式求值</li></ul><h3 id="2-5-数组的基本概念"><a href="#2-5-数组的基本概念" class="headerlink" title="2.5 数组的基本概念"></a>2.5 数组的基本概念</h3><p>数组是由相同类型的数据元素构成的一个有限序列，对于<script type="math/tex">m(m\geq1)</script>维数组，每个元素受m个线性关系的约束，所以数组是线性表的推广。</p><blockquote><p>数组具有随机存储的特性（存储连续，随机访问，通过下标；链表存储连续，访问连续？）</p></blockquote><h4 id="2-5-1-特殊矩阵的压缩存储"><a href="#2-5-1-特殊矩阵的压缩存储" class="headerlink" title="2.5.1 特殊矩阵的压缩存储"></a>2.5.1 特殊矩阵的压缩存储</h4><p>n阶对称矩阵<script type="math/tex">A[1...n]A[1...n]</script>存放在一维数组<script type="math/tex">B[1...\frac{n(n+1)}{2}]</script>中，即元素<script type="math/tex">a_{ij}</script>存放在<script type="math/tex">b_k</script>中，即只存放主对角线元素和下三角区的元素<script type="math/tex">(i \ge j)</script>。</p><p>就是求出i，j和k的关系。求顺序号，即它前面有几个元素。</p><script type="math/tex; mode=display">\begin{bmatrix}{a_{11}}&{a_{12}}&{a_{13}}&{\cdots}&{a_{1n}}\\{a_{21}}&{a_{22}}&{a_{23}}&{\cdots}&{a_{2n}}\\{a_{31}}&{a_{32}}&{a_{33}}&{\cdots}&{a_{2n}}\\{\vdots}&{\vdots}&{\vdots}&{\ddots}&{\vdots}\\{\vdots}&{\vdots}&{a_{ij}}&{\ddots}&{\vdots}\\{\vdots}&{\vdots}&{\vdots}&{\ddots}&{\vdots}\\{a_{n1}}&{a_{n2}}&{a_{n3}}&{\cdots}&{a_{nn}}\\\end{bmatrix}</script><p>求<script type="math/tex">a_{ij}</script>前面有<script type="math/tex">(1+2+\cdots+i-1)+j-1=\frac{(i-1)(i-1+1)}{2}+j-1=\frac{i(i-1)}{2}+j-1</script>个元素，得：</p><script type="math/tex; mode=display">k=\begin{cases}\cfrac{i(i-1)}{2}+j, &当i\ge j(下三角区和主对角线元素)\\\cfrac{j(j-1)}{2}+i, &当i<j(上三角区元素a_{ij}=a_{ji})\end{cases}</script><h4 id="2-5-2-三角矩阵"><a href="#2-5-2-三角矩阵" class="headerlink" title="2.5.2 三角矩阵"></a>2.5.2 三角矩阵</h4><p>矩阵中上三角区的所有元素均为同一变量c，只需存放下三角区，主对角线上的元素和常量c。</p><h4 id="2-5-3-对角矩阵"><a href="#2-5-3-对角矩阵" class="headerlink" title="2.5.3 对角矩阵"></a>2.5.3 对角矩阵</h4><script type="math/tex; mode=display">k=2i+j-2</script><h4 id="2-5-4-稀疏矩阵"><a href="#2-5-4-稀疏矩阵" class="headerlink" title="2.5.4 稀疏矩阵"></a>2.5.4 稀疏矩阵</h4><p>定义：非零元素远小于元素总数的二维数组。压缩方法是只存非零元素。</p><p>常用的存储结构有<strong>三元组</strong>（行、列号和权值）表示和<strong>十字链表</strong>表示。</p><h2 id="三、树与二叉树"><a href="#三、树与二叉树" class="headerlink" title="三、树与二叉树"></a>三、树与二叉树</h2><h3 id="3-1-树的概念"><a href="#3-1-树的概念" class="headerlink" title="3.1 树的概念"></a>3.1 树的概念</h3><blockquote><p>树是由<script type="math/tex">\mathtt{n}(\mathtt {n}\geq0)</script>个节点组成的有限集合。其中，如果<script type="math/tex">\mathtt {n}=0</script>，它是一棵空树；如果<script type="math/tex">\mathtt {n}>0</script>，这<script type="math/tex">\mathtt {n}</script>个节点作为树的根节点，其余节点可分为<script type="math/tex">m(m\geq0)</script>个互不相交的有限集，其中每一棵自己本身又是一棵符合本定义的树，称为根节点的子树。</p></blockquote><ul><li><p>基本术语</p><p><code>度</code>：树中各节点的度的最大值；</p><p><code>分支节点</code>：度不为0的节点称为非终端结点，又叫分支节点；</p><p><code>叶子节点</code>：度为0的节点称为终端结点，或叶子节点；</p><p><code>孩子节点、双亲结点和兄弟节点</code></p><p><code>节点的层次</code>：根节点为第一层；</p><p><code>树的高度（深度）</code>：节点的最大层次；</p><p><code>路径</code>：由经过的节点序列构成；</p><p><code>路径长度</code>：经过的边的数目（树中分支是有向的，从上向下，兄弟节点间无路径）；</p><p><code>森林</code>：<script type="math/tex">n(n\ge 0)</script>个互不相交的树的集合。</p></li><li><p>树的性质</p><p><code>性质1</code>：树中节点数为n，度之和 <em>等于</em> 分支数，分支数=n-1</p><p><code>性质2</code>：度为m的树中第i层上至多有<script type="math/tex">m^{i-1}</script>个结点<script type="math/tex">i\ge 1</script></p><p><code>性质3</code>：高度为h的m次树至多有<script type="math/tex">\frac{m^{h-1}}{m-1}</script>个结点（等比数列前n项和）</p><p><code>性质4</code>：具有n个结点的m次树的最小高度为<script type="math/tex">\lceil log_m{[n(m-1)+1]} \rceil</script></p></li><li><p>树的存储结构</p><ul><li><p>双亲存储结构</p><p><em>连续空间存储树的所有结点</em></p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/DataStructure/parental_storage.png" style="zoom: 60%;" /></p></li><li><p>孩子链存储结构</p><p><em>按树的度设计节点的孩子节点指针域个数（m叉树的一个节点的指针域m个，加数据域共m+1域）</em></p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/DataStructure/children&#39;s_chain.png" alt=""></p></li><li><p>孩子兄弟链存储结构</p><p>3个域：数据元素域、第一个孩子域、下一个兄弟节点指针域。</p></li></ul></li></ul><h3 id="3-2-二叉树"><a href="#3-2-二叉树" class="headerlink" title="3.2 二叉树"></a>3.2 二叉树</h3><h4 id="3-2-1-二叉树的定义及其主要特征"><a href="#3-2-1-二叉树的定义及其主要特征" class="headerlink" title="3.2.1 二叉树的定义及其主要特征"></a>3.2.1 二叉树的定义及其主要特征</h4><p>二叉树是<script type="math/tex">n(n\ge 0)</script>个结点的有限集合，该集合或者为空集<script type="math/tex">(n=0)</script>，或者由一个根节点或两棵互不相交的、分别称为根节点的左子树和右子树的二叉树组成。</p><p><em>二叉树不同于度为2的树，度为2的树至少有3个结点，不区分子树的次序。</em></p><p>完全二叉树的特点：</p><ul><li>如果有度为1的节点，只能有一个，且该节点只有左孩子而无右孩子</li><li>当节点总数n为奇数时，<script type="math/tex">n_1=0</script>；当节点总数n为偶数时，<script type="math/tex">n_1=1</script></li></ul><h4 id="3-2-2-二叉树的性质"><a href="#3-2-2-二叉树的性质" class="headerlink" title="3.2.2 二叉树的性质"></a>3.2.2 二叉树的性质</h4><ul><li><p><code>性质1</code>：非空二叉树上叶子节点数等于双分支节点数加1，即<script type="math/tex">n_0=n_1+1</script></p><p>（度之和 <em>等于</em> 节点数-1）<script type="math/tex">\Rightarrow</script>叶子节点数 <em>等于</em> 度为2的节点数+1</p></li><li><p><code>性质2</code>：非空二叉树上第i层上至多有<script type="math/tex">2^{i-1}</script>个结点。<script type="math/tex">(i\ge 1)</script></p></li><li><p><code>性质3</code>：高度为h的二叉树至多有<script type="math/tex">2^{h-1}(\frac{2^{i-1}}{2-1})</script>个结点。<script type="math/tex">(h\ge 1)</script></p></li><li><p><code>性质4</code>：若二叉树采用顺序存储结构表示，则编号为 i 和 j 的两个节点处于同一层的条件是<script type="math/tex">\lfloor log_2(i+1) \rfloor=\lfloor log_2(j+1) \rfloor</script></p></li></ul><h4 id="3-2-3-二叉树的顺序存储结构"><a href="#3-2-3-二叉树的顺序存储结构" class="headerlink" title="3.2.3 二叉树的顺序存储结构"></a>3.2.3 二叉树的顺序存储结构</h4><p> 用一组地址连续的存储单元存放（没有结点的地方用’#’字符填补）</p><h4 id="3-2-4-二叉树的链式存储结构"><a href="#3-2-4-二叉树的链式存储结构" class="headerlink" title="3.2.4 二叉树的链式存储结构"></a>3.2.4 二叉树的链式存储结构</h4><h4 id="3-2-5-二叉树的遍历"><a href="#3-2-5-二叉树的遍历" class="headerlink" title="3.2.5 二叉树的遍历"></a>3.2.5 二叉树的遍历</h4><ul><li>先序遍历：<em>根左右</em></li><li>中序遍历：<em>左根右</em></li><li>后序遍历：<em>左右根</em></li><li>层次遍历</li><li>基于递归的二叉树算法设计方法</li><li>基于非递归的二叉树算法设计方法</li></ul><h4 id="3-2-6-二叉树的构造"><a href="#3-2-6-二叉树的构造" class="headerlink" title="3.2.6 二叉树的构造"></a>3.2.6 二叉树的构造</h4><ul><li>由<code>先序序列</code>和<strong>中序序列</strong>构造二叉树</li><li>由<code>后序序列</code>和<strong>中序序列</strong>构造二叉树</li><li>由<code>层次序列</code>和<strong>中序序列</strong>构造二叉树</li></ul><h4 id="3-2-7-线索二叉树的基本概念和构造"><a href="#3-2-7-线索二叉树的基本概念和构造" class="headerlink" title="3.2.7 线索二叉树的基本概念和构造"></a>3.2.7 线索二叉树的基本概念和构造</h4><p>对于n个结点的二叉树，在二叉链存储结构中有n+1个空链域，利用这些空链域<strong>存放</strong>在某种遍历次序下该节点的<strong>前驱节点和后续节点</strong>的指针，这些指针称为线索。加上线索的二叉树称为线索二叉树。<em>提高遍历过程的效率</em>。</p><h3 id="3-3-二叉排序树（Binary-Search-Tree-BST）"><a href="#3-3-二叉排序树（Binary-Search-Tree-BST）" class="headerlink" title="3.3 二叉排序树（Binary Search Tree, BST）"></a>3.3 二叉排序树（Binary Search Tree, BST）</h3><p> 二叉排序树或是一颗空树，或者是满足如下性质的二叉树：</p><ul><li>若其左子树非空，则左子树上所有的记录的值均小于根记录的值；</li><li>若其右子树非空，则右子树上所有的记录的值均大于根记录的值；</li><li>左、右子树本身又各是一颗BST。</li></ul><h3 id="3-4-平衡二叉树（AVL）"><a href="#3-4-平衡二叉树（AVL）" class="headerlink" title="3.4 平衡二叉树（AVL）"></a>3.4 平衡二叉树（AVL）</h3><p> 平衡二叉树或是一颗空树，或者是具有下列性质的<strong>二叉排序树</strong>：</p><ul><li>其左子树和右子树都是AVL；</li><li>且左、右子树高度之差的绝对值不超过1。</li></ul><p>平衡因子定义为节点左子树的高度减去它的右子树的高度<script type="math/tex">(-1, 0, 1)</script>。</p><h4 id="3-4-1-平衡二叉树中插入一个新节点的方法"><a href="#3-4-1-平衡二叉树中插入一个新节点的方法" class="headerlink" title="3.4.1 平衡二叉树中插入一个新节点的方法"></a>3.4.1 平衡二叉树中插入一个新节点的方法</h4><ul><li>LL型调整</li><li>RR型调整</li><li>LR型调整</li><li>RL型调整</li></ul><h4 id="3-4-2-平衡二叉树中删除一个节点的方法"><a href="#3-4-2-平衡二叉树中删除一个节点的方法" class="headerlink" title="3.4.2 平衡二叉树中删除一个节点的方法"></a>3.4.2 平衡二叉树中删除一个节点的方法</h4><h4 id="3-4-3-平衡二叉树查找节点的过程"><a href="#3-4-3-平衡二叉树查找节点的过程" class="headerlink" title="3.4.3 平衡二叉树查找节点的过程"></a>3.4.3 平衡二叉树查找节点的过程</h4><p>含有n个节点的平衡二叉树的平均查找长度为<script type="math/tex">O(log_2n)</script>。</p><h2 id="四、树、森林"><a href="#四、树、森林" class="headerlink" title="四、树、森林"></a>四、树、森林</h2><h3 id="4-1-树的存储结构"><a href="#4-1-树的存储结构" class="headerlink" title="4.1 树的存储结构"></a>4.1 树的存储结构</h3><ul><li>双亲存储结构</li></ul><p>双亲表示法采用顺序表（也就是数组）存储普通树，其实现的核心思想是：顺序存储各个节点的同时，给各节点附加一个记录其父节点位置的变量。（求某节点双亲结点<script type="math/tex">o(1)</script>，求某节点孩子<script type="math/tex">O(n)</script>）</p><blockquote><p>注意，根节点没有父节点（父节点又称为双亲节点），因此根节点记录父节点位置的变量通常置为 -1。</p></blockquote><ul><li>孩子链式存储结构</li></ul><p>按树的度设计节点指针域个数。就是一个父节点链上其所有孩子节点。</p><ul><li>孩子兄弟链存储结构</li></ul><p>3个域：数据元素域，第一个孩子域，下一个兄弟节点指针域。</p><h3 id="4-2-森林与二叉树的转换"><a href="#4-2-森林与二叉树的转换" class="headerlink" title="4.2 森林与二叉树的转换"></a>4.2 森林与二叉树的转换</h3><p>树的先根序列对应二叉树的先序序列；树的后根序列对应二叉树的中序序列。</p><h4 id="4-2-1-森林、树转换为二叉树"><a href="#4-2-1-森林、树转换为二叉树" class="headerlink" title="4.2.1 森林、树转换为二叉树"></a>4.2.1 森林、树转换为二叉树</h4><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/DataStructure/transformation.png" alt=""></p><h4 id="4-2-2-二叉树还原为森林、树"><a href="#4-2-2-二叉树还原为森林、树" class="headerlink" title="4.2.2 二叉树还原为森林、树"></a>4.2.2 二叉树还原为森林、树</h4><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/DataStructure/reduction.png" alt=""></p><h3 id="4-3-树与森林的遍历"><a href="#4-3-树与森林的遍历" class="headerlink" title="4.3 树与森林的遍历"></a>4.3 树与森林的遍历</h3><h3 id="4-4-树的应用"><a href="#4-4-树的应用" class="headerlink" title="4.4 树的应用"></a>4.4 树的应用</h3><h3 id="4-5-等价类问题"><a href="#4-5-等价类问题" class="headerlink" title="4.5 等价类问题"></a>4.5 等价类问题</h3><h3 id="4-6-哈夫曼树和哈夫曼编码"><a href="#4-6-哈夫曼树和哈夫曼编码" class="headerlink" title="4.6 哈夫曼树和哈夫曼编码"></a>4.6 哈夫曼树和哈夫曼编码</h3><p>带权路径长度：从根节点到该节点之间的路径长度与该节点权值的乘积。</p><p>树的带权路径长度：树中所有叶子节点的带权路径长度之和。记为：</p><script type="math/tex; mode=display">WPL=\sum_{i=0}^NW_iL_i</script><p>其中，n表示叶子节点的数目，<script type="math/tex">W_i</script>表示叶子节点的权值，<script type="math/tex">L_i</script>表示根到该叶子节点间的路径长度。</p><p>哈夫曼树：在n个带权叶子节点构成的所有二叉树中，带权路径长度WPL最小的二叉树。</p><ul><li>哈夫曼树的构造算法</li></ul><p>哈夫曼编码中没有单分支节点，即<script type="math/tex">n_1=0</script></p><ul><li>哈夫曼编码</li></ul><p>在哈夫曼树的基础上构造哈夫曼编码的过程如下：</p><blockquote><p>只对叶子编码，不存在两个编码相同的叶子，不存在一个编码是另一个编码的前缀。</p></blockquote><h2 id="五、图"><a href="#五、图" class="headerlink" title="五、图"></a>五、图</h2><h3 id="5-1-图的概念"><a href="#5-1-图的概念" class="headerlink" title="5.1 图的概念"></a>5.1 图的概念</h3><ul><li>无向图：</li><li>有向图：</li><li>完全图：</li><li>端点：</li><li>顶点的度、入度和出度</li><li>子图：</li><li>路径：</li><li>路径长度：</li><li>回路（环）：</li><li>连通：</li><li>连通图：</li><li>连通分量：</li><li>强连通分量：</li><li>稠密图：</li><li>稀疏图：</li><li>权：</li><li>网：</li></ul><h3 id="5-2-图的存储及基本操作"><a href="#5-2-图的存储及基本操作" class="headerlink" title="5.2 图的存储及基本操作"></a>5.2 图的存储及基本操作</h3><h4 id="5-2-1-邻接矩阵法（图的顺序存储结构）"><a href="#5-2-1-邻接矩阵法（图的顺序存储结构）" class="headerlink" title="5.2.1 邻接矩阵法（图的顺序存储结构）"></a>5.2.1 邻接矩阵法（图的顺序存储结构）</h4><p>带权图中，通常约定矩阵<script type="math/tex">A[i][i]=0</script>。</p><h4 id="5-2-2-邻接表法（图的链式存储）"><a href="#5-2-2-邻接表法（图的链式存储）" class="headerlink" title="5.2.2 邻接表法（图的链式存储）"></a>5.2.2 邻接表法（图的链式存储）</h4><p>图的邻接表不唯一</p><h3 id="5-3-图的遍历"><a href="#5-3-图的遍历" class="headerlink" title="5.3 图的遍历"></a>5.3 图的遍历</h3><h4 id="5-3-1-深度优先搜索（DFS）"><a href="#5-3-1-深度优先搜索（DFS）" class="headerlink" title="5.3.1 深度优先搜索（DFS）"></a>5.3.1 深度优先搜索（DFS）</h4><p>递归，可用于求简单路径。</p><h4 id="5-3-2-广度优先搜索（BFS）"><a href="#5-3-2-广度优先搜索（BFS）" class="headerlink" title="5.3.2 广度优先搜索（BFS）"></a>5.3.2 广度优先搜索（BFS）</h4><p>类似于树的层次遍历，借助队列。</p><ul><li><p>非连通图的遍历</p><p>对于无向图，调用<script type="math/tex">DFS(G, i)</script>或<script type="math/tex">BFS(G, i)</script>几次，说明该图中有几个连通分量。</p></li></ul><h3 id="5-4-图的基本应用及其复杂度分析"><a href="#5-4-图的基本应用及其复杂度分析" class="headerlink" title="5.4 图的基本应用及其复杂度分析"></a>5.4 图的基本应用及其复杂度分析</h3><h4 id="5-4-1-最小（代价生成树）"><a href="#5-4-1-最小（代价生成树）" class="headerlink" title="5.4.1 最小（代价生成树）"></a>5.4.1 最小（代价生成树）</h4><p>生成树：</p><p>图的最小生成树不唯一，当存在相同权值的边时，其最小生成树也可能不唯一。</p><ul><li><p>普里姆（Prim）算法</p><blockquote><p>Prim算法是一种构造型算法，一步一步地选择最小边。</p><p>由于Prim算法中需要频繁地取一条条边的权值，所以采用邻接矩阵更合适。</p><p>Prim算法中有两重for循环，所以时间复杂度<script type="math/tex">O(n^2)</script>，n为图的顶点个数。</p><p>时间复杂度与边数e无关，适用于<strong>稠密图</strong>。</p></blockquote></li><li><p>克鲁斯卡尔（Kruskal）算法</p><p>算法时间复杂度<script type="math/tex">O(e*log_2e)</script>，适合稀疏图。</p></li></ul><h4 id="5-4-2-最短路径"><a href="#5-4-2-最短路径" class="headerlink" title="5.4.2 最短路径"></a>5.4.2 最短路径</h4><p>对于带权有向图G，最短路径是指从一个顶点到达另一个顶点所经过的边上的<strong>权值之和最小</strong>的路径，而不是边数最少的路径。</p><ul><li><p>从一个顶点到其余<strong>各</strong>顶点的最短路径</p><p>采用迪克斯特拉（Dijkstra）算法求解，算法时间复杂度<script type="math/tex">O(n^2)</script></p></li><li><p><strong>每队顶点之间</strong>的最短路径</p><p>采用弗洛伊德（Floyd）算法，时间复杂度<script type="math/tex">O(n^3)</script></p></li></ul><h4 id="5-4-3-拓扑排序"><a href="#5-4-3-拓扑排序" class="headerlink" title="5.4.3 拓扑排序"></a>5.4.3 拓扑排序</h4><ul><li><p>AOV网的定义（Activity On Vertex Network）</p><p>利用顶点表示活动，边表示活动间的先后关系的有向图称为顶点活动图，简称AOV网。</p></li><li><p>拓扑排序</p></li></ul><h4 id="5-4-4-关键路径"><a href="#5-4-4-关键路径" class="headerlink" title="5.4.4 关键路径"></a>5.4.4 关键路径</h4><ul><li><p>AOE网的定义（Activity On Edge Network）</p><p>在带权有向图中以<code>顶点表示事件</code>，以<code>有向边表示活动</code>，边上的<code>权值表示该活动持续的时间</code>，则此带权有向图称为用边表示活动的网，简称AOE网。</p><p>AOE网中至少一个源点，其入度为0，同时应有一个汇点，其出度为0；网中不存在回路，否则整个工程无法结束。</p></li><li><p>求关键路径的过程</p><p>在AOE网中，完成工程的最短时间是从开始点到完成点的最长路径长度，路径长度最长的路径叫做关键路径。</p><p>由关键获得构成的路径便是关键路径，关键路径不唯一。</p></li></ul><h2 id="六、查找"><a href="#六、查找" class="headerlink" title="六、查找"></a>六、查找</h2><h3 id="6-1-查找的基本概念"><a href="#6-1-查找的基本概念" class="headerlink" title="6.1 查找的基本概念"></a>6.1 查找的基本概念</h3><p>给定一个值k，在含有n个记录的表中找出关键字等于k的记录。</p><p>静态查找表和动态查找表</p><p>评价查找长度（ASL，Average Search Length），也叫平均比较次数。</p><p>ASL可分为成功查找情况下和不成功查找情况下ASL两种。</p><p>线性表的查找方法主要有：顺序查找、折半查找和分块查找。</p><h3 id="6-2-顺序查找法"><a href="#6-2-顺序查找法" class="headerlink" title="6.2 顺序查找法"></a>6.2 顺序查找法</h3><p>成功时：<script type="math/tex">ASL=\sum_{i=0}^np_ic_i=\frac{1}{n}\sum_{i=1}^n=\frac{n+1}{2}</script></p><p>不成功时：<script type="math/tex">ASL=n</script></p><p>时间复杂度<script type="math/tex">O(n)</script>，适用于顺序、链式存储。</p><h3 id="6-3-折半查找法"><a href="#6-3-折半查找法" class="headerlink" title="6.3 折半查找法"></a>6.3 折半查找法</h3><h3 id="6-4-B-树"><a href="#6-4-B-树" class="headerlink" title="6.4 B-树"></a>6.4 B-树</h3><h3 id="6-5-散列表（Hash）表及其查找"><a href="#6-5-散列表（Hash）表及其查找" class="headerlink" title="6.5 散列表（Hash）表及其查找"></a>6.5 散列表（Hash）表及其查找</h3><h3 id="6-6-查找算法的分析及应用"><a href="#6-6-查找算法的分析及应用" class="headerlink" title="6.6 查找算法的分析及应用"></a>6.6 查找算法的分析及应用</h3><h2 id="七、内部排序"><a href="#七、内部排序" class="headerlink" title="七、内部排序"></a>七、内部排序</h2><h3 id="7-1-排序的基本概念"><a href="#7-1-排序的基本概念" class="headerlink" title="7.1 排序的基本概念"></a>7.1 排序的基本概念</h3><h3 id="7-2-插入排序"><a href="#7-2-插入排序" class="headerlink" title="7.2 插入排序"></a>7.2 插入排序</h3><h4 id="7-2-1-直接插入排除"><a href="#7-2-1-直接插入排除" class="headerlink" title="7.2.1 直接插入排除"></a>7.2.1 直接插入排除</h4><h4 id="7-2-2-折半插入排除"><a href="#7-2-2-折半插入排除" class="headerlink" title="7.2.2 折半插入排除"></a>7.2.2 折半插入排除</h4><h4 id="7-2-3-希尔（shell）排序"><a href="#7-2-3-希尔（shell）排序" class="headerlink" title="7.2.3 希尔（shell）排序"></a>7.2.3 希尔（shell）排序</h4><h3 id="7-3-交换排序"><a href="#7-3-交换排序" class="headerlink" title="7.3 交换排序"></a>7.3 交换排序</h3><h4 id="7-3-1-冒泡排序"><a href="#7-3-1-冒泡排序" class="headerlink" title="7.3.1 冒泡排序"></a>7.3.1 冒泡排序</h4><h4 id="7-3-2-快速排序"><a href="#7-3-2-快速排序" class="headerlink" title="7.3.2 快速排序"></a>7.3.2 快速排序</h4><h4 id="7-3-3-选择排序"><a href="#7-3-3-选择排序" class="headerlink" title="7.3.3 选择排序"></a>7.3.3 选择排序</h4><h4 id="7-3-4-简单选择排序"><a href="#7-3-4-简单选择排序" class="headerlink" title="7.3.4 简单选择排序"></a>7.3.4 简单选择排序</h4><h3 id="7-4-堆排序"><a href="#7-4-堆排序" class="headerlink" title="7.4 堆排序"></a>7.4 堆排序</h3><h3 id="7-5-归并排序"><a href="#7-5-归并排序" class="headerlink" title="7.5 归并排序"></a>7.5 归并排序</h3><h3 id="7-6-二路归并排序"><a href="#7-6-二路归并排序" class="headerlink" title="7.6 二路归并排序"></a>7.6 二路归并排序</h3><h3 id="7-7-基数排序"><a href="#7-7-基数排序" class="headerlink" title="7.7 基数排序"></a>7.7 基数排序</h3><h3 id="7-8-各种内部排序算法的比较"><a href="#7-8-各种内部排序算法的比较" class="headerlink" title="7.8 各种内部排序算法的比较"></a>7.8 各种内部排序算法的比较</h3><table>  <tr>    <th align="center" rowspan="2">分类</th>    <th rowspan="2">排序方法</th>    <th align="center" colspan="3">时间复杂度</th>    <th rowspan="2">空间复杂度</th>    <th rowspan="2">稳定性</th>    </tr>  <tr>    <th>最坏情况</th>    <th>最好情况</th>    <th>平均情况</th>  </tr>    <tr >    <td rowspan="3">插入排序</td>    <td>直接插入排序</td>    <td>$$O(n^2)$$</td>    <td>$$O(n)$$</td>    <td>$$O(n^2)$$</td>    <td>$$O(1)$$</td>    <td>稳定</td>    </tr>    <tr>    <td>折半插入排序</td>    <td>$$O(n^2)$$</td>    <td>$$O(n)$$</td>    <td>$$O(n^2)$$</td>    <td>$$O(1)$$</td>    <td>稳定</td>    </tr>    <tr>    <td>希尔排序</td>    <td></td>    <td></td>    <td>$$O(n^{1.3})$$</td>    <td>$$O(1)$$</td>    <td bgcolor="#00FF00">不稳定</td>    </tr>    <tr>    <td rowspan="2">交换排序</td>    <td>冒泡排序</td>    <td>$$O(n^2)$$</td>    <td>$$O(n)$$</td>    <td>$$O(n^2)$$</td>    <td>$$O(1)$$</td>    <td>稳定</td>    </tr>    <tr>    <td        >快速排序</td>      <td>$$O(n^2)$$</td>    <td>$$O(n*log_2n)$$</td>    <td>$$O(n*log_2n)$$</td>    <td>$$O(log_2n)$$</td>    <td bgcolor="#00FF00">不稳定</td>    </tr>    <tr>    <td rowspan="2">选择排序</td>      <td>简单选择排序</td>      <td>$$O(n^2)$$</td>    <td>$$O(n^2)$$</td>    <td>$$O(n^2)$$</td>    <td>$$O(1)$$</td>    <td bgcolor="#00FF00">不稳定</td>    </tr>    <tr>      <td>堆排序</td>      <td>$$O(n*log_2n)$$</td>    <td>$$O(n*log_2n)$$</td>    <td>$$O(n*log_2n)$$</td>    <td>$$O(1)$$</td>    <td bgcolor="#00FF00">不稳定</td>    </tr>    <tr>    <td rowspan="1"></td>      <td>二路归并排序</td>      <td>$$O(n*log_2n)$$</td>    <td>$$O(n*log_2n)$$</td>    <td>$$O(n*log_2n)$$</td>    <td>$$O(1)$$</td>    <td>稳定</td>    </tr>    <tr>    <td rowspan="1"></td>      <td >基数排序</td>      <td>$$O(n+r)$$</td>    <td>$$O(n+r)$$</td>    <td>$$O(n+r)$$</td>    <td>$$O(r)$$</td>    <td>稳定</td>    </tr></table><blockquote><p>简单选择排序：<br>    比较次数：<script type="math/tex">O(n^2)</script><br>    移动次数：<script type="math/tex">O(n)</script><br>二路归并排序：与初始序列无关</p></blockquote><h3 id="7-9-内部排序算法的应用"><a href="#7-9-内部排序算法的应用" class="headerlink" title="7.9 内部排序算法的应用"></a>7.9 内部排序算法的应用</h3><h2 id="八、参考书目"><a href="#八、参考书目" class="headerlink" title="八、参考书目"></a>八、参考书目</h2><p>从考试大纲看，所要求的知识在一般的大学数据结构教材中都已经包含，所以，选择哪本书并不是重要的事情。我们推荐清华大学出版社的《数据结构（第二版）》（严蔚敏主编）。这本书有多种语言的版本，建议选择C语言的版本，在复习的过程中，还可以配以相应的习题集。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;考查目标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;理解数椐结构的基本概念、掌握数椐的逻辑结构、存储结构及其差异，以及各种基本操作的实现。&lt;/li&gt;
&lt;li&gt;掌握基本的数据处理原理和方法，在此基础上能够对算法进行设计与分析。&lt;/li&gt;
&lt;li&gt;能够选择合适的数椐结构和方法进行问题求解。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以西北工业大学801计算机专业基础为考纲&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Study" scheme="https://mysticalguest.github.io/categories/Study/"/>
    
    
      <category term="计算机基础" scheme="https://mysticalguest.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络课程复习</title>
    <link href="https://mysticalguest.github.io/Study/41461.html"/>
    <id>https://mysticalguest.github.io/Study/41461.html</id>
    <published>2021-01-08T12:53:37.022Z</published>
    <updated>2021-04-23T08:22:08.041Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>考查目标：</p><ol><li>掌握计算机网络的基本概念、基本原理和基本方法。</li><li>掌握计算机网络的体系结构和典型网络协议，了解典型网络设备的组成和特点，理解典型网络设备的工作原理。</li><li>能够运用计算机网络基本概念、基本原理和基本方法进行网络系统分析、设计和应用。</li></ol><p>以西北工业大学801计算机专业基础为考纲</p></blockquote><a id="more"></a><h2 id="一、计算机网络体系结构"><a href="#一、计算机网络体系结构" class="headerlink" title="一、计算机网络体系结构"></a>一、计算机网络体系结构</h2><h3 id="1-1-计算机网络概述"><a href="#1-1-计算机网络概述" class="headerlink" title="1.1 计算机网络概述"></a>1.1 计算机网络概述</h3><h4 id="1-1-1-计算机网络的概念、组成与功能"><a href="#1-1-1-计算机网络的概念、组成与功能" class="headerlink" title="1.1.1 计算机网络的概念、组成与功能"></a>1.1.1 计算机网络的概念、组成与功能</h4><ul><li>计算机网络是“以相互共享资源的方式互联起来的自治计算机系统的集合”。</li><li>计算机网络通常由3个部分组成，分别是资源子网、通信子网和通信协议。</li></ul><div class="table-container"><table><thead><tr><th>组成</th><th>资源子网</th><th>通信子网</th><th>通信协议</th></tr></thead><tbody><tr><td>包括</td><td>主机与终端、终端控制器、联网外设、各种网络软件与数据资源</td><td>路由器、各种互联设备与通信线路</td><td>通信双方必须共同遵守的规则和约定就称为通信协议</td></tr><tr><td>作用</td><td>负责全网的数据处理业务，向网络用户提供各种网络资源与网络服务</td><td>负责完成网络数据传输、路由与分组转发等信息处理任务</td><td>等</td></tr></tbody></table></div><ul><li>计算机网络的功能</li></ul><div class="table-container"><table><thead><tr><th>主要功能</th><th>详细</th><th>作用</th></tr></thead><tbody><tr><td>数据通信</td><td>依照一定的通信协议，利用数据传输技术在两个终端之间传递数据信息的一种通信方式和通信业务</td><td>实现计算机和计算机、计算机和终端以及终端与终端之间的数据信息传递，是继电报、电话业务之后的第三种最大的通信业务</td></tr><tr><td>资源共享</td><td>资源共享是人们建立计算机网络的主要目的之一。计算机资源包括硬件资源、软件资源和数据资源</td><td>硬件资源的共享可以提高设备的利用率，避免设备的重复投资，如利用计算机网络建立网络打印机；软件资源和数据资源的共享可以充分利用已有的信息资源，减少软件开发过程中的劳动，避免大型数据库的重复建设</td></tr><tr><td>集中管理</td><td>计算机网络技术的发展和应用，已使得现代的办公手段、经营管理等发生了变化</td><td>管理信息系统、办公自动化系统等，通过这些系统可以实现日常工作的集中管理，提高工作效率，增加经济效益</td></tr><tr><td>实现分布式处理</td><td>网络技术的发展，使得分布式计算成为可能</td><td>对于大型的课题，可以分为许许多多小题目，由不同的计算机分别完成，然后再集中起来，解决问题</td></tr><tr><td>负荷均衡</td><td>负荷均衡是指工作被均匀的分配给网络上的各台计算机系统</td><td>网络控制中心负责分配和检测，当某台计算机负荷过重时，系统会自动转移负荷到较轻的计算机系统去处理</td></tr></tbody></table></div><h4 id="1-1-2-计算机网络的分类"><a href="#1-1-2-计算机网络的分类" class="headerlink" title="1.1.2 计算机网络的分类"></a>1.1.2 计算机网络的分类</h4><ul><li>计算机网络的分类方法有多种，其中最主要的方法是根据<strong>覆盖范围</strong>进行分类的方法。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">分类</th><th>覆盖范围(Reference)</th><th>详细</th><th>特点</th><th>种类</th></tr></thead><tbody><tr><td style="text-align:center">广域网(Wide Area Network; WAN)</td><td>&gt;100km</td><td>也称为远程网。一般是在不同城市之间的LAN或者MAN网络互联</td><td>距离较远，信息衰减比较严重，所以这种网络一般是要租用专线，通过IMP（接口信息处理）协议和线路连接起来，构成网状结构，解决循径问题</td><td>邮电部的CHINANET，CHINAPAC，和CHINADDN网</td></tr><tr><td style="text-align:center">城域网(Metropolitan Area Network; MAN)</td><td>10~100km</td><td>早期以光纤为传输介质。宽带城域网以IP为基础，通过<strong>计算机网络、广播电视网、电信网三网融合</strong></td><td>完善的光纤传输网是基础。传统电信、有线电视与IP业务的融合成为宽带城域网的核心业务。高端路由器和多层交换机是核心设备。扩大宽带接入规模与服务质量是应用关键</td><td>提供普通家庭用户和集团用户高速接入因特网、局域网互连以及VPN/VPDN等业务</td></tr><tr><td style="text-align:center">局域网(Local Area Network; LAN)</td><td>10m~10km</td><td>局部地区范围内的网络。局域网一般位于一个建筑物或一个单位内，不存在寻径问题，不包括网络层的应用</td><td>连接范围窄、用户数少、配置容易、连接速率高</td><td><strong>以太网</strong>（<strong>Ethernet</strong>）、令牌环网（Token Ring）、光纤分布式接口网络（FDDI）、异步传输模式网（ATM）以及最新的无线局域网（WLAN）</td></tr><tr><td style="text-align:center">个人区域网(Personal Area Network; PAN)</td><td>&lt;10m</td><td>个人操作空间(Personal Operating Space; POS)。无线个人区域网络(WPAN)。近距离不同移动办公设备之间低速互联</td><td>蓝牙：开放的规范，近距离无线通信，语音和数据传输，世界任何地方通信<br>ZigBee：低功耗、低速率、低成本</td><td>蓝牙技术与ZigBee技术（近距离无线通信）</td></tr></tbody></table></div><h4 id="1-1-3-计算机网络与互联网的发展历史"><a href="#1-1-3-计算机网络与互联网的发展历史" class="headerlink" title="1.1.3 计算机网络与互联网的发展历史"></a>1.1.3 计算机网络与互联网的发展历史</h4><ul><li><p>第一阶段：计算机网络技术与理论准备阶段（20世纪50年代）</p><blockquote><p>数据通信技术日趋成熟，为计算机网络的形成奠定技术基础</p><p>分组交换概念的提出为计算机网络的研究奠定了理论基础</p></blockquote></li><li><p>第二阶段：计算机网络的形成（20世纪60年代）</p><blockquote><p>ARPANET的成功运行证明了分组交换理论的正确性</p><p>TCP/IP协议的广泛应用为更大规模的网络互联奠定了坚实的基础</p><p>E-mail、FTP、TELNET、BBS等应用展现出网络技术广阔的应用前景</p></blockquote></li><li><p>第三阶段：网络体系结构的研究（20世纪70年代中期）</p><blockquote><p>网络体系结构与协议的标准化研究，对更大规模的网络互联起到推动作用</p><p>国际标准化组织(ISO)在推动“<strong>开放系统互连(Open System Interconnection, OSI)参考模型</strong>”与网络协议标准化研究方面做了大量工作</p><p>OSI参考模型的研究对网络理论体系的形成与发展，以及在网络协议标准化研究方面起到了重要的推动作用</p><p>TCP/IP经受了市场和用户的检验，吸引了大量的投资，推动了Internet应用的发展，成为业界标准</p></blockquote></li><li><p>第四阶段：Internet应用、无线网络与网络安全技术研究的发展</p><blockquote><p>Internet作为全球性的国际网与大型信息系统</p><p>Internet大规模接入推动了接入技术的发展</p><p>对等(Peer-to-Peer, P2P)网络技术的研究，使得“即时通信”等新的网络应用不断涌现</p><p>WPAN、WLAN与WMAN技术日益成熟，并应用阶段。无线自组网、无线传感器网络受到高度重视</p><p>物联网技术形成与发展</p><p>网络安全技术快速发展</p></blockquote></li></ul><h3 id="1-2计算机网络的标准化工作及相关组织。"><a href="#1-2计算机网络的标准化工作及相关组织。" class="headerlink" title="1.2计算机网络的标准化工作及相关组织。"></a>1.2计算机网络的标准化工作及相关组织。</h3><h4 id="1-2-1-网络协议标准化组织"><a href="#1-2-1-网络协议标准化组织" class="headerlink" title="1.2.1 网络协议标准化组织"></a>1.2.1 网络协议标准化组织</h4><ul><li><p>国际电信联盟（International Telecommunications Union, ITU）</p><p>负责电信方面的标准制定。</p></li><li><p>国际标准化组织（International Organization for Standardization, ISO）</p><p>组织制定国际标准。ISO中负责数据通信标准的是ISO第97技术委员会（TC97）。OSI参考模型就是由ISO的TC97组织制定的。</p></li><li><p>电子工业协会（Electronic Industries Association, EIA）</p><p>制定的RS-232接口标准在通信中应用广泛。</p></li><li><p>电气电子工程师协会（Institute of Electrical and Electronics Engineers, IEEE）</p><p>组织制定了局域网中最重要的802系列标准。</p></li></ul><h3 id="1-3-计算机网络体系结构与参考模型"><a href="#1-3-计算机网络体系结构与参考模型" class="headerlink" title="1.3 计算机网络体系结构与参考模型"></a>1.3 计算机网络体系结构与参考模型</h3><h4 id="1-3-1-计算机网络分层结构"><a href="#1-3-1-计算机网络分层结构" class="headerlink" title="1.3.1 计算机网络分层结构"></a>1.3.1 计算机网络分层结构</h4><ul><li>OSI体系结构：应用层，表示层，会话层，运输层，网络层，数据链路层，物理层</li><li>TCP/IP体系结构：应用层，运输层（TCP或UDP），网际层（IP），网络接口层</li><li>五层协议体系结构：应用层，运输层，网络层，数据链路层，物理层</li></ul><h4 id="1-3-2-计算机网络协议、接口、服务等概念"><a href="#1-3-2-计算机网络协议、接口、服务等概念" class="headerlink" title="1.3.2 计算机网络协议、接口、服务等概念"></a>1.3.2 计算机网络协议、接口、服务等概念</h4><ul><li><p>协议就是一组<strong>控制数据交互</strong>过程的通信规则，这些为网络数据交换制定的通信规则、约定与标准被称为“网络协议”</p><blockquote><p>网络协议三要素：</p><p>（1）语义：解释<em>控制信息</em>每个部分的意义（包括用于协调同步和差错处理的控制信息）</p><p>（2）语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序（包括数据格式、编码和信号电平等）</p><p>（3）时序（定时/同步）：是对事件发生顺序地详细说明</p></blockquote></li><li><p><em>层次结构</em>是处理计算机网络问题最基本的方法。对于一些难以处理的复杂问题，通常采用分解为若干个容易处理的、小一些的问题，“化整为零，分而治之”的方法去解决</p></li><li><p>在邮政系统中，邮箱就是发信人、收信人与邮递员之间交互的接口。接口是同一主机内<strong>相邻层之间交换信息</strong>的连接点</p></li><li><p>实体：任何可<strong>发送或接受信息</strong>的<strong>硬件或软件进程</strong>，通常是个特定的软件模块。</p><blockquote><p>第n层的活动元素称为n层实体</p><p>不同机器上同一层称为对等层，同一层的实体叫做<strong>对等实体</strong></p></blockquote></li><li><p>服务：下层为相邻上层提供的功能调用，垂直的。对等实体在协议的控制下使得本层能为上一层提供服务。</p></li></ul><h4 id="1-3-3-ISO-OSI参考模型和TCP-IP模型"><a href="#1-3-3-ISO-OSI参考模型和TCP-IP模型" class="headerlink" title="1.3.3 ISO/OSI参考模型和TCP/IP模型"></a>1.3.3 ISO/OSI参考模型和TCP/IP模型</h4><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/computernetwork/stratification.png" style="zoom: 90%;" /></p><h2 id="二、物理层"><a href="#二、物理层" class="headerlink" title="二、物理层"></a>二、物理层</h2><p>物理层提供了编码、解码，时钟提取、发送、接收和载波检测等功能，并为数据链路层提供服务。协议中规定了物理链路操作的电气和机械特性参数。</p><p>由4个部分组成：物理介质；物理介质连接设备（PMA）或接口；接口电缆；物理收发信号（PLS）。</p><h3 id="2-1-通信基础"><a href="#2-1-通信基础" class="headerlink" title="2.1 通信基础"></a>2.1 通信基础</h3><h4 id="2-1-1-信道、信号、宽带、码元、波特、速率、信源与信宿等基本概念"><a href="#2-1-1-信道、信号、宽带、码元、波特、速率、信源与信宿等基本概念" class="headerlink" title="2.1.1 信道、信号、宽带、码元、波特、速率、信源与信宿等基本概念"></a>2.1.1 信道、信号、宽带、码元、波特、速率、信源与信宿等基本概念</h4><ul><li><p>信道：通信的通道，是信号传输的媒介</p></li><li><p>信号：在通信系统中，二进制代码0、1比特序列必须变换成不同的电平或频率变化的信号之后，才能通过传输介质进行传输</p><script type="math/tex; mode=display">\begin{cases}模拟信号：连续变化的信号\\数字信号：离散的脉冲序列\\\end{cases}</script></li><li><p>带宽：网络的通信线路传送数据的能力。即：在单位时间内从网络中的某一个点到另一点所能通过的“最高数据率”（单位：赫兹Hz）</p></li><li><p>码元：在数字通信中常常用时间间隔相同的符号来表示一个<em>二进制数字</em>，这样的时间间隔内的信号称为(二进制）码元</p><blockquote><p>一个数字脉冲就是一个码元</p></blockquote></li><li><p>波特（Baud）：调制速率描述<code>通过模拟线路传输模拟数据信号</code>的过程中，从调制解调器输出的调制信号每秒钟<em>载波调制状态改变的数值</em>，单位是1/s，称为波特</p><blockquote><p>1波特表示数字通信系统每秒传输1个码元，单位时间内数字通信系统所传输的码元个数</p><p>波特率：调制速率也称为波特率，波特率描述的是<strong>码元</strong>传输的速率。</p><p>与比特率的比较。</p></blockquote></li><li><p>速率：连接在计算机网络上的主机在数字信道上传送数据的速率，也称为数据率或<strong>比特率</strong>。单位<script type="math/tex">bit/s, bps, kbps, Mbps</script></p></li><li><p>信源：发送数据的一方</p></li><li><p>信宿：接收数据的一方</p></li></ul><h4 id="2-1-2-奈奎斯特定理与香农定理"><a href="#2-1-2-奈奎斯特定理与香农定理" class="headerlink" title="2.1.2 奈奎斯特定理与香农定理"></a>2.1.2 奈奎斯特定理与香农定理</h4><p>描述信道带宽与数据传输速率到底有什么关系？从定量的角度描述“带宽”与“速率”间的联系。</p><ul><li><p>Nyquist准则（<code>有限带宽，无噪声</code>）</p><p>理想信道，前后码元间不产生相互串扰<script type="math/tex">R_{max}=2B(bps), 2Blog_2V?</script>，对于二进制数据，如果信道带宽<script type="math/tex">B=3000Hz</script>，则最大传输速率为<script type="math/tex">6000bps</script>。</p><blockquote><p>若用V表示每个码元离散电平的数目，则理想低通信信道下的<script type="math/tex">极限数据传输率=2Blog_2V(bps)</script></p></blockquote></li><li><p>Shanon定理（<code>有限带宽，有随机噪声</code>）</p><p>描述<script type="math/tex">R_{max}</script>和<script type="math/tex">B</script>、信号噪声功率比之间关系。信噪比S/N（无单位）。<script type="math/tex">R_{max}=B\ast log_2(1+S/N)</script></p><blockquote><p>信噪比是信号功率S与噪声功率N之比</p><p>如果<script type="math/tex">S/N=1000, B=3000Hz</script>，则<script type="math/tex">R_{max}\approx 30kbps</script>，表示数据传输速率不超过<script type="math/tex">30kbps</script>。</p><p>其中<script type="math/tex">S/N</script>越大，信息的极限传输速率越高。</p><p>通信系统中，信噪比通常以分贝（dB）表示，<script type="math/tex">S/N=10lg(S/N)</script></p><p>如果<script type="math/tex">S/N=1000</script>，用分贝表示的<script type="math/tex">S/N=30dB</script></p></blockquote></li><li><p>奈奎斯特采样定理</p><blockquote><p>现实世界接触到的诸如电信号、光信号、声音信号等这些信号都是随时间连续变化的，称之为连续信号。但对于计算机来说，处理这些连续的信号显然无能为力，要使计算机能够识别、计算、处理这些信号就必须将其转化为<strong>离散信号</strong>，将连续信号转换为离散信号的过程叫<code>采样</code>。</p></blockquote><p>采样后，计算得到的是离散的点，用这些离散的点来代替连续的线，就势必会产生误差，那么这个误差是不是在容许的范围内？根据采样得到的离散的点，能不能还原出连续的信号？</p><p>采样定理解释了采样率<script type="math/tex">f_S</script>和所测信号评率<script type="math/tex">f_N</script>之间的关系，<script type="math/tex">f_S>2f_N</script></p></li></ul><h4 id="2-1-3-编码与调制"><a href="#2-1-3-编码与调制" class="headerlink" title="2.1.3 编码与调制"></a>2.1.3 编码与调制</h4><ul><li><p>编码：把数字信号转换为另一种形式的数字信号</p><blockquote><p>常用编码方式：</p><p>（1）不归零制，归零制（正脉冲代表1，负脉冲代表0）</p><p>（2）差分不归零码（遇1就跳）</p><p>（3）曼彻斯特编码（位周期中心的向上跳变代表0，向下代表1，反之亦可）</p><p>（4）差分曼彻斯特（每一位的中心处始终有跳变。位开始边界有跳变为0，位开始边界无跳变为1）</p></blockquote></li><li><p>调制：将发送端的数字信号变换成模拟信号的过程。实现调制功能的设备称为“调制器”</p></li></ul><h4 id="2-1-4-电路交换、报文交换与分组交换"><a href="#2-1-4-电路交换、报文交换与分组交换" class="headerlink" title="2.1.4 电路交换、报文交换与分组交换"></a>2.1.4 电路交换、报文交换与分组交换</h4><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/computernetwork/dataexchange.png" alt=""></p><div class="table-container"><table><thead><tr><th>分类</th><th>内容</th><th>特点</th></tr></thead><tbody><tr><td>电路交换（Circuit Switching）</td><td>两台计算机通过通信子网进行数据交换之前，首先从信源到信宿建立一条实际的物理连接通道</td><td>在保持连接期间双方独占信道（没有冲突，浪费信道资源）。信道资源的利用效率较低。适用于交互式会话类通信。</td></tr><tr><td>报文交换</td><td>以报文为数据交换的单位，整块数据从源到宿由交换结点逐一中转</td><td>整块数据逐站<strong>存储转发</strong>。对报文的长度没有限制，对于大块数据（占用存储空间大，占用信道时间长）。延迟较大，不能实现交互式通信</td></tr><tr><td>分组交换</td><td>将数据拆分成分组，依次从源到宿经交换结点转发</td><td>分组的长度有上限控制，各自独立传输（占用信道时间短，占用缓存空间小）。信道共享（可充分利用信道资源，有可能发生资源(信道和结点）占用冲突）</td></tr></tbody></table></div><ul><li><p>电路交换补充</p><ul><li><p>电路交换工作过程：电路建立阶段，数据传输阶段，电路拆除阶段。</p></li><li><p>无差错检测，建立的是一条双方独占的物理通路。错误率比较低，比较稳定，但无差错检测的功能，一旦发生错误，数据就会丢失，而不会要求重发。（无差错检测不代表不需要？）</p></li></ul></li><li><p>分组交换的优点</p><ul><li>比报文交换的延迟小</li><li>比电路交换的效率高</li><li>适于计算机网络通信</li></ul><blockquote><p>分组交换有保证可靠性的网络协议。当存储转发时，某一个节点或链路突然<em>出故障</em>，在各路由器中运行的<em>路由选择协议</em>能自动找到其他路径转发。</p></blockquote></li><li><p>分组交换的缺点</p><ul><li>仍然有延迟，不能满足实时多媒体通信的服务质量</li><li>需要解决冲突检测、拥塞控制和纠错重发等问题</li></ul></li></ul><h4 id="2-1-5-数据报与虚电路"><a href="#2-1-5-数据报与虚电路" class="headerlink" title="2.1.5 数据报与虚电路"></a>2.1.5 数据报与虚电路</h4><p>分组交换技术可以分为2类：数据报（Data Gram, DG）与虚电路（Virtual Circuit, VC）。</p><ul><li><p>数据报方式</p><p>尽最大努力交付，可靠性低但有差错检测，一旦出错，就会要求重发</p></li><li><p>虚电路方式</p></li></ul><h3 id="2-2-传输介质"><a href="#2-2-传输介质" class="headerlink" title="2.2 传输介质"></a>2.2 传输介质</h3><h4 id="2-2-1-双绞线、同轴电缆、光纤与无线传输介质"><a href="#2-2-1-双绞线、同轴电缆、光纤与无线传输介质" class="headerlink" title="2.2.1 双绞线、同轴电缆、光纤与无线传输介质"></a>2.2.1 双绞线、同轴电缆、光纤与无线传输介质</h4><h4 id="2-2-2-物理层接口的特性"><a href="#2-2-2-物理层接口的特性" class="headerlink" title="2.2.2 物理层接口的特性"></a>2.2.2 物理层接口的特性</h4><h3 id="2-3-物理层设备"><a href="#2-3-物理层设备" class="headerlink" title="2.3 物理层设备"></a>2.3 物理层设备</h3><h4 id="2-3-1-中继器"><a href="#2-3-1-中继器" class="headerlink" title="2.3.1 中继器"></a>2.3.1 中继器</h4><h4 id="2-3-2-集线器"><a href="#2-3-2-集线器" class="headerlink" title="2.3.2 集线器"></a>2.3.2 集线器</h4><h2 id="三、数据链路层"><a href="#三、数据链路层" class="headerlink" title="三、数据链路层"></a>三、数据链路层</h2><p>包括2个子层：逻辑链路控制（<code>Logical Link Control, LLC</code>）子层和介质访问控制（<code>Medium Access Control, MAC</code>）子层。</p><h3 id="3-1-数据链路层的功能"><a href="#3-1-数据链路层的功能" class="headerlink" title="3.1 数据链路层的功能"></a>3.1 数据链路层的功能</h3><p>采取差错检测、差错控制与流量控制等方法，将有差错的物理线路改进成无差错的数据链路，向网络层提供高质量的数据传输服务。</p><p>数据链路层的通信规程主要有两类：<strong>面向字符型</strong>的通信规程和<strong>面向比特型</strong>的通信规程（同步数据链路控制规程）</p><h3 id="3-2-组帧（这是一个动词）"><a href="#3-2-组帧（这是一个动词）" class="headerlink" title="3.2 组帧（这是一个动词）"></a>3.2 组帧（这是一个动词）</h3><ul><li>封装成帧：在一段数据的前后部分添上首部和尾部，这就构成了一个帧。接收端在接收到物理层上传的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。</li><li>组帧：为了使接收方能够正确地接收并检查所传输的帧，发送方必须依据一定规则把网络层递交的分组封装成帧。</li><li>组帧的4种方法：字符计数法、首尾填充法、零比特填充法，违规编程法。</li></ul><h3 id="3-3-差错控制"><a href="#3-3-差错控制" class="headerlink" title="3.3 差错控制"></a>3.3 差错控制</h3><p>在计算机通信中，研究<strong>检测与纠正比特流传输错误</strong>的方法称为“差错控制”。差错控制的目的是减少物理线路的传输错误。在设计差错控制方法时提出以下2种策略：</p><h4 id="3-3-1-检错编码"><a href="#3-3-1-检错编码" class="headerlink" title="3.3.1 检错编码"></a>3.3.1 检错编码</h4><p>检错码为每个传输单元加上一定的冗余信息，接收端可以根据这些冗余信息<strong>发现</strong>传输差错，但是不能确定是哪一位或哪些位出错，并且自己不能够自动纠正传输错误。</p><p>常用的检错码有奇偶校验码（垂直、水平、垂直水平奇偶校验（也叫方阵码））和循环冗余码（CRC）。</p><h4 id="3-3-2-纠错编码"><a href="#3-3-2-纠错编码" class="headerlink" title="3.3.2 纠错编码"></a>3.3.2 纠错编码</h4><p>纠错码为每个传输单元加上足够多的冗余信息，以便接收端能够发现，并能够自动<strong>纠正</strong>传输差错。</p><blockquote><p>检错码需要通过重传机制达到纠错目的，但工作原理简单，实现起来容易，广泛使用。</p><p>纠错码有优越之处，但实现起来困难，在一般的通信场所不易采用。</p></blockquote><h3 id="3-4-流量控制与可靠传输机制"><a href="#3-4-流量控制与可靠传输机制" class="headerlink" title="3.4 流量控制与可靠传输机制"></a>3.4 流量控制与可靠传输机制</h3><h4 id="3-4-1-流量控制、可靠传输与滑动窗口机制"><a href="#3-4-1-流量控制、可靠传输与滑动窗口机制" class="headerlink" title="3.4.1 流量控制、可靠传输与滑动窗口机制"></a>3.4.1 流量控制、可靠传输与滑动窗口机制</h4><ul><li><p>流量控制（流控）</p><blockquote><p>是一种协调发送站的发送速率和接收站的接收速率一致性的数据传输同步技术，发送速率是指生成和发送帧的速率。</p></blockquote><p>发送端发送数据超过物理线路的传输能力或超过接收端的帧接收能力时，就会造成<strong>链路拥塞</strong>。为了防止链路拥塞，数据链路层必须具有流量控制功能。（避免淹没物理线路和接收端，同步失调）解决同步失调和高效利用介质问题。</p></li><li><p>停止-等待协议（1位滑动窗口协议）</p></li><li><p>带有差错控制的滑动窗口协议（多帧连续发送）</p><ul><li>后退N帧协议（GBN）</li><li>选择重传协议（SR）</li></ul></li></ul><h3 id="3-5-介质访问控制"><a href="#3-5-介质访问控制" class="headerlink" title="3.5 介质访问控制"></a>3.5 介质访问控制</h3><p>无论何种Ethernet，其MAC层均采用争用型介质访问控制协议，即载波监听多路访问/冲突检测。</p><h4 id="3-5-1-信道划分介质访问控制："><a href="#3-5-1-信道划分介质访问控制：" class="headerlink" title="3.5.1 信道划分介质访问控制："></a>3.5.1 信道划分介质访问控制：</h4><p>频分多路复用、时分多路复用、波分多路复用、码分多路复用的概念和基本原理;</p><h4 id="3-5-2-随即访问介质访问控制："><a href="#3-5-2-随即访问介质访问控制：" class="headerlink" title="3.5.2 随即访问介质访问控制："></a>3.5.2 随即访问介质访问控制：</h4><p>ALOHA协议，CSMA协议，CSMA/CD协议，CSMA/CA协议</p><h4 id="3-5-3-轮询访问介质访问控制：令牌传递协议。"><a href="#3-5-3-轮询访问介质访问控制：令牌传递协议。" class="headerlink" title="3.5.3 轮询访问介质访问控制：令牌传递协议。"></a>3.5.3 轮询访问介质访问控制：令牌传递协议。</h4><h3 id="3-6-局域网"><a href="#3-6-局域网" class="headerlink" title="3.6 局域网"></a>3.6 局域网</h3><h4 id="3-6-1-局域网的基本概念与体系结构"><a href="#3-6-1-局域网的基本概念与体系结构" class="headerlink" title="3.6.1 局域网的基本概念与体系结构"></a>3.6.1 局域网的基本概念与体系结构</h4><p>局域网是指传输距离有限，传输速率较高，以共享网络资源为主要目的的网络系统。</p><h4 id="3-6-2-以太网与IEEE-802-3"><a href="#3-6-2-以太网与IEEE-802-3" class="headerlink" title="3.6.2 以太网与IEEE 802.3"></a>3.6.2 以太网与IEEE 802.3</h4><h4 id="3-6-3-IEEE-802-11（无线局域网）"><a href="#3-6-3-IEEE-802-11（无线局域网）" class="headerlink" title="3.6.3 IEEE 802.11（无线局域网）"></a>3.6.3 IEEE 802.11（无线局域网）</h4><h4 id="3-6-4-令牌环网的基本原理"><a href="#3-6-4-令牌环网的基本原理" class="headerlink" title="3.6.4 令牌环网的基本原理"></a>3.6.4 令牌环网的基本原理</h4><h3 id="3-7-广域网"><a href="#3-7-广域网" class="headerlink" title="3.7 广域网"></a>3.7 广域网</h3><h4 id="3-7-1-广域网的基本概念"><a href="#3-7-1-广域网的基本概念" class="headerlink" title="3.7.1 广域网的基本概念"></a>3.7.1 广域网的基本概念</h4><p>广域网是指覆盖范围广，传输速率相对较低，以数据通信为主要目的的数据通信网。</p><h4 id="3-7-2-PPP协议"><a href="#3-7-2-PPP协议" class="headerlink" title="3.7.2 PPP协议"></a>3.7.2 PPP协议</h4><h4 id="3-7-3-HDLC协议"><a href="#3-7-3-HDLC协议" class="headerlink" title="3.7.3 HDLC协议"></a>3.7.3 HDLC协议</h4><ul><li><p>背景</p><p>ISO将SDLC协议（面向比特型）修改后的高级数据链路控制（HDLC）协议作为国际标准（ISO 3309）。目前很多流行的数据链路层协议，如Ethernet帧结构与PPP协议，都是在HDLC基础上修改，或是取其子集形成的。</p></li><li><p>数据链路的配置方式和数据传送方式</p><p>HDLC数据链路有2种基本配置方式：非平衡配置与平衡配置</p><ul><li><p>非平衡配置</p><p>一组主机根据在通信过程中的地位分为主站与从站（次站），由主站来控制数据链路的工作过程。</p></li></ul></li></ul><h3 id="3-8-数据链路层设备"><a href="#3-8-数据链路层设备" class="headerlink" title="3.8 数据链路层设备"></a>3.8 数据链路层设备</h3><h4 id="3-8-1-网桥的概念及其基本原理"><a href="#3-8-1-网桥的概念及其基本原理" class="headerlink" title="3.8.1 网桥的概念及其基本原理"></a>3.8.1 网桥的概念及其基本原理</h4><h4 id="3-8-2-局域网交换机及其工作原理"><a href="#3-8-2-局域网交换机及其工作原理" class="headerlink" title="3.8.2 局域网交换机及其工作原理"></a>3.8.2 局域网交换机及其工作原理</h4><h3 id="3-9-延时问题"><a href="#3-9-延时问题" class="headerlink" title="3.9 延时问题"></a>3.9 延时问题</h3><h4 id="3-9-1-Ethernet技术的研究与发展"><a href="#3-9-1-Ethernet技术的研究与发展" class="headerlink" title="3.9.1 Ethernet技术的研究与发展"></a>3.9.1 Ethernet技术的研究与发展</h4><p>评价网络性能的两个参数是传播延时和带宽，<script type="math/tex">传播延时带宽积=传播延时*带宽</script></p><h4 id="3-9-2-帧传播总延时分析"><a href="#3-9-2-帧传播总延时分析" class="headerlink" title="3.9.2 帧传播总延时分析"></a>3.9.2 帧传播总延时分析</h4><ul><li><p>传播延时<script type="math/tex">t_p</script></p><p>指电信号通过传输介质从发送端到接收端的传播时间。则<script type="math/tex">t_p=\frac{传输介质的长度L}{电磁波传播速度v}=\frac{L}{v}</script></p></li><li><p>发送延时<script type="math/tex">t_f</script></p><p>指主机发送数据帧比特序列所需时间。则<script type="math/tex">\frac{帧长度}{发送速率}</script></p></li><li><p>处理延时<script type="math/tex">t_{pr}</script></p><p>指接收端接收帧和处理帧所需要的时间。</p><p>在理想状态下，帧传输总延时<script type="math/tex">t_T</script>计算公式：<script type="math/tex">t_T=(t_p+t_f+t_r)+(t_a+t_p+t_{pr})=2t_p+2t_{pr}+t_f+t_a</script></p><blockquote><p><script type="math/tex">t_a</script>是确认帧ACK的发送延时，通常很短，可以忽略。</p><p>帧的处理延时<script type="math/tex">t_{pr}</script>小于帧发送延时<script type="math/tex">t_f</script>与传播延时<script type="math/tex">t_p</script>，<script type="math/tex">t_{pr}</script>可以忽略</p></blockquote><p>简化后的帧传输总延时为：<script type="math/tex">t_T\approx t_f+2t_p</script></p></li></ul><h2 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h2><p>网络层及以上使用IP地址，其他层使用硬件地址（Mac，物理地址）</p><h3 id="4-1-网络层的功能"><a href="#4-1-网络层的功能" class="headerlink" title="4.1 网络层的功能"></a>4.1 网络层的功能</h3><h4 id="4-1-1-异构网络互联"><a href="#4-1-1-异构网络互联" class="headerlink" title="4.1.1 异构网络互联"></a>4.1.1 异构网络互联</h4><h4 id="4-1-2-路由与转发"><a href="#4-1-2-路由与转发" class="headerlink" title="4.1.2 路由与转发"></a>4.1.2 路由与转发</h4><h4 id="4-1-3-拥塞控制"><a href="#4-1-3-拥塞控制" class="headerlink" title="4.1.3 拥塞控制"></a>4.1.3 拥塞控制</h4><h3 id="4-2-路由算法"><a href="#4-2-路由算法" class="headerlink" title="4.2 路由算法"></a>4.2 路由算法</h3><h4 id="4-2-1-静态路由与动态路由"><a href="#4-2-1-静态路由与动态路由" class="headerlink" title="4.2.1 静态路由与动态路由"></a>4.2.1 静态路由与动态路由</h4><h4 id="4-2-2-距离-向量路由算法"><a href="#4-2-2-距离-向量路由算法" class="headerlink" title="4.2.2 距离-向量路由算法"></a>4.2.2 距离-向量路由算法</h4><h4 id="4-2-3-链路状态路由算法"><a href="#4-2-3-链路状态路由算法" class="headerlink" title="4.2.3 链路状态路由算法"></a>4.2.3 链路状态路由算法</h4><h4 id="4-2-4-层次路由"><a href="#4-2-4-层次路由" class="headerlink" title="4.2.4 层次路由"></a>4.2.4 层次路由</h4><h3 id="4-3-IPv4"><a href="#4-3-IPv4" class="headerlink" title="4.3 IPv4"></a>4.3 IPv4</h3><blockquote><p>IP协议的主要特点：</p><ol><li>IP协议是一种无连接、不可靠的分组传送服务的协议</li><li>IP协议是点-点网络层通信协议</li><li>IP协议屏蔽了互联的网络在数据链路层、物理层协议与实现技术上的差异</li></ol></blockquote><h4 id="4-3-1-IPv4分组"><a href="#4-3-1-IPv4分组" class="headerlink" title="4.3.1 IPv4分组"></a>4.3.1 IPv4分组</h4><p>分组由2部分组成：分组头（首部）和数据</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/computernetwork/IPv4_packet_header.png" style="zoom:100%;" /></p><blockquote><p>图中分组头的每行宽度（0~31）共32位，4字节。前5行是分组头中必有字段，第6行开始是选项字段，因此IPv4分组头的基本长度（$4(字节)*5(行)$）20字节，最大长度（$20+40(字节的选项)$）60字节。</p></blockquote><h4 id="4-3-2-IPv4地址与NAT（Network-Address-Translation）"><a href="#4-3-2-IPv4地址与NAT（Network-Address-Translation）" class="headerlink" title="4.3.2 IPv4地址与NAT（Network Address Translation）"></a>4.3.2 IPv4地址与NAT（Network Address Translation）</h4><blockquote><p>研究NAT网络地址转换技术出于两个目的：一是由于IPv4过渡到IPv6进程缓慢，过渡技术之一的NAT短时间内有效缓解了IP地址短缺的问题；二是出于网络安全的目的（隐藏内部网络地址的目的）。</p></blockquote><p>连接到每个局域网的计算机都有一块网卡，就有一个MAC地址（物理地址）。IP地址（逻辑地址）是网络层的地址，主要用于路由器的寻址，因此IP地址采用层次结构。</p><h4 id="4-3-3-子网划分与子网掩码、CIDR"><a href="#4-3-3-子网划分与子网掩码、CIDR" class="headerlink" title="4.3.3 子网划分与子网掩码、CIDR"></a>4.3.3 子网划分与子网掩码、CIDR</h4><p><code>求子网掩码的方法</code></p><ul><li><p>如果需要划分出<script type="math/tex">64(2^6)</script>个子网，可以借用原16位主机号中的6位，该子网的主机号就变成10位。</p><p>B类IP地址：<script type="math/tex">190.1.2.26</script>（不需要化为2进制）</p><p>它的子网掩码用点分十进制表示为：<script type="math/tex">255.255.252.0</script></p><script type="math/tex; mode=display">\underbrace{11111111\ \ 11111111}_{16位的网络号}\ \ \underbrace{111111}_{16位主机号中的6位}00\ \ 00000000 \quad \quad 16+6=22</script><p>另一种表示法：<script type="math/tex">190.1.2.26/22(CIDR)</script></p></li><li><p>对一个B类IP地址<script type="math/tex">(156.26.0.0)</script>进行子网划分。该校园网由近210个局域网组成。（只要满足提供了210个子网即可，向上取整）由<script type="math/tex">2^7<210<2^8</script>，则<strong>借用8位主机号</strong>。</p><p>B类地址有16位主机号，借了8位主机号得到子网掩码为<script type="math/tex">255.255.255.0</script></p><p>根据以上方案，校园网可用IP地址如下：</p></li></ul><div class="table-container"><table><thead><tr><th>子网1</th><th><script type="math/tex">156.26.1.1 \sim 156.26.1.254</script></th></tr></thead><tbody><tr><td>子网2</td><td><script type="math/tex">156.26.2.1 \sim 156.26.2.254</script></td></tr><tr><td><script type="math/tex">\cdots</script></td><td><script type="math/tex">\cdots \sim \cdots</script></td></tr><tr><td>子网254</td><td><script type="math/tex">156.26.254.1 \sim 156.26.254.254</script></td></tr></tbody></table></div><p>  由于子网地址不能全为0或全1，因此校园网只能拥有254个子网。</p><h4 id="4-3-4-ARP协议、DHCP协议与ICMP协议"><a href="#4-3-4-ARP协议、DHCP协议与ICMP协议" class="headerlink" title="4.3.4 ARP协议、DHCP协议与ICMP协议"></a>4.3.4 ARP协议、DHCP协议与ICMP协议</h4><h3 id="4-4-IPv6"><a href="#4-4-IPv6" class="headerlink" title="4.4 IPv6"></a>4.4 IPv6</h3><h4 id="4-4-1-IPv6的主要特点"><a href="#4-4-1-IPv6的主要特点" class="headerlink" title="4.4.1 IPv6的主要特点"></a>4.4.1 IPv6的主要特点</h4><h4 id="4-4-2-IPv6地址"><a href="#4-4-2-IPv6地址" class="headerlink" title="4.4.2 IPv6地址"></a>4.4.2 IPv6地址</h4><h4 id="4-4-3-IPv4到IPv6的过渡技术"><a href="#4-4-3-IPv4到IPv6的过渡技术" class="headerlink" title="4.4.3 IPv4到IPv6的过渡技术"></a>4.4.3 IPv4到IPv6的过渡技术</h4><ul><li><p>NAT、CIDR和子网技术</p><p><code>NAT</code>：将专用网内部使用的本地IP地址转换成有效的外部全球IP地址，使得整个专用网只需要一个全球IP地址就可以与因特网联通。由于本地IP地址是可重用的，可大大减少IP地址的消耗。</p></li><li><p>双协议栈和隧道技术</p></li></ul><h3 id="4-5-路由协议"><a href="#4-5-路由协议" class="headerlink" title="4.5 路由协议"></a>4.5 路由协议</h3><h4 id="4-5-1-自治系统"><a href="#4-5-1-自治系统" class="headerlink" title="4.5.1 自治系统"></a>4.5.1 自治系统</h4><h4 id="4-5-2-域内路由与域间路由"><a href="#4-5-2-域内路由与域间路由" class="headerlink" title="4.5.2 域内路由与域间路由"></a>4.5.2 域内路由与域间路由</h4><h4 id="4-5-3-RIP路由协议"><a href="#4-5-3-RIP路由协议" class="headerlink" title="4.5.3 RIP路由协议"></a>4.5.3 RIP路由协议</h4><h4 id="4-5-4-OSPF路由协议"><a href="#4-5-4-OSPF路由协议" class="headerlink" title="4.5.4 OSPF路由协议"></a>4.5.4 OSPF路由协议</h4><h4 id="4-5-5-BGP路由协议"><a href="#4-5-5-BGP路由协议" class="headerlink" title="4.5.5 BGP路由协议"></a>4.5.5 BGP路由协议</h4><h3 id="4-6-IP组播"><a href="#4-6-IP组播" class="headerlink" title="4.6 IP组播"></a>4.6 IP组播</h3><h4 id="4-6-1-组播的概念"><a href="#4-6-1-组播的概念" class="headerlink" title="4.6.1 组播的概念"></a>4.6.1 组播的概念</h4><h4 id="4-6-2-IP组播地址。"><a href="#4-6-2-IP组播地址。" class="headerlink" title="4.6.2 IP组播地址。"></a>4.6.2 IP组播地址。</h4><h3 id="4-7-移动IP"><a href="#4-7-移动IP" class="headerlink" title="4.7 移动IP"></a>4.7 移动IP</h3><h4 id="4-7-1-移动IP的概念"><a href="#4-7-1-移动IP的概念" class="headerlink" title="4.7.1 移动IP的概念"></a>4.7.1 移动IP的概念</h4><h4 id="4-7-2-移动IP的通信过程"><a href="#4-7-2-移动IP的通信过程" class="headerlink" title="4.7.2 移动IP的通信过程"></a>4.7.2 移动IP的通信过程</h4><h3 id="4-8-网络层设备"><a href="#4-8-网络层设备" class="headerlink" title="4.8 网络层设备"></a>4.8 网络层设备</h3><h4 id="4-8-1-路由器的组成和功能"><a href="#4-8-1-路由器的组成和功能" class="headerlink" title="4.8.1 路由器的组成和功能"></a>4.8.1 路由器的组成和功能</h4><h4 id="4-8-2-路由表与路由转发"><a href="#4-8-2-路由表与路由转发" class="headerlink" title="4.8.2 路由表与路由转发"></a>4.8.2 路由表与路由转发</h4><h2 id="五、传输层"><a href="#五、传输层" class="headerlink" title="五、传输层"></a>五、传输层</h2><h3 id="5-1-传输层提供的服务"><a href="#5-1-传输层提供的服务" class="headerlink" title="5.1 传输层提供的服务"></a>5.1 传输层提供的服务</h3><blockquote><p>传输层的功能：实现分布式进程通信。面向进程提供端到端的数据传输服务（这种数据传输服务可以是采用<em>面向连接</em>或<em>无连接</em>交换方式来实现）</p></blockquote><h3 id="5-1-1-传输层寻址与端口"><a href="#5-1-1-传输层寻址与端口" class="headerlink" title="5.1.1 传输层寻址与端口"></a>5.1.1 传输层寻址与端口</h3><h3 id="5-1-2-无连接服务与面向连接服务"><a href="#5-1-2-无连接服务与面向连接服务" class="headerlink" title="5.1.2 无连接服务与面向连接服务"></a>5.1.2 无连接服务与面向连接服务</h3><div class="table-container"><table><thead><tr><th>区别</th><th>无连接服务</th><th>面向连接服务</th></tr></thead><tbody><tr><td><strong>概念</strong></td><td>不需要建立连接直接进行数据的传输，报文之间相互独立</td><td>通信双方在通信时，要事先建立一条通信线路，其过程有建立连接、使用连接和释放连接3个过程</td></tr><tr><td><strong>特点</strong></td><td>动态地分配资源，每个带有目的地址的包（报文分组）送到线路上，由系统选定路线进行传输，适用于发送少量报文的情况</td><td>静态地分配资源，传输前需要建立连接，适用于在一段时间内向一个目的地址发送大量的数据</td></tr><tr><td><strong>参考模型</strong></td><td>IP、UDP协议（无连接协议），邮件系统（无连接的模式）</td><td>TCP（面向连接的协议），电话系统（面向连接的模式）</td></tr><tr><td><strong>优点</strong></td><td>不占用通信信道</td><td>实时通信 / 可靠信息流 / 信息回复确认</td></tr><tr><td><strong>缺点</strong></td><td>非实时通信 / 信息流可能丢失 / 信息无回复确认</td><td>占用通信道</td></tr></tbody></table></div><h3 id="5-2-UDP协议"><a href="#5-2-UDP协议" class="headerlink" title="5.2 UDP协议"></a>5.2 UDP协议</h3><p>User Datagram Protocol（用户数据报协议）</p><h4 id="5-2-1-UDP数据报"><a href="#5-2-1-UDP数据报" class="headerlink" title="5.2.1 UDP数据报"></a>5.2.1 UDP数据报</h4><ul><li>UDP协议是一种无连接、不可靠的传输层协议。</li><li>UDP协议是一种面向报文的传输层协议。</li></ul><h4 id="5-2-2-UDP校验"><a href="#5-2-2-UDP校验" class="headerlink" title="5.2.2 UDP校验"></a>5.2.2 UDP校验</h4><h3 id="5-3-TCP协议"><a href="#5-3-TCP协议" class="headerlink" title="5.3 TCP协议"></a>5.3 TCP协议</h3><p>Transmission Control Protocol（传输控制协议）</p><h4 id="5-3-1-TCP段（报文段，TCP报文）"><a href="#5-3-1-TCP段（报文段，TCP报文）" class="headerlink" title="5.3.1 TCP段（报文段，TCP报文）"></a>5.3.1 TCP段（报文段，TCP报文）</h4><h4 id="5-3-2-TCP连接管理"><a href="#5-3-2-TCP连接管理" class="headerlink" title="5.3.2 TCP连接管理"></a>5.3.2 TCP连接管理</h4><ul><li>TCP连接建立（3次握手）</li></ul><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/computernetwork/tcp_connection_established.png" alt=""></p><ul><li>TCP连接释放（4次握手）</li></ul><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/computernetwork/tcp_connection_released.png" alt=""></p><h4 id="5-3-3-TCP可靠传输"><a href="#5-3-3-TCP可靠传输" class="headerlink" title="5.3.3 TCP可靠传输"></a>5.3.3 TCP可靠传输</h4><p>可靠：保证接收方进程从缓存区读出的字节流与发送方发出的字节流是完全一样的。</p><p>TCP实现可靠传输的4个机制</p><ul><li>校验</li></ul><p>与UDP校验一样，发送方和接收方增加伪首部，然后通过二进制反码求和的计算方法来判断有没有发生错误</p><ul><li>序号</li></ul><blockquote><p>TCP是面向字节流的，但在发送的时候会把一些字节放在一起组成一个报文段然后把报文段发送出去；报文段的大小是不定的（可以是2个、十个、百个等），报文段的大小取决于链路层的MTU（最大传输单元）</p></blockquote><p>就是TCP根据下方数据链路层的MTU（最大传输单元）来随即将数据切割成好几段并且进行编号</p><ul><li>确认</li></ul><p>发送方每一次发送数据之后都需要接收方进行确认。</p><p>TCP使用的是累计确认机制，就是从第一个丢失的字节开始请求丢失的报文段。如由于网络状况原因，456丢失，78到达，但接收端仍然请求发送的数据序号是4，等到456出现在缓存中，78早已在，那么接下来接收端应该请求发送的数据序号是9。</p><ul><li>重传</li></ul><p>为什么要使用自适应算法？网络环境太复杂，路径又长又短，RTT设置短了可能会引起长报文段不必要的重传，RTT设置长了又导致网络利用率降低，所以使用RTTs</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/computernetwork/retransmission.png" alt=""></p><h4 id="5-3-4-TCP流量控制与拥塞控制"><a href="#5-3-4-TCP流量控制与拥塞控制" class="headerlink" title="5.3.4 TCP流量控制与拥塞控制"></a>5.3.4 TCP流量控制与拥塞控制</h4><h3 id="5-4-TCP与UDP区别总结"><a href="#5-4-TCP与UDP区别总结" class="headerlink" title="5.4 TCP与UDP区别总结"></a>5.4 TCP与UDP区别总结</h3><div class="table-container"><table><thead><tr><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>面向连接</td><td>是无连接的，即发送数据之前不需要建立连接</td></tr><tr><td>提供<strong>可靠</strong>的服务，传送数据无差错，不丢失，不重复，且按序到达</td><td>UDP尽最大努力交付，即<strong>不保证可靠</strong>交付</td></tr><tr><td><strong>面向字节流</strong>，实际上是TCP把数据看成一连串无结构的字节流</td><td>UDP是<strong>面向报文</strong>的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</td></tr><tr><td>每一条TCP连接只能是点到点的</td><td>UDP支持一对一，一对多，多对一和多对多的交互通信</td></tr><tr><td>首部开销20字节</td><td>首部开销小，8个字节</td></tr><tr><td>逻辑通信信道是全双工的可靠信道</td><td>不可靠信道</td></tr><tr><td>应用于整个数据要准确无误地传递给对方，这往往用于一些要求可靠的应用，比如HTTP，HTTPS，FTP等传输文件的额协议，POP，SMTP等邮件传输协议，Putty用的Telnet，SSH</td><td>常见使用UDP协议的应用如下：当对网络通信质量要求不高时，要求网络通信速度能尽量地快，这时可以使用UDP。如QQ语言，在线视频，TFTP</td></tr></tbody></table></div><ul><li><p>在以太网中传输一个TCP报文段要经过网络层、数据链路层的封装，封装形式：</p><p>当应用程序用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息），该过程如下图所示。TCP传给IP的数据单元称作TCP报文段。IP传给网络接口层的数据单元称作IP数据报，通过以太网传输的比特流称作帧。</p></li><li><p>周知端口分配表</p></li></ul><div class="table-container"><table><thead><tr><th>TCP端口号</th><th>TCP协议关键字</th><th>UDP端口号</th><th>UDP协议关键字</th></tr></thead><tbody><tr><td>20</td><td>FTP的数据连接</td><td></td><td></td></tr><tr><td>21</td><td>FTP的控制连接</td><td></td><td></td></tr><tr><td>23</td><td>TELNET（终端连接）</td><td></td><td></td></tr><tr><td>25</td><td>SMTP</td><td></td></tr></tbody></table></div><h2 id="六、应用层"><a href="#六、应用层" class="headerlink" title="六、应用层"></a>六、应用层</h2><h3 id="6-1-网络应用模型"><a href="#6-1-网络应用模型" class="headerlink" title="6.1 网络应用模型"></a>6.1 网络应用模型</h3><p>从Internet应用系统的工作模式角度，网络应用可以分为两类。</p><h4 id="6-1-1-客户-服务器模型（以下4个都是C-S模型）"><a href="#6-1-1-客户-服务器模型（以下4个都是C-S模型）" class="headerlink" title="6.1.1 客户/服务器模型（以下4个都是C/S模型）"></a>6.1.1 客户/服务器模型（以下4个都是C/S模型）</h4><h4 id="6-1-2-P2P模型（对等网络）"><a href="#6-1-2-P2P模型（对等网络）" class="headerlink" title="6.1.2 P2P模型（对等网络）"></a>6.1.2 P2P模型（对等网络）</h4><p>P2P是网络节点之间采用对等的方式，通过直接交换信息达到共享计算机资源和服务的工作模式。</p><h3 id="6-2-DNS系统"><a href="#6-2-DNS系统" class="headerlink" title="6.2 DNS系统"></a>6.2 DNS系统</h3><h4 id="6-2-1-层次域名空间"><a href="#6-2-1-层次域名空间" class="headerlink" title="6.2.1 层次域名空间"></a>6.2.1 层次域名空间</h4><h4 id="6-2-2-域名服务器"><a href="#6-2-2-域名服务器" class="headerlink" title="6.2.2 域名服务器"></a>6.2.2 域名服务器</h4><h4 id="6-2-3-域名解析过程"><a href="#6-2-3-域名解析过程" class="headerlink" title="6.2.3 域名解析过程"></a>6.2.3 域名解析过程</h4><h3 id="6-3-FTP"><a href="#6-3-FTP" class="headerlink" title="6.3 FTP"></a>6.3 FTP</h3><h4 id="6-3-1-FTP协议的工作原理"><a href="#6-3-1-FTP协议的工作原理" class="headerlink" title="6.3.1 FTP协议的工作原理"></a>6.3.1 FTP协议的工作原理</h4><h4 id="6-3-2-控制连接与数据连接"><a href="#6-3-2-控制连接与数据连接" class="headerlink" title="6.3.2 控制连接与数据连接"></a>6.3.2 控制连接与数据连接</h4><h3 id="6-4-电子邮件"><a href="#6-4-电子邮件" class="headerlink" title="6.4 电子邮件"></a>6.4 电子邮件</h3><h4 id="6-4-1-电子邮件系统的组成结构"><a href="#6-4-1-电子邮件系统的组成结构" class="headerlink" title="6.4.1 电子邮件系统的组成结构"></a>6.4.1 电子邮件系统的组成结构</h4><h4 id="6-4-2-电子邮件格式与MIME"><a href="#6-4-2-电子邮件格式与MIME" class="headerlink" title="6.4.2 电子邮件格式与MIME"></a>6.4.2 电子邮件格式与MIME</h4><h4 id="6-4-3-SMTP协议与POP3协议"><a href="#6-4-3-SMTP协议与POP3协议" class="headerlink" title="6.4.3 SMTP协议与POP3协议"></a>6.4.3 SMTP协议与POP3协议</h4><h3 id="6-5-WWW"><a href="#6-5-WWW" class="headerlink" title="6.5 WWW"></a>6.5 WWW</h3><h4 id="6-5-1-WWW的概念与组成结构"><a href="#6-5-1-WWW的概念与组成结构" class="headerlink" title="6.5.1 WWW的概念与组成结构"></a>6.5.1 WWW的概念与组成结构</h4><h4 id="6-5-2-HTTP协议"><a href="#6-5-2-HTTP协议" class="headerlink" title="6.5.2 HTTP协议"></a>6.5.2 HTTP协议</h4>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;考查目标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;掌握计算机网络的基本概念、基本原理和基本方法。&lt;/li&gt;
&lt;li&gt;掌握计算机网络的体系结构和典型网络协议，了解典型网络设备的组成和特点，理解典型网络设备的工作原理。&lt;/li&gt;
&lt;li&gt;能够运用计算机网络基本概念、基本原理和基本方法进行网络系统分析、设计和应用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以西北工业大学801计算机专业基础为考纲&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Study" scheme="https://mysticalguest.github.io/categories/Study/"/>
    
    
      <category term="计算机基础" scheme="https://mysticalguest.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>华为面经</title>
    <link href="https://mysticalguest.github.io/Interview/25291.html"/>
    <id>https://mysticalguest.github.io/Interview/25291.html</id>
    <published>2020-09-16T00:00:00.000Z</published>
    <updated>2021-04-20T12:44:30.621Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>收到面试邀约后该怎么做？我参考了尚硅谷雷老师的博客，他的B站ID是“黎曼的猜想”。通过他的经验的指导，并结合我的面试实际情况，为面试准备了许多说辞。</p></blockquote><a id="more"></a><h2 id="面试前准备"><a href="#面试前准备" class="headerlink" title="面试前准备"></a>面试前准备</h2><p>当收到面试通知后，通过如下准备可以大大提升面试成功率。</p><p>知己知彼，百战不殆。即使侥幸面试成，亦可防止压工资。</p><p>其实公司肯花时间让你去面试，前提条件一定是通过了你的简历，一定发现你和公司的匹配点，也就是说，一定是有录用意向的。</p><p>在技术面试的时间段里（最长1个小时，并且可能有多伦技面），尽可能地展现优势。</p><p>至于通过技术面试后，业务主管、项目经理或人事的面试一般是过滤特别差的，比如考察团队协作能力和沟通表达能力等，这对大家来说应该都不是问题。</p><p>敲重点！</p><ul><li><p>至少定出2天的准备时间</p></li><li><p>一定要再次阅读公司的职位要求</p><ul><li>就类似于考试，一定是先审题嘛，然后再做相应的准备。</li></ul></li></ul><p>比如，我报的西安华为21届秋季校招，第一意向部门传送与接入产品线，第二意向部门云核心网产品线，领域都是通用软件开发工程师。</p><h3 id="岗位职责"><a href="#岗位职责" class="headerlink" title="岗位职责"></a>岗位职责</h3><blockquote><p>在这里，你将从事IT应用层软件、分布式云化软件、互联网软件等的设计开发，可以采用敏捷、Devops、开源等先进的软件设计开发模式，接触最前沿的产品和软件技术，成为大容量高并发技术的专家；你将参与华为产品的软件研发工作，包括但不限于：<br>（1）完成从客户需求到软件产品定义、架构设计、开发实现、再到上线运营维护等产品生命周期中的各个环节；<br>（2）创造性解决产品在实现过程中的技术难题，应用前沿技术提升产品的核心竞争力，如分布式系统、性能调优、可靠性、数据库等；<br>（3）有机会参与业界前沿技术研究和规划，参与开源社区运作，与全球专家一起工作、交流，构建华为在业界影响力。</p></blockquote><h3 id="岗位要求"><a href="#岗位要求" class="headerlink" title="岗位要求"></a>岗位要求</h3><blockquote><p>1、计算机、软件、通信等相关专业本科及以上学历；<br>2、热爱编程，基础扎实，熟悉掌握但不限于JAVA/C++/C/Python/JS/HTML/GO等编程语言中的一种或数种，有良好的编程习惯；<br>3、具备独立工作能力和解决问题的能力、善于沟通，乐于合作，热衷新技术，善于总结分享，喜欢动手实践；<br>4、对数据结构、算法有一定了解；<br>5、优选条件：<br>（1）熟悉TCP/IP协议及互联网常见应用和协议的原理；<br>（2）有IT应用软件、互联网软件、IOS/安卓等相关产品开发经验，不满足于课堂所学，在校期间积极参加校内外软件编程大赛或积极参于编程开源社区组织；<br>（3）熟悉JS/AS/AJAX/HTML5/CSS等前端开发技术。</p></blockquote><p>能从中挖掘出如下的技能需求点：</p><p>专业性要求：</p><ul><li>基础扎实</li><li>熟悉TCP/IP协议及互联网常见应用和协议的原理</li><li>编程大赛</li></ul><p>其实在投简历前，就可以根据不同公司的不同要求对简历进行微调，这样获得该岗位的面试机会更大。</p><h3 id="准备项目描述的说辞"><a href="#准备项目描述的说辞" class="headerlink" title="准备项目描述的说辞"></a>准备项目描述的说辞</h3><p>面试环节中的项目介绍必要环节</p><p>这里介绍些项目描述的要点：</p><ul><li>业务需求一笔带过，项目背景，工期人数等寥寥几句，面试官不关心的。就可以这样介绍：</li></ul><blockquote><p>大二在软通动力实训的过程中接触了SpringBoot，由于我家有个亲戚开了个私人宾馆，就萌生了开发一个宾馆的Web应用的想法。然后我一个人在大二暑假花了3个月的时间用SpringBoot做一个宾馆信息管理系统，面向的用户就是宾馆的前台，可以简化管理宾馆的业务过程。</p></blockquote><ul><li>结合项目实际需求，介绍项目用到的技术，比如上面“岗位要求”描述中，要求有“开发经验，熟悉一些前端知识等”，可以这样介绍：</li></ul><blockquote><p>在这个项目里，开发用户界面要到模板引擎，比如JSP和Thymeleaf，就必须了解前端知识嘛，所以我还学习并用到了许多前端框架，比如EasyUI、Bootstrap、Ajax和axios等，甚至还接触过Vue。</p></blockquote><p>注意：这里仅仅是介绍项目，结合功能点说出技术即可，一定要思路清晰。</p><ul><li>再结合项目，说些招聘方需要的非技术的要求</li></ul><blockquote><p>在这个项目中，我用到了MVC设计模式，在项目的开发过程中去学习，遇到问题我首先会在网络上寻找解决方案，然后再去和同学商量，或是我在Java学习的微信群里，不乏工作经验丰富的人，我也会去问他们解决方案。过一定时间我也会再回顾代码，优化代码逻辑，减少代码量等。</p></blockquote><ul><li>如果有，说下项目中的亮点，比如用到了一些比较好的技术。</li></ul><blockquote><p>官方推荐模板渲染引擎Thymeleaf，语法更灵活</p><p>MyBatis框架，SQL语句更灵活，实现更简单</p><p>缓存</p><p>String对象的优化</p><p>这个项目对数据库性能和内存性能要求比较高，所以我用到了Oracle调优技术和JVM内存优化技术，此外，我们还用到了大数据分析工具对计费模式做了优化。</p></blockquote><p>准备好说辞，能给面试官留下思路清晰，技术匹配的印象。 </p><p>如果运用到项目的技术和要求不匹配，但可以在了解的基础上说出来，整理一下说辞即可。但通过后面的问题，面试官发现你根本不了解，性质就变了。</p><p>在准备项目说辞的时候，可以尽量和职位要求靠，但你说的每个技术点，稍后面试官都会问的。如果某个技术点没有掌握，其实问题不大，面试官不会要求十全十美。</p><h3 id="一定得准备项目描述里提到的技术"><a href="#一定得准备项目描述里提到的技术" class="headerlink" title="一定得准备项目描述里提到的技术"></a>一定得准备项目描述里提到的技术</h3><p>在介绍项目时，吸引面试官把注意力集中到你提到的技术点上。这些技术大多也是岗位要求的技术。</p><p>结合项目点明技术。</p><h3 id="准备亮点话题"><a href="#准备亮点话题" class="headerlink" title="准备亮点话题"></a>准备亮点话题</h3><p>亮点话题多多益善</p><p>对于Java高级开发而言，可以准备以下话题：</p><ul><li>虚拟内存优化</li><li>数据库性能优化</li><li>分布式高并发架构</li><li>一些热门组件，比如redis、nginx等</li><li>大数据方向的用法？</li><li>Java core（比如集合或多线程）方面的底层实现代码</li><li>Spring系列（比如IOC、AOP、MVC、SpringBoot、SpringCloud）方面的底层实现代码</li></ul><p>要准备到什么程度：</p><ul><li>最好结合项目实际说出真的用过这些技术</li><li>最好往性能调优方面靠</li></ul><p>通过准备，大家可以主导面试官提问，否则面试官开始天马行空地问问题，大家薄弱点被暴露的机会就有可能大大增加。</p><h3 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h3><p>手撕代码啊，远程的话，就是用本地IDE，然后共享屏幕，不要紧张对自己代码不自信。</p><h2 id="面试中的表现"><a href="#面试中的表现" class="headerlink" title="面试中的表现"></a>面试中的表现</h2><h3 id="软实力"><a href="#软实力" class="headerlink" title="软实力"></a>软实力</h3><p>面试官只有当确认候选人在责任心和团队协作能力方面没问题，才会把你招进公司。面试官会通过（1）问问题的方式；（2）通过回答问题的方式和说话的语气；来确认。</p><p>所以大家面试的过程中：</p><ul><li>交流时尽量目视面试官，谈吐清晰，语速不急不缓，说话果断，语气不卑不亢，别太僵硬</li><li>适当微笑，点头互动</li><li>积极回答问题，如果没听清问题，及时主动询问</li><li>不急不燥，从容应对“压力测试”</li><li>放松心态</li></ul><blockquote><p>当觉得自己不行的时候，就走在这个斑马线上，你就是一个行人。</p><p>上面这些都是我二面之前做的准备。</p></blockquote><h2 id="二面完后总结"><a href="#二面完后总结" class="headerlink" title="二面完后总结"></a>二面完后总结</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>自我介绍嘛，基本信息，实习实践经历比赛，虽然简历上有。</p><ul><li><p>开始看机试的题</p><blockquote><p>我是没有想到的，依次回顾当时的机试题，我当时是8月12号参加的华为西北校招机试，距离面试这天已经1个月了吧，有些没有印象，只说出了一题的大概思路，觉得自己没有表现好。当时的题及我写的代码都以放在我的<a href="https://github.com/MysticalGuest/OPP-Java/tree/master/SchoolRecruitment/src/com/huawei">GitHub</a>上，大家可以参考，并不都是AC。</p></blockquote></li><li><p>项目</p><blockquote><p>问我做过的项目给他展示，我是直接共享屏幕展示，他会问我如何实现，他也会指出我项目里出现的问题。和我讨论，大家把握说话方式，不要太拘束即可。还会展示数据库，问数据库中各个表的实现和意义，问我了为什么密码是明文没有加密，这是我第二个感觉表现不好的地方。</p></blockquote></li><li><p>然后就手撕代码</p><blockquote><p>当时机试，有两题没写出来，他就从里面挑了一道题让我写，当时没有思路，最后又写出来了，觉得挺幸运，不过写代码过程中出现了写小插曲，这是我第三个感觉表现不好的地方。</p></blockquote></li><li><p>结束</p><blockquote><p>大概聊得就这么多，最后问我有什么问题想问他，我也没有问题。</p></blockquote></li></ul><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>一面结束10分钟后就会出结果，前2面安排挺紧凑的相隔30分钟吧，会换面试官的。轮到我就比较凑巧，刚好到饭点，我一面面完群里就通知大家可以去吃饭了。</p><p>吃完饭会来，等了一会儿，1点30分开始。还是自我介绍，基本信息，实习实践经历比赛，虽然简历上有。</p><ul><li><p>项目</p><blockquote><p>然后他提了个功能，问我实现思路，感觉也没有达到他的要求</p></blockquote></li><li><p>结合项目，给出场景</p><blockquote><p>问我有没有什么想法？我说出了大概思路，感觉也没有达到他的要求</p></blockquote></li><li><p>B树系列问题</p><blockquote><p>B树，B+树为什么比二叉树等效率高？特点是什么？我之前通过MySQL了解的B+树，现在已经没啥印象了，就也没有回答的很顺利。</p></blockquote></li><li><p>数据结构，排序</p><blockquote><p>问快速排序、归并排序和堆排序的时间复杂度，有没有了解比这些排序更快的，还有他们的稳定性。</p></blockquote></li><li><p>结束</p><blockquote><p>大概聊得就这么多，最后问我有什么问题想问他，我也没有问题。</p></blockquote></li></ul><h2 id="专业主管面试"><a href="#专业主管面试" class="headerlink" title="专业主管面试"></a>专业主管面试</h2><h3 id="职业规划（人生规划）："><a href="#职业规划（人生规划）：" class="headerlink" title="职业规划（人生规划）："></a>职业规划（人生规划）：</h3><p>最重要的就是找对职业方向</p><p>1、自我分析阶段</p><p>兴趣分析：</p><blockquote><p>我应聘的岗位是通用软件开发，我也向HR了解过情况，我的意向工作就是Java开发。我热爱Java，我从大二接触到这门语言就开始了，Java是我接触到的第二门编程语言，第一门面向对象的编程语言，我喜欢他的规范和严谨。所以我会主动努力地去学习Java及其相关的框架，比如Spring。</p></blockquote><p>性格分析：</p><blockquote><p>大学期间我参与过比较多的项目，做过开发，也做过项目组长，做过项目汇报，我都可以适应这些角色，开发不用说我是喜欢的，项目组长的话，主要负责协调组内成员，规划好项目进度，也会帮助和鼓励组员开发。我觉得我的性格比较活泼比较负责，我每次参与开发完成项目都很有成就感和满足感，会有冲动向同学们汇报展示。</p></blockquote><p>优缺点分析：</p><blockquote><p>优点：做事比较负责，认真，有上进心，肯吃苦</p><p>缺点：比较在意他人的看法</p></blockquote><p>2、职业分析规划</p><p>毕业之后找到自己心仪的工作，认真完成工作，抽时间学习专业知识技能，向前辈和同事学习经验。因为自己要学的东西还很多，积淀一段时间后，想着在工作中职位向上晋升，不断积累经验。</p><h3 id="网上翻到一篇博客"><a href="#网上翻到一篇博客" class="headerlink" title="网上翻到一篇博客"></a>网上翻到一篇博客</h3><p>【面试经验】三轮面试拿到华为Offer</p><p>问我为什么选择华为，我说我<strong>想去大城市闯荡，华为有很大的平台可以供我们年轻人发挥</strong>。然后主管问有没有人推荐你选华为，或者你是怎么了解华为的。这些问题我都是心里面有答案的，因为我邻居就有在华为工作的，所以我稍微了解华为，也有人力挺我要去华为发展，这些都是这个问题的答案。</p><p>接下来就是压力面试，问我如果你和你同学一起进入华为，发现你的工资比同学低个几千元，你该怎么办，你会不会心理不平衡？<strong>我说我会弄明白我为什么会比别人低，然后努力工作，改正一些缺点，争取在业务上超过他们。</strong>业务主管说在华为刚进去不要在乎你比别人少几千，以后都是年薪几十万，几百万的，那几千元算什么，刚进去的两个人，几年以后可能待遇截然不同。</p><p>接着又问我如果你有一项技术只有你一个人会，是你的独门秘诀，现在又需要，你会不会把他教给其他人。我直接说不会，因为这是吃饭的家伙。业务主管笑了笑说虽然这是我不想得到的答案，但是你诚实，在华为大家都是有技术互相交流的，大家都倾其所有的完成项目，这样项目就能轻松的完成，然后一些奖励大家一起分，这样多开心。接着又问我，如果我是业务主管，给5个不同方向的人打等级，打绩效成绩该怎么打。这个我答的比较好，因为要看团队合作能力，看他在完成工作的同时还为团队带来了哪些利益，因为华为是狼道盛行的团队，特别讲究团队合作。</p><p>聊完这些压力面以后，面试官问我有没有问题要问他。我就顺便问了一个我这个方向的进入华为能不能直接上手，对不对口。你进来以后也会跟着师傅学习，慢慢上手项目，开始融入团队完成项目，到后来一个人负责一个项目。三轮面试差不多就结束了，第三轮面试大概35分钟左右，这个还是比较轻松的。</p><p>这里要注意的是，三轮面试的时候，如果业务主管问你地点的问题，那你就要小心了，如果说给你深圳你去不去，你说不去的话，可能第三轮你就会倒下。当然了很多同学没有被问到这个问题，关于地点问题倒在三轮的，我们学院大概两个人。（当你面试完华为以后，恭喜你，你的面试经验已经非常成熟了。你再去面试其他公司，你就会发现很轻松，基本都不需要准备，级别绝对不是一个level，因为华为的面试官带你把项目都仔仔细细的过了一遍，华为三轮面试的那两个小时绝对成为你人生中宝贵的财富）</p><p>面试完三轮以后等通知，说一个星期后给结果。19号面试的同学，有大部分都撑完了三轮面试，20号面试的同学最后只有2个撑到了第三轮。然后面试完以后，第二天就有三轮面试的结果了，我是录用排序中，有的同学倒下了，显示面试不通过。苦苦等了一个星期，然后HR说可能国庆之后给结果。在家里过了一个国庆后。大概11号的时候，有人收到签约短信了，那波人是第一批被捞上来了，网络能源产品线电源岗只有我同门被捞了，因为他研究方向就是逆变器，十分对口，面试也很顺利，薪资待遇开的20k。我们专业，面试其他部门的第一批被捞的都是开的20k，价格都一样。过了几天，华为第二批开始捞人，我被捞出来了，16号南研所签约，签两方（华为的两方可以毁约，没有违约金），第二批的待遇稍微差一点只有19k，计算方法就是19*（14-16），签完两方，拿到了华为的聘书，我就回学校了。后来听说第三批只有18k了。</p><p>最后再说一下我去了哪里吧，最后我选择了江苏电网（某市供电公司）。主要原因是签了承诺书，不允许毁约电网，再加上家里人不同意我去华为，怕我身体吃不消。签完电网刚开始三天我还状态良好，后来慢慢的有些后悔，觉得我这性格的更适合华为，我喜欢奋斗干出一番事业，年轻人不能怕吃苦。然后同学对我进行了一波开导，再加上家里人不同意去华为，最后我还是坚定的选择了国家电网。其实选择哪有什么后悔不后悔，你进去以后踏实干活，干出成绩来，有所成就，你就会觉得当初的选择多么的对。如果你整天浑水摸鱼，一事无成，这样你就会觉得当初为什么选择了它，而没选择另一者。所以为了以后不留遗憾，今后也会努力工作，带着华为那种拼搏的精神进入电网，踏实干活。最后我们学院大概4个签约了华为公司，都选择了上海。最后衷心的祝愿在华为拼搏的这些同学，你们带着东大电气人的梦想，勇敢新世界，拖着世界往前走，虽然在华为拼搏的路上没有我，但梦想与你们跟随。</p><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><p>依然是自我介绍，充分准备一下。</p><ul><li><p>专业：软件工程</p><blockquote><p>对软件工程的理解，工程化开发软件项目…自我感觉还行</p></blockquote></li><li><p>软件工程中最重要的是什么？为什么？</p><blockquote><p>需求分析，软件开发的开端</p></blockquote></li><li><p>最有成就感的事</p></li><li><p>最遗憾的事</p></li><li><p>未来规划</p></li><li><p>了解华为的企业文化吗</p></li></ul><p>总体觉得面试华为收获不少，拿不拿得到Offer另说。前两面挺虚的，但三面还好，等待通知吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;收到面试邀约后该怎么做？我参考了尚硅谷雷老师的博客，他的B站ID是“黎曼的猜想”。通过他的经验的指导，并结合我的面试实际情况，为面试准备了许多说辞。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Interview" scheme="https://mysticalguest.github.io/categories/Interview/"/>
    
    
      <category term="校招面试" scheme="https://mysticalguest.github.io/tags/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>管理GitHub个人资料README</title>
    <link href="https://mysticalguest.github.io/GitHub/55476.html"/>
    <id>https://mysticalguest.github.io/GitHub/55476.html</id>
    <published>2020-09-13T02:05:40.655Z</published>
    <updated>2021-04-08T13:00:55.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="管理您的个人资料README"><a href="#管理您的个人资料README" class="headerlink" title="管理您的个人资料README"></a>管理您的个人资料README</h2><a id="more"></a><p>最近看到一个Github主页添加个人资料，觉得挺不错，就想着也弄一个，就像下图一样，其实并不麻烦。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Github/github.PNG" alt=""></p><p>GitHub提供了这样的服务，<a href="https://docs.github.com/en/github/setting-up-and-managing-your-github-profile/managing-your-profile-readme">官方文档</a>，我也是在官方文档找到的详细教程。以下大多都是翻译版，还有一些个人建议和踩坑经验，我挑出其中最重要的部分分享。</p><h3 id="关于您的个人资料README"><a href="#关于您的个人资料README" class="headerlink" title="关于您的个人资料README"></a>关于您的个人资料README</h3><p>您可以将自述文件添加到您的GitHub个人资料中，以向其他人介绍您自己。</p><p>您可以通过创建个人资料README与GitHub社区上有关您自己的信息。 GitHub在个人资料页面顶部显示您的个人资料README。</p><p>您可以决定在个人资料README中包含哪些信息，因此可以完全控制自己在GitHub上的展示方式。以下是一些访问者在您的个人资料README中可能发现有趣，有趣或有用的信息示例。</p><ul><li><p>“关于我”部分描述了您的工作和兴趣</p></li><li><p>您引以为豪的贡献以及这些贡献的背景</p></li><li><p>在您所参与的社区中获得帮助的指南</p></li></ul><p>您可以使用GitHub Flavored Markdown设置文本格式，并在个人资料README中包含表情符号，图像和GIF。有关更多信息，请参阅“<a href="https://docs.github.com/en/github/writing-on-github/getting-started-with-writing-and-formatting-on-github">在GitHub上编写和格式化入门</a>”。</p><h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><p>如果满足以下所有条件，则GitHub将在您的个人资料页面上显示您的个人资料README。</p><ul><li><p>您已经创建了一个名称与<strong>您的GitHub用户名相匹配</strong>的存储库。</p></li><li><p>该存储库是<strong>公共（Public）</strong>的。</p></li><li><p>存储库的根目录中包含一个名为README.md的文件（初始化创建即可，不需要克隆到本地）。</p></li><li><p>README.md文件包含任何内容。</p></li></ul><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Github/create.PNG" alt=""></p><p>当你创建仓库的时候，将仓库名命名为<code>mysticalguest</code>，下面就会出现提示：</p><blockquote><p><em>您发现了一个秘密！ MysticalGuest / MysticalGuest是一个“特殊”存储库，可用于将README.md添加到您的GitHub个人资料中。确保它是公开的，并使用自述文件对其进行初始化以开始使用。</em></p></blockquote><p>其他仓库不会出现这样的提示。说明是成功的。</p><blockquote><p>注意：如果您在2020年7月之前创建了一个与用户名相同名称的公共存储库，则GitHub不会在您的个人资料上自动显示该存储库的自述文件。您可以通过转到GitHub.com上的存储库并单击“共享到配置文件”，手动将存储库的自述文件共享到您的配置文件。（这个不用管了，因为7月之后很方便，一旦仓库创建成功，GitHub个人主页就会显示了！）</p></blockquote><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Github/success.PNG" alt=""></p><p>下面就开始<strong>在线编辑</strong>这个仓库下的README.md文件即可：</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Github/edit.PNG" alt=""></p><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><p>GitHub提供了强大的在线编辑器，还可以预览。我的编辑：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">### Welcome！👋 </span></span><br><span class="line"><span class="bullet">+ </span><span class="strong">**My Github Blog.[https://mysticalguest.github.io](https://mysticalguest.github.io/)**</span></span><br><span class="line"><span class="bullet">+ </span><span class="strong">**My Gitee Blog.[https://mysteryguest.gitee.io](https://mysteryguest.gitee.io/)**</span></span><br><span class="line"><span class="bullet">+ </span><span class="strong">**My CSDN Blog.[https://blog.csdn.net/etherealsymbol](https://blog.csdn.net/etherealsymbol/)**</span></span><br><span class="line"><span class="bullet">+ </span><span class="strong">**My CNBlogs Blog.[https://www.cnblogs.com/mysteryguest](https://www.cnblogs.com/mysteryguest/)**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>🔭 I’m currently working on java source code...</span><br><span class="line"><span class="bullet">- </span>🌱 I’m currently learning Java, MySQL, Spring, Redis, Elasticsearch...</span><br><span class="line"><span class="bullet">- </span>📫 How to reach me: mysticalguest@163.com</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--</span></span></span><br><span class="line"><span class="xml">**MysticalGuest/mysticalguest** is a ✨ _special_ ✨ repository </span></span><br><span class="line"><span class="xml">because its `README.md` (this file) appears on your GitHub profile.</span></span><br><span class="line"></span><br><span class="line"><span class="xml">Here are some ideas to get you started:</span></span><br><span class="line"></span><br><span class="line"><span class="xml">- 🔭 I’m currently working on ...</span></span><br><span class="line"><span class="xml">- 🌱 I’m currently learning ...</span></span><br><span class="line"><span class="xml">- 👯 I’m looking to collaborate on ...</span></span><br><span class="line"><span class="xml">- 🤔 I’m looking for help with ...</span></span><br><span class="line"><span class="xml">- 💬 Ask me about ...</span></span><br><span class="line"><span class="xml">- 📫 How to reach me: ...</span></span><br><span class="line"><span class="xml">- 😄 Pronouns: ...</span></span><br><span class="line"><span class="xml">- ⚡ Fun fact: ...</span></span><br><span class="line"><span class="xml">--&gt;</span></span><br></pre></td></tr></table></figure><p>编辑完成<code>Commit Changes</code>即可，刷新主页。</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Github/github.PNG" alt=""></p><p>成功，就是这么简单！</p><h3 id="删除个人资料README"><a href="#删除个人资料README" class="headerlink" title="删除个人资料README"></a>删除个人资料README</h3><p>如果满足以下任何条件，则从您的GitHub个人资料中删除个人资料README：</p><ul><li><p>自述文件为空或不存在。</p></li><li><p>该存储库是私有的。</p></li><li><p>存储库名称不再与您的用户名匹配。</p></li></ul><p>选择的方法取决于您的需求，但是如果不确定，我们建议将存储库设为私有。 有关如何将存储库设为私有的步骤，请参阅“<a href="https://docs.github.com/en/github/administering-a-repository/setting-repository-visibility#changing-a-repositorys-visibility">更改存储库的可见性</a>”。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;管理您的个人资料README&quot;&gt;&lt;a href=&quot;#管理您的个人资料README&quot; class=&quot;headerlink&quot; title=&quot;管理您的个人资料README&quot;&gt;&lt;/a&gt;管理您的个人资料README&lt;/h2&gt;
    
    </summary>
    
    
      <category term="GitHub" scheme="https://mysticalguest.github.io/categories/GitHub/"/>
    
    
      <category term="配置" scheme="https://mysticalguest.github.io/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程</title>
    <link href="https://mysticalguest.github.io/Java/58846.html"/>
    <id>https://mysticalguest.github.io/Java/58846.html</id>
    <published>2020-09-05T15:50:15.714Z</published>
    <updated>2021-04-22T07:35:33.749Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>创建线程的<strong>主要</strong>方式</p><ol><li>继承Thread类创建线程类（重点）</li><li>实现Runnable接口创建线程类（重点）</li><li>实现Callable接口或Future接口创建线程（了解）</li><li>线程池</li></ol></blockquote><a id="more"></a><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>关于学习Java多线程，其中程序，进程和线程等重要概念及其关系在这里就不多赘述，之前操作系统也详细讲过，我就不再详细扩展，直接进入Java线程的学习吧！</p><p>此处分享一下<a href="https://pan.baidu.com/s/1BqJdwPNVusF14r9JhMzwdA">Java1.8帮助文档</a>（中文版），提取码: k26d</p><h2 id="2、Thread类"><a href="#2、Thread类" class="headerlink" title="2、Thread类"></a>2、Thread类</h2><h3 id="2-1-Thread类实现Runnable接口"><a href="#2-1-Thread类实现Runnable接口" class="headerlink" title="2.1 Thread类实现Runnable接口"></a>2.1 Thread类实现Runnable接口</h3><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Make sure registerNatives is the first thing &lt;clinit&gt; does. */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    registerNatives();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>            priority;</span><br><span class="line">  <span class="keyword">private</span> Thread         threadQ;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span>           eetop;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Whether or not to single_step this thread. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span>     single_step;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-创建步骤："><a href="#2-2-创建步骤：" class="headerlink" title="2.2 创建步骤："></a>2.2 创建步骤：</h3><p><strong>将一个类声明为<code>Thread</code>的子类。  这个子类应该重写<code>Thread</code>类的<code>run</code>方法 。 然后可以分配并启动子类的实例</strong></p><ul><li>自定义线程类继承<strong>Thread类</strong></li><li>重写<strong>run()</strong>方法，编写线程执行体</li><li>创建线程对象，调用<strong>start()</strong>方法启动线程</li></ul><h4 id="2-2-1-测试"><a href="#2-2-1-测试" class="headerlink" title="2.2.1 测试"></a>2.2.1 测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// run方法线程体</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">      System.out.print(String.format(<span class="string">"%-3d"</span>, i) + <span class="string">"Hello    "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// main方法主线程</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个线程对象</span></span><br><span class="line">    Thread1 thread1 = <span class="keyword">new</span> Thread1();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用start方法开启线程</span></span><br><span class="line">    thread1.start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">800</span>; i++) &#123;</span><br><span class="line">      System.err.print(String.format(<span class="string">"%-3d"</span>, i) + <span class="string">"World    "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看控制台输出：</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Java/Thread/thread1.PNG" alt=""></p><blockquote><p>注意：线程开启不一定立即执行，由CPU调度执行</p><p>调用start方法，是线程同时执行，交替执行。如果调用run方法，就是顺序执行。</p></blockquote><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Java/Thread/run_and_start.PNG" alt=""></p><h4 id="2-2-2-案例：实现多线程同步下载图片"><a href="#2-2-2-案例：实现多线程同步下载图片" class="headerlink" title="2.2.2 案例：实现多线程同步下载图片"></a>2.2.2 案例：实现多线程同步下载图片</h4><p>APACHE官网下载<a href="https://commons.apache.org/proper/commons-io/download_io.cgi">commons-io</a>，导入项目Library</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String url;<span class="comment">// Picture url</span></span><br><span class="line">  <span class="keyword">private</span> String path;</span><br><span class="line">  <span class="keyword">private</span> String name;<span class="comment">// Saved file name</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Thread2</span><span class="params">(String url, String path, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">    <span class="keyword">this</span>.path = path;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WebDownloader webDownloader = <span class="keyword">new</span> WebDownloader();</span><br><span class="line">    webDownloader.downloader(url, path, name);</span><br><span class="line">    System.out.println(<span class="string">"Downloaded the file which name is "</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String path = <span class="string">"src/com/newthread/img/"</span>;</span><br><span class="line">    Thread2 t1 = <span class="keyword">new</span> Thread2(</span><br><span class="line">        <span class="string">"https://wx1.sinaimg.cn/orj360/67e231a6ly1geq8okovekj21hc0u0e42.jpg"</span>,</span><br><span class="line">        path, <span class="string">"tower.jpg"</span>);</span><br><span class="line">    Thread2 t2 = <span class="keyword">new</span> Thread2(</span><br><span class="line">        <span class="string">"https://wx1.sinaimg.cn/orj360/67e231a6ly1geq8oq8jx1j21hc0u0qse.jpg"</span>,</span><br><span class="line">        path, <span class="string">"bike.jpg"</span>);</span><br><span class="line">    Thread2 t3 = <span class="keyword">new</span> Thread2(</span><br><span class="line">        <span class="string">"https://wx1.sinaimg.cn/orj360/67e231a6ly1geq8on2u4gj21hc0u0ngj.jpg"</span>,</span><br><span class="line">        path, <span class="string">"bridge.jpg"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// simultaneous execution</span></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// downloader</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebDownloader</span></span>&#123;</span><br><span class="line">  <span class="comment">// download function</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downloader</span><span class="params">(String url, String path,String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      FileUtils.copyURLToFile(<span class="keyword">new</span> URL(url), <span class="keyword">new</span> File(path + name));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      System.err.println(<span class="string">"IO Exception...downloader function has a problem!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Java/Thread/webdownloader.PNG" alt=""></p><h2 id="3、Runnable接口"><a href="#3、Runnable接口" class="headerlink" title="3、Runnable接口"></a>3、Runnable接口</h2><h3 id="3-1-Runnable接口"><a href="#3-1-Runnable接口" class="headerlink" title="3.1 Runnable接口"></a>3.1 Runnable接口</h3><p>声明实现类<code>Runnable</code>接口。 那个类然后实现了<code>run</code>方法。  然后可以分配类的实例，在<strong>创建<code>Thread</code>时作为参数传递</strong>，并启动。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Make sure registerNatives is the first thing &lt;clinit&gt; does. */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    registerNatives();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实现Runnable接口创建的线程，不能通过run或start方法来启动。在Thread类中有一个构造器，这个构造器接收一个Runnable接口的实现类对象，构造Thread线程类对象，然后使用这个线程类对象调用start方法启动我们的线程。</p></blockquote><h3 id="3-2-创建步骤"><a href="#3-2-创建步骤" class="headerlink" title="3.2 创建步骤"></a>3.2 创建步骤</h3><ul><li>自定义线程类实现<strong>Runnable接口</strong></li><li>实现<strong>run()</strong>方法，编写线程执行体</li><li>创建线程对象，调用<strong>start()</strong>方法启动线程</li></ul><p>推荐使用Runnable对象，因为Java单继承的局限性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// run方法线程体</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">      System.out.print(String.format(<span class="string">"%-3d"</span>, i) + <span class="string">"Hello    "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// main方法主线程</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建Runnable接口的实现类对象</span></span><br><span class="line">    Thread3 thread3 = <span class="keyword">new</span> Thread3();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    Thread thread = new Thread(thread3);</span></span><br><span class="line"><span class="comment">//    thread.start();</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(thread3).start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">800</span>; i++) &#123;</span><br><span class="line">      System.err.print(String.format(<span class="string">"%-3d"</span>, i) + <span class="string">"World    "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-对比"><a href="#3-3-对比" class="headerlink" title="3.3 对比"></a>3.3 对比</h3><ul><li>继承Thread类<ul><li>子类继承Thread类具有多线程能力</li><li>启动线程：子类对象.start()</li><li>不建议使用：避免OOP单继承局限</li></ul></li><li>实现Runnable接口<ul><li>子类实现Runnable接口具有多线程能力</li><li>启动线程：传入目标对象+Thread对象.start()</li><li>推荐使用：避免单继承局限性，灵活方便，方便同一对象被多个线程使用</li></ul></li></ul><h2 id="4、Callable接口（了解即可）"><a href="#4、Callable接口（了解即可）" class="headerlink" title="4、Callable接口（了解即可）"></a>4、Callable接口（了解即可）</h2><h3 id="4-1-源码："><a href="#4-1-源码：" class="headerlink" title="4.1 源码："></a>4.1 源码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从源码可以看出，Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p><p>这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务。</p></blockquote><h3 id="4-2-创建步骤"><a href="#4-2-创建步骤" class="headerlink" title="4.2 创建步骤"></a>4.2 创建步骤</h3><ul><li><p>实现Callable接口，需要返回值类型</p></li><li><p>重写call方法，需要抛出异常</p></li><li><p>创建目标对象</p></li><li><p>创建执行服务：<code>ExecutorService ser = Executors.newFixedThreadPool(1);</code></p></li><li><p>提交执行：<code>Future&lt; Boolean&gt; result1 = ser.submit(1);</code></p></li><li><p>获取结果：<code>boolean r1= result1.get();</code></p></li><li><p>关闭服务：<code>ser.shutdownNow();</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Callable1</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">      System.out.println(String.format(<span class="string">"%-3d"</span>, i) +</span><br><span class="line">            Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Callable1 callable1 = <span class="keyword">new</span> Callable1();</span><br><span class="line">    Callable1 callable2 = <span class="keyword">new</span> Callable1();</span><br><span class="line">    Callable1 callable3 = <span class="keyword">new</span> Callable1();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建执行服务</span></span><br><span class="line">    ExecutorService ser = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交执行</span></span><br><span class="line">    Future&lt;Boolean&gt; result1 = ser.submit(callable1);</span><br><span class="line">    Future&lt;Boolean&gt; result2 = ser.submit(callable2);</span><br><span class="line">    Future&lt;Boolean&gt; result3 = ser.submit(callable3);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取结果</span></span><br><span class="line">    <span class="keyword">boolean</span> r1= result1.get();</span><br><span class="line">    <span class="keyword">boolean</span> r2= result2.get();</span><br><span class="line">    <span class="keyword">boolean</span> r3= result3.get();</span><br><span class="line">    System.out.println(r1 + <span class="string">" "</span>+ r2 + <span class="string">" "</span> + r3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭服务</span></span><br><span class="line">    ser.shutdownNow();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、静态代理模式"><a href="#5、静态代理模式" class="headerlink" title="5、静态代理模式"></a>5、静态代理模式</h2><h3 id="5-1-内容"><a href="#5-1-内容" class="headerlink" title="5.1 内容"></a>5.1 内容</h3><p>真实角色，代理角色；真实角色和代理角色要实现同一个接口，代理角色要持有真实角色的<strong>引用</strong>。</p><blockquote><p>在Java中线程的设计使用了静态代理设计模式，其中自定义线程类实现Runable接口，Thread类也实现了Runalbe接口，在创建子线程的时候，传入了自定义线程类的引用，再通过调用start()方法，调用自定义线程对象的run()方法。实现了线程的并发执行。</p></blockquote><p>Thread对象调用线程的start()方法，在内部调用了真实角色的run()方法。</p><h3 id="5-2-设计"><a href="#5-2-设计" class="headerlink" title="5.2 设计"></a>5.2 设计</h3><p>代码结构由三部分组成</p><ul><li><p>接口：主题</p></li><li><p>代理类</p></li><li><p>被代理类</p></li></ul><blockquote><p>实现方式：代理类和被代理类要实现同一个主题接口，而且代理类中要有一个被代理类的属性（target），这样才能把核心业务逻辑交还给被代理类完成；而一些与核心业务逻辑无关的逻辑，并且需求是多变的，那么这些逻辑就可以交给代理类来完成。</p><p>代理对象可以做很多真实对象做不了的事情，真实对象专注做自己的事情</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringPioneer springPioneer = <span class="keyword">new</span> SpringPioneer(<span class="keyword">new</span> Programmer());</span><br><span class="line">    springPioneer.Deploy();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SpringBootFrame</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 接口主题：框架整合部署</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Deploy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实角色，程序员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> <span class="keyword">implements</span> <span class="title">SpringBootFrame</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Deploy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Programmer SpringBoot deployed successfully!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理角色，SpringBoot的作者，帮我们简化开发</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringPioneer</span> <span class="keyword">implements</span> <span class="title">SpringBootFrame</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 代理谁--&gt;真实目标角色</span></span><br><span class="line">  <span class="keyword">private</span> SpringBootFrame target;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SpringPioneer</span><span class="params">(SpringBootFrame target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Deploy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    before();</span><br><span class="line">    <span class="keyword">this</span>.target.Deploy();<span class="comment">// 这就是真实对象</span></span><br><span class="line">    after();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"研发出这个SpringBoot框架，并开源。"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"不断推出新的特性。"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、Lambda表达式"><a href="#6、Lambda表达式" class="headerlink" title="6、Lambda表达式"></a>6、Lambda表达式</h2><p>函数式编程的概念</p><h3 id="6-1-为什么要使用lambda表达式？"><a href="#6-1-为什么要使用lambda表达式？" class="headerlink" title="6.1 为什么要使用lambda表达式？"></a>6.1 为什么要使用lambda表达式？</h3><p>避免匿名内部类定义过多，代码简洁，去掉无意义代码，核心逻辑。</p><p>理解Functional Interface（函数式接口）是学习Java8 lambda表达式的关键。</p><p>函数式接口的定义：任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于函数式接口，我们可以通过lambda表达式来创建接口的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lambda1</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 3.静态内部类</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticEntityLike</span> <span class="keyword">implements</span> <span class="title">Like</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Static likes lambda!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Like entityLike = <span class="keyword">new</span> EntityLike();</span><br><span class="line">    entityLike.lambda();</span><br><span class="line"></span><br><span class="line">    Like staticEntityLike = <span class="keyword">new</span> StaticEntityLike();</span><br><span class="line">    staticEntityLike.lambda();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.局部内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InternalEntityLike</span> <span class="keyword">implements</span> <span class="title">Like</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Internal likes lambda!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Like internalEntityLike = <span class="keyword">new</span> InternalEntityLike();</span><br><span class="line">    internalEntityLike.lambda();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.匿名内部类，没有类的名称，必须借助接口或者父类</span></span><br><span class="line">    Like anonymousEntityLike = <span class="keyword">new</span> Like() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Anonymous likes lambda!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    anonymousEntityLike.lambda();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.用lambda简化</span></span><br><span class="line">    Like lambdaLike = () -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="string">"Lambda likes lambda!"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    lambdaLike.lambda();</span><br><span class="line"></span><br><span class="line"><span class="comment">//    new Like(()-&gt;System.out.println("Lambda likes lambda!")).lambda();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.带参数的</span></span><br><span class="line">    Love lambdaLove = (<span class="keyword">int</span> t) -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="string">"Lambda loves you "</span> + t + <span class="string">" times!"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    lambdaLove.time(<span class="number">520</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.1简化去掉参数类型</span></span><br><span class="line">    Love love1 = (t) -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="string">"Lambda loves you "</span> + t + <span class="string">" times!"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    love1.time(<span class="number">521</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.2简化去掉括号</span></span><br><span class="line">    Love love2 = t -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="string">"Lambda loves you "</span> + t + <span class="string">" times!"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    love2.time(<span class="number">522</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.3简化去掉花括号</span></span><br><span class="line">    <span class="comment">// lambda表达式只能有一行代码的情况下才能简化成为一行，如果有多行，那么就用代码块包裹</span></span><br><span class="line">    Love love3 = t -&gt; System.out.println(<span class="string">"Lambda loves you "</span> + t + <span class="string">" times!"</span>);</span><br><span class="line">    love3.time(<span class="number">523</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.定义一个函数式接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Like</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EntityLike</span> <span class="keyword">implements</span> <span class="title">Like</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"I like lambda!"</span>);</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参数的</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Love</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">time</span><span class="params">(<span class="keyword">int</span> t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个参数可以去掉参数类型，再简化就必须加上括号<code>(a, b)-&gt;{};</code></p><h2 id="7、线程"><a href="#7、线程" class="headerlink" title="7、线程"></a>7、线程</h2><h3 id="7-1-线程状态"><a href="#7-1-线程状态" class="headerlink" title="7.1 线程状态"></a>7.1 线程状态</h3><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Java/Thread/thread_state.PNG" style="zoom:80%;" /></p><p>创建状态（new）：<code>Thread t = new Thread();</code>，线程对象一旦创建，就进入到了新生状态。</p><p>就绪状态：当调用<code>start()</code>方法，线程立即进入就绪状态，但不意味着立即调度执行。</p><p>运行状态：CPU调度进入运行状态线程才真正执行线程体的代码块。</p><p>阻塞状态：当调用<code>sleep()</code>，<code>wait()</code>或同步锁定时，线程进入阻塞状态就是代码不往下执行，阻塞<br>事件解除后，重新进入就绪状态，等待cpu调度执行。</p><p>死亡状态（dead）：线程中断或者结束，<strong>一旦进入死亡状态，就不能再次启动</strong>。</p><h3 id="7-2-线程方法"><a href="#7-2-线程方法" class="headerlink" title="7.2 线程方法"></a>7.2 线程方法</h3><div class="table-container"><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">setPriority(int newPriority)</td><td style="text-align:left">设置当前线程的优先级</td></tr><tr><td style="text-align:center">static void sleep(long millis)</td><td style="text-align:left">在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）。休眠的线程进入阻塞状态。</td></tr><tr><td style="text-align:center">void join()</td><td style="text-align:left">调用join方法的线程强制执行，其他线程处于阻塞状态，等该线程执行完后，其他线程再执行。有可能被外界中断产生InterruptedException中断异常。</td></tr><tr><td style="text-align:center">static void yield()</td><td style="text-align:left">调用yield方法的线程，（暂停当前执行的线程对象）会礼让其他线程先运行。（大概率其他线程先运行，小概率自己还会运行）</td></tr><tr><td style="text-align:center">void interrupt()</td><td style="text-align:left">中断线程，不建议使用</td></tr><tr><td style="text-align:center">boolean isAlive()</td><td style="text-align:left">判断线程是否处于活动状态 （线程调用start后，即处于活动状态）</td></tr></tbody></table></div><h3 id="7-3-停止线程"><a href="#7-3-停止线程" class="headerlink" title="7.3 停止线程"></a>7.3 停止线程</h3><ul><li><p>不推荐使用JDK提供的<code>stop()</code>和<code>destroy()</code>方法。（已废弃）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">      checkAccess();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread()) &#123;</span><br><span class="line">        security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// A zero status value corresponds to "NEW", it can't change to</span></span><br><span class="line">    <span class="comment">// not-NEW because we hold the lock.</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) &#123;</span><br><span class="line">      resume(); <span class="comment">// Wake up thread if it was suspended; no-op otherwise</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The VM can handle all thread states</span></span><br><span class="line">    stop0(<span class="keyword">new</span> ThreadDeath());</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>推荐线程自己停止下来，建议使用一个标志位进行终止变量当<code>flag=false</code>，则终止线程运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.设置一个标志位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">      System.out.println(<span class="string">"run...Thread..."</span>+i++);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.设置一个公开的方法停止线程，转换标志位</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TestStop testStop = <span class="keyword">new</span> TestStop();</span><br><span class="line">    <span class="keyword">new</span> Thread(testStop).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">"main...Thread..."</span>+i);</span><br><span class="line">      <span class="keyword">if</span>(i==<span class="number">100</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用stop方法停止线程</span></span><br><span class="line">        testStop.stop();</span><br><span class="line">        System.out.println(<span class="string">"run...Thread...stoped..."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：线程停止，main线程继续执行到结束</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Java/Thread/test_stop.PNG" style="zoom:67%;" /></p></li></ul><h3 id="7-4-线程休眠"><a href="#7-4-线程休眠" class="headerlink" title="7.4 线程休眠"></a>7.4 线程休眠</h3><blockquote><p>sleep(时间)指定当前线程阻塞的毫秒数；sleep存在异常Interrupted Exception；sleep时间达到后线程进入<strong>就绪状态</strong>；sleep可以模拟网络延时，倒计时等；每一个对象都有一个锁，sleep不会释放锁。</p></blockquote><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟倒计时</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSleep2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      tenDown();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印当前系统时间</span></span><br><span class="line">    Date startTime = <span class="keyword">new</span> Date(System.currentTimeMillis());<span class="comment">// 获取当前系统时间</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Start printing system time..."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(startTime));</span><br><span class="line">        startTime = <span class="keyword">new</span> Date(System.currentTimeMillis());<span class="comment">// 更新时间</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tenDown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      System.out.println(num--);</span><br><span class="line">      <span class="keyword">if</span> (num&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-线程礼让"><a href="#7-4-线程礼让" class="headerlink" title="7.4 线程礼让"></a>7.4 线程礼让</h3><p><strong>礼让线程，让当前正在执行的线程暂停，但不阻塞；将线程从运行状态转为就绪状态；让cpu重新调度，礼让不一定成功！看CPU心情。</strong></p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestYield</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyYield myYield = <span class="keyword">new</span> MyYield();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(myYield, <span class="string">"a"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(myYield, <span class="string">"b"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyYield</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"Thread starts..."</span>);</span><br><span class="line">    Thread.yield();    <span class="comment">// 礼让</span></span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"Thread ends..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-5-线程强制执行"><a href="#7-5-线程强制执行" class="headerlink" title="7.5 线程强制执行"></a>7.5 线程强制执行</h3><blockquote><p>join()合并程序，待此线程执行完成后，再执行其他线程，其他线程阻塞。可以想象为插队。</p></blockquote><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">"VIP thread comes..."</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TestJoin testJoin = <span class="keyword">new</span> TestJoin();</span><br><span class="line">    Thread thisThread = <span class="keyword">new</span> Thread(testJoin);</span><br><span class="line">    thisThread.start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i==<span class="number">90</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          thisThread.join();<span class="comment">// 插队</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"main Thread..."</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取一个运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">main Thread...0</span><br><span class="line">VIP thread comes...0</span><br><span class="line">main Thread...1</span><br><span class="line">VIP thread comes...1</span><br><span class="line">VIP thread comes...2</span><br><span class="line">VIP thread comes...3</span><br><span class="line">VIP thread comes...4</span><br><span class="line">VIP thread comes...5</span><br><span class="line">...</span><br><span class="line">main Thread...87</span><br><span class="line">main Thread...88</span><br><span class="line">main Thread...89</span><br><span class="line">VIP thread comes...19</span><br><span class="line">VIP thread comes...20</span><br><span class="line">VIP thread comes...21</span><br><span class="line">VIP thread comes...22</span><br><span class="line">VIP thread comes...23</span><br><span class="line">VIP thread comes...24</span><br><span class="line">...</span><br><span class="line">VIP thread comes...98</span><br><span class="line">VIP thread comes...99</span><br><span class="line">main Thread...90</span><br><span class="line">main Thread...91</span><br><span class="line">main Thread...92</span><br><span class="line">main Thread...93</span><br></pre></td></tr></table></figure><p>在插队之前，2线程并行，当调用join()后，这个线程即成为VIP，只能等VIP线程执行结束，其他线程才能继续执行。</p><h3 id="7-6-线程状态"><a href="#7-6-线程状态" class="headerlink" title="7.6 线程状态"></a>7.6 线程状态</h3><p>线程状态State是枚举类型，有5个状态，在中文帮助文档中有声明。</p><p>Thread.java源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    TERMINATED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sun.misc.VM.toThreadState(threadStatus);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestState</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"\\\\\\"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 观察状态</span></span><br><span class="line">    Thread.State state = thread.getState();</span><br><span class="line">    System.out.println(state);<span class="comment">// NEW</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动</span></span><br><span class="line">    thread.start();</span><br><span class="line">    state = thread.getState();</span><br><span class="line">    System.out.println(state);<span class="comment">// RUN</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (state != Thread.State.TERMINATED) &#123;<span class="comment">// 只要线程不终止就一直输出状态</span></span><br><span class="line">      Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      state = thread.getState();<span class="comment">// 更新状态</span></span><br><span class="line">      System.out.println(state);</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-7-线程优先级"><a href="#7-7-线程优先级" class="headerlink" title="7.7 线程优先级"></a>7.7 线程优先级</h3><blockquote><p>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行；线程的优先级用数字表示，范围从1-10。</p></blockquote><p>Thread.java源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">        newPriority = g.getMaxPriority();</span><br><span class="line">      &#125;</span><br><span class="line">      setPriority0(priority = newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优先级低只是意味着获得调度的概率低，并不是优先级低就不会被调用了，这都是看CPU的调度。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPriority</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 主线程默认优先级</span></span><br><span class="line">    System.out.println(</span><br><span class="line">        Thread.currentThread().getName() +</span><br><span class="line">        <span class="string">"--&gt;"</span>+Thread.currentThread().getPriority()</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    MyPriority myPriority = <span class="keyword">new</span> MyPriority();</span><br><span class="line">    </span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(myPriority);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(myPriority);</span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(myPriority);</span><br><span class="line">    Thread t4 = <span class="keyword">new</span> Thread(myPriority);</span><br><span class="line">    Thread t5 = <span class="keyword">new</span> Thread(myPriority);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    </span><br><span class="line">    t2.setPriority(<span class="number">2</span>);<span class="comment">// 先设置优先级再启动</span></span><br><span class="line">    t2.start();</span><br><span class="line">    </span><br><span class="line">    t3.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">    t3.start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      t4.setPriority(-<span class="number">1</span>);</span><br><span class="line">      t4.start();</span><br><span class="line">      </span><br><span class="line">      t5.setPriority(<span class="number">11</span>);</span><br><span class="line">      t5.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.err.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPriority</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(</span><br><span class="line">        Thread.currentThread().getName()+<span class="string">"--&gt;"</span> +</span><br><span class="line">        Thread.currentThread().getPriority()</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取一个运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main--&gt;5</span><br><span class="line">java.lang.IllegalArgumentException</span><br><span class="line">Thread-0--&gt;5</span><br><span class="line">Thread-2--&gt;10</span><br><span class="line">Thread-1--&gt;2</span><br></pre></td></tr></table></figure><p>总是主线程mian限制性，优先级低的也可能比高的优先执行。</p><h3 id="7-8-守护（daemon）线程"><a href="#7-8-守护（daemon）线程" class="headerlink" title="7.8 守护（daemon）线程"></a>7.8 守护（daemon）线程</h3><blockquote><p>线程分为用户线程和守护线程；虚拟机必须确保用户线程（main线程）执行完毕；虚拟机不用等待守护线程执行完毕；如后台记录操作日志，监控内存垃圾回收等。</p></blockquote><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDaemon</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    God god = <span class="keyword">new</span> God();</span><br><span class="line">    Man man = <span class="keyword">new</span> Man();</span><br><span class="line">    </span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(god);</span><br><span class="line">    thread.setDaemon(<span class="keyword">true</span>);  <span class="comment">// 默认false表示用户线程，正常的线程都是用户线程</span></span><br><span class="line">    </span><br><span class="line">    thread.start();  <span class="comment">// 守护线程启动</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(man).start();  <span class="comment">// 用户线程挺停止</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">God</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">"God bless you!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.err.println(<span class="string">"Goodbye World!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看似god线程会一直循环执行下去，但它是守护线程，man线程执行结束后，守护线程等一会也会结束，因为虚拟机还会运行一会儿。</p><h2 id="8、线程同步"><a href="#8、线程同步" class="headerlink" title="8、线程同步"></a>8、线程同步</h2><p>多个线程操作同一个资源。</p><p>并发：同一个对象被多个线程同时操作。</p><p>处理多线程问题时，多个线程访问同—个对象，并且某些线程还想修改这个对象，这时候我们就需要线程同步。线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程再使用。</p><h3 id="8-1-队列和锁"><a href="#8-1-队列和锁" class="headerlink" title="8.1 队列和锁"></a>8.1 队列和锁</h3><p>由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制synchronized，当一个线程获得对象的排它锁（锁是对象的），将会独占资源。其他线程必须等待这个线程使用后释放锁即可。存在以下问题：</p><ul><li><p>一个线程持有锁会导致其他所有需要此锁的<strong>线程挂起</strong></p></li><li><p>在多线程竞争下，加锁，释放锁会导致比较多的<strong>上下文切换</strong>和<strong>调度延时</strong>，引起性能问题</p></li><li><p>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致<strong>优先级倒置</strong>，引起性能问题</p></li></ul><h3 id="8-2-同步方法"><a href="#8-2-同步方法" class="headerlink" title="8.2 同步方法"></a>8.2 同步方法</h3><ul><li><p>由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是synchronized关键字，它包括两种用法synchronized方法和synchronized块</p><blockquote><p>同步方法: <code>public synchronized void method(int args)</code></p></blockquote></li><li><p>synchronized方法控制对“<strong>对象</strong>“的访问，每个<strong>对象</strong>对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行</p><blockquote><p>缺陷：若将一个大的方法申明为 synchronized将会影响效率</p></blockquote></li><li><p>弊端：需要锁太多，浪费资源</p></li></ul><h3 id="8-3-同步块"><a href="#8-3-同步块" class="headerlink" title="8.3 同步块"></a>8.3 同步块</h3><ul><li><p>同步块：<code>synchronized(obj){}</code></p></li><li><p>obj称之为同步监视器</p><ul><li>obj可以是任何对象，但是推荐使用共享资源作为同步监视器</li><li>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class[反射中讲解]</li></ul></li><li><p>同步监视器的执行过程</p><ul><li>第一个线程访问，锁定同步监视器，执行其中代码</li><li>第二个线程访问，发现同步监视器被锁定，无法访问</li><li>第一个线程访问完毕，解锁同步监视器</li><li>第二个线程访问，发现同步监视器没有锁，然后锁定并访问</li></ul></li></ul><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Account account = <span class="keyword">new</span> Account(<span class="number">100</span>, <span class="string">"Deposit"</span>);</span><br><span class="line">    </span><br><span class="line">    Drawing husband = <span class="keyword">new</span> Drawing(account, <span class="number">50</span>, <span class="string">"husband"</span>);</span><br><span class="line">    Drawing wife = <span class="keyword">new</span> Drawing(account, <span class="number">100</span>, <span class="string">"wife"</span>);</span><br><span class="line">    </span><br><span class="line">    husband.start();</span><br><span class="line">    wife.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> money;</span><br><span class="line">  String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> money, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.money = money;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drawing</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  Account account;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> drawingMoney;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> nowMoney;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Drawing</span><span class="params">(Account account, <span class="keyword">int</span> drawingMoney, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.account = account;</span><br><span class="line">    <span class="keyword">this</span>.drawingMoney = drawingMoney;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// @Override</span></span><br><span class="line">  <span class="comment">// public synchronized void run() &#123;</span></span><br><span class="line">  <span class="comment">//   if(account.money-drawingMoney&lt;0) &#123;</span></span><br><span class="line">  <span class="comment">//     System.out.println(Thread.currentThread().getName()+" Money is not enough!");</span></span><br><span class="line">  <span class="comment">//     return;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">//   try &#123;</span></span><br><span class="line">  <span class="comment">//     Thread.sleep(1000);</span></span><br><span class="line">  <span class="comment">//   &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line">  <span class="comment">//     e.printStackTrace();</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">//   // 卡内余额</span></span><br><span class="line">  <span class="comment">//   account.money = account.money - drawingMoney;</span></span><br><span class="line">  <span class="comment">//   // 手里的现金</span></span><br><span class="line">  <span class="comment">//   nowMoney = nowMoney + drawingMoney;</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">//   System.out.println(account.name + " balance is "+account.money);</span></span><br><span class="line">  <span class="comment">//   System.out.println(this.getName()+"'s cash now is "+nowMoney);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (account) &#123;</span><br><span class="line">      <span class="keyword">if</span>(account.money-drawingMoney&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" Money is not enough!"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      account.money = account.money - drawingMoney;</span><br><span class="line"></span><br><span class="line">      nowMoney = nowMoney + drawingMoney;</span><br><span class="line">      </span><br><span class="line">      System.out.println(account.name + <span class="string">" balance is "</span>+account.money);</span><br><span class="line">      System.out.println(<span class="keyword">this</span>.getName()+<span class="string">"'s cash now is "</span>+nowMoney);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里要注意了：同步块指定锁住的对象，可以锁住任何对象。如果用上面的方法将run方法上锁，锁住的是husband和wife对象，也就是有两把锁了（2个线程2把锁）。只能用下面的方法锁住变化的量，才有用。</p><p>List等常见数据集合是非安全的，JUC(java.util.concurrent包)中提供了CopyOnWriteArrayList等安全类型的集合。</p></blockquote><h2 id="9、锁"><a href="#9、锁" class="headerlink" title="9、锁"></a>9、锁</h2><h3 id="9-1-死锁"><a href="#9-1-死锁" class="headerlink" title="9.1 死锁"></a>9.1 死锁</h3><blockquote><p>多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。某一个同步块同时拥有“两个以上对象的锁”时，就可能会发生“死锁”的问题。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Makeup girl1 = <span class="keyword">new</span> Makeup(<span class="number">0</span>, <span class="string">"Marry"</span>);</span><br><span class="line">    Makeup girl2 = <span class="keyword">new</span> Makeup(<span class="number">1</span>, <span class="string">"Lisa"</span>);</span><br><span class="line">    </span><br><span class="line">    girl1.start();</span><br><span class="line">    girl2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lipstick</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mirror</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Makeup</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用static保证资源只有一份儿</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Lipstick lipstick = <span class="keyword">new</span> Lipstick();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Mirror mirror = <span class="keyword">new</span> Mirror();</span><br><span class="line">  <span class="keyword">int</span> choice;</span><br><span class="line">  String name;<span class="comment">// 化妆的人</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Makeup</span><span class="params">(<span class="keyword">int</span> choice, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.choice = choice;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      startMakeup();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 化妆，互相持有对方的锁，就是需要拿到对方的资源</span></span><br><span class="line">  <span class="comment">// private void startMakeup() throws InterruptedException &#123;</span></span><br><span class="line">  <span class="comment">//   if (choice==0) &#123;</span></span><br><span class="line">  <span class="comment">//     synchronized (lipstick) &#123;// 获得口红的锁</span></span><br><span class="line">  <span class="comment">//       System.out.println(this.name+" got the lipstick!");</span></span><br><span class="line">  <span class="comment">//       Thread.sleep(1000);</span></span><br><span class="line">  <span class="comment">//       synchronized (mirror) &#123;// 1秒钟后向获得镜子</span></span><br><span class="line">  <span class="comment">//         System.out.println(this.name+" got the mirror!");</span></span><br><span class="line">  <span class="comment">//       &#125;</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">//   &#125; else &#123;</span></span><br><span class="line">  <span class="comment">//     synchronized (mirror) &#123;</span></span><br><span class="line">  <span class="comment">//       System.out.println(this.name+" got the mirror!");</span></span><br><span class="line">  <span class="comment">//       Thread.sleep(1000);</span></span><br><span class="line">  <span class="comment">//       synchronized (lipstick) &#123;</span></span><br><span class="line">  <span class="comment">//         System.out.println(this.name+" got the lipstick!");</span></span><br><span class="line">  <span class="comment">//       &#125;</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">//   // 比如选择0时，只有当得到镜子后才会释放口红的锁，就会死锁</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startMakeup</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (choice==<span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (lipstick) &#123;<span class="comment">// 获得口红的锁</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">" got the lipstick!"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">synchronized</span> (mirror) &#123;<span class="comment">// 1秒钟后向获得镜子</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">" got the mirror!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (mirror) &#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">" got the mirror!"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">synchronized</span> (lipstick) &#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">" got the lipstick!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这样做就是当口红用完口红的锁就释放</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合操作系统死锁产生的条件和避免死锁的方式。</p><h3 id="9-2-Lock（锁）"><a href="#9-2-Lock（锁）" class="headerlink" title="9.2 Lock（锁）"></a>9.2 Lock（锁）</h3><ul><li><p>从JDK5.0开始，Java提供了更强大的线程同步机制：通过显式定义<strong>同步锁对象</strong>来实现同步。同步锁使用Lock对象充当</p></li><li><p>java.utll.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问,毎次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象</p></li><li><p>ReentrantLock（可重入锁）类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是Reentrantlock，可以显式加锁、释放锁。</p></li></ul><h3 id="9-3-synchronized和Lock的对比"><a href="#9-3-synchronized和Lock的对比" class="headerlink" title="9.3 synchronized和Lock的对比"></a>9.3 synchronized和Lock的对比</h3><ul><li><p>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁）synchronized是隐式锁，出了作用域自动释放</p></li><li><p>Lock只有代码块锁，synchronized有代码块锁和方法锁</p></li><li><p>使用Lock锁，JwM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</p></li><li><p>优先使用顺序：Lock &gt; 同步代码块（已经进入了方法体，分配了相应资源） &gt; 同步方法（在方法体之外）</p></li></ul><h2 id="10、线程协作（线程通信）"><a href="#10、线程协作（线程通信）" class="headerlink" title="10、线程协作（线程通信）"></a>10、线程协作（线程通信）</h2><blockquote><p>在生产者消费者问题中，仅有synchronized是不够的</p><ul><li><p>synchronized可阻止并发更新同一个共享资源，实现了同步</p></li><li><p>synchronized不能用来实现不同线程之间的消息传递（通信）</p></li></ul></blockquote><p>Java提供了几个方法解决线程之间的通信问题</p><div class="table-container"><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>wait()</td><td>表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁</td></tr><tr><td>wait(long timeout)</td><td>指定等待的毫秒数</td></tr><tr><td>notify()</td><td>唤醒一个处于等待状态的线程</td></tr><tr><td>notifyAll()</td><td>唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度</td></tr></tbody></table></div><blockquote><p>注意：均是Object类的方法，都只能在同步方法或者同步代码块中使用否则会抛出异常IlegalMonitorState Exception</p></blockquote><h3 id="10-1-解决方式1：管程法"><a href="#10-1-解决方式1：管程法" class="headerlink" title="10.1 解决方式1：管程法"></a>10.1 解决方式1：管程法</h3><p>并发协作模型“生产者/消费者模式”—&gt;管程法</p><ul><li><p>生产者：负责生产数据的模块(可能是方法，对象，线程，进程)</p></li><li><p>消费者：负责处理数据的模块(可能是方法，对象，线程，进程)</p></li><li><p>缓冲区：消费者不能直接使用生产者的数据，他们之间有个“缓冲区“</p></li></ul><p>生产者将生产好的数据放入<strong>缓冲区</strong>，消费者从缓冲区拿出数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProductorCustomer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Buffer buffer = <span class="keyword">new</span> Buffer();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Productor(buffer).start();</span><br><span class="line">    <span class="keyword">new</span> Customer(buffer).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Productor</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 需要一个容器</span></span><br><span class="line">  Buffer buffer;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Productor</span><span class="params">(Buffer buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.buffer = buffer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生产</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">      buffer.push(<span class="keyword">new</span> Goods(i));</span><br><span class="line">      System.out.println(<span class="string">"生产了第"</span>+i+<span class="string">"个商品！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  Buffer buffer;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(Buffer buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.buffer = buffer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 消费</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">"消费了第"</span> + buffer.pop().getID() + <span class="string">"个商品！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> ID;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ID = id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ID;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓冲区</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 需要一个容器大小</span></span><br><span class="line">  Goods[] goods = <span class="keyword">new</span> Goods[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生产者放入产品</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Goods good)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果容器满了，就需要等待消费者消费</span></span><br><span class="line">    <span class="keyword">if</span>(count==goods.length) &#123;</span><br><span class="line">      <span class="comment">// 通知消费者消费，生产等待</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.wait();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有满就需要放入产品</span></span><br><span class="line">    goods[count] = good;</span><br><span class="line">    count++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以通知消费者消费了</span></span><br><span class="line">    <span class="keyword">this</span>.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 消费者消费产品</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Goods <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果容器是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 通知生产者生产，消费等待</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.wait();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果可以消费</span></span><br><span class="line">    count--;</span><br><span class="line">    Goods good = goods[count];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以通知生产者生产了</span></span><br><span class="line">    <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    <span class="keyword">return</span> good;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-2-解决方式2：信号灯法"><a href="#10-2-解决方式2：信号灯法" class="headerlink" title="10.2 解决方式2：信号灯法"></a>10.2 解决方式2：信号灯法</h3><p>就是长度为1的管程法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductorCustomerUsingSignal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Show show = <span class="keyword">new</span> Show();</span><br><span class="line">    <span class="keyword">new</span> Actor(show).start();</span><br><span class="line">    <span class="keyword">new</span> Audience(show).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者演员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actor</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Show show;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Actor</span><span class="params">(Show show)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.show = show;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.show.play(<span class="string">"Happy Camp!"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.show.play(<span class="string">"TikTok!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者观众</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Audience</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Show show;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Audience</span><span class="params">(Show show)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.show = show;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>.show.watch();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源节目</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 演员表演，观众等待T</span></span><br><span class="line">  <span class="comment">// 观众观看，演员等待F</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">  String display;<span class="comment">// 表演的节目</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表演</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String display)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.wait();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"Actors show the "</span>+display);</span><br><span class="line">    <span class="comment">// 通知观众观看</span></span><br><span class="line">    <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    <span class="keyword">this</span>.display = display;</span><br><span class="line">    <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表演</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.wait();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"Audience watch the "</span>+display);</span><br><span class="line">    <span class="comment">// 通知演员表演</span></span><br><span class="line">    <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11、线程池"><a href="#11、线程池" class="headerlink" title="11、线程池"></a>11、线程池</h2><blockquote><p>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。</p><p>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具（共享单车）。</p></blockquote><p>优势：</p><ul><li><p>提高响应速度（减少了创建新线程的时间）</p></li><li><p>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p></li><li><p>便于线程管理（…）</p><ul><li>corePoolsize：核心池的大小</li><li>maximumPoolsize：最大线程数</li><li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPool</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建服务，创建线程池</span></span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    executorService.execute(<span class="keyword">new</span> PoolThread());</span><br><span class="line">    executorService.execute(<span class="keyword">new</span> PoolThread());</span><br><span class="line">    executorService.execute(<span class="keyword">new</span> PoolThread());</span><br><span class="line">    executorService.execute(<span class="keyword">new</span> PoolThread());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.关闭连接</span></span><br><span class="line">    executorService.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoolThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>JDK5.0起提供了线程池相关API：ExecutorService和Executors</p></li><li><p>Executor Service：真正的线程池接口。常见子类 ThreadPoolExecutor</p><ul><li><code>void execute( Runnable command)</code>：执行任务命令，没有返回值，一般用来执行 Runnable</li><li><code>&lt;T&gt; Future&lt;T&gt; submit( Callable&lt;T&gt;task)</code>：执行任务，有返回值，一般又来执行Callable（上面我们介绍Callable接口时测试过）</li><li><code>void shutdown()</code>：关闭连接池</li></ul></li><li><p>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;创建线程的&lt;strong&gt;主要&lt;/strong&gt;方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;继承Thread类创建线程类（重点）&lt;/li&gt;
&lt;li&gt;实现Runnable接口创建线程类（重点）&lt;/li&gt;
&lt;li&gt;实现Callable接口或Future接口创建线程（了解）&lt;/li&gt;
&lt;li&gt;线程池&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://mysticalguest.github.io/categories/Java/"/>
    
    
      <category term="原理" scheme="https://mysticalguest.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Redis入门</title>
    <link href="https://mysticalguest.github.io/Redis/3392.html"/>
    <id>https://mysticalguest.github.io/Redis/3392.html</id>
    <published>2020-09-02T02:02:44.660Z</published>
    <updated>2021-04-15T13:15:01.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、NoSQL概述"><a href="#1、NoSQL概述" class="headerlink" title="1、NoSQL概述"></a>1、NoSQL概述</h2><h3 id="1-1-为什么要用NoSQL"><a href="#1-1-为什么要用NoSQL" class="headerlink" title="1.1 为什么要用NoSQL"></a>1.1 为什么要用NoSQL</h3><a id="more"></a><p>大数据时代，分布式集群，单机—&gt;分布式</p><ul><li><p>单机MySQL的时代</p><blockquote><p>应用不是直接访问MySQL，会通过一些方法，DAL（数据访问层，Data Access Layer）去访问MySQL实例。以前不同SQL对应不同语法，麻烦，出现了框架Hibernate和MyBatis等框架，开发变得简单，框架底层值得学习。</p></blockquote></li><li><p>90年代，一个基本的的网站访问量不会太大，单个数据库完全足够！</p><blockquote><p>那个时候更多的去使用静态网页Html，服务器根本没有太大压力！</p><p>思考一下，这种情况下：整个网站的瓶颈是什么？</p></blockquote><ul><li>数据量太大，一个机器放不下！</li><li>数据的索引，比如如果MySQL的数据超300万，不建立索引太慢！MySQL使用B+Tree，索引机器也放不下！</li><li>访问量（读写混合），一个服务器承受不来！</li></ul><blockquote><p>只要出现以上3种情况之一，就要晋级！</p></blockquote></li><li><p>Memcached（缓存）+MySQL+垂直拆分（读写分离）</p><blockquote><p>网站80%的情况都在读，每次都要去查询数据库的话时分麻烦（比如两个人查询语句相同，无需再次查询服务器），所以说我们希望减轻服务器压力，可以使用缓存来保持效率！</p><p>发展过程：优化数据结构和索引-&gt;文件索引（IO）-&gt;Memcached（当时最热门的技术）</p></blockquote><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/redis/cache.png" style="zoom:50%;" /></p></li><li><p>分库分表+水平拆分+MySQL集群</p><blockquote><p>技术和业务在发展的同时，对人的要求也越来越高了！</p><p>数据库本质：读写</p><p>早些年MyISAM（默认存储引擎）：表锁，十分影响效率！高并发下就会出现严重的锁问题；</p><p>转战Innodb：行锁</p><p>慢慢的开始使用分库分表来解决写的压力！多服务多表MySQL在那个年代推出了表分区！但并没有多少公司使用。MySQL的集群，很好满足那个年代需求。</p></blockquote><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/redis/Cluster.png" style="zoom: 40%;" /></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、NoSQL概述&quot;&gt;&lt;a href=&quot;#1、NoSQL概述&quot; class=&quot;headerlink&quot; title=&quot;1、NoSQL概述&quot;&gt;&lt;/a&gt;1、NoSQL概述&lt;/h2&gt;&lt;h3 id=&quot;1-1-为什么要用NoSQL&quot;&gt;&lt;a href=&quot;#1-1-为什么要用NoSQL&quot; class=&quot;headerlink&quot; title=&quot;1.1 为什么要用NoSQL&quot;&gt;&lt;/a&gt;1.1 为什么要用NoSQL&lt;/h3&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://mysticalguest.github.io/categories/Redis/"/>
    
    
      <category term="数据库" scheme="https://mysticalguest.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch入门</title>
    <link href="https://mysticalguest.github.io/ElasticSearch/36460.html"/>
    <id>https://mysticalguest.github.io/ElasticSearch/36460.html</id>
    <published>2020-08-29T13:00:34.978Z</published>
    <updated>2021-04-08T13:00:42.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、ElasticSearch介绍"><a href="#1、ElasticSearch介绍" class="headerlink" title="1、ElasticSearch介绍"></a>1、ElasticSearch介绍</h2><a id="more"></a><h3 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1 引言"></a>1.1 引言</h3><ul><li><p>在海量数据中执行搜索功能时，如果使用MSQL，效率太低。</p></li><li><p>如果关键字输入的不准确一样可以搜索到想要的数据。</p></li><li><p>将搜索关键字，以高亮字体展示（购物网站）。</p></li></ul><h3 id="1-2-ES的介绍"><a href="#1-2-ES的介绍" class="headerlink" title="1.2 ES的介绍"></a>1.2 ES的介绍</h3><p>ES是一个使用Java语言并且基于lucence编写的搜索引擎框架，他提供了分布式的全文搜索功能，提供了一个统一的基于RESTful风格的WEB接口。<a href="https://www.elastic.co/cn/">官方文档</a></p><ul><li><p>lucence：一个搜索引擎底层，<a href="https://lucene.apache.org/">官方网站</a>，apache旗下的顶级项目，直接使用成本太高，所以采用ES实现功能。</p></li><li><p>分布式：突出ES的横向扩展能力。</p></li><li><p>全文检索：将一段词语进行分词，并将分出的单个词语统一的放在一个分词库中，在搜索时，根据关键字取分词库中检索，找到匹配的内容（倒排索引）。</p><blockquote><p>比如：淘宝搜索“壳手机”，将其分解为“壳”、“手机”、“手”等；将目标“…苹果手机壳…”也这样分解。（全文检索）</p></blockquote></li><li><p>RESTful风格的WEB接口：操作ES，只需要发送一个http请求，并且根据请求方式的不同，携带参数的不同，执行相应的功能。</p></li></ul><p>应用广泛：WIKI，Github，Gold Man用ES每天维护将近10TB数据。</p><h3 id="1-3-ES的由来"><a href="#1-3-ES的由来" class="headerlink" title="1.3 ES的由来"></a>1.3 ES的由来</h3><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/intro.html">你知道的, 为了搜索…</a></p><p><strong>回忆时光</strong></p><p>许多年前，一个刚结婚的名叫 Shay Banon 的失业开发者，跟着他的妻子去了伦敦，他的妻子在那里学习厨师。 在寻找一个赚钱的工作的时候，为了给他的妻子做一个食谱搜索引擎，他开始使用 Lucene 的一个早期版本。</p><p>直接使用 Lucene 是很难的，因此 Shay 开始做一个抽象层，Java 开发者使用它可以很简单的给他们的程序添加搜索功能。 他发布了他的第一个开源项目 Compass。</p><p>后来 Shay 获得了一份工作，主要是高性能，分布式环境下的内存数据网格。这个对于高性能，实时，分布式搜索引擎的需求尤为突出， 他决定重写 Compass，把它变为一个独立的服务并取名 Elasticsearch。</p><p>第一个公开版本在2010年2月发布，从此以后，Elasticsearch 已经成为了 Github 上最活跃的项目之一，他拥有超过300名 contributors(目前736名 contributors )。 一家公司已经开始围绕 Elasticsearch 提供商业服务，并开发新的特性，但是，Elasticsearch 将永远开源并对所有人可用。</p><p>据说，Shay 的妻子还在等着她的食谱搜索引擎…</p><h3 id="1-4-ES和Slor"><a href="#1-4-ES和Slor" class="headerlink" title="1.4 ES和Slor"></a>1.4 ES和Slor</h3><ul><li><p>Solr在查询死数据时，速度比ES快。但是数据如果是改变的，Solr查询速度会降低很多，ES的查询速度没有变化。</p></li><li><p>Solr搭建集群依赖ZooKeeper来帮助管理，ES本身就支持集群的搭建，不需要第三方的介入。</p></li><li><p>Solr出现早，最开始Solr的社区很火爆，针对国内文档少；ES出现后，国内社区火爆程度 上升，ES的文档非常健全。</p></li><li><p>ES对云计算和大数据支持很好</p></li></ul><h3 id="1-5-倒排索引"><a href="#1-5-倒排索引" class="headerlink" title="1.5 倒排索引"></a>1.5 倒排索引</h3><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/elasticsearch/step.png" style="zoom: 67%;" /></p><p>拿到数据的过程分两步：（关键字：“好编程“，分词为”好“和”编程“）</p><ul><li><strong>query</strong>：根据输入的关键字，去分词库中检索内容；结果：1,2,3</li><li><strong>fetch</strong>：根据在分词库中检索到的id，直接拉取指定数据；结果：“1：你好”，“2：编程”和“3：你好编程”</li></ul><blockquote><p>将存放的数据以一定的方式进行分词，并将分词的内容存放到一个单独的分词库中。</p><p>当用户取查询数据时，会将用户的查询关键字进行分词。</p><p>然后去分词库中匹配内容，最终得到数据的id标识</p><p>根据id标识去存放数据的位置拉去指定数据</p></blockquote><h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><h3 id="2-1-安装docker-compose"><a href="#2-1-安装docker-compose" class="headerlink" title="2.1 安装docker-compose"></a>2.1 安装docker-compose</h3><p><a href="https://mysteryguest.gitee.io/2020/08/18/Spring/SpringBootDocker/#3、安装Docker">Docker安装方法</a></p><h4 id="2-2-1-安装方法1，使用pip"><a href="#2-2-1-安装方法1，使用pip" class="headerlink" title="2.2.1 安装方法1，使用pip"></a>2.2.1 安装方法1，使用pip</h4><ul><li><p>安装pip需要先安装epel-release包</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> yum <span class="literal">-y</span> install <span class="literal">-y</span> epel<span class="literal">-release</span></span><br></pre></td></tr></table></figure></li><li><p>安装pip</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> yum install <span class="literal">-y</span> python<span class="literal">-pip</span></span><br></pre></td></tr></table></figure></li><li><p>检查python和pip版本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> python <span class="literal">-V</span>   <span class="comment"># 3+</span></span><br><span class="line"><span class="variable">$</span> pip <span class="literal">-V</span>      <span class="comment"># 20+</span></span><br></pre></td></tr></table></figure></li><li><p>若不满足上述条件</p><ul><li><p>pip升级</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> pip install -<span class="literal">-upgrade</span> pip <span class="literal">-ihttp</span>://pypi.douban.com/simple -<span class="literal">-trusted</span><span class="literal">-host</span> pypi.douban.com</span><br></pre></td></tr></table></figure></li><li><p>升级python2到python3</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line"><span class="variable">$</span> wget https://www.python.org/ftp/python/<span class="number">3.7</span>.<span class="number">0</span>/Python<span class="literal">-3</span>.<span class="number">7.0</span>.tgz</span><br><span class="line"><span class="comment"># 解压源码包</span></span><br><span class="line"><span class="variable">$</span> tar <span class="literal">-zxvf</span> Python<span class="literal">-3</span>.<span class="number">7.0</span>.tgz</span><br><span class="line"><span class="comment"># 创建安装目录</span></span><br><span class="line"><span class="variable">$</span> mkdir /usr/local/python3</span><br><span class="line"><span class="variable">$</span> cd Python<span class="literal">-3</span>.<span class="number">7.0</span>/</span><br><span class="line"><span class="comment"># 安装到指定目录</span></span><br><span class="line"><span class="variable">$</span> ./configure -<span class="literal">-prefix</span>=/usr/local/python3</span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line"><span class="variable">$</span> make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li><li><p>设置软链接全局使用python3</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> cd /usr/local/python3</span><br><span class="line"><span class="variable">$</span> ln <span class="literal">-s</span> /usr/local/python3/bin/python3 /usr/local/bin/python3</span><br><span class="line"><span class="variable">$</span> ln <span class="literal">-s</span> /usr/local/python3/bin/pip3 /usr/local/bin/pip3</span><br><span class="line"><span class="variable">$</span> ln <span class="literal">-s</span> /usr/local/bin/pip3 /usr/bin/pip</span><br></pre></td></tr></table></figure></li><li><p>验证版本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> python3 <span class="literal">-V</span></span><br><span class="line">Python <span class="number">3.7</span>.<span class="number">0</span></span><br><span class="line"><span class="variable">$</span> pip <span class="literal">-v</span></span><br><span class="line">pip <span class="number">20.2</span>.<span class="number">2</span> from /usr/local/python3/lib/python3.<span class="number">7</span>/site<span class="literal">-packages</span>/pip (python <span class="number">3.7</span>)</span><br></pre></td></tr></table></figure></li><li><p>可以使用下述命令来查看软链接设置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> ls <span class="literal">-al</span> /usr/bin | grep python</span><br></pre></td></tr></table></figure></li><li><p>升级 Python 之后，由于将默认的 python 指向了 python3，yum 不能正常使用，需要编辑 yum 的配置文件：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> vi /usr/bin/yum</span><br><span class="line">将 <span class="comment">#!/usr/bin/python 改为 #!/usr/bin/python2.7</span></span><br><span class="line"><span class="variable">$</span> vi /usr/libexec/urlgrabber<span class="literal">-ext</span><span class="literal">-down</span></span><br><span class="line">将 <span class="comment">#!/usr/bin/python 改为 #!/usr/bin/python2.7</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>指定安装源，安装docker-compose</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> pip install <span class="literal">-i</span> https://pypi.tuna.tsinghua.edu.cn/simple docker<span class="literal">-compose</span></span><br></pre></td></tr></table></figure></li><li><p>查看docker-compose的版本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> docker<span class="literal">-compose</span> <span class="literal">-v</span></span><br><span class="line">docker<span class="literal">-compose</span> version <span class="number">1.24</span>.<span class="number">0</span>, build <span class="number">0</span>aa5906</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-1-2-安装方法2，离线安装（推荐）"><a href="#2-1-2-安装方法2，离线安装（推荐）" class="headerlink" title="2.1.2 安装方法2，离线安装（推荐）"></a>2.1.2 安装方法2，离线安装（推荐）</h4><p>Github发行<a href="https://github.com/docker/compose/releases">版本</a>，下载<code>docker-compose-Linux-x86_64</code>，推荐一个软件<code>Motrix</code>，加快下载速度，将下载文件命名为<code>docker-compose</code>。</p><ul><li><p>上传到服务器并移动到<code>/usr/local/bin/</code>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> mv docker<span class="literal">-compose</span> /usr/local/bin/</span><br></pre></td></tr></table></figure></li><li><p>添加可执行权限</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> chmod +x /usr/local/bin/docker<span class="literal">-compose</span></span><br></pre></td></tr></table></figure></li><li><p>查看docker-compose版本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> docker<span class="literal">-compose</span> <span class="literal">-v</span></span><br><span class="line">docker<span class="literal">-compose</span> version <span class="number">1.26</span>.<span class="number">2</span>, build eefe0d31</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-安装ElasticSearch-amp-Kibana"><a href="#2-2-安装ElasticSearch-amp-Kibana" class="headerlink" title="2.2 安装ElasticSearch&amp;Kibana"></a>2.2 安装ElasticSearch&amp;Kibana</h3><p><a href="http://hub.daocloud.io/">Docker镜像工厂</a>，分别搜索“elasticsearch”和“kibana”，选取“<strong>社区镜像</strong>”作为来源，找到“library/elasticsearch”和“library/kibana”，版本同一。</p><p>Kibana是为Elasticsearch设计的开源分析和可视化平台。</p><ul><li><p>在指定文件夹下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> vi docker<span class="literal">-compose</span>.yml</span><br></pre></td></tr></table></figure></li><li><p>并复制下面内容到docker-compose.yml文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line">  <span class="attr">elasticsearch:</span> </span><br><span class="line">    <span class="attr">image:</span> <span class="string">daocloud.io/library/elasticsearch:6.5.4</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line">  <span class="attr">kibana:</span> </span><br><span class="line">    <span class="attr">image:</span> <span class="string">daocloud.io/library/kibana:6.5.4</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kibana</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="number">5601</span><span class="string">:5601</span></span><br><span class="line">    <span class="attr">environment:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticsearch_url=ip:9200</span>   <span class="comment"># 此处ip为自己对应主机地址</span></span><br><span class="line">    <span class="attr">depends_on:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticsearch</span></span><br></pre></td></tr></table></figure></li><li><p>运行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> docker<span class="literal">-compose</span> up <span class="literal">-d</span></span><br></pre></td></tr></table></figure></li><li><p>查看日志</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> docker<span class="literal">-compose</span> logs <span class="operator">-f</span></span><br></pre></td></tr></table></figure></li><li><p>浏览器查看，成功</p><ul><li><p>浏览<a href="http://192.168.6.33:9200/：">http://192.168.6.33:9200/：</a></p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/elasticsearch/es_success.PNG" alt=""></p></li><li><p>浏览<a href="http://192.168.6.33:5601">http://192.168.6.33:5601</a></p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/elasticsearch/kb_success.PNG" alt=""></p></li></ul></li></ul><h3 id="2-3-安装IK分词器"><a href="#2-3-安装IK分词器" class="headerlink" title="2.3 安装IK分词器"></a>2.3 安装IK分词器</h3><p>Es默认的分词器对中文的支持是不友好的，Github下载<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">地址</a>，版本还是要统一。</p><p>还是使用docker安装：</p><ul><li><p>查看es容器的CONTAINER ID，进入es容器内部：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">docker_elasticsearch</span>]<span class="comment"># docker exec -it &lt;CONTAINER ID&gt; bash</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">fddcec4fe9e7</span> <span class="type">elasticsearch</span>]<span class="comment">#</span></span><br></pre></td></tr></table></figure></li><li><p>进入bin目录，执行bin目录下的脚本文件：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> cd bin</span><br></pre></td></tr></table></figure></li><li><p>IK分词器对于es来说就是一个插件：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> ./elastic<span class="built_in">search-plugin</span> install </span><br><span class="line">      https://github.com/medcl/elastic<span class="built_in">search-analysis</span><span class="literal">-ik</span>/releases/download/v6.<span class="number">5.4</span>/</span><br><span class="line">              elastic<span class="built_in">search-analysis</span><span class="literal">-ik</span><span class="literal">-6</span>.<span class="number">5.4</span>.zip</span><br></pre></td></tr></table></figure><blockquote><p>由于在容器内安装IK分词器，如果把容器<code>down</code>掉，这个IK分词器就没了，重启就可以了</p></blockquote></li><li><p>记得重启es容器，分词器才会生效，重启es就可以了：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> docker restart &lt;CONTAINER ID&gt;</span><br></pre></td></tr></table></figure></li><li><p>在Kibana中测试，使用GitHub推荐<a href="https://github.com/medcl/elasticsearch-analysis-ik#quick-example">方法</a>；在Dev Tool中：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">_analyze</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">"analyzer"</span>: <span class="string">"ik_max_word",</span></span><br><span class="line">  <span class="meta">"text"</span>:<span class="string">"我是Java工程师.你呢?"</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>得到输出“</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"tokens"</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"token"</span> : <span class="string">"我"</span>,</span><br><span class="line">      <span class="attr">"start_offset"</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"end_offset"</span> : <span class="number">1</span>,</span><br><span class="line">      <span class="attr">"type"</span> : <span class="string">"CN_CHAR"</span>,</span><br><span class="line">      <span class="attr">"position"</span> : <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"token"</span> : <span class="string">"是"</span>,</span><br><span class="line">      <span class="attr">"start_offset"</span> : <span class="number">1</span>,</span><br><span class="line">      <span class="attr">"end_offset"</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"type"</span> : <span class="string">"CN_CHAR"</span>,</span><br><span class="line">      <span class="attr">"position"</span> : <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"token"</span> : <span class="string">"java"</span>,</span><br><span class="line">      <span class="attr">"start_offset"</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"end_offset"</span> : <span class="number">6</span>,</span><br><span class="line">      <span class="attr">"type"</span> : <span class="string">"ENGLISH"</span>,</span><br><span class="line">      <span class="attr">"position"</span> : <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"token"</span> : <span class="string">"工程师"</span>,</span><br><span class="line">      <span class="attr">"start_offset"</span> : <span class="number">6</span>,</span><br><span class="line">      <span class="attr">"end_offset"</span> : <span class="number">9</span>,</span><br><span class="line">      <span class="attr">"type"</span> : <span class="string">"CN_WORD"</span>,</span><br><span class="line">      <span class="attr">"position"</span> : <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"token"</span> : <span class="string">"工程"</span>,</span><br><span class="line">      <span class="attr">"start_offset"</span> : <span class="number">6</span>,</span><br><span class="line">      <span class="attr">"end_offset"</span> : <span class="number">8</span>,</span><br><span class="line">      <span class="attr">"type"</span> : <span class="string">"CN_WORD"</span>,</span><br><span class="line">      <span class="attr">"position"</span> : <span class="number">4</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"token"</span> : <span class="string">"师"</span>,</span><br><span class="line">      <span class="attr">"start_offset"</span> : <span class="number">8</span>,</span><br><span class="line">      <span class="attr">"end_offset"</span> : <span class="number">9</span>,</span><br><span class="line">      <span class="attr">"type"</span> : <span class="string">"CN_CHAR"</span>,</span><br><span class="line">      <span class="attr">"position"</span> : <span class="number">5</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"token"</span> : <span class="string">"你"</span>,</span><br><span class="line">      <span class="attr">"start_offset"</span> : <span class="number">10</span>,</span><br><span class="line">      <span class="attr">"end_offset"</span> : <span class="number">11</span>,</span><br><span class="line">      <span class="attr">"type"</span> : <span class="string">"CN_CHAR"</span>,</span><br><span class="line">      <span class="attr">"position"</span> : <span class="number">6</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"token"</span> : <span class="string">"呢"</span>,</span><br><span class="line">      <span class="attr">"start_offset"</span> : <span class="number">11</span>,</span><br><span class="line">      <span class="attr">"end_offset"</span> : <span class="number">12</span>,</span><br><span class="line">      <span class="attr">"type"</span> : <span class="string">"CN_CHAR"</span>,</span><br><span class="line">      <span class="attr">"position"</span> : <span class="number">7</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、ElasticSearch介绍&quot;&gt;&lt;a href=&quot;#1、ElasticSearch介绍&quot; class=&quot;headerlink&quot; title=&quot;1、ElasticSearch介绍&quot;&gt;&lt;/a&gt;1、ElasticSearch介绍&lt;/h2&gt;
    
    </summary>
    
    
      <category term="ElasticSearch" scheme="https://mysticalguest.github.io/categories/ElasticSearch/"/>
    
    
      <category term="搜索引擎" scheme="https://mysticalguest.github.io/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Java及JVM简介</title>
    <link href="https://mysticalguest.github.io/Java/6688.html"/>
    <id>https://mysticalguest.github.io/Java/6688.html</id>
    <published>2020-08-28T14:49:08.862Z</published>
    <updated>2021-04-08T13:01:36.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><h3 id="1-1-你是否也遇到过这些问题"><a href="#1-1-你是否也遇到过这些问题" class="headerlink" title="1.1 你是否也遇到过这些问题?"></a>1.1 你是否也遇到过这些问题?</h3><a id="more"></a><ul><li><p>运行着的线上系统突然卡死，系统无法访问，甚至直接OOM（Out Of Memory）!</p></li><li><p>想解决线上 JVM GC（ JVM垃圾回收 ）问题，但却无从下手。</p></li><li><p>新项目上线，对各种JVM参数设置一脸茫然，直接默认吧，然后就错了。</p></li><li><p>每次面试之前都要重新背一遍J的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优JVM参数，如何解决GC、OOM等问题，一脸懵逼。</p></li></ul><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Java/JVM/JVM.PNG" alt="JVM"></p><p>我们通常都是学习基础的技能，在此基础上学习更复杂的功能。</p><h3 id="1-2-开发人员如何看待上层框架"><a href="#1-2-开发人员如何看待上层框架" class="headerlink" title="1.2 开发人员如何看待上层框架"></a>1.2 开发人员如何看待上层框架</h3><ul><li><p>一些有一定工作经验的开发人员，打心眼儿里觉得SSM、微服务等上层技术才是重点，基础技术并不重要，这其实是一种本末倒置的“病态“。</p></li><li><p>如果我们把核心类库的 API 比做数学公式的话，那么 Java 虚拟机的知识就好比公式的推导过程</p></li></ul><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Java/JVM/Composition-principle.PNG" alt=""></p><blockquote><p>计算机系统体系对我们来说越来越远，在不了解底层实现方式的前提下，通过高级语言很容易编写程序代码。但事实上计算机并不认识高级语言。</p></blockquote><h3 id="1-3-架构师每天都在思考什么"><a href="#1-3-架构师每天都在思考什么" class="headerlink" title="1.3 架构师每天都在思考什么?"></a>1.3 架构师每天都在思考什么?</h3><ul><li><p>应该如何让我的系统更快?</p></li><li><p>如何避免系统出现瓶颈?</p></li></ul><h3 id="1-4-知乎上有条帖子：应该如何看招聘信息，直通年薪50万"><a href="#1-4-知乎上有条帖子：应该如何看招聘信息，直通年薪50万" class="headerlink" title="1.4 知乎上有条帖子：应该如何看招聘信息，直通年薪50万+?"></a>1.4 知乎上有条帖子：应该如何看招聘信息，直通年薪50万+?</h3><ul><li>参与现有系统的性能优化，重构，保证平台性能和稳定性</li><li>根据业务场景和需求，决定技术方向，做技术选型</li><li>能够独立架构和设计海量数据下高并发分布式解决方案，满足功能和非功能需求</li><li>解决各类潜在系统风险，核心功能的架构与代码编写</li><li>分析系统瓶颈，解决各种疑难杂症,性能调优等</li></ul><h3 id="1-5-为什么要学JVM？"><a href="#1-5-为什么要学JVM？" class="headerlink" title="1.5 为什么要学JVM？"></a>1.5 为什么要学JVM？</h3><ul><li>面试的需要：入职BATJ（京东）、T（头条）MD（滴滴）、P（拼多多）K（快手）Q（趣头条）等一线大厂不光关注技术的广度，更关注技术的深度，JVM技术是大厂面试的必备技能，掌握越深越好</li><li>中高级程序员、架构师必备技能：架构师每天都在思考如何让我的系统更快，如何避免系统出现性能瓶颈。单纯的依靠物理机不足以解决问题，分析系统性能、调优系统瓶颈离不了对JVM中内存、垃圾回收、字节码指令、性能监控工具、调优参数的熟练掌握。</li><li>精进技术、极客（好奇与行动）追求：JVM是Java生态的核心价值的体现，垃圾回收算法、JIT（ just in time 的缩写，也就是即时编译编译器，AOT：提前编译器）、底层原理值得每个程序员去探索。同时，JVM作为跨语言的平台，对于深入理解Scala、Kotlin、JavaScript、Jython、Groovy也很有帮助。Java最前沿最成熟垃圾回收算法。</li></ul><h3 id="1-6-Java-vs-C"><a href="#1-6-Java-vs-C" class="headerlink" title="1.6 Java  vs  C++"></a>1.6 Java  vs  C++</h3><p>以C语言代表的语言是高级语言的开端了，Java借鉴了C和C++的有点，并摈弃其缺点；缺点主要就是<strong>内存动态分配</strong>和<strong>垃圾收集技术</strong>。</p><p>分配内存想要再次使用就要垃圾回收，否则就成一次性内存了。对于C语言来说，就需要程序员自己分配内存自己回收；Java是自动管理内存的。对于自动管理内存的弊端就是不了解Java内部的内存结构和工作机制，对于项目调优就没办法了，理解为黑盒？心中胆怯，没底？</p><p>垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是Java工程师进阶的必备能力。</p><h2 id="2、Java及JVM简介"><a href="#2、Java及JVM简介" class="headerlink" title="2、Java及JVM简介"></a>2、Java及JVM简介</h2><p>栈管运行，堆管存储？Java半解释型，半编译型语言？</p><p><a href="https://docs.oracle.com/javase/specs/index.html">Java虚拟机官方文档下载</a></p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Java/JVM/hotspot.PNG" alt="HotSpot" style="zoom: 70%;" /></p><p><a href="https://www.tiobe.com/tiobe-index/">TIOBE语言热度排行榜</a></p><h3 id="2-1-Java生态圈"><a href="#2-1-Java生态圈" class="headerlink" title="2.1 Java生态圈"></a>2.1 Java生态圈</h3><p>Java是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大，Java也早已不再是简简单单的一门计算机语言了,它更是一个平台、一种文化、一个社区。</p><ul><li><p><strong>作为一个平台</strong>，Java虚拟机扮演着举足轻重的作用。</p><p>Groovy、 Scala、 JRuby、Kot]in等都是Java平台的一部分</p></li><li><p><strong>作为一种文化</strong>，Java几乎成为了“开源”的代名词</p><ul><li>第三方开源软件和框架。如 Tomcat、 struts, My Batis, Spring等。</li><li>就连UDK和JM自身也有不少开源的实现,如 OpenJDK、 Harmony（开源的JVM）</li></ul></li><li><p><strong>作为一个社区</strong>，Java拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到Java的身影。其应用形式之复杂、参与人数之众多也令人咋舌</p></li></ul><h3 id="2-2-Java：跨平台的语言"><a href="#2-2-Java：跨平台的语言" class="headerlink" title="2.2 Java：跨平台的语言"></a>2.2 Java：跨平台的语言</h3><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Java/JVM/Cross-platform.PNG" style="zoom:80%;" /></p><h3 id="2-3-JVM虚拟机规范"><a href="#2-3-JVM虚拟机规范" class="headerlink" title="2.3 JVM虚拟机规范"></a>2.3 JVM虚拟机规范</h3><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-1.html#jvms-1">The Java Virtual Machine Specification, Java SE 8 Edition</a></p><p>Java虚拟机是Java平台的基石。 它是技术的组成部分，负责硬件和操作系统的独立性，编译代码的小巧大小以及保护用户免受恶意程序攻击的能力。</p><p>编译代码的小巧（小尺寸）：在一个程序中用到了基本数据类型和类，在编译字节码文件时对应一个常量池，运行的时候对应运行常量池，通过常量指向，避免去字节码文件加载大量数据和类，以保证字节码文件的小尺寸，</p><h3 id="2-4-JVM：跨语言的平台"><a href="#2-4-JVM：跨语言的平台" class="headerlink" title="2.4 JVM：跨语言的平台"></a>2.4 JVM：跨语言的平台</h3><p>Java：跨平台的语言</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Java/JVM/Cross-language.PNG" style="zoom:90%;" /></p><p>不仅可以执行Java程序，其他语言也是可以的。只需保证各<strong>自的编译器</strong>编译出的字节码文件遵循Java虚拟机规范即可。在Java虚拟机的<strong>编译器</strong>中运行。</p><p>三大并行难题：CPU、OS、编译器。</p><ul><li><p>随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在<strong>Java虚拟机平台上运行非Java语言编写的程序。</strong></p></li><li><p>Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，<strong>它只关心“字节码”文件</strong>。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</p></li></ul><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-1.html#jvms-1">The Java Virtual Machine Specification, Java SE 8 Edition</a></p><p>为了安全起见，Java虚拟机对类文件中的代码施加了严格的语法和结构约束。 但是，Java虚拟机可以托管任何具有<strong>可用有效类文件表示的功能的语言</strong>。 受通用的独立于机器的平台的吸引，其他语言的实现者可以将Java虚拟机作为其语言的交付工具。</p><p>Java不是最强大的语言，但是JVM是最强大的虚拟机。</p><h3 id="2-5-字节码"><a href="#2-5-字节码" class="headerlink" title="2.5 字节码"></a>2.5 字节码</h3><ul><li><p>我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在JVM平台上执行的字节码格式都是一样的。所以应该统称为<strong>JVM字节码</strong>。</p></li><li><p>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。</p></li><li><p>Java 虚拟机与Java 语言并没有必然的联系，它只与特定的二进制文件格式——Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、 Bytecodes）和符号表，还有一些其他辅助信息。</p></li></ul><h3 id="2-6-多语言混合编程"><a href="#2-6-多语言混合编程" class="headerlink" title="2.6 多语言混合编程"></a>2.6 多语言混合编程</h3><ul><li><p>Java平台上的<strong>多语言混合编程</strong>正成为主流，通过<strong>特定领域的语言</strong>去解决<strong>特定领域的问题</strong>是当前软件干发应对日趋复杂的项目需求的一个方向。</p></li><li><p>试想一下，在一个项目之中，并行处理用Clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，<strong>各种语言之间的交互</strong>不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在<strong>一个虚拟机</strong>之上。</p></li><li><p>对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如Da Vinci machine项目、 Nashorn引擎、 Invoke Dynamic指令、java.lang.invoke包等），<strong>推动Java虚拟机从“Java语言的虚拟机”向“多语言虚拟机”的方向发展</strong>。</p></li></ul><h2 id="3、Java发展的重大事件"><a href="#3、Java发展的重大事件" class="headerlink" title="3、Java发展的重大事件"></a>3、Java发展的重大事件</h2><ul><li><p>1990年，在Sun计算机公司中，由 Patrick Naughton、 Mikesheridan及James Gosling领导的小组 Green Team，开发出的新的程序语言，命名为oak，后期命名为Java</p></li><li><p>1995年，Sun正式发布Java和 HotJava产品，Java首次公开亮相。</p></li><li><p>1996年1月23日 Sun Microsystems发布了JDK1.0。</p></li><li><p>1998年，JDK1.2版木发布。同时，sun发布了JSP/ Servlet、EJB规范，以及将Java分成了J2EE（企业级应用）、J2SE（桌面级应用）和J2ME（移动端）。这表明了Java开始向企业、桌面应用和移动设备应用3大领域挺进。</p></li><li><p>2000年，JDK1.3发布， <strong>Java Hotspot Virtual Machine正式发布，成为</strong><br><strong>Java的默认虚拟机</strong>。</p></li><li><p>2002年，JDK1.4发布，古老的 Classic虚拟机退出历史舞台，同期微软.NET发布</p></li><li><p>2003年年底，<strong>Java平台的 Scala正式发布，同年 Groovy也加入了Java阵营</strong>。</p></li><li><p>2004年，JDK1.5发布。同时JDK1.5改名为 JavaSE5.0。</p></li><li><p>2006年，JDK6发布。同年，<strong>Java开源并建立了 OpenJDK</strong>。顺理成章，<strong>Hotspot虚拟机也成为了 OpenJDK中的默认虚拟机</strong>。</p></li><li><p>2007年，Java平台迎来了新伙伴Clojure。</p></li><li><p>2008年，Oracle收购了BEA，得到了JRockit虚拟机。</p></li><li><p>2009年，Twitter宣布把后台大部分程序从Ruby迁移到 Scala，这是Java平台的又一次大规模应用。</p></li><li><p>2010年，Oracle收购了Sun，<strong>获得Java商标和最具价值的 Hotspot虚拟机</strong>，JCP组织管理Java语言，但Oracle话语权比较重。此时，Oracle拥有市场占用率最高的两款虚拟机Hot Spot和 JRockit，并计划在未来对它们进行整合：Hotrockit</p></li><li><p>2011年，JDK7发布。在JDK1.7u4中，正式启用了新的垃圾回收器G1。</p></li><li><p>2014年，算是整合了上述两款虚拟机Hotrockit，从JavaSE8.0后</p></li><li><p>2017年，JDK9发布。将G1设置为默认GC，替代CMS。同年，<strong>IBM的J9开源</strong>，形成了现在的 Open J9社区</p></li><li><p>2018年，Android的Java侵权案判决，Google赔偿Oracle计88亿美元。同年，OracLe宣告 JavaEE成为历史名词，JDBC、JMS、servlet赠予Eclipse基金会。同年，JDK11发布，LTS版本的JDK，<strong>发布革命性的ZGC，调整JDK授权许可</strong></p></li><li><p>2019年，JDK12发布，加入RedHat领导开发的 Shenandoah GC</p></li></ul><p>在JDK11之前，OracleJDK中还会存在一些 OpenJDK中没有的、闭源的功能。但在JDK11中，我们可以认为 OpenJDK和 oracleJDK代码实质上已经完全一致的程度。主要是基于的协议不同，OpenJDK基于OPL协议，OracleJDK基于OPN协议。OpenJDK维护期半年，过了就更新下一版本，OracleJDK持续维护3年</p><h2 id="4、虚拟机与Java虚拟机"><a href="#4、虚拟机与Java虚拟机" class="headerlink" title="4、虚拟机与Java虚拟机"></a>4、虚拟机与Java虚拟机</h2><h3 id="4-1-虚拟机"><a href="#4-1-虚拟机" class="headerlink" title="4.1 虚拟机"></a>4.1 虚拟机</h3><ul><li><p>所谓虚拟机( Virtual Machine)，就是一台虚拟的计算机它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为<strong>系统虚拟机</strong>和<strong>程序虚拟机</strong>。</p><ul><li>大名鼎鼎的 Visual Box，VMware就属于系统虚拟机，它们<strong>完全是对物理计算机的仿真</strong>，提供了一个可运行完整操作系统的软件平台。</li><li>程序虚拟机的典型代表就是Java虚拟机，它<strong>专门为执行单个计算机程序而设计</strong>，在Java虚拟机中执行的指令我们称为Java字节码指令。</li></ul></li><li><p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p></li></ul><h3 id="4-2-Java虚拟机"><a href="#4-2-Java虚拟机" class="headerlink" title="4.2 Java虚拟机"></a>4.2 Java虚拟机</h3><ul><li><p>Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。</p></li><li><p>JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回收器，以及可靠的即时编译器。</p></li><li><p><strong>Java技术的核心就是Java虚拟机</strong>（JVM，Java Virtual Machine）因为所有的Java程序都运行在Java虚拟机内部。</p></li><li><p>作用：</p><p><strong>Java虚拟机就是二进制字节码的运行环境</strong>，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p></li><li><p>特点</p><ul><li>一次编译，到处运行</li><li>自动内存管理</li><li>自动垃圾回收功能</li></ul></li></ul><h2 id="5、JVM的位置"><a href="#5、JVM的位置" class="headerlink" title="5、JVM的位置"></a>5、JVM的位置</h2><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Java/JVM/JVM-location.PNG" alt=""></p><p>JⅥM是运行在操作系统之上的，它与硬件没有直接的交互。不同操作系统的JVM是有区别的。</p><h2 id="6、JVM的整体结构"><a href="#6、JVM的整体结构" class="headerlink" title="6、JVM的整体结构"></a>6、JVM的整体结构</h2><ul><li><p>HotSpot VM是目前市面上高性能虚拟机的代表作之一。</p></li><li><p>它采用解释器与即时编译器并存的架构。</p></li><li><p>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。</p></li></ul><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Java/JVM/overall-structure.PNG" alt=""></p><p>将图示结构分为上中下层：</p><ul><li><p>上层：入口是字节码文件，通过装载器加载到内存中，生成class对象；</p></li><li><p>中层：有对应class的实例了；多线程共享方法区和堆，虚拟机栈（Java栈），本地方法栈和程序计数器是每个线程独有的。</p></li><li><p>下层：有“后端编译器”，将高级语言翻译为机器语言</p></li></ul><h2 id="7、Java代码执行流程"><a href="#7、Java代码执行流程" class="headerlink" title="7、Java代码执行流程"></a>7、Java代码执行流程</h2><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Java/JVM/Implementation-process.png" alt=""></p><p>关于上图中Java编译器（“前端”编译器）的细节不用过多关注，除非涉及开发一门语言；在这个过程中任何一个过程失败，都不能正确生成字节码文件。字节码文件也是跨平台的</p><p>“解析执行”和“编译执行“模块相当于执行引擎，”解析执行“保证响应时间，逐行对字节码解释执行，反复执行的代码称为”热点代码“，“编译执行”有个二次编译，第一编译为字节码的热点代码，将其缓存起来，下次直接调用，转换为机器指令。</p><h2 id="8、JVM的架构模型"><a href="#8、JVM的架构模型" class="headerlink" title="8、JVM的架构模型"></a>8、JVM的架构模型</h2><p>Java编译器输入的指令流基本上是一种基于<strong>栈的指令集架构</strong>，另外一种指令集架构则是基于<strong>寄存器的指令集架构</strong>。HotSpot是基于栈的架构。</p><h3 id="8-1-具体来说：这两种架构之间的区别："><a href="#8-1-具体来说：这两种架构之间的区别：" class="headerlink" title="8.1 具体来说：这两种架构之间的区别："></a>8.1 具体来说：这两种架构之间的区别：</h3><ul><li>基于栈式架构的特点<ul><li>设计和实现更简单，适用于资源受限的系统；（方法，入栈出栈？实现简单）</li><li>避开了寄存器的分配难题：使用零地址（无地址，只有操作数）指令方式分配。（栈的结构？栈顶元素？不需要知道地址？不麻烦）</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。</li><li>不需要硬件支持，可移植性更好，更好实现跨平台。（栈与内存交互）</li></ul></li><li>基于寄存器架构的特点<ul><li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li><li><strong>指令集架构则完全依赖硬件，可移植性差</strong></li><li><strong>性能优秀和执行更高效</strong></li><li>花费更少的指令去完成一项操作。</li><li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主方水洋</li></ul></li></ul><h3 id="8-2-示例"><a href="#8-2-示例" class="headerlink" title="8.2 示例"></a>8.2 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackStructureTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int i = 1+2;</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> k = i+j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行后，会在项目的out文件夹下生成字节码文件：</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Java/JVM/out-complie.PNG" alt=""></p><p>在“chapter01”下打开cmd执行下面语句进行反编译：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> javap <span class="literal">-v</span> StackStructureTest<span class="class">.<span class="keyword">class</span></span></span><br></pre></td></tr></table></figure><p>输出：（基于栈的计算流程（以Java虚拟机为例））</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">#23 = Utf8               java/lang/Object</span></span><br><span class="line">&#123;</span><br><span class="line">  public com.chapter01.StackStructureTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial <span class="comment">#1                  // Method java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  this   Lcom/chapter01/StackStructureTest;</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">static</span> void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([<span class="type">Ljava</span>/<span class="type">lang</span>/<span class="built_in">String</span>;)<span class="type">V</span></span><br><span class="line">    <span class="type">flags</span>: <span class="type">ACC_PUBLIC</span>, <span class="type">ACC_STATIC</span></span><br><span class="line">    <span class="type">Code</span>:</span><br><span class="line">      <span class="type">stack</span>=<span class="number">2</span>, <span class="type">locals</span>=<span class="number">4</span>, <span class="type">args_size</span>=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="type">iconst_3</span>  // 定义常量<span class="number">3</span></span><br><span class="line">         <span class="number">1</span>: <span class="type">istore_1</span>  // <span class="number">1</span>是操作数栈的索引位置，将上面常量保存到索引为<span class="number">1</span>的操作数栈中</span><br><span class="line">         <span class="number">2</span>: <span class="type">iconst_4</span></span><br><span class="line">         <span class="number">3</span>: <span class="type">istore_2</span></span><br><span class="line">         <span class="number">4</span>: <span class="type">iload_1</span>   // 将索引<span class="number">1</span>加载进来</span><br><span class="line">         <span class="number">5</span>: <span class="type">iload_2</span>   // 加载索引<span class="number">2</span></span><br><span class="line">         <span class="number">6</span>: <span class="type">iadd</span>      // 求和操作</span><br><span class="line">         <span class="number">7</span>: <span class="type">istore_3</span>  // 将结果存到索引为<span class="number">3</span>的操作数栈中</span><br><span class="line">         <span class="number">8</span>: <span class="type">return</span>    // <span class="number">8</span>行，寄存器的话</span><br><span class="line">      <span class="type">LineNumberTable</span>:</span><br><span class="line">        <span class="type">line</span> <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">        <span class="type">line</span> <span class="number">8</span>: <span class="number">2</span></span><br><span class="line">        <span class="type">line</span> <span class="number">9</span>: <span class="number">4</span></span><br><span class="line">        <span class="type">line</span> <span class="number">10</span>: <span class="number">8</span></span><br><span class="line">      <span class="type">LocalVariableTable</span>:</span><br><span class="line">        <span class="type">Start</span>  <span class="type">Length</span>  <span class="type">Slot</span>  <span class="type">Name</span>   <span class="type">Signature</span></span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="type">args</span>   [<span class="type">Ljava</span>/<span class="type">lang</span>/<span class="built_in">String</span>;</span><br><span class="line">            <span class="number">2</span>       <span class="number">7</span>     <span class="number">1</span>     <span class="type">i</span>   <span class="type">I</span></span><br><span class="line">            <span class="number">4</span>       <span class="number">5</span>     <span class="number">2</span>     <span class="type">j</span>   <span class="type">I</span></span><br><span class="line">            <span class="number">8</span>       <span class="number">1</span>     <span class="number">3</span>     <span class="type">k</span>   <span class="type">I</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">SourceFile</span>: <span class="string">"StackStructureTest.java"</span></span><br></pre></td></tr></table></figure><p>而基于寄存器的计算流程：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax,<span class="number">2</span> //将eax寄存器的值设为<span class="number">1</span></span><br><span class="line">add eax,<span class="number">3</span> //使eax寄存器的值加<span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="8-3-总结"><a href="#8-3-总结" class="headerlink" title="8.3 总结"></a>8.3 总结</h3><p><strong>由于跨平台性的设计，Java的指令都是根据栈来设计的。</strong>不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p><p>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpot VM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</p><p>栈：跨平台性、指令集小、指令多；执行性能比寄存器差</p><h2 id="9、JVM的生命周期"><a href="#9、JVM的生命周期" class="headerlink" title="9、JVM的生命周期"></a>9、JVM的生命周期</h2><h3 id="9-1-虚拟机的启动"><a href="#9-1-虚拟机的启动" class="headerlink" title="9.1 虚拟机的启动"></a>9.1 虚拟机的启动</h3><p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p><p>自定义的类通过系统类加载器加载，继承自Object，Object需要被引导类加载器加载，Object并不是初始类，一个简单类的执行就需要加载很多类，此时JVM启动</p><h3 id="9-2-虚拟机的执行"><a href="#9-2-虚拟机的执行" class="headerlink" title="9.2 虚拟机的执行"></a>9.2 虚拟机的执行</h3><ul><li><p>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。</p></li><li><p>程序开始执行时他才运行，<strong>程序结束时他就停止</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackStructureTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int i = 1+2;</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> k = i+j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行，趁还没有结束，在cmd中输入：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> jps    // 打印当前执行程序中的进程</span><br><span class="line"><span class="number">22272</span> StackStructureTest   // <span class="number">22272</span>端口号</span><br><span class="line"><span class="number">22548</span></span><br><span class="line"><span class="number">24164</span> RemoteMavenServer36</span><br><span class="line"><span class="number">22024</span> Launcher</span><br><span class="line"><span class="number">21388</span> Jps   // JVM就退出了</span><br><span class="line"><span class="variable">$</span> jps    // 结束后</span><br><span class="line"><span class="number">22548</span></span><br><span class="line"><span class="number">24164</span> RemoteMavenServer36</span><br><span class="line"><span class="number">3188</span> Jps</span><br><span class="line"><span class="number">22024</span> Launcher</span><br></pre></td></tr></table></figure></li></ul><ul><li>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做<strong>Java虚拟机的进程</strong>。</li></ul><h3 id="9-3-虚拟机的退出"><a href="#9-3-虚拟机的退出" class="headerlink" title="9.3 虚拟机的退出"></a>9.3 虚拟机的退出</h3><p>有如下的几种情况：</p><ul><li><p>程序正常执行结束</p></li><li><p>程序在执行过程中遇到了异常（没有处理的异常）或错误而异常终止</p></li><li><p>由于操作系统用现错误而导致Java虚拟机进程终止</p></li><li><p>某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。</p><p>第6节运行时数据区，就是运行时环境，对应的类就是<code>java.lang.Runtime</code>，这个类是单例的</p></li><li><p>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。</p></li></ul><h2 id="10、JVM发展历程"><a href="#10、JVM发展历程" class="headerlink" title="10、JVM发展历程"></a>10、JVM发展历程</h2><h3 id="10-1-Sun-Classic-VM"><a href="#10-1-Sun-Classic-VM" class="headerlink" title="10.1 Sun Classic VM"></a>10.1 Sun Classic VM</h3><ul><li><p>早在1996年Java1.0版本的时候，Sun公司发布了一款名为sun classic VM的Java虚拟机，它同时也是<strong>世界上第一款商用Java虚拟机</strong>，JDK1.4时完全被淘汰。</p></li><li><p>这款虚拟机内部只提供解释器。</p><blockquote><p>现在还有及时编译器，因此效率比较低，而及时编译器会把热点代码缓存起来，那么以后使用热点代码的时候，效率就比较高。提升效率就要用JIT编译器。</p></blockquote></li><li><p>如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。</p><blockquote><p>解释器响应快，编译器寻找热点代码，不用解释器逐行编译。如果只使用高性能编译器，响应时间慢，加上逐行编译指令，就会使程序启动时响应时间过长（卡顿）。其实现今的Java虚拟机的执行速度以不亚于C，更形象地例子，解释器相当于步行，命令响即出发，编译器相当于坐公交车，命令响等公交或转车，两者配合更优。</p></blockquote></li><li><p>现在hotspot内置了此虚拟机。</p></li></ul><h3 id="10-2-Exact-VM"><a href="#10-2-Exact-VM" class="headerlink" title="10.2 Exact VM"></a>10.2 Exact VM</h3><ul><li><p>为了解决上一个虚拟机问题，jdk1.2时，sun提供了此虚拟机。 Exact Memory Management：准确式内存管理</p><ul><li>也可以叫Non-Conservative/Accurate Memory Management</li><li>虚拟机可以知道内存中某个位置的数据具体是什么类型。|</li></ul></li><li><p>具备现代高性能虚拟机的维形</p><ul><li>热点探测（寻找出热点代码进行缓存）</li><li>编译器与解释器混合工作模式</li></ul></li><li><p>只在solaris平台短暂使用，其他平台上还是classic vm，英雄气短，终被Hotspot虚拟机替换</p></li></ul><h3 id="10-3-HotSpot-VM"><a href="#10-3-HotSpot-VM" class="headerlink" title="10.3 HotSpot VM"></a>10.3 HotSpot VM</h3><ul><li><p>HotSpot历史</p><ul><li>最初由一家名为“Longview Technologies”的小公司设计</li><li>1997年，此公司被sun收购；2009年，Sun公司被甲骨文收购。</li><li>JDK1.3时，HotSpot VM成为默认虚拟机</li></ul></li><li><p>目前<strong>Hotspot占有绝对的市场地位，称霸武林</strong>。</p><ul><li>不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot</li><li>Sun/oracle JDK和openJDK的默认虚拟机</li><li>因此本课程中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的Gc机制。（比如其他两个商用虚机都没有方法区的概念）</li></ul></li><li><p>从服务器、桌面到移动端、嵌入式都有应用。</p></li><li>名称中的HotSpot指的就是它的热点代码探测技术。<ul><li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</li><li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li></ul></li></ul><h3 id="10-4-JRockit"><a href="#10-4-JRockit" class="headerlink" title="10.4 JRockit"></a>10.4 JRockit</h3><ul><li><p><strong>专注于服务器端应用</strong></p></li><li><p>它可以<strong>不太关注程序启动速度</strong>，因此<strong>JRockit内部不包含解析器实现</strong>，全部代码都靠即时编译器编译后执行。</p></li><li><p>大量的行业基准测试显示，<strong>JRockit JVM是世界上最快的JVM</strong>。</p></li><li><p>使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。</p></li><li><p>优势：全面的Java运行时解决方案组合</p><ul><li><p>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要</p></li><li><p>MissionControl服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</p><blockquote><p>官网<a href="https://www.oracle.com/java/technologies/javase-downloads.html">JMC</a>，监控内存泄露。</p></blockquote></li></ul></li><li><p>原属BEA公司，2008年，JRockit被oracle收购。</p></li><li><p>oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。</p></li><li><p>高斯林（Java之父）：目前就职于谷歌，研究人工智能和水下机器人</p></li></ul><h3 id="10-5-IBM的J9"><a href="#10-5-IBM的J9" class="headerlink" title="10.5 IBM的J9"></a>10.5 IBM的J9</h3><ul><li><p>全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9</p></li><li><p>市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM广泛用于IBM的各种Java产品。</p></li><li><p><strong>目前，有影响力的三大商用虚拟机之一</strong>，也号称是世界上最快的Java虚拟机。</p></li><li><p>2017年左右，IBM发布了开源J9VM，命名为openJ9，交给EClipse基金会管理，也称为Eclipse OpenJ9</p></li></ul><h3 id="10-6-KVM和CDC-CLDC-Hotspot"><a href="#10-6-KVM和CDC-CLDC-Hotspot" class="headerlink" title="10.6 KVM和CDC / CLDC Hotspot"></a>10.6 KVM和CDC / CLDC Hotspot</h3><ul><li><p>oracle在Java ME产品线上的两款虚拟机为：CDC/CLDC HotSpot Implementation VM KVM（Kilobyte）是CLDC-HI早期产品目前移动领域地位尴尬，智能机被Android和ioS二分天下。</p></li><li><p>KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场</p><ul><li>智能控制器、传感器</li><li>老人手机、经济欠发达地区的功能手机</li></ul></li><li><p>所有的虚拟机的原则：一次编译，到处运行。</p></li></ul><h3 id="10-7-Azul-VM"><a href="#10-7-Azul-VM" class="headerlink" title="10.7 Azul VM"></a>10.7 Azul VM</h3><ul><li>前面三大“高性能Java虚拟机”使用在通用硬件平台上</li><li><p>这里Azul VW和BEA Liquid VM是<strong>与特定硬件平台绑定、软硬件配合的专有虚拟机</strong></p><ul><li>高性能Java虚拟机中的战斗机。</li></ul></li><li><p>Azul VM是Azul Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的ava虚拟机。</p></li><li><p><strong>每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性</strong>。</p></li><li><p>2010年，Azul Systems公司开始从硬件转向软件，发布了自己的Zing JVM，可以在通用x86平台上提供接近于Vega系统的特性。</p></li></ul><h3 id="10-8-Liquid-VM"><a href="#10-8-Liquid-VM" class="headerlink" title="10.8 Liquid VM"></a>10.8 Liquid VM</h3><ul><li><p>高性能Java虚拟机中的战斗机。</p></li><li><p>BEA公司开发的，直接运行在自家Hypervisor系统上Liquid VM即是现在的JRockit VE（Virtual Edition），</p></li><li><p>Liquid VM即是现在的 JRockit VE（Virtual Edition）。Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。</p></li><li><p>随着JRockit虚拟机终止开发，Liquid vM项目也停止了。</p></li></ul><h3 id="10-9Apache-Marmony"><a href="#10-9Apache-Marmony" class="headerlink" title="10. 9Apache Marmony"></a>10. 9Apache Marmony</h3><ul><li><p>Apache也曾经推出过与JDK1.5和JDK1.6兼容的Java运行平台Apache Harmony。</p></li><li><p>它是IBM和Intel联合开发的开源JVM，受到同样开源的OpenJDK的压制，Sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK</p></li><li><p>虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。</p></li></ul><h3 id="10-10-Micorsoft-JVM"><a href="#10-10-Micorsoft-JVM" class="headerlink" title="10.10 Micorsoft JVM"></a>10.10 Micorsoft JVM</h3><ul><li><p>微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。</p></li><li><p>只能在window平台下运行。但确是当时Windows下性能最好的Java VM。</p></li><li><p>1997年，sun以侵犯商标、不正当竞争罪名指控微软成功，赔了sun很多钱。微软windowsXP SP3中抹掉了其VM。现在windows上安装的jdk都是HotSpot。</p></li></ul><h3 id="10-11-Taobao-JVM"><a href="#10-11-Taobao-JVM" class="headerlink" title="10.11 Taobao JVM"></a>10.11 Taobao JVM</h3><ul><li><p>由Ali JVM团队发布。阿里，国内使用Java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。</p></li><li><p><strong>基于OpenJDK开发了自己的定制版本AlibabaJDK</strong>，简称AJDK。是整个阿里Java体系的基石。</p></li><li><p>基于OpenJDK Hotspot VM发布的国内第一个优化、<strong>深度定制且开源的高性能服务器版Java虚拟机。</strong></p><ul><li>创新的GCIH（GC invisible heap）技术实现了off-heap，<strong>即将生命周期较长的Java对象从heap中移到heap之外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</strong></li><li>GCIH中的对象还能够在多个Java虚拟机进程中实现共享</li><li>使用crc32指令实现JVM intrinsic降低JNI的调用开销</li><li>PMU hardware的Java profiling tool和诊断协助功能</li><li>针对大数据场景的ZenGc</li></ul></li><li><p>taobao vm应用在阿里产品上性能高，硬件严重依赖intel的cpu，损失了兼容性，但提高了性能</p><ul><li>目前已经在淘宝、天猫上线，把Oracle官方JVM版本全部替换了。</li></ul></li></ul><h3 id="10-12-Dalvik-VM"><a href="#10-12-Dalvik-VM" class="headerlink" title="10.12 Dalvik VM"></a>10.12 Dalvik VM</h3><ul><li><p>谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。</p></li><li><p><strong>Dalvik VM只能称作虚拟机，而不能称作“Java虚拟机”</strong>，它没有遵循 Java虚拟机规范</p></li><li><p>不能直接执行Java的Class文件</p></li><li><p>基于寄存器架构，不是jvm的栈架构。</p></li><li><p>执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。</p><ul><li>它执行的dex（Dalvik Executable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。</li></ul></li><li><p>Android 5.0使用支持提前编译（Ahead of Time Compilation，AOT）的ART VM替换Dalvik VM。</p></li></ul><h3 id="10-13-Graal-VM"><a href="#10-13-Graal-VM" class="headerlink" title="10.13 Graal VM"></a>10.13 Graal VM</h3><ul><li><p>2018年4月，Oracle Labs公开了Graal VM，号称 “<strong>Run Programs Faster Anywhere</strong>“，勃勃野心。与1995年java的”write once，run anywhere”遥相呼应。</p></li><li><p>Graa VM在HotSpot VM基础上增强而成的<strong>跨语言全栈虚拟机，可以作为“任何语言” 的运行平台使用</strong>。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等</p></li><li><p>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</p></li><li><p>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</p></li><li><p><strong>如果说HotSpot有一天真的被取代，Graal VM希望最大</strong>。但是Java的软件生态没有丝毫变化。</p></li></ul><h3 id="10-14-总结"><a href="#10-14-总结" class="headerlink" title="10.14 总结"></a>10.14 总结</h3><p>具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以oracle HotSpot VM为默认虚拟机。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、前言&quot;&gt;&lt;a href=&quot;#1、前言&quot; class=&quot;headerlink&quot; title=&quot;1、前言&quot;&gt;&lt;/a&gt;1、前言&lt;/h2&gt;&lt;h3 id=&quot;1-1-你是否也遇到过这些问题&quot;&gt;&lt;a href=&quot;#1-1-你是否也遇到过这些问题&quot; class=&quot;headerlink&quot; title=&quot;1.1 你是否也遇到过这些问题?&quot;&gt;&lt;/a&gt;1.1 你是否也遇到过这些问题?&lt;/h3&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://mysticalguest.github.io/categories/Java/"/>
    
    
      <category term="原理" scheme="https://mysticalguest.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot与缓存</title>
    <link href="https://mysticalguest.github.io/Spring/43845.html"/>
    <id>https://mysticalguest.github.io/Spring/43845.html</id>
    <published>2020-08-28T04:02:16.963Z</published>
    <updated>2021-04-08T13:05:02.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、Spring-Boot与缓存"><a href="#1、Spring-Boot与缓存" class="headerlink" title="1、Spring Boot与缓存"></a>1、Spring Boot与缓存</h2><a id="more"></a><p>缓存应该是每个系统都应考虑的功能，用来加速系统的访问以及提升系统的性能；</p><p>引入缓存中间件，将高频信息从数据库存入缓存，从缓存拿数据；如果缓存中没有，在到数据库中查找吗，继续放入缓存。应用程序和缓存的交互式非常快的。</p><p>还有验证码这些临时性数据就没有必要存在数据库中了，缓存是不错的选择。</p><p>那么为了统一缓存的开发规范以及提升系统的扩展性，J2EE发布了<strong>JSR-107规范</strong>，但由于整合难度大，用的比较少。JSR-107规范定义的都是一些接口，这样的好处就类似JDBC一样，面向接口编程。但市面上的组件不都提供JSR-107的实现。但为了简化开发，Spring更多使用的是自己的<strong>Spring缓存抽象</strong>。</p><h3 id="1-1-JSR107"><a href="#1-1-JSR107" class="headerlink" title="1.1 JSR107"></a>1.1 JSR107</h3><p>Java Caching定义了5个核心接口，分别是<strong>CachingProvider</strong>, <strong>CacheManager</strong>, <strong>Cache</strong>, <strong>Entry</strong> 和 <strong>Expiry</strong>。</p><ul><li><p><strong>CachingProvider</strong>定义了创建、配置、获取、管理和控制多个<strong>CacheManager</strong>。一个应用可以在运行期访问多个CachingProvider。</p></li><li><p><strong>CacheManager</strong>定义了创建、配置、获取、管理和控制多个唯一命名的<strong>Cache</strong>，这些Cache存在于CacheManager的上下文中。一个CacheManager仅被一个CachingProvider所拥有。</p></li><li><p><strong>Cache</strong>是一个类似Map的数据结构并临时存储以Key为索引的值。一个Cache仅被一个CacheManager所拥有。</p></li><li><p><strong>Entry</strong>是一个存储在Cache中的key-value对。</p></li><li><p><strong>Expiry</strong> 每一个存储在Cache中的条目有一个定义的有效期。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置。</p></li></ul><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Spring/Advanced/JSR.png" alt="JSR" style="zoom:80%;" /></p><h3 id="1-2-Spring缓存抽象"><a href="#1-2-Spring缓存抽象" class="headerlink" title="1.2 Spring缓存抽象"></a>1.2 Spring缓存抽象</h3><p>Spring从3.1开始定义了org.springframework.cache.Cache和org.springframework.cache.CacheManager接口来统一不同的缓存技术；</p><p>并支持使用JCache（JSR-107）注解简化我们开发；</p><ul><li><p>Cache接口为缓存的组件规范定义，包含缓存的各种操作集合；</p></li><li><p>Cache接口下Spring提供了各种xxxCache的实现；如RedisCache，EhCacheCache , ConcurrentMapCache等；</p></li><li><p>每次调用需要缓存功能的方法时，Spring会检查检查指定参数的指定的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取。</p></li><li><p>使用Spring缓存抽象时我们需要关注以下两点；</p><ul><li>确定方法需要被缓存以及他们的缓存策略</li><li>从缓存中读取之前缓存存储的数据</li></ul></li></ul><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Spring/Advanced/CacheManager.png" alt="CacheManager" style="zoom:80%;" /></p><h3 id="1-3-几个重要概念-amp-缓存注解"><a href="#1-3-几个重要概念-amp-缓存注解" class="headerlink" title="1.3 几个重要概念&amp;缓存注解"></a>1.3 几个重要概念&amp;缓存注解</h3><div class="table-container"><table><thead><tr><th><strong>Cache</strong></th><th>缓存接口，定义缓存操作。实现有：<strong>RedisCache</strong>、<strong>EhCacheCache</strong>、<strong>ConcurrentMapCache</strong>等</th></tr></thead><tbody><tr><td><strong>CacheManager</strong></td><td><strong>缓存管理器，管理各种缓存（Cache）组件</strong></td></tr><tr><td><strong>@Cacheable</strong></td><td><strong>主要针对方法配置，能够根据方法的请求参数对其结果进行缓存</strong></td></tr><tr><td><strong>@CacheEvict</strong></td><td><strong>清空缓存</strong></td></tr><tr><td><strong>@CachePut</strong></td><td><strong>保证方法被调用，又希望结果被缓存。</strong></td></tr><tr><td><strong>@EnableCaching</strong></td><td><strong>开启基于注解的缓存</strong></td></tr><tr><td><strong>keyGenerator</strong></td><td><strong>缓存数据时key生成策略</strong></td></tr><tr><td><strong>serialize</strong></td><td><strong>缓存数据时value序列化策略</strong></td></tr></tbody></table></div><p>都是作用于缓存，不作用于数据库？</p><h3 id="1-4-搭建基本环境"><a href="#1-4-搭建基本环境" class="headerlink" title="1.4 搭建基本环境"></a>1.4 搭建基本环境</h3><ul><li>创建出department和employee表</li></ul><ul><li>创建javaBean封装数据</li></ul><ul><li>整合MyBatis操作数据库<ul><li>配置数据源信息</li><li>使用注解版的MyBatis</li><li>@MapperScan指定需要扫描的mapper接口所在的包</li></ul></li></ul><h2 id="2、快速体验缓存"><a href="#2、快速体验缓存" class="headerlink" title="2、快速体验缓存"></a>2、快速体验缓存</h2><p>缓存SpEL可用元数据</p><div class="table-container"><table><thead><tr><th><strong>名字</strong></th><th><strong>位置</strong></th><th><strong>描述</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>methodName</td><td>root object</td><td>当前被调用的方法名</td><td>#root.methodName</td></tr><tr><td>method</td><td>root object</td><td>当前被调用的方法</td><td>#root.method.name</td></tr><tr><td>target</td><td>root object</td><td>当前被调用的目标对象</td><td>#root.target</td></tr><tr><td>targetClass</td><td>root object</td><td>当前被调用的目标对象类</td><td>#root.targetClass</td></tr><tr><td>args</td><td>root object</td><td>当前被调用的方法的参数列表</td><td>#root.args[0]</td></tr><tr><td>caches</td><td>root object</td><td>当前方法调用使用的缓存列表（如@Cacheable(value={“cache1”,  “cache2”})），则有两个cache</td><td>#root.caches[0].name</td></tr><tr><td><em>argument name</em></td><td>evaluation context</td><td>方法参数的名字. 可以直接 #参数名 ，也可以使用 #p0或#a0 的形式，0代表参数的索引；</td><td>#iban 、 #a0 、 #p0</td></tr><tr><td>result</td><td>evaluation context</td><td>方法执行后的返回值（仅当方法执行之后的判断有效，如‘unless’，’cache put’的表达式 ’cache evict’的表达式beforeInvocation=false）</td><td>#result</td></tr></tbody></table></div><p>步骤：</p><h3 id="2-1-开启基于注解的缓存-EnableCaching"><a href="#2-1-开启基于注解的缓存-EnableCaching" class="headerlink" title="2.1 开启基于注解的缓存 @EnableCaching"></a>2.1 开启基于注解的缓存 @EnableCaching</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动类</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringinitializrApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Start..."</span>);</span><br><span class="line">    SpringApplication.run(SpringinitializrApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    System.out.println(<span class="string">"Success..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-标注缓存注解即可"><a href="#2-2-标注缓存注解即可" class="headerlink" title="2.2 标注缓存注解即可"></a>2.2 标注缓存注解即可</h3><p>将方法的运行结果进行缓存；以后再要相同的数据，直接从缓存中获取，不用调用方法；</p><p>CacheManager管理多个Cache组件的，对缓存的真正CRUD操作在Cache组件中，每一个缓存组件有自己唯一一个名字；</p><h3 id="2-3-Cacheable"><a href="#2-3-Cacheable" class="headerlink" title="2.3 @Cacheable"></a>2.3 @Cacheable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DepartmentController.java</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepartmentController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  DepartmentService departmentService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"/service/dept/&#123;id&#125;"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Department <span class="title">getDepart</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> departmentService.getDepartment(id);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-1-几个属性："><a href="#2-3-1-几个属性：" class="headerlink" title="2.3.1 几个属性："></a>2.3.1 几个属性：</h4><div class="table-container"><table><thead><tr><th>@Cacheable的属性</th><th>详情</th><th>用法</th></tr></thead><tbody><tr><td>cacheNames/value</td><td>指定缓存组件的名字;将方法的返回结果放在哪个缓存中，是数组的方式，可以指定多个缓存</td><td></td></tr><tr><td>key</td><td>缓存数据使用的key；可以用它来指定。默认是使用方法参数的值  1-方法的返回值</td><td>编写SpEL； #i d;参数id的值   #a0  #p0  #root.args[0]<br>getEmp[2]</td></tr><tr><td>keyGenerator</td><td>key的生成器；可以自己指定key的生成器的组件id</td><td>key/keyGenerator：二选一使用</td></tr><tr><td>cacheManager</td><td>指定缓存管理器；或者cacheResolver指定获取解析器</td><td></td></tr><tr><td>condition</td><td>指定符合条件的情况下才缓存；</td><td>condition = “#id&gt;0”<br/>condition = “#a0&gt;1”：第一个参数的值&gt;1的时候才进行缓存</td></tr><tr><td>unless</td><td>否定缓存；当unless指定的条件为true，方法的返回值就不会被缓存；可以获取到结果进行判断</td><td>unless = “#result == null”<br>unless = “#a0==2”:如果第一个参数的值是2，结果不缓存</td></tr><tr><td>sync</td><td>是否使用异步模式</td></tr></tbody></table></div><h4 id="2-3-2-应用举例"><a href="#2-3-2-应用举例" class="headerlink" title="2.3.2 应用举例"></a>2.3.2 应用举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DepartmentService.java</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepartmentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  DepartmentMapper departmentMapper;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// @Cacheable(cacheNames = "dept", key = "#id")</span></span><br><span class="line">  <span class="comment">// @Cacheable(cacheNames = &#123;"dept", "tdept"&#125;, key = "#id") 多缓存名</span></span><br><span class="line">  <span class="comment">// @Cacheable(cacheNames = "dept", key = "#root.args[0]", condition = "#id&gt;0")</span></span><br><span class="line">  <span class="comment">// @Cacheable(cacheNames = "dept", key = "#root.args[0]", unless = "#result == null")</span></span><br><span class="line">  <span class="meta">@Cacheable</span>(cacheNames = <span class="string">"dept"</span>, key = <span class="string">"#root.args[0]"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Department <span class="title">getDepartment</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"查询"</span>+id+<span class="string">"号部门"</span>);</span><br><span class="line">    Department dept = departmentMapper.getDeptById(id);</span><br><span class="line">    <span class="keyword">return</span> dept;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-3-运行主程序"><a href="#2-3-3-运行主程序" class="headerlink" title="2.3.3 运行主程序"></a>2.3.3 运行主程序</h4><p>访问<a href="http://localhost:8088/service/dept/1，查看控制台，然后在刷新浏览器再查看控制台，发现后台并不执行数据库查询：">http://localhost:8088/service/dept/1，查看控制台，然后在刷新浏览器再查看控制台，发现后台并不执行数据库查询：</a></p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Spring/Advanced/cacheable-test.PNG" alt="Cacheable"></p><h4 id="2-3-4-分析缓存的工作原理以及工作步骤"><a href="#2-3-4-分析缓存的工作原理以及工作步骤" class="headerlink" title="2.3.4 分析缓存的工作原理以及工作步骤"></a>2.3.4 分析缓存的工作原理以及工作步骤</h4><p>结合以上例子来：</p><ul><li><p>自动配置类入手：<code>CacheAutoConfiguration.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123;CacheManager<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnBean</span>(</span>&#123;CacheAspectSupport<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(</span></span><br><span class="line"><span class="class">  <span class="title">value</span> </span>= &#123;CacheManager<span class="class">.<span class="keyword">class</span>&#125;,</span></span><br><span class="line"><span class="class">  <span class="title">name</span> </span>= &#123;<span class="string">"cacheResolver"</span>&#125;</span><br><span class="line">)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;CacheProperties<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureBefore</span>(</span>&#123;HibernateJpaAutoConfiguration<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(</span>&#123;</span><br><span class="line">  CouchbaseAutoConfiguration<span class="class">.<span class="keyword">class</span>, </span></span><br><span class="line"><span class="class">  <span class="title">HazelcastAutoConfiguration</span>.<span class="title">class</span>, </span></span><br><span class="line"><span class="class">  <span class="title">RedisAutoConfiguration</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">Import</span>(</span>&#123;CacheAutoConfiguration.CacheConfigurationImportSelector<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">CacheAutoConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> String VALIDATOR_BEAN_NAME = <span class="string">"cacheAutoConfigurationValidator"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CacheAutoConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CacheManagerCustomizers <span class="title">cacheManagerCustomizers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ObjectProvider&lt;List&lt;CacheManagerCustomizer&lt;?&gt;&gt;&gt; customizers</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheManagerCustomizers((List)customizers.getIfAvailable());</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    CacheConfigurationImportSelector() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">      CacheType[] types = CacheType.values();</span><br><span class="line">      String[] imports = <span class="keyword">new</span> String[types.length];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; types.length; ++i) &#123;</span><br><span class="line">        imports[i] = CacheConfigurations.getConfigurationClass(types[i]);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> imports;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>放了一些缓存管理的自定义器（<code>CacheManagerCustomizers</code>）等；</p></li><li><p>关注一下<code>@Import({CacheAutoConfiguration.CacheConfigurationImportSelector.class})</code>，查看源码来到上面代码中的<code>CacheConfigurationImportSelector</code>方法；在方法体中调用的<code>selectImports</code>打上断点，debug来查看给容器中导入了哪些缓存组件：缓存的配置类</p><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/Spring/Advanced/CacheConfigurationImportSelector.png" alt="CacheConfigurationImportSelector"></p></li><li><p>哪个配置类默认生效？配置文件加入以下配置，然后运行<strong>主程序</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开自动配置报告</span></span><br><span class="line"><span class="attr">debug</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p>可以看到控制台：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">=========================</span><br><span class="line">AUTO<span class="literal">-CONFIGURATION</span> REPORT</span><br><span class="line">=========================</span><br><span class="line"></span><br><span class="line">Positive matches:</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">   SimpleCacheConfiguration matched:</span><br><span class="line">      - Cache org.springframework.boot.autoconfigure.cache.SimpleCacheConfiguration </span><br><span class="line">            automatic cache type (CacheCondition)</span><br><span class="line">      - @ConditionalOnMissingBean (types: org.springframework.cache.CacheManager; </span><br><span class="line">            SearchStrategy: all) did not find any beans (OnBeanCondition)</span><br><span class="line">      </span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">Negative matches:</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">   ActiveMQAutoConfiguration:</span><br><span class="line">      Did not match:</span><br><span class="line">         - @ConditionalOnClass </span><br><span class="line">            did not find required classes <span class="string">'javax.jms.ConnectionFactory'</span>, </span><br><span class="line">            <span class="string">'org.apache.activemq.ActiveMQConnectionFactory'</span> (OnClassCondition)</span><br><span class="line"></span><br><span class="line">   AopAutoConfiguration.CglibAutoProxyConfiguration:</span><br><span class="line">      Did not match:</span><br><span class="line">            - @ConditionalOnProperty (spring.aop.proxy<span class="literal">-target</span><span class="literal">-class</span>=true) </span><br><span class="line">            did not find property <span class="string">'proxy-target-class'</span> (OnPropertyCondition)</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>可以看出是<code>SimpleCacheConfiguration</code>配置类生效；给容器中注册了一个<code>CacheManager</code>：<code>ConcurrentMapCacheManager</code></p></li><li><p>可以获取和创建ConcurrentMapCache类型的缓存组件；其的作用将数据保存在ConcurrentMap中；</p></li></ul><h4 id="2-3-5-Cacheable运行流程"><a href="#2-3-5-Cacheable运行流程" class="headerlink" title="2.3.5 @Cacheable运行流程"></a>2.3.5 @Cacheable运行流程</h4><ul><li><p>方法运行之前，先去查询Cache（缓存组件），按照cacheNames指定的名字获取；</p><p>（CacheManager先获取相应的缓存），第一次获取缓存如果没有Cache组件会自动创建。</p></li><li><p>去Cache中查找缓存的内容，使用一个key，默认就是方法的参数；</p><p>key是按照某种策略生成的；默认是使用keyGenerator生成的，默认使用SimpleKeyGenerator生成key；</p><p>SimpleKeyGenerator生成key的默认策略；</p><ul><li>如果没有参数；key=new SimpleKey()；</li><li>如果有一个参数：key=参数的值</li><li>如果有多个参数：key=new SimpleKey(params)；</li></ul></li><li><p>没有查到缓存就调用目标方法；</p></li><li>将目标方法返回的结果，放进缓存中</li></ul><blockquote><p>@Cacheable标注的方法执行之前先来检查缓存中有没有这个数据，默认按照参数的值作为key去查询缓存，如果没有就运行方法并将结果放入缓存；以后再来调用就可以直接使用缓存中的数据。</p></blockquote><p>核心：</p><ul><li>使用CacheManager【ConcurrentMapCacheManager】按照名字得到Cache【ConcurrentMapCache】组件</li><li>key使用keyGenerator生成的，默认是SimpleKeyGenerator</li></ul><h3 id="2-4-CacheEvict"><a href="#2-4-CacheEvict" class="headerlink" title="2.4 @CacheEvict"></a>2.4 @CacheEvict</h3><h3 id="2-5-CachePut"><a href="#2-5-CachePut" class="headerlink" title="2.5 @CachePut"></a>2.5 @CachePut</h3><p>默认使用的是ConcurrentMapCacheManager==ConcurrentMapCache；将数据保存在    ConcurrentMap<Object, Object>中</p><p>开发中使用缓存中间件；redis、memcached、ehcache；</p><p>三、整合redis作为缓存</p><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。</p><p>1、安装redis：使用docker；</p><p>2、引入redis的starter</p><p>3、配置redis</p><p>4、测试缓存</p><p>原理：CacheManager===Cache 缓存组件来实际给缓存中存取数据</p><p>1）、引入redis的starter，容器中保存的是 RedisCacheManager；</p><p>2）、RedisCacheManager 帮我们创建 RedisCache 来作为缓存组件；RedisCache通过操作redis缓存数据的</p><p>3）、默认保存数据 k-v 都是Object；利用序列化保存；如何保存为json</p><p>1、引入了redis的starter，cacheManager变为 RedisCacheManager；</p><p>2、默认创建的 RedisCacheManager 操作redis的时候使用的是 RedisTemplate<Object, Object></p><p>3、RedisTemplate<Object, Object> 是 默认使用jdk的序列化机制</p><p>4）、自定义CacheManager；</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、Spring-Boot与缓存&quot;&gt;&lt;a href=&quot;#1、Spring-Boot与缓存&quot; class=&quot;headerlink&quot; title=&quot;1、Spring Boot与缓存&quot;&gt;&lt;/a&gt;1、Spring Boot与缓存&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://mysticalguest.github.io/categories/Spring/"/>
    
    
      <category term="框架" scheme="https://mysticalguest.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
</feed>
