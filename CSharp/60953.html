<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="baidu-site-verification" content="code-kyGo8s2mM1"><title>电子商务课程复习 - Longing(MysteryGuest的博客)</title><meta description="第1章 计算机、Internet与Visual C#简介"><meta property="og:type" content="blog"><meta property="og:title" content="电子商务课程复习"><meta property="og:url" content="https://mysticalguest.github.io/"><meta property="og:site_name" content="Longing(MysteryGuest的博客)"><meta property="og:description" content="第1章 计算机、Internet与Visual C#简介"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/mysteryguest/ObjectStorage/raw/master/CSharp/running_shoes.jpg"><meta property="article:published_time" content="2020-08-18T09:44:24.536Z"><meta property="article:modified_time" content="2021-04-08T12:57:16.934Z"><meta property="article:author" content="MysticalGuest"><meta property="article:tag" content="积累"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://gitee.com/mysteryguest/ObjectStorage/raw/master/CSharp/running_shoes.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://mysticalguest.github.io/CSharp/60953.html"},"headline":"MysteryGuest","image":["https://gitee.com/mysteryguest/ObjectStorage/raw/master/CSharp/running_shoes.jpg"],"datePublished":"2020-08-18T09:44:24.536Z","dateModified":"2021-04-08T12:57:16.934Z","author":{"@type":"Person","name":"MysticalGuest"},"description":"java,技术分享,后端开发,算法,spring"}</script><link rel="canonical" href="https://mysticalguest.github.io/CSharp/60953.html"><link rel="alternative" href="/atom.xml" title="Longing(MysteryGuest的博客)" type="application/atom+xml"><link rel="icon" href="/img/bird.ico"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script src="/js/click.js"></script><script src="/js/anime.min.js"></script><canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"></canvas><script src="/js/snow.js"></script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/mylogo.svg" alt="Longing(MysteryGuest的博客)" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Visit on GitHub" href="https://github.com/MysticalGuest"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="thumbnail" src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/CSharp/running_shoes.jpg" alt="电子商务课程复习"></span></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-18T09:44:24.536Z" title="2020-08-18T09:44:24.536Z">2020-08-18</time><span class="level-item"><a class="link-muted" href="/tags/%E7%A7%AF%E7%B4%AF/">积累</a></span><span class="level-item"><a class="link-muted" href="/categories/CSharp/">CSharp</a></span><span class="level-item">1 小时 读完 (大约 12700 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">电子商务课程复习</h1><div class="content"><h2 id="第1章-计算机、Internet与Visual-C-简介"><a href="#第1章-计算机、Internet与Visual-C-简介" class="headerlink" title="第1章 计算机、Internet与Visual C#简介"></a>第1章 计算机、Internet与Visual C#简介</h2><a id="more"></a>
<h3 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h3><h4 id="1-1-填空题"><a href="#1-1-填空题" class="headerlink" title="1.1 填空题"></a>1.1 填空题</h4><ul>
<li>计算机只能直接理解其本身的<strong>机器</strong>语言，这种语言是由1和0构成的。</li>
<li>计算机处理数据时由一组指令控制，这组指令称为计算机<strong>程序</strong>。</li>
<li>本章介绍的3种语言是机器语言、<strong>汇编语言</strong>和<strong>高级语言</strong>。</li>
<li>将高级语言程序变成机器语言程序称为<strong>编译器</strong>。</li>
<li>Visual Studio是开发C#程序的<strong>集成开发环境（IDE）</strong>。</li>
<li>C语言是作为<strong>UNIX</strong>操作系统的开发语言而著称的。</li>
<li>Web服务分别用<strong>XML</strong>和<strong>SOAP</strong>在Internet上标记和发送消息。</li>
</ul>
<h4 id="2-2-判断题（更正过的）"><a href="#2-2-判断题（更正过的）" class="headerlink" title="2.2 判断题（更正过的）"></a>2.2 判断题（更正过的）</h4><ul>
<li>UML主要用于设计面向对象系统。</li>
<li>C#是面向对象语言。</li>
<li>C#是多个.NET语言之一（还有Visual Basic与Visual C++）。</li>
<li>面向对象编程（针对事情）是比过程式编程更自然的建模方式。</li>
<li>计算机只能直接理解其机器语言。</li>
<li>MSIL是公共中间格式，不管原.NET语言是什么，所有.NET程序都要编译成这种格式。</li>
<li>.NET框架可以移植到非Windows平台</li>
</ul>
<h2 id="第2章-Visual-C-2008-Express简介"><a href="#第2章-Visual-C-2008-Express简介" class="headerlink" title="第2章 Visual C# 2008 Express简介"></a>第2章 Visual C# 2008 Express简介</h2><h3 id="课后习题-1"><a href="#课后习题-1" class="headerlink" title="课后习题"></a>课后习题</h3><h4 id="2-1-填空题"><a href="#2-1-填空题" class="headerlink" title="2.1 填空题"></a>2.1 填空题</h4><ul>
<li><strong>可视化编程</strong>技术可以创建GUI而不用编写任何代码。</li>
<li><strong>方案</strong>是一个或多个工程，一起形成Visual C#程序。</li>
<li><strong>自动隐藏</strong>特性在鼠标指针移到窗口区外时隐藏窗口。</li>
<li><strong>工具提示</strong>在鼠标指针放到图标上时显示。</li>
<li><strong>Solution Explorer</strong>窗口可以浏览方案文件。</li>
<li>加号框表示Solution Explorer中的树可以<strong>展开</strong>。</li>
<li>属性窗口的属性按<strong>字母顺序</strong>或<strong>类别</strong>排序</li>
<li>窗体的<strong>Text</strong>属性指定窗体标题栏中显示的文本。</li>
<li><strong>工具栏</strong>可以直观地将控件加进窗体中。</li>
<li>用<strong>动态帮助</strong>根据当前上下文显示相关帮助文章。</li>
<li><strong>TextAlign</strong>属性指定文本在卷标边界中的对齐方式。</li>
</ul>
<h4 id="2-2-判断题（更正过的）-1"><a href="#2-2-判断题（更正过的）-1" class="headerlink" title="2.2 判断题（更正过的）"></a>2.2 判断题（更正过的）</h4><ul>
<li>标题栏显示IDE的方式。</li>
<li>图钉图标切换，自动隐藏，而X框关闭窗口。</li>
<li>工具栏图标表示各种菜单命令。</li>
<li>工具箱包括表示控件的图标。</li>
<li>窗体有标题栏，卷标没有（但有卷标文本）。</li>
<li>控制属性可以用属性窗口修改。 </li>
<li>图形框通常显示图形。</li>
<li>Visual C#文件扩展名为.cs。</li>
<li>窗体背景颜色用BackColor属性设置。</li>
</ul>
<h2 id="第3章-C-程序简介"><a href="#第3章-C-程序简介" class="headerlink" title="第3章 C#程序简介"></a>第3章 C#程序简介</h2><p>简单程序：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//console.WriteLine()和console.Write()区别在于最后是否有换行。</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Welcome</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"Hello world!"</span>);</span><br><span class="line">    <span class="comment">//使用formating</span></span><br><span class="line">    Console.WriteLine(<span class="string">"&#123;0&#125;\n&#123;1&#125;"</span>,<span class="string">"Welcome to"</span>, <span class="string">"C# Programming!"</span>);</span><br><span class="line">    <span class="comment">//读入加转换</span></span><br><span class="line">    Convert.ToInt32(Console.ReadLine());</span><br><span class="line">    <span class="comment">//输出指定长度,如果需要在左侧则使用&#123;0，-20&#125;表示</span></span><br><span class="line">    Console.WriteLine(<span class="string">"&#123;0,4&#125;&#123;1,20:C&#125;"</span>, year, acc ount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="课后习题-2"><a href="#课后习题-2" class="headerlink" title="课后习题"></a>课后习题</h3><h4 id="3-1-填空题"><a href="#3-1-填空题" class="headerlink" title="3.1 填空题"></a>3.1 填空题</h4><ul>
<li><strong>左花括号（ { ）</strong>开始方法体，<strong>右花括号（ } ）</strong>结束方法体。</li>
<li>每条语句以<strong>分号</strong>结束。</li>
<li><strong>if</strong>是决策语句。</li>
<li>单行注释以<strong>//</strong>开始。</li>
<li><strong>空行、空格</strong>和<strong>制表符</strong>称为空白符，新行符也是空白符。</li>
<li><strong>关键字</strong>保留给C#使用。</li>
<li>C#程序从<strong>Main</strong>方法开始执行。</li>
<li>方法<strong>Console.WriteLine()</strong>和<strong>Console.Write()</strong>在控制台窗口显示信息。</li>
</ul>
<h4 id="3-2-判断题（更正过的）"><a href="#3-2-判断题（更正过的）" class="headerlink" title="3.2 判断题（更正过的）"></a>3.2 判断题（更正过的）</h4><ul>
<li>注释不在程序执行时导致操作，而是建档程序和改进其可读性。</li>
<li>C#是大小写相关的，所以number和NuMbEr是不同变量。</li>
<li>求余运算符（%）也可以在C#中处理非整数算子。</li>
<li>*、/和%同一优先级，而+和-低一级。</li>
</ul>
<h2 id="第4章-类与对象简介"><a href="#第4章-类与对象简介" class="headerlink" title="第4章 类与对象简介"></a>第4章 类与对象简介</h2><p>Main是个特殊方法，在程序执行时自动调用，但大多数方法并不自动调用。</p>
<p>习惯上，方法名从大写字母开始，后续单词首字母大写。</p>
<p>get和set方法的使用：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GradeBook</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">string</span> courseName;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">GradeBook</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    CourseName = name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 之后直接使用CourseName获取到其变量</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">string</span> CourseName</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> courseName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">    courseName = <span class="keyword">value</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*更好的get和set方法：</span></span><br><span class="line"><span class="comment">  *public string CourseName&#123;get; set;&#125;</span></span><br><span class="line"><span class="comment">  *称为：自实现属性</span></span><br><span class="line"><span class="comment">  *直接写出来，声明+实现一起出现</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DisplayMessage</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"Hello\n&#123;0&#125;"</span>, CourseName)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main方法</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GradeBookTest</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    GradeBook myGradeBook = <span class="keyword">new</span> GradeBook();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让Main方法执行程序的关键部分是static关键字，表示这个Main方法是静态方法，调用是不必先创建这个类的对象。</p>
<p>可以在需要时声明新的类类型，因此C#称为可扩展语言。</p>
<h3 id="关于using指令"><a href="#关于using指令" class="headerlink" title="关于using指令"></a>关于using指令</h3><p>注意上面的程序，这个指令告诉编译器程序使用System名字空间中的类，如Console类。默认情况下，GradeBook类和GradeBookTest类在相同名字空间，一个类使用同一名字空间的另一个类，不需要using指令。</p>
<p>没有显式放进一个名字空间的类隐式放进全局名字空口。</p>
<p>实际上也可以不用using指令，使用类的<strong>完全限定类名</strong>，包括完全名字空间和类名，System.Console.WriteLine();</p>
<h3 id="GradeBook类带实例变量与属性"><a href="#GradeBook类带实例变量与属性" class="headerlink" title="GradeBook类带实例变量与属性"></a>GradeBook类带实例变量与属性</h3><p>GradeBook类的每个实例包含每个实例变量的一个副本。</p>
<h3 id="访问修饰符public与private"><a href="#访问修饰符public与private" class="headerlink" title="访问修饰符public与private"></a>访问修饰符public与private</h3><p>用private声明的变量与方法只能在声明这个方法的类中访问。</p>
<p>用private声明的实例变量称为信息隐藏。在GradeBook类中，属性CourseName操纵实例变量courseName。</p>
<h3 id="设置与读取专用实例变量、属性"><a href="#设置与读取专用实例变量、属性" class="headerlink" title="设置与读取专用实例变量、属性"></a>设置与读取专用实例变量、属性</h3><p><strong>属性（Property）</strong> 是类（class）、结构（structure）和接口（interface）的命名（named）成员。类或结构中的成员变量或方法称为 <strong>域（Field）</strong>。属性（Property）是域（Field）的扩展，且可使用相同的语法来访问。它们使用 <strong>访问器（accessors）</strong> 让私有域的值可被读写或操作。</p>
<p>尽管可以定义get和set方法，但C#<strong>属性</strong>更方便。</p>
<p>上面程序GradeBook类中的CourseName就是属性。属性声明可以有get访问函数、set访问函数或两者皆有。</p>
<p>定义属性后，可以在代码中像变量一样使用。可以用赋值运算符对属性赋值，其执行属性set函数代码。</p>
<h3 id="get和set访问方法"><a href="#get和set访问方法" class="headerlink" title="get和set访问方法"></a>get和set访问方法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = gradeBook.CourseName;</span><br></pre></td></tr></table></figure>
<p>用户不能直接操纵实例变量courseName，因为它是专用的。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradeBook.CourseBook = <span class="string">"OS"</span>;</span><br></pre></td></tr></table></figure>
<p>这时文本“OS”传入隐式参数value，执行set访问方法。注意value在set访问方法中隐式声明和初始化，在set方法体中声明局部变量value会发生编译错误。set方法完成任务后不返回任何数据。</p>
<p>声明顺序不做要求。</p>
<p>在公用属性中，get方法可以是公用的，set方法可以是专用的。</p>
<h3 id="值类型与引用类型"><a href="#值类型与引用类型" class="headerlink" title="值类型与引用类型"></a>值类型与引用类型</h3><p>C#语言的类型分为两类——值类型与引用类型。C#的简单类型都是值类型。值类型的变量（如int）只包含这个类型的值。例如：<code>int count = 7</code>表示：int类型的变量count，只能包含像7这样的整数。</p>
<p>引用类型的变量（也称为引用）包含存储变量所引用数据的内存地址。这个变量在程序中称为引用一个对象。即引用类型（GradeBook）的变量（gradeBook）包含该类型对象的引用（内存地址）。</p>
<p>引用类型实例变量默认初始化为null。string是个引用类型实例变量。</p>
<p>值为null的字符串变量不是空串。空串表示””或string.Empty。null表示引用的不是对象。空串是不含字符的string对象。</p>
<h3 id="用构造函数初始化对象"><a href="#用构造函数初始化对象" class="headerlink" title="用构造函数初始化对象"></a>用构造函数初始化对象</h3><p>默认情况下，编译器在没有显式提供构造函数的类中提供一个没有变元的默认构造方法，因此任何类都有函数。默认构造方法不修改实例变量的默认值。如果声明类的任何构造函数，则C#不对这个类创建默认构造函数。</p>
<p>构造函数名必须与类名相同。与方法不同，构造函数不指定返回类型（连void也没有）。</p>
<h3 id="浮点数与decimal类型"><a href="#浮点数与decimal类型" class="headerlink" title="浮点数与decimal类型"></a>浮点数与decimal类型</h3><p>float、double和decimal可以在内存中存储实数。float和double类型称为浮点类型，它们与decimal的主要区别在于：decimal变量精确存储有限范围的实数，而浮点数只存储实数的近似值，但取值范围大得多。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>简单类型</th>
<th></th>
<th>有效位</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>单精度浮点数</td>
<td>7</td>
<td></td>
<td></td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点数</td>
<td>15~16</td>
<td></td>
<td>精度是float的2倍</td>
</tr>
<tr>
<td>decimal</td>
<td></td>
<td>28~29</td>
<td>7.33M或7.33m</td>
<td>需要double变量2倍内存</td>
</tr>
</tbody>
</table>
</div>
<p>整数直接赋值给上面3种类型，隐式转换成这些类型。</p>
<p>格式项{0:C}将数据格式化为金额值：$3.3</p>
<p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/CSharp/format.PNG" alt=""></p>
<h3 id="课后习题-3"><a href="#课后习题-3" class="headerlink" title="课后习题"></a>课后习题</h3><h4 id="4-1-填空题"><a href="#4-1-填空题" class="headerlink" title="4.1 填空题"></a>4.1 填空题</h4><ul>
<li>房子的蓝图就像对象的类。</li>
<li>运算符new创建关键字右边所指定的对象。</li>
<li>默认情况下，没有显式在名字空间中声明的类隐式放在全局名字空间。</li>
<li>类的每个对象维护属性复制时，表示属性的字段也称为实例变量。</li>
<li>Convert方法ToDecimal返回decimal值。</li>
<li>Console方法ReadLine读取字符，直到遇到新行符，然后用string返回这些字符（不包含新行符）。</li>
<li>对于自实现属性，编译器自动生成专用实例变量及其get与set方法。</li>
</ul>
<h4 id="4-2-判断题"><a href="#4-2-判断题" class="headerlink" title="4.2 判断题"></a>4.2 判断题</h4><ul>
<li>方法和属性体用左右花括号定界。</li>
<li>实例变量默认初始化，局部变量不是。</li>
<li>源代码中的实数值称为浮点数直接输，默认类型为float。</li>
</ul>
<h2 id="第5章-控制语句：第一部分"><a href="#第5章-控制语句：第一部分" class="headerlink" title="第5章 控制语句：第一部分"></a>第5章 控制语句：第一部分</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>解决问题的过程（procedure）称为算法（algorithm），包括：</p>
<ul>
<li>执行的操作（action）</li>
<li>执行的操作的顺序（order）</li>
</ul>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>伪代码是人为的非正式语言，帮助程序员开发算法。</p>
<h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><p>程序中的语句按编写的顺序一条一条地执行，称为顺序执行。</p>
<p>指定下一个执行的语句不是紧邻其后的语句，这称为控制转移。</p>
<p>结构化编程更清晰、更易调试与修改并且不容易出错。</p>
<p>研究表明，所有程序都可以只用三种控制结构，即顺序结构、选择结构和重复结构。</p>
<p><strong>顺序结构</strong>是C#内置的，除非另外指定，计算机总是按编写的顺序一条一条地执行。</p>
<p><strong>选择结构</strong>有三种，称为选择语句。</p>
<p>if语句称为单选择语句，if…else语句称为双选择语句，switch语句称为多选择语句。</p>
<p>C#提供四种重复结构，称为重复语句（也称为迭代语句或循环），重复语句有while、do…while、for与foreach。</p>
<p><strong>控制语句小结</strong>：C#只有三种控制语句，分别是顺序结构、选择结构（三种）和重复语句（四种）。</p>
<p>C#提供条件运算符（? :），可以代替if…else语句。是C#中唯一的三元运算符（ternary operator），操作数和条件运算符一起形成条件表达式（conditional expression）。</p>
<p><strong>垂悬else问题</strong>：C#编译器总是将else与最接近的if相关联，除非用花括号指定。（就近原则）</p>
<p>放在花括号中的一组语句称为<strong>块</strong>。</p>
<p><strong>简单类型间的显式和隐式转换</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> average;</span><br><span class="line"><span class="keyword">int</span> total,gradeCounter;</span><br><span class="line">average = (<span class="keyword">double</span>)total / gradeCounter;</span><br></pre></td></tr></table></figure>
<p>这里使用double类型转换符称为显式转换，这是的计算式浮点数除以整数，要保证操作数的数据类型一致，C#将int操作数提升为double（提升操作，也称为隐式转换）。</p>
<p><strong>C#支持复合赋值运算符</strong></p>
<p>分别为：+=，-=，*=，/=和%=</p>
<p><strong>也支持自增自减</strong>，前置和后置</p>
<p>C#也是强类型语言，即要求所有变量都具有类型。</p>
<h3 id="课后习题-4"><a href="#课后习题-4" class="headerlink" title="课后习题"></a>课后习题</h3><h4 id="5-1-填空题"><a href="#5-1-填空题" class="headerlink" title="5.1 填空题"></a>5.1 填空题</h4><ul>
<li>将一组指令重复特定次数称为<strong>计数器控制或确定</strong>重复。</li>
<li>事先不知道一组指令的重复次数，可以用标记（记号，标志或哑元）值终止重复。</li>
</ul>
<h4 id="5-2-判断题"><a href="#5-2-判断题" class="headerlink" title="5.2 判断题"></a>5.2 判断题</h4><ul>
<li>指定计算机程序执行语句的顺序称为程序控制。</li>
</ul>
<h2 id="第6章-控制语句：第二部分"><a href="#第6章-控制语句：第二部分" class="headerlink" title="第6章 控制语句：第二部分"></a>第6章 控制语句：第二部分</h2><p><strong>for循环语句</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> counter = <span class="number">1</span>; counter &lt;= <span class="number">10</span>; counter++, total += counter )</span><br><span class="line">&#123;</span><br><span class="line">  statement/empty statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>switch多选择语句</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(grade / <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    ++aCount;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    ++bCount;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>break语句</p>
<p>continue语句在循环结构中执行时跳过该结构体的其余语句，进入下一轮循环。</p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>有&amp;&amp;（条件与）、||（条件或）、&amp;（布尔逻辑与）、|（布尔逻辑或）、^（布尔逻辑异或）和!（逻辑非）。</p>
<p>只有逻辑非是一元运算符。</p>
<p>短路求值：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gender == <span class="string">'F'</span>) &amp;&amp; (++age &gt;= <span class="number">65</span>)</span><br></pre></td></tr></table></figure>
<p>将在gender不等于“F”时立即停止（整个表达式为假）。</p>
<p>布尔逻辑（&amp;和|）不进行短路求值，所以如果用布尔表达式++age&gt;=会执行，age值会发生改变。</p>
<h3 id="课后习题-5"><a href="#课后习题-5" class="headerlink" title="课后习题"></a>课后习题</h3><h4 id="6-1-填空题"><a href="#6-1-填空题" class="headerlink" title="6.1 填空题"></a>6.1 填空题</h4><ul>
<li>通常，for语句用于计数器控制循环，while语句用于标记控制循环。</li>
</ul>
<h4 id="6-2-判断题"><a href="#6-2-判断题" class="headerlink" title="6.2 判断题"></a>6.2 判断题</h4><ul>
<li>switch选择结构的每个case中可以使用break语句退出当前case结构，也可以使用return语句。</li>
</ul>
<h2 id="第7章-方法详述"><a href="#第7章-方法详述" class="headerlink" title="第7章 方法详述"></a>第7章 方法详述</h2><p>分治法（divide and conquer）：经验表明，要开发和维护大程序，最好的办法是从更容易管理的小块和小组件开始。</p>
<h3 id="C-代码包装"><a href="#C-代码包装" class="headerlink" title="C#代码包装"></a>C#代码包装</h3><p>代码包装的三种常见途径是方法、类和名字空间。</p>
<p>方法（函数、过程）可以将程序模块化，用户定义方法。分治，复用。</p>
<h3 id="静态方法，静态变量和Math类"><a href="#静态方法，静态变量和Math类" class="headerlink" title="静态方法，静态变量和Math类"></a>静态方法，静态变量和Math类</h3><p>所有Math方法都是静态的。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine( Math.Sqrt( a + b * c ) )</span><br></pre></td></tr></table></figure>
<p align="center">
    <img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/CSharp/Math.PNG" alt="Math">
</p>

<p><strong>静态常量</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.PI</span><br><span class="line">Math.E</span><br></pre></td></tr></table></figure>
<p>这些变量在Math类中声明，修饰符为public与const。任何用关键字const声明的变量都是常量，声明之后不能改变数值。</p>
<p>前面提到，属性的变量也称为实例变量，类的每个对象在内存中有这个变量的不同实例。但静态变量，类的每个对象在内存中没有这个变量的不同实例。类的对象包含静态变量时，这个类的所有对象共享静态变量的同一备份。</p>
<p><strong>为什么Main方法声明为static？</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span> args[]</span>)</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main方法声明为static是执行环境可以调用Main方法而不必创建类的实例。</p>
<p>string args[]可以省略，public也可以省略，void也可替换为int</p>
<p><strong>用字符串接合组装字符串</strong></p>
<p>C#中生成string对象时可以用运算符+（或复合赋值运算符+=）将小字符串组装成大字符串。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> result = <span class="number">9.35000</span>;</span><br><span class="line">Console.WriteLine(<span class="string">"Maximum is: "</span> + result);</span><br></pre></td></tr></table></figure>
<p>控制台输出为：Maximum is: 9.35</p>
<p>布尔值也会隐式转换成string。</p>
<h3 id="关于方法的声明与使用"><a href="#关于方法的声明与使用" class="headerlink" title="关于方法的声明与使用"></a>关于方法的声明与使用</h3><p>可以用三种方式调用方法。</p>
<h3 id="方法调用堆栈云激活记录"><a href="#方法调用堆栈云激活记录" class="headerlink" title="方法调用堆栈云激活记录"></a>方法调用堆栈云激活记录</h3><p>堆栈是后进先出（LIFO）数据结构。</p>
<p>程序调用方法是，被调的方法要知道如何放回调用者，因此把调用者的返回地址压入程序执行堆栈（也称方法调用堆栈）。</p>
<p>程序执行堆栈还包含程序执行期间每个方法调用使用的局部变量。这个数据存放成程序执行堆栈的一部分，称为方法调用的激活记录( activation record)或堆栈帧( stack frame)。进行方法调用时，这个方法调用的激活记录压进程序执行堆栈。方法返回调用者时，这个方法调用的激活记录出栈，程序不再知道这些局部变量。如果局部变量保存对象引用，是具有该对象引用的程序中唯一变量，则包含这个局部变量的激活记录出栈时，程序不能再访问这个对象，最终会在“内存回收”时从内存中删除。<br>当然，计算机的内存量有限,因此只能用一定量的内存存储程序执行堆栈中的激活记录。如果发生的方法调用太多，程序执行堆栈无法存储其激活记录,则会发生堆栈溢出错误。</p>
<h3 id="变元提升与类型转换"><a href="#变元提升与类型转换" class="headerlink" title="变元提升与类型转换"></a>变元提升与类型转换</h3><p>方法调用的另一个重要特性是变元提升——隐式地将变元值变成方法参数所需要的类型。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine( Math.Sqrt( <span class="number">4</span> ) );</span><br></pre></td></tr></table></figure>
<p>虽然Sqrt方法要求double变元，但也可以使用整型值，打印数值2.0。方法声明的参数表使C#将int值4转换成double值4.0，然后传入Sqrt方法。</p>
<p>隐式转换要求满足升级规则，否则必须显式转换。</p>
<p>所有简单类型都可以隐式转换为object类型。</p>
<p align="center">
    <img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/CSharp/Implicit.PNG" alt="Implicit">
</p>

<h3 id="NET框架类库"><a href="#NET框架类库" class="headerlink" title=".NET框架类库"></a>.NET框架类库</h3><p>许多预定义类组成相关类的名字空间。名字空间组成.NET框架类库（即FCL）。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br></pre></td></tr></table></figure>
<p>程序可以使用System名字空间的类名，不必用完全限定名。</p>
<p>C#的一个强大之处是FCL的名字空间中有许多类。</p>
<p align="center">
  <img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/CSharp/FCL_namespace.PNG">
  <img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/CSharp/FCL_namespace_next.PNG" alt="FCL">
</p>

<h3 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h3><p>可以用随机数生成器<strong>对象</strong>产生随机byte、int与double值。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Random randomNumbers = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="comment">// Next方法产生值：0&lt;=randomValue&lt;=+2147483646</span></span><br><span class="line"><span class="keyword">int</span> randomValue = randomNumber.Next();</span><br><span class="line"><span class="comment">// 返回0、1、2、3、4、5。变元6称为比例因子，表示Next要产生的数值的个数</span></span><br><span class="line"><span class="keyword">int</span> randomValue = randomNumber.Next( <span class="number">6</span> );</span><br><span class="line"><span class="comment">// 返回1、2、3、4、5、6</span></span><br><span class="line"><span class="keyword">int</span> randomValue = <span class="number">1</span> + randomNumber.Next( <span class="number">6</span> );</span><br><span class="line"><span class="comment">// 返回1、2、3、4、5、6</span></span><br><span class="line"><span class="keyword">int</span> randomValue = randomNumber.Next( <span class="number">1</span>, <span class="number">7</span> );</span><br></pre></td></tr></table></figure>
<p>Next返回的值实际上是伪随机数——通过复杂数学计算产生的数值序列。用当前时间作为种子。</p>
<h3 id="比例缩放与移动随机数"><a href="#比例缩放与移动随机数" class="headerlink" title="比例缩放与移动随机数"></a>比例缩放与移动随机数</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">返回<span class="number">2</span>、<span class="number">5</span>、<span class="number">8</span>、<span class="number">11</span>、<span class="number">14</span></span><br><span class="line"><span class="keyword">int</span> number = <span class="number">2</span> + <span class="number">3</span> * randomNumber.Next( <span class="number">5</span> )</span><br></pre></td></tr></table></figure>
<h3 id="随机数可重复性与测试-调试"><a href="#随机数可重复性与测试-调试" class="headerlink" title="随机数可重复性与测试/调试"></a>随机数可重复性与测试/调试</h3><p>要保证运行和调试是随机数一致</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Random randomNumbers = <span class="keyword">new</span> Random( seedValue );</span><br></pre></td></tr></table></figure>
<p>seedValue变元（int类型）提供随机数计算的种子。如果每次使用相同的seedValue，则Random对象产生相同的随机数列。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">enum</span> Status &#123; CONTINUE, WON, LOST &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">enum</span> DiceNames</span><br><span class="line">&#123;</span><br><span class="line">  SNAKE_EYES = <span class="number">2</span>,</span><br><span class="line">  ...</span><br><span class="line">  TREY = <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="声明作用域"><a href="#声明作用域" class="headerlink" title="声明作用域"></a>声明作用域</h3><ul>
<li><p>参数声明的作用域是声明所在的方法体。</p>
</li>
<li><p>局部变量声明的作用域从声明点开始，到声明所在块结束为此。</p>
</li>
<li><p>for语句首部初始化部分出现的局部变量声明的作用域是for语句体和首部的其他表达式。</p>
</li>
<li><p>类的方法、属性、字段的作用域是整个类体。这就使类的非静态方法与属性可以使用类的任何方法、属性、字段，不管声明顺序如何。同样，<strong>静态属性与方法可以使用类的任何静态成员</strong>。</p>
</li>
</ul>
<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>一个类中可以声明同名方法，只要其参数集不同（参数个数、类型和顺序），称为方法重载。</p>
<p><strong>区别重载方法</strong></p>
<p>编译器根据签名区别重载方法，签名是方法名和参数个数、类型与顺序地组合。</p>
<p><strong>重载方法的返回类型</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Square</span>(<span class="params"> <span class="keyword">int</span> x </span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Square</span>(<span class="params"> <span class="keyword">int</span> y </span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> y * y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面2个方法<strong>签名相同</strong>，返回值类型不同，会产生编译错误。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">Factorial</span>(<span class="params"> <span class="keyword">long</span> number </span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// base case</span></span><br><span class="line">  <span class="keyword">if</span>(number &lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> number * Factorial( number <span class="number">-1</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="按值与按引用传递变元"><a href="#按值与按引用传递变元" class="headerlink" title="按值与按引用传递变元"></a>按值与按引用传递变元</h3><p>参数声明中使用关键字ref可以按引用将变量传递给方法——被调方法可以修改调用者的原变量。ref关键字用于调用方法中已经初始化的变量。</p>
<p>在参数前面加上关键字out可以建立输出参数，告诉编译器这个变元按引用传入被调方法，被调方法对调用者的原变量赋值。如果方法中没有在每个执行路径上对输出参数赋值，则编译器报错。</p>
<p>一个方法只能通过return语句向调用者返回一个值，但指定多个输出参数（ref或out）可以返回多个值。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReferenceAndOutParameters</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> y = <span class="number">5</span>; <span class="comment">// initialize y to 5</span></span><br><span class="line">  <span class="keyword">int</span> z; <span class="comment">// declare z, but does not initilize it</span></span><br><span class="line">  </span><br><span class="line">  SquareRef(<span class="keyword">ref</span> y);</span><br><span class="line">  SquareOut(<span class="keyword">out</span> z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SquareRef</span>(<span class="params"><span class="keyword">ref</span> <span class="keyword">int</span> x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x = x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SquareOut</span>(<span class="params"><span class="keyword">out</span> <span class="keyword">int</span> x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="课后习题-6"><a href="#课后习题-6" class="headerlink" title="课后习题"></a>课后习题</h3><h4 id="7-1-填空题"><a href="#7-1-填空题" class="headerlink" title="7.1 填空题"></a>7.1 填空题</h4><ul>
<li>数据只能从堆栈<strong>顶</strong>增加和取出。</li>
<li>将控制从被调方法返回调用者的三种方法是：<strong>return</strong>，<strong>return expression</strong>或<strong>方法右花括号处</strong></li>
<li>程序执行堆栈包含程序执行期间每次调用方法时局部变量的内存。这个数据存放在程序执行堆栈中，称为方法调用的<strong>活动记录</strong>或<strong>堆栈顶</strong>。</li>
</ul>
<h2 id="第8章-数组"><a href="#第8章-数组" class="headerlink" title="第8章 数组"></a>第8章 数组</h2><p>前面说过，类型可以分为两类——值类型和引用类型。数组是引用类型。</p>
<p>我们通常意义上的数组实际上是内存中数组实例的引用。</p>
<p>数组的元素可以是值类型或引用类型。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">5</span>;</span><br><span class="line">b=<span class="number">6</span>;</span><br><span class="line"><span class="comment">// 索引应为非负整数或整型表达式</span></span><br><span class="line">c[a + b] +=<span class="number">2</span>;</span><br><span class="line"><span class="comment">// 将元素c[11]加2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用数组的Length属性确定数组长度</span></span><br><span class="line"><span class="comment">// 注意数组的Length属性不能改变，因为它没有set方法</span></span><br><span class="line">c.Length</span><br></pre></td></tr></table></figure>
<p>数组索引值应为int、uint、long、ulong类型或可以隐式升级为这些类型的值。</p>
<p><strong>声明与创建数组</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span>[] array2;</span><br><span class="line">array2 = <span class="keyword">new</span> <span class="keyword">string</span>[<span class="number">12</span>];</span><br><span class="line"><span class="comment">// 每个元素接收默认值, 数组简单类型元素为0, 布尔元素为false, 引用为null</span></span><br></pre></td></tr></table></figure>
<p><strong>改变数组长度</strong></p>
<p>虽然数组是定长实体，但可以用静态Array方法Resize改变数组长度。这个方法创建指定长度的新数组，将原数组内容复制到新数组，并<strong>将收到的变量设置为引用新数组的第一个</strong>。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">Array.Resize( <span class="keyword">ref</span> array3, <span class="number">10</span> );</span><br></pre></td></tr></table></figure>
<p>如果新数组比旧数组小，则后面的内容被截尾。</p>
<p><strong>使用数组初始化器</strong></p>
<p>逗号分隔的表达式清单（称为初始化清单），放在花括号中：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array4 = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>编译器遇到包括初始化清单的数组声明时，首先计算清单中的初始化器个数，确定数组长度，然后在“幕后”建立相应的new操作。</p>
<p>声明常量全部用大写字母。</p>
<p><strong>用数组元素作为计数器</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RollDie</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> <span class="keyword">string</span>[] args </span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    Random randomNumbers = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span>[] frequency = <span class="keyword">new</span> <span class="keyword">int</span>[ <span class="number">7</span> ];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> roll = <span class="number">1</span>; roll &lt;= <span class="number">6000</span>; roll++)</span><br><span class="line">      ++frequency[ randomNumber.Next(<span class="number">1</span>, <span class="number">7</span>) ];</span><br><span class="line">    </span><br><span class="line">    Console.writeLine(<span class="string">"&#123;0&#125;&#123;1, 10&#125;"</span>, <span class="string">"Face"</span>, <span class="string">"Frequency"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> face = <span class="number">1</span>; face &lt; frequency.Length; face++)</span><br><span class="line">      Console.writeLine(<span class="string">"&#123;0, 4&#125;&#123;1, 10&#125;"</span>, face, frequency[face]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Face Frequency</span><br><span class="line">   1       956</span><br><span class="line">   2       981</span><br><span class="line">   3      1001</span><br><span class="line">   4      1030</span><br><span class="line">   5      1035</span><br><span class="line">   6       997</span><br></pre></td></tr></table></figure>
<p><strong>foreach语句</strong></p>
<p>foreach语句只能访问数组元素，不能修改元素。否则编译错误。</p>
<p><strong>隐式类型局部变量</strong></p>
<p>C#提供了隐式类型局部变量特性，是编译器可以根据变量初始化值类型推出局部变量的类型。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="number">7</span>; <span class="comment">// 编译器推出变量x类型为int，因为编译器认为7之类的整数是int类型</span></span><br><span class="line"><span class="keyword">var</span> <span class="number">-123.45</span>; <span class="comment">// double</span></span><br><span class="line"><span class="keyword">var</span> array5 = <span class="keyword">new</span>[] (<span class="number">32</span>, <span class="number">27</span>, <span class="number">64</span>, <span class="number">18</span>, <span class="number">95</span>, <span class="number">14</span>);</span><br></pre></td></tr></table></figure>
<p><strong>将数组与数组元素传入方法</strong></p>
<p>指定不带方括号的数组名。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyArray</span>(<span class="params"><span class="keyword">double</span>[] a</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法调用语句</span></span><br><span class="line"><span class="keyword">double</span>[] array6 = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">24</span>];</span><br><span class="line">ModifyArray( array6 );</span><br><span class="line"><span class="comment">// 接收double数组的引用, a与array6是相同对象</span></span><br></pre></td></tr></table></figure>
<p><strong>按值与按引用传递数组</strong></p>
<p>C#中“存储”数组之类对象的变量并不实际存储对象本身，而是存储对象的引用（即存储对象的计算机内存地址）。</p>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>二维的多维数组也称为数值表，把信息放在行和列中。</p>
<p>c#支持两种二维数组——矩形数组和齿状数组。</p>
<p><strong>矩形数组</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[ , ] array7 = &#123; &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125; &#125;</span><br></pre></td></tr></table></figure>
<p>编译器在每行的初始化器个数不同时产生一个错误，因为矩形数组的每一行要长度相同。</p>
<p><strong>齿状数组</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] jagged = &#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,</span><br><span class="line">  <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">3</span>&#125;,</span><br><span class="line">  <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>数组jagged本身是三个元素的数组，各引用一个int值的一维数组。</p>
<p>注意矩形数组与齿状数组的数组生成表达式差别。jagged数组后面是两组方括号，表示这是个int数组的数组。在数组初始化器中，C#要求用new关键字创建每一行的数组对象。</p>
<p><strong>用数组生成表达式创建二维数组</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[,] array8;</span><br><span class="line">array8 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>, <span class="number">4</span>]; <span class="comment">// 3行4列</span></span><br><span class="line"><span class="comment">// 齿状数组不能如此</span></span><br><span class="line"><span class="keyword">int</span>[][] array9 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">5</span>]; <span class="comment">// error</span></span><br><span class="line"><span class="comment">// 而是</span></span><br><span class="line"><span class="keyword">int</span>[][] a;</span><br><span class="line">a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][]; <span class="comment">// 2行</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">a[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p><strong>游长变元表（Variable-length argument lists）</strong></p>
<p>可以创建接收任意个变元的方法。</p>
<p>一维数组型变元前面加上关键字params在方法参数表中，表示这个方法接收任意个变元，类型为数组<strong>元素</strong>类型。params修饰符的这个用法只能在参数表最后一个项目中出现。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">Average</span>(<span class="params"><span class="keyword">params</span> <span class="keyword">double</span>[] numbers</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> total = <span class="number">0.0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">foreach</span>(<span class="keyword">double</span> d <span class="keyword">in</span> numbers)</span><br><span class="line">    total += d;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> total / numbers.Length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> d1 = <span class="number">10.0</span>;</span><br><span class="line">  <span class="keyword">double</span> d2 = <span class="number">10.0</span>;</span><br><span class="line">  <span class="keyword">double</span> d3 = <span class="number">10.0</span>;</span><br><span class="line">  </span><br><span class="line">  Console.WriteLine( Average(d1, d2) ); <span class="comment">// 15.0</span></span><br><span class="line">  Console.WriteLine( Average(d1, d2, d3) ); <span class="comment">// 20.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用命令行变元</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ArgTest</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span>(args.Length == <span class="number">0</span>)</span><br><span class="line">      Console.WriteLine(<span class="string">"The number of arg is 0!"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">foreach</span>(<span class="keyword">var</span> arg <span class="keyword">in</span> args)</span><br><span class="line">        Console.WriteLine(arg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ArgTest.exe 1 2 3</span></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="课后习题-7"><a href="#课后习题-7" class="headerlink" title="课后习题"></a>课后习题</h3><h4 id="8-1-填空题"><a href="#8-1-填空题" class="headerlink" title="8.1 填空题"></a>8.1 填空题</h4><ul>
<li>清单与数值表可以存放在<strong>数组</strong>中。</li>
<li>命令行变元存放在<strong>strings数组，通常称args</strong>中。</li>
</ul>
<h2 id="第9章-LINQ与泛型集合简介"><a href="#第9章-LINQ与泛型集合简介" class="headerlink" title="第9章 LINQ与泛型集合简介"></a>第9章 LINQ与泛型集合简介</h2><p>一组预包装数据结构——.NET框架集合类。</p>
<p>LINQ（language Integrated Query，语言集成查询表达式）。利用LINQ可以编写与SQL查询相识的查询表达式，从各种数据源，不限于数据库，还有数组和list驱动信息，选择符合一组条件的元素，称为筛选。</p>
<p>声明式编程：LINQ指定的不是读取结果所要的<strong>步骤</strong>，而是所选元素要满足的<strong>条件</strong>。</p>
<p>指定式编程：指定执行任务所有的步骤，面向对象是指示式编程的子集。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">LINQWithArray</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    <span class="keyword">int</span>[] values = &#123;<span class="number">2</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> filtered = </span><br><span class="line">      <span class="keyword">from</span> <span class="keyword">value</span> <span class="keyword">in</span> values</span><br><span class="line">      <span class="keyword">where</span> <span class="keyword">value</span> &gt; <span class="number">4</span></span><br><span class="line">      <span class="keyword">select</span> <span class="keyword">value</span>;</span><br><span class="line">    </span><br><span class="line">    Display(filtered); <span class="comment">// 9 5 7 8 5</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> sorted = </span><br><span class="line">      <span class="keyword">from</span> <span class="keyword">value</span> <span class="keyword">in</span> values</span><br><span class="line">      <span class="keyword">orderby</span> <span class="keyword">value</span></span><br><span class="line">      <span class="keyword">select</span> <span class="keyword">value</span>;</span><br><span class="line">    </span><br><span class="line">    Display(sorted); <span class="comment">// 0 1 2 3 4 5 7 8 9</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> sortedAndfiltered = </span><br><span class="line">      <span class="keyword">from</span> <span class="keyword">value</span> <span class="keyword">in</span> values</span><br><span class="line">      <span class="keyword">where</span> <span class="keyword">value</span> &gt; <span class="number">4</span></span><br><span class="line">      <span class="keyword">orderby</span> <span class="keyword">value</span></span><br><span class="line">      <span class="comment">// orderby value desending 都是降序</span></span><br><span class="line">      <span class="keyword">select</span> <span class="keyword">value</span>; <span class="comment">// </span></span><br><span class="line">    </span><br><span class="line">    Display(sortedAndfiltered); <span class="comment">// 9 8 7 5 5</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// IEnumerable&lt;int&gt;是个接口，描述的对象可迭代</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Display</span>(<span class="params">IEnumerable&lt;<span class="keyword">int</span>&gt; results</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="keyword">var</span> element <span class="keyword">in</span> results)</span><br><span class="line">      Console.WriteLine(<span class="string">" &#123;0&#125;"</span>, element);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>用泛型方法显示LINQ查询结果</strong></p>
<p>泛型方法，指定一个类型参数表。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> Display&lt;T&gt;(IEnumerable&lt;T&gt; results)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">foreach</span>(T element <span class="keyword">in</span> results)</span><br><span class="line">    Console.WriteLine(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Employee[] employees;</span><br><span class="line"><span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">Display(employees);</span><br><span class="line">Display(array);</span><br></pre></td></tr></table></figure>
<p>T是类型变元的占位符。调用泛型方法时，编译器根据调用中的变元指定每个类型表示的类型。</p>
<p>T可以在参数表和方法体中多次出现，也可以作为返回值。</p>
<h3 id="集合简介"><a href="#集合简介" class="headerlink" title="集合简介"></a>集合简介</h3><p>.NET框架类库提供了几个类（称为集合），可以存储相关对象集合。</p>
<p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/CSharp/List.PNG" alt="List"></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collection.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ListCollection</span></span><br><span class="line">&#123;</span><br><span class="line">  List&lt;<span class="keyword">string</span>&gt; items = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">  </span><br><span class="line">  items.Add(<span class="string">"red"</span>);</span><br><span class="line">  items.Insert(<span class="number">0</span>, <span class="string">"yellow"</span>); <span class="comment">// yellow, red</span></span><br><span class="line">  items.Add(<span class="string">"yellow"</span>); <span class="comment">// yellow, red, yellow</span></span><br><span class="line">  items.Remove(<span class="string">"yellow"</span>); <span class="comment">// red, yellow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用LINQ查询泛型集合"><a href="#用LINQ查询泛型集合" class="headerlink" title="用LINQ查询泛型集合"></a>用LINQ查询泛型集合</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Collection.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LINQListCollection</span></span><br><span class="line">&#123;</span><br><span class="line">  List&lt;<span class="keyword">string</span>&gt; items = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">  </span><br><span class="line">  items.Add(<span class="string">"aQua"</span>);</span><br><span class="line">  items.Add(<span class="string">"RusT"</span>);</span><br><span class="line">  items.Add(<span class="string">"yElLow"</span>);</span><br><span class="line">  items.Add(<span class="string">"rEd"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// List&lt;string&gt; items = new List&lt;string&gt;&#123;"aQua", "RusT", "yElLow", "rEd"&#125;;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> startWithR = </span><br><span class="line">    <span class="keyword">from</span> item <span class="keyword">in</span> items</span><br><span class="line">    <span class="keyword">let</span> uppercasedString = item.ToUpper()</span><br><span class="line">    <span class="keyword">where</span> uppercasedString.StartsWith(<span class="string">"R"</span>)</span><br><span class="line">    <span class="keyword">orderby</span> uppercasedString</span><br><span class="line">    <span class="keyword">select</span> uppercasedString;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">foreach</span>(<span class="keyword">var</span> item <span class="keyword">in</span> startWithR)</span><br><span class="line">    Console.Write(<span class="string">"&#123;0&#125; "</span>, item); <span class="comment">// RED RUST</span></span><br><span class="line">  </span><br><span class="line">  items.Add(<span class="string">"rUby"</span>);</span><br><span class="line">  items.Add(<span class="string">"SaFfRon"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">foreach</span>(<span class="keyword">var</span> item <span class="keyword">in</span> startWithR)</span><br><span class="line">    Console.Write(<span class="string">"&#123;0&#125; "</span>, item); <span class="comment">// RED RUBY RUST </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>查询只创建一次，但对结果迭代得到两个不同的列表。这里演示了LINQ的延迟执行——查询<strong>只在访问结果时才执行</strong>，而不是在定义查询时执行。一次创建，多次执行，数据改变，返回结果。</p>
</blockquote>
<h3 id="课后习题-8"><a href="#课后习题-8" class="headerlink" title="课后习题"></a>课后习题</h3><h4 id="9-1-填空题"><a href="#9-1-填空题" class="headerlink" title="9.1 填空题"></a>9.1 填空题</h4><ul>
<li>集合类专门用于存储对象组和提供组织、存储与读取对象的方法。</li>
</ul>
<h2 id="第10章-再论类与对象"><a href="#第10章-再论类与对象" class="headerlink" title="第10章 再论类与对象"></a>第10章 再论类与对象</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span>.Format(<span class="string">"&#123;0:D2&#125;:&#123;1:D2&#125;:&#123;2:D2&#125;"</span>, hour, minute, second);</span><br></pre></td></tr></table></figure>
<p>Format()返回格式化字符串，而不是在控制台显示。</p>
<h3 id="用this引用访问当前对象成员"><a href="#用this引用访问当前对象成员" class="headerlink" title="用this引用访问当前对象成员"></a>用this引用访问当前对象成员</h3><p>每个对象都可以用关键字this引用自己。调用特点对象的非静态方法时，方法体隐式用关键字this引用这个对象的实例变量和其他成员。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimpleTime</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> hour;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleTime</span>(<span class="params"><span class="keyword">int</span> hour</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    <span class="keyword">this</span>.hour = hour;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">BuildString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    <span class="keyword">this</span>.ToString();</span><br><span class="line">    ToString();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    reutrn <span class="keyword">string</span>.Format(<span class="string">"0:D2"</span>, <span class="keyword">this</span>.hour);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h3><p>类可以用关键字this定义属性式的类成员，称为索引器，可以像数组一样用索引访问元素清单。索引器的好处是可以定义整数索引和非整数索引。</p>
<p>索引器在类中像属性一样定义，用关键字this定义，不能用static修饰。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Box</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">string</span>[] names = &#123;<span class="string">"length"</span>, <span class="string">"width"</span>, <span class="string">"height"</span>&#125;;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span>[] dimensions = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">3</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Box</span>(<span class="params"><span class="keyword">double</span> length, <span class="keyword">double</span> width, <span class="keyword">double</span> heght</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    dimensions[<span class="number">0</span>] = length;</span><br><span class="line">    dimensions[<span class="number">1</span>] = width;</span><br><span class="line">    dimensions[<span class="number">2</span>] = height;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">double</span> <span class="keyword">this</span>[<span class="keyword">int</span> index]</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>( (index&lt;<span class="number">0</span>) || (index&gt;=dimensions.Length) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> dimensions[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>( (index&gt;=<span class="number">0</span>) || (index&lt;dimensions.Length) )</span><br><span class="line">        dimensions[index] = vlaue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">double</span> <span class="keyword">this</span>[<span class="keyword">string</span> name]</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>((i&lt;names.Length) &amp;&amp; (name.ToLower()!=names[i]))</span><br><span class="line">        ++i;</span><br><span class="line">      <span class="keyword">return</span> (i == naems.Length) ? <span class="number">-1</span> : dimensions[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>((i&lt;names.Length) &amp;&amp; (name.ToLower()!=names[i]))</span><br><span class="line">        ++i;</span><br><span class="line">      <span class="keyword">if</span>(i != names.Length)</span><br><span class="line">        dimensions[i] = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BoxTest.cs</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BoxTest</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    Box box = <span class="keyword">new</span> Box(<span class="number">30</span>, <span class="number">30</span> ,<span class="number">30</span>);</span><br><span class="line">    <span class="comment">// box[0] 30</span></span><br><span class="line">    <span class="comment">// box[1] 30</span></span><br><span class="line">    <span class="comment">// box[2] 30</span></span><br><span class="line">    box[<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line">    box[<span class="string">"width"</span>]=<span class="number">20</span>;</span><br><span class="line">    <span class="comment">// box[0] 10</span></span><br><span class="line">    <span class="comment">// box[1] 20</span></span><br><span class="line">    <span class="comment">// box[2] 30</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>索引器可以重载。</p>
<h3 id="重载构造函数"><a href="#重载构造函数" class="headerlink" title="重载构造函数"></a>重载构造函数</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Time</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> hour;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> minute;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Time</span>(<span class="params"></span>) : <span class="title">this</span>(<span class="params"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span>)</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Time</span>(<span class="params"><span class="keyword">int</span> h</span>) : <span class="title">this</span>(<span class="params">h, <span class="number">0</span>, <span class="number">0</span></span>)</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Time</span>(<span class="params"><span class="keyword">int</span> h, <span class="keyword">int</span> m</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    SetTime(h ,m);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Time</span>(<span class="params">Time time</span>) : <span class="title">this</span>(<span class="params">time.Hour, time.Minute</span>)</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SetTime</span>(<span class="params"><span class="keyword">int</span> h, <span class="keyword">int</span> m</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    Hour = h;</span><br><span class="line">    Minute = m;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> Hour</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> hour;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个类外不能使用set方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">      hour = ((<span class="keyword">value</span>&gt;=<span class="number">0</span> &amp;&amp; <span class="keyword">value</span>&lt;<span class="number">24</span>) ? <span class="keyword">value</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> Minute</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的this引用用法称为构造函数初始化器，易维护。</p>
<h3 id="默认与无参数构造函数"><a href="#默认与无参数构造函数" class="headerlink" title="默认与无参数构造函数"></a>默认与无参数构造函数</h3><p>注意上面Time无参构造函数，显式初始化Time对象，为每个参数传递三个参数0。如果省略无参构造函数，则无法用表达式<code>new Time()</code>创建对象，会发生编译错误。</p>
<h3 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h3><p>类可以引用其他类的对象，作为成员。这个功能称为合成，也称为“有”（has-a）关系。</p>
<p>Employee类中引用其他对象</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> Date birthDate;</span><br><span class="line">  <span class="keyword">private</span> Date hireDate;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内存回收与析构函数"><a href="#内存回收与析构函数" class="headerlink" title="内存回收与析构函数"></a>内存回收与析构函数</h3><p>Garbage Collection and Destructors</p>
<p>如果管理资源的对象失去所有引用，而还没有显式释放资源，则程序不能再访问和释放这个资源。这就产生了资源泄露。</p>
<p>公共语言运行环境（CLR）进行自动内存管理，用内存回收单元（Garbage Collection）释放对象不再需要的内存，其他对象可以使用这个内存。</p>
<p>对象失去所有引用时，成为可析构对象。每个对象有个特殊成员，称为析构函数。</p>
<p>析构函数由内存回收单元调用，在内存回收单元释放对象内存之前用于进行对象的终止整理工作。</p>
<h3 id="静态类成员"><a href="#静态类成员" class="headerlink" title="静态类成员"></a>静态类成员</h3><p>static Class Members</p>
<p>某些情况下，类的所有对象要共享某个变量的一个副本。这时就要使用静态变量。静态变量表示类信息，类的所有对象共享同一数据。静态变量的作用域是类体。</p>
<ul>
<li>类的公用静态成员访问方法：<strong>类名</strong>和点号运算符<code>Math.PI</code>；</li>
<li>类的专用静态成员只能通过类的方法和属性访问。</li>
</ul>
<p>如果没有Employee类的对象，则成员count任然可以引用，弹药通过静态属性Count，如<code>Employee.Count</code>C#的字符串对象创建后不能修改。</p>
<p>声明为静态的方法不能直接访问非静态类成员，因为即使类对象不存在，也可以调用静态方法。静态方法也不能使用this引用，this引用要引用特定类对象。</p>
<h3 id="只读实例变量"><a href="#只读实例变量" class="headerlink" title="只读实例变量"></a>只读实例变量</h3><p>readonly Instance Variables</p>
<p>C#提供了readonly关键字，可以指定对象的实例变量不能修改，想修改会发生错误。</p>
<p>构造函数可以多次对readonly实例变量赋值。</p>
<p>声明为const的成员要在编译时赋值，常量成员的值不能在编译时确定要用readonly关键字声明。如果构造函数不初始化readonly声明的成员，则编译器产生一个警告。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Increment</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">int</span> INCREMENT;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Increment</span>(<span class="params"><span class="keyword">int</span> incrementValue</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    INCREMENT = incrementValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="软件复用性"><a href="#软件复用性" class="headerlink" title="软件复用性"></a>软件复用性</h3><p>Software Reusability</p>
<p>类库，快速程序开发（RAD），FCL，CLR</p>
<h3 id="数据抽象与封装"><a href="#数据抽象与封装" class="headerlink" title="数据抽象与封装"></a>数据抽象与封装</h3><p>Data Abstraction and Encapsulation</p>
<p>信息隐藏：类通常对类的客户隐藏其实现细节。</p>
<p>数据抽象：描述类的功能而不管其实现细节。</p>
<p>int、double与char类的类型，还有队列都是抽象数据类型（ADT）。抽象数据类型（ADT）实际上包含两个概念，即数据表达和该数据允许的操作。</p>
<h3 id="internal-Access"><a href="#internal-Access" class="headerlink" title="internal Access"></a>internal Access</h3><p>目前为止我们所定义的类，只能用两个访问修饰符声明：public与internal。顶级类。C#支持嵌套类——定义在其他类中的类。除了public与internal，类还可以声明为private或protected。如果类声明没有访问修饰符，默认internal访问。声明为internal的方法。实例变量和其他成员可以让同一汇编中的所有代码访问，而其他汇编中的代码则不行。同一汇编中，internal相当于public。</p>
<h3 id="Class-View-and-Object-Browser"><a href="#Class-View-and-Object-Browser" class="headerlink" title="Class View and Object Browser"></a>Class View and Object Browser</h3><p>使用Class View窗口</p>
<p>使用Object Browser</p>
<h3 id="对象初始化器"><a href="#对象初始化器" class="headerlink" title="对象初始化器"></a>对象初始化器</h3><p>Object Initializers</p>
<p>创建对象并在同一语句中将其属性初始化。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ObjectInitialzerTest</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    Time aTime = <span class="keyword">new</span> Time&#123;Hour=<span class="number">14</span>, Minutre=<span class="number">145</span>, Second=<span class="number">12</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    Time anotherTime = <span class="keyword">new</span> Time&#123;Minute=<span class="number">45</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代理delegate"><a href="#代理delegate" class="headerlink" title="代理delegate"></a>代理delegate</h3><p>代理对象保存一个方法的引用。代理可以把方法看成数据，通过代理可以将方法赋值给一个变量，将这个方法与其他方法相互传递。</p>
<p>代理类型只是描述一组具有特定参数和特定返回类型的方法。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Delegates</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 委托一个接收int并返回布尔值的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">bool</span> <span class="title">NumberPredicate</span>(<span class="params"><span class="keyword">int</span> number</span>)</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    <span class="keyword">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ,<span class="number">10</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建NumberPredicate委托类型的实例</span></span><br><span class="line">    NumberPredicate evenPredicate = IsEven;</span><br><span class="line">    </span><br><span class="line">    List&lt;<span class="keyword">int</span>&gt; evenNumbers = FilterArray(numbers, evenPredicate);</span><br><span class="line">    <span class="comment">// evenNumber: 2 4 6 8 10</span></span><br><span class="line">    </span><br><span class="line">    List&lt;<span class="keyword">int</span>&gt; oddNumbers = FilterArray(numbers, IsOdd);</span><br><span class="line">    <span class="comment">// oddNumber: 1 3 5 7 9</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> list&lt;<span class="keyword">int</span>&gt; <span class="title">FilterArray</span>(<span class="params"><span class="keyword">int</span>[] intArray, NumberPredicate predicate</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">      List&lt;<span class="keyword">int</span>&gt; result = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">      <span class="keyword">foreach</span>(<span class="keyword">int</span> item <span class="keyword">in</span> inArray)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span>(predicate(item))</span><br><span class="line">          result.Add(item);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsEven</span>(<span class="params"><span class="keyword">int</span> number</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">      <span class="keyword">return</span> (number%<span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsOdd</span>(<span class="params"><span class="keyword">int</span> number</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">      <span class="keyword">return</span> (number%<span class="number">2</span> == <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>由于IsEven方法的签名与NumberPredicate代理的签名匹配</strong>，因此可以用NumberPredicate类型的变量引用IsEven方法。</p>
<h3 id="Lambda-Expressions"><a href="#Lambda-Expressions" class="headerlink" title="Lambda Expressions"></a>Lambda Expressions</h3><p>lambda表达式首先是个参数表。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Lambda</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">bool</span> <span class="title">NumberPredicate</span>(<span class="params"><span class="keyword">int</span> number</span>)</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    <span class="keyword">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ,<span class="number">10</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    NumberPredicate evenPredicate = number =&gt; (number%<span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    evenPredicate(<span class="number">4</span>); <span class="comment">// True</span></span><br><span class="line">    </span><br><span class="line">    List&lt;<span class="keyword">int</span>&gt; evenNumbers = FilterArray(numbers, evenPredicate);</span><br><span class="line">    <span class="comment">// evenNumber: 2 4 6 8 10</span></span><br><span class="line">    </span><br><span class="line">    List&lt;<span class="keyword">int</span>&gt; oddNumbers = FilterArray(numbers, (<span class="keyword">int</span> number) =&gt; (number%<span class="number">2</span> == <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// evenNumber: 1 3 5 7 9</span></span><br><span class="line">    </span><br><span class="line">    List&lt;<span class="keyword">int</span>&gt; numberOver5 = FilterArray(numbers, number =&gt; &#123;<span class="keyword">return</span> number&gt;<span class="number">5</span>; &#125; );</span><br><span class="line">    <span class="comment">// 6 7 8 9 10</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> list&lt;<span class="keyword">int</span>&gt; <span class="title">FilterArray</span>(<span class="params"><span class="keyword">int</span>[] intArray, NumberPredicate predicate</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">      List&lt;<span class="keyword">int</span>&gt; result = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">      <span class="keyword">foreach</span>(<span class="keyword">int</span> item <span class="keyword">in</span> inArray)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span>(predicate(item))</span><br><span class="line">          result.Add(item);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数表后面是lambda运算符（=&gt;，读作go to）和一个表示函数体的表达式。</p>
<p>没有指定返回类型，返回类型可以从返回值或代理的返回值推定。</p>
<p>同样，lambda表达式定义的方法要与代理类型定义的方法有相同签名。</p>
<h3 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a>匿名类型</h3><p>Anonymous Types可以创建简单类，用于存储数据，不必编写类定义。</p>
<p>匿名类型的属性都是公用和不可变的。匿名类型是只读的，创建对象之后不能修改属性值。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Lambda</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">bool</span> <span class="title">NumberPredicate</span>(<span class="params"><span class="keyword">int</span> number</span>)</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> bob1 = <span class="keyword">new</span> &#123;Name = <span class="string">"Bob Smith"</span>, Age = <span class="number">37</span>&#125;;</span><br><span class="line">    bob.ToString(); <span class="comment">// &#123;Name = Bob Smith, Age = 37&#125;</span></span><br><span class="line">    <span class="keyword">var</span> bob2 = <span class="keyword">new</span> &#123;Name = <span class="string">"Bob Smith"</span>, Age = <span class="number">37</span>&#125;;</span><br><span class="line">    bob1.Equals(bob2); <span class="comment">// True</span></span><br><span class="line">    <span class="comment">// 两者属性值相同，声明顺序相同</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>LINQ中的匿名类型</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = </span><br><span class="line">  <span class="keyword">from</span> e <span class="keyword">in</span> employees</span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">new</span> &#123;e.FirstName, Last = e.LastName&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="课后习题-9"><a href="#课后习题-9" class="headerlink" title="课后习题"></a>课后习题</h3><h4 id="10-1-填空题"><a href="#10-1-填空题" class="headerlink" title="10.1 填空题"></a>10.1 填空题</h4><ul>
<li><strong>最低权限原则</strong>要求代码只能分配完成指定任务所需的访问量。</li>
<li>编译器将类库工程监理在所谓<strong>动态链接库</strong>的汇编中。</li>
</ul>
<h4 id="10-2-判断题"><a href="#10-2-判断题" class="headerlink" title="10.2 判断题"></a>10.2 判断题</h4><ul>
<li>lambda表达式必须返回一个值。</li>
</ul>
<h2 id="第11章-面向对象编程：继承"><a href="#第11章-面向对象编程：继承" class="headerlink" title="第11章 面向对象编程：继承"></a>第11章 面向对象编程：继承</h2><h3 id="基类和派生类"><a href="#基类和派生类" class="headerlink" title="基类和派生类"></a>基类和派生类</h3><p>Base Classes and Derived Classes</p>
<p>继承形成了树状层次结构。</p>
<p>并非每个类关系都是继承关系。“有”关系，类的成员是其他类对象的引用。</p>
<h3 id="protected成员"><a href="#protected成员" class="headerlink" title="protected成员"></a>protected成员</h3><p>protected介于公用与专用之间，基类的protected成员可以让基类成员和派生类成员访问。所有非专用基类成员在派生类中保持原访问修饰符。</p>
<h3 id="基类和派生类的关系"><a href="#基类和派生类的关系" class="headerlink" title="基类和派生类的关系"></a>基类和派生类的关系</h3><p>C#中除object以外的每个类都扩展现有类。object是唯一没有基类的类。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommissionEmployee类显式扩展（继承自）object类（FCL中的System.Object）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CommissionEmployee</span> : <span class="title">object</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数不继承，但隐式调用object类的构造函数。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseCommissionEmployee</span> : <span class="title">CommissionEmployee</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">decimal</span> baseSalary;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 构造函数初始化器和关键字base调用基类构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BaseCommissionEmployee</span>(<span class="params"><span class="keyword">string</span> name, <span class="keyword">decimal</span> sales, <span class="keyword">decimal</span> salary</span>): <span class="title">base</span>(<span class="params">name, sales</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    BaseSalary = salary;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">decimal</span> BaseSalary&#123;<span class="keyword">get</span>; <span class="keyword">set</span>&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">decimal</span> <span class="title">Earnings</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键字virtual与abstract表示派生类中可以覆盖基类方法。</p>
<p>使用父类private实例变量</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseCommissionEmployee</span> : <span class="title">CommissionEmployee</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">decimal</span> <span class="title">Earnings</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> BaseSalary + <span class="keyword">base</span>.Earnings();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="派生类的构造函数"><a href="#派生类的构造函数" class="headerlink" title="派生类的构造函数"></a>派生类的构造函数</h3><p>Constructors in Derived Classes</p>
<p>派生类构造函数在执行自己的任务之前要显示（通过base引用和构造函数初始化器）或隐式（调用基类默认构造函数或无参构造函数）调用直接基类的构造函数。链中最后一个调用的构造函数总是object类的构造函数。</p>
<h3 id="继承和软件工程"><a href="#继承和软件工程" class="headerlink" title="继承和软件工程"></a>继承和软件工程</h3><p>Software Engineering with Inheritance</p>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/CSharp/object.PNG" alt="object"></p>
<h2 id="第12章-多态、接口与运算符重载"><a href="#第12章-多态、接口与运算符重载" class="headerlink" title="第12章 多态、接口与运算符重载"></a>第12章 多态、接口与运算符重载</h2><h3 id="多态举例"><a href="#多态举例" class="headerlink" title="多态举例"></a>多态举例</h3><p>程序通过基类变量调用方法时，发生多态——执行时，根据引用对象的类型调用这个方法的正确派生类版本。</p>
<p>程序通过向下转换技术显式将基类引用转换为派生类类型，程序可以调用基类中没有的派生类方法。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PolymorphismTest</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    BaseCommissionEmployee baseCommissionEmployee = <span class="keyword">new</span> BaseCommissionEmployee(<span class="string">"Bob"</span>, <span class="number">5000</span>, <span class="number">300</span>);</span><br><span class="line">    </span><br><span class="line">    CommissionEmployee commissionEmployee = baseCommissionEmployee;</span><br><span class="line">    </span><br><span class="line">    CommissionEmployee.ToString();</span><br><span class="line">    CommissionEmployee.Earnings();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抽象类与方法"><a href="#抽象类与方法" class="headerlink" title="抽象类与方法"></a>抽象类与方法</h3><p>定义不实例化为任何对象的类，抽象类。抽象基类。</p>
<p>抽象类用关键字abstract声明。抽象类通常包含一个或几个抽象方法。</p>
<p>抽象属性声明形式如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> property</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">get</span>;</span><br><span class="line">  <span class="keyword">set</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数和静态方法不能声明为abstract。派生类不能覆盖静态方法。</p>
<p>不能实例化抽象基类的对象，但可以用抽象基类声明变量，保存这些抽象类派生的任何具体类的对象引用。程序通常用这种变量多态操纵派生类对象。可以用抽象基类名调用抽象基类中声明的静态方法。</p>
<p>as运算符进行向下转换</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employee = currentEmployee <span class="keyword">as</span> BaseCommissionEmployee;</span><br></pre></td></tr></table></figure>
<h3 id="sealed方法与类"><a href="#sealed方法与类" class="headerlink" title="sealed方法与类"></a>sealed方法与类</h3><p>基类中声明为sealed的方法不能在派生类中覆盖，声明为static和private的方法隐含sealed，因为派生类中不能覆盖（但派生类可以声明与基类中专用方法同名的新方法）。同时声明override与sealed的派生方法可以覆盖基类方法。</p>
<p>声明为sealed的类不能作为基类（不能扩展）。</p>
<h3 id="创建与使用接口"><a href="#创建与使用接口" class="headerlink" title="创建与使用接口"></a>创建与使用接口</h3><p>Creating and Using Interfaces</p>
<p>接口定义和标准化人与系统交互的方式。</p>
<p>软件对象也是通过接口通信。</p>
<p>所有接口成员隐式声明为public与abstract。</p>
<p>每个接口可以扩展一个或多个其他接口。</p>
<p>实现这个接口的具体类要声明接口中指定了签名的每个接口成员。实现接口而不实现其所有成员的类是个抽象类，要声明为abstract，每个未实现的接口成员要包含一个abstract声明。</p>
<p>和公用抽象类一样，接口通常为公用类型，因此通常在单独文件中声明，文件名与接口名相同，文件扩展名为.cs。</p>
<p><strong>声明接口IPayable</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IPayable.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPayable</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">decimal</span> <span class="title">GetPaymentAmount</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>创建Invoice类</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invoice.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Invoice</span> : <span class="title">IPayable</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">decimal</span> <span class="title">GetPaymentAmount</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>修改Employee类，实现IPayable接口</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Employee.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Employee</span> : <span class="title">IPayable</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">string</span> Name &#123;<span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>;&#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">decimal</span> <span class="title">GetPaymentAmount</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>.NET框架类库公共接口</strong></p>
<p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/CSharp/interface.PNG" alt=""></p>
<p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/CSharp/interface_next.PNG" alt="interface"></p>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>使运算符适用于类对象，这个过程称为运算符重载。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ComplexNumber.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ComplexNumber</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">double</span> Real &#123;<span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">double</span> Imaginary &#123;<span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ComplexNumber</span>(<span class="params"><span class="keyword">double</span> a, <span class="keyword">double</span> b</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    Real = a;</span><br><span class="line">    Imaginary = b;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>.Format( <span class="string">"&#123;0&#125; &#123;1&#125; &#123;2&#125;i"</span>,</span><br><span class="line">                        Real, (Imaginary &lt; <span class="number">0</span> ? <span class="string">"-"</span>:<span class="string">"+"</span>), Math.Abs(Imaginary))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ComplexNumber <span class="keyword">operator</span> +(ComplexNumber x, ComplexNumber y)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">reutrn new <span class="title">ComplexNumber</span>(<span class="params">x.Real+y.Real, x.Imaginary+y.Imaginary</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OperatorOverloading.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ComplexTest</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    ComplexNumber x, y;</span><br><span class="line">    x = <span class="keyword">new</span> ComplexNumber(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    y = <span class="keyword">new</span> ComplexNumber(<span class="number">4</span>, <span class="number">-2</span>);</span><br><span class="line">    </span><br><span class="line">    x+y; <span class="comment">// (2+4i)+(4-2i)=(6+2i)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第13章-异常处理"><a href="#第13章-异常处理" class="headerlink" title="第13章 异常处理"></a>第13章 异常处理</h2><p>异常就是程序执行期间发生的问题。</p>
<p>异常处理使应用程序能够解决异常。异常处理可实现清晰，健壮和更多容错的程序。</p>
<h3 id="异常处理概述"><a href="#异常处理概述" class="headerlink" title="异常处理概述"></a>异常处理概述</h3><p>Exception Handling Overview</p>
<p>程序员可以决定处理任何异常——所有异常，某种类型的所有异常或相关类型的所有异常。</p>
<h3 id="例子：除数为0不用异常处理"><a href="#例子：除数为0不用异常处理" class="headerlink" title="例子：除数为0不用异常处理"></a>例子：除数为0不用异常处理</h3><p>其他信息（称为堆栈跟踪）显示异常名称和导致异常的执行路径。</p>
<p>堆栈跟踪中的每一行“ at”都表示发生异常时正在执行的特定方法中的一行代码。该信息说明异常的起源，以及达到该点之前进行了哪些方法调用。</p>
<p>当Convert方法ToInt32接收到不代表有效整数的字符串时，将发生<code>FormatException</code>。即使发生异常并且已打印堆栈跟踪，程序也可能继续执行。在这种情况下，应用程序可能会产生错误的结果。</p>
<h3 id="使用异常处理"><a href="#使用异常处理" class="headerlink" title="使用异常处理"></a>使用异常处理</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DivideByZeroTest.cs</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DivideByZeroTest</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">DivideByZeroTestForm</span> : <span class="title">Form</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DivideByZeroTestForm</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">      InitializeComponent();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从用户那里获得2个整数</span></span><br><span class="line">    <span class="comment">// 将分子除以分母</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">divideButton_click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">      outputLabel.Text = <span class="string">""</span>; <span class="comment">// 清除标签OutputLabel</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">int</span> numerator = Convert.ToInt32( numeratorTextBox.Text );</span><br><span class="line">        <span class="keyword">int</span> denominator = Convert.ToInt32( denominatorTextBox.Text );</span><br><span class="line">        <span class="keyword">int</span> result = numerator / denominator;</span><br><span class="line">        outputLabel.Text = result.ToString();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span>(FormatException)</span><br><span class="line">      &#123;</span><br><span class="line">        	MessageBox.Show( <span class="string">"You must enter two integers."</span>,</span><br><span class="line">                          <span class="string">"Invalid Number Format"</span>, MessageBoxButtons.OK,</span><br><span class="line">                          MessageBoxIcon.Error );                                   </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> ( DivideByZeroException divideByZeroExceptionParameter )</span><br><span class="line">      &#123;</span><br><span class="line">        	MessageBox.Show( divideByZeroExceptionParameter.Message,</span><br><span class="line">                          <span class="string">"Attempted to Divide by Zero"</span>, MessageBoxButtons.OK,</span><br><span class="line">                          MessageBoxIcon.Error );                                  </span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/CSharp/divide.PNG" alt="DivideByZeroTest.cs"></p>
<p>另一种有效的方法：</p>
<p><code>Int32.TryParse</code>方法将字符串转换为int值。该方法需要两个参数-一个是要解析的字符串，另一个是要将转换后的值存储在其中的变量。如果成功解析了字符串，则该方法返回true。如果无法转换字符串，则将值0分配给第二个参数。</p>
<p><strong>Enclosing Code in a try Block（用try块界定代码）</strong></p>
<p>try块包含可能引发异常的代码以及发生异常时被跳过的代码。</p>
<p>catch块至多只能有一个参数。</p>
<p><strong>Catching Exceptions（捕获异常）</strong></p>
<p>当try块中发生异常时，相应的catch块将捕获该异常并进行处理。一个try块之后必须至少有一个catch块。catch块指定一个异常参数，该参数表示catch块可以处理的异常。catch块也可以不指定异常类型或标识符，这种catch块（称为通用catch子句），捕获所有异常类型。</p>
<p><strong>未捕获异常</strong></p>
<p>未捕获的异常（或未处理的异常）是没有匹配的catch块的异常。</p>
<p><strong>Termination Model of Exception Handling（异常处理的终止模型）</strong></p>
<p>当程序或CLR中调用的方法检测到问题时，该方法或CLR会引发异常。发生异常的点称为抛出点。如果try块中发生异常，则try块立即终止，程序控制将立即转移到后面第一个异常参数类型与所有抛出类型匹配的catch块中。处理异常后，程序控制在最后一个catch块之后恢复。这称为异常处理的终止模型</p>
<h3 id="NET-Exception层次"><a href="#NET-Exception层次" class="headerlink" title=".NET Exception层次"></a>.NET Exception层次</h3><p>C#中的异常处理机制只能抛出和捕获Exception类（命名空间System）及其派生类的对象。</p>
<p>其他.NET语言（如C++）引发的异常可以通过常规catch子句捕获。</p>
<p><strong>SystemException类</strong></p>
<p>Exception类是.NET异常类层次结构的基类。从Exception派生的一个最重要的类是SystemException。CLR产生SystemException，可以在程序执行期间的任何时候发生。</p>
<p>如果程序尝试访问超出范围的数组索引，则CLR会引发IndexOutOfRangeException类型的异常。尝试使用空引用会导致NullReferenceException。</p>
<p>catch块可以使用基类类型来捕获相关异常的层次结构。指定异常类型参数的catch块可以捕获所有异常。仅当基类和所有派生类的处理行为相同时，此技术才有意义。</p>
<p><strong>确定方法抛出什么异常（Determining Which Exceptions a Method Throws）</strong></p>
<h3 id="finally块"><a href="#finally块" class="headerlink" title="finally块"></a>finally块</h3><p>程序经常动态地请求和释放资源。操作系统通常会阻止多个程序处理文件。因此，该程序应关闭文件（即释放资源），以便其他程序可以使用它。如果未关闭文件，则会发生资源泄漏。</p>
<p>处理资源时经常会发生异常。无论程序是否遇到异常，该程序都应在不再需要该文件时将其关闭。<strong>C#提供了finally块，无论是否发生异常，该块都可以保证执行</strong>。<br>这使得finally块非常适合从相应的try块中释放资源。</p>
<p>try块中的局部变量无法在相应的finally块中访问，因此必须在try块之前声明必须在两者中访问的变量。</p>
<p><strong>using语句</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span>(ExampleObject e = <span class="keyword">new</span> ExampleObject())</span><br><span class="line">&#123;</span><br><span class="line">  e.SomeMethod&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以简化取得资源、在try块中使用资源和在相应finally中释放资源的代码。文件处理程序，保证文件不再使用时正确关闭。</p>
<p>using语句代码等效于</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ExampleObject e = <span class="keyword">new</span> ExampleObject();</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    e.SomeMethod();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( e != <span class="literal">null</span> )</span><br><span class="line">      ( ( IDisposable ) e ).Dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Exception Properties</strong></p>
<p>类Exception的属性用于制定错误消息，指示捕获到的异常。属性Message存储与Exception对象关联的错误消息。属性StackTrace包含一个表示方法调用堆栈的字符串</p>
<p>发生异常时，程序员可能会使用其他错误消息或指示新的异常类型。原始异常对象存储在InnerException属性中。</p>
<p><strong>类异常提供其他属性：</strong></p>
<ul>
<li>HelpLink指定描述问题的帮助文件的位置。</li>
<li>Source指定引起异常的应用程序或对象的名称。</li>
<li>TargetSite指定异常发生的方法。</li>
</ul>
<p>最近调用的方法出现在堆栈的顶部。第一种方法（Main）出现在底部。</p>
<p>StackTrace表示抛出点处方法调用堆栈的状态。内部异常信息包括内部异常堆栈跟踪。</p>
<h3 id="用户定义异常类（User-Defined-Exception-Classes）"><a href="#用户定义异常类（User-Defined-Exception-Classes）" class="headerlink" title="用户定义异常类（User-Defined Exception Classes）"></a>用户定义异常类（User-Defined Exception Classes）</h3><p>用户定义的异常类应直接或间接从名称空间System的Exception类派生。</p>
<p>用户定义的异常应定义三个构造函数：</p>
<ul>
<li>无参数构造函数</li>
<li>接收字符串参数的构造函数（错误消息）</li>
<li>接收字符串参数和Exception参数的构造函数（错误消息和内部异常对象）</li>
</ul>
<h2 id="第14章-图形用户界面概念：第一部分"><a href="#第14章-图形用户界面概念：第一部分" class="headerlink" title="第14章 图形用户界面概念：第一部分"></a>第14章 图形用户界面概念：第一部分</h2><p>图形用户界面（GUI）允许用户在视觉上与程序进行交互。</p>
<p>GUI控件是可以在屏幕上显示信息或使用户能够与应用程序交互的对象。</p>
<p><img src="https://gitee.com/mysteryguest/ObjectStorage/raw/master/CSharp/controller.PNG" alt="controller"></p>
<h3 id="Windows-Forms"><a href="#Windows-Forms" class="headerlink" title="Windows Forms"></a>Windows Forms</h3><p>Form是出现在计算机桌面上的图形元素； 它可以是对话框，窗口或MDI窗口。组件是实现IComponent接口的类的实例，该接口定义了组件必须实现的行为，例如如何加载组件。诸如按钮或标签的控件在运行时具有图形表示。</p>
</div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E7%A7%AF%E7%B4%AF/">积累</a></div><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_dd" href="https://www.addtoany.com/share"></a><a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_telegram"></a><a class="a2a_button_whatsapp"></a><a class="a2a_button_reddit"></a></div><script src="https://static.addtoany.com/menu/page.js" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/donate/alipay.jpg" alt="支付宝"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/donate/wechatpay.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/Spring/33482.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">SpringBoot与数据访问</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Spring/36445.html"><span class="level-item">Spring Boot与Docker</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            appId: "vucxC0bltE95lsPGxGXlUJBf-gzGzoHsz",
            appKey: "YgRn5inwLxs6B4VgyLp4zvti",
            placeholder: "ヾﾉ≧∀≦)o快来评论一下吧!",
            avatar: "mm",
            
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            
            highlight: true,
            
            
            
            
            
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/shadow.jpg" alt="肖梦杰"></figure><p class="title is-size-4 is-block line-height-inherit">肖梦杰</p><p class="is-size-6 is-block">MysticalGuest</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Xiangyang City, Hubei Province, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">59</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">16</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/MysticalGuest" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/MysticalGuest"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="QQ" href="https://user.qzone.qq.com/1317148109/main"><i class="fab fa-qq"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://weibo.com/MysticalGuest"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:etherealsymbol@gmail.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#第1章-计算机、Internet与Visual-C-简介"><span class="mr-2">1</span><span>第1章 计算机、Internet与Visual C#简介</span></a><ul class="menu-list"><li><a class="is-flex" href="#课后习题"><span class="mr-2">1.1</span><span>课后习题</span></a><ul class="menu-list"><li><a class="is-flex" href="#1-1-填空题"><span class="mr-2">1.1.1</span><span>1.1 填空题</span></a></li><li><a class="is-flex" href="#2-2-判断题（更正过的）"><span class="mr-2">1.1.2</span><span>2.2 判断题（更正过的）</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#第2章-Visual-C-2008-Express简介"><span class="mr-2">2</span><span>第2章 Visual C# 2008 Express简介</span></a><ul class="menu-list"><li><a class="is-flex" href="#课后习题-1"><span class="mr-2">2.1</span><span>课后习题</span></a><ul class="menu-list"><li><a class="is-flex" href="#2-1-填空题"><span class="mr-2">2.1.1</span><span>2.1 填空题</span></a></li><li><a class="is-flex" href="#2-2-判断题（更正过的）-1"><span class="mr-2">2.1.2</span><span>2.2 判断题（更正过的）</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#第3章-C-程序简介"><span class="mr-2">3</span><span>第3章 C#程序简介</span></a><ul class="menu-list"><li><a class="is-flex" href="#课后习题-2"><span class="mr-2">3.1</span><span>课后习题</span></a><ul class="menu-list"><li><a class="is-flex" href="#3-1-填空题"><span class="mr-2">3.1.1</span><span>3.1 填空题</span></a></li><li><a class="is-flex" href="#3-2-判断题（更正过的）"><span class="mr-2">3.1.2</span><span>3.2 判断题（更正过的）</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#第4章-类与对象简介"><span class="mr-2">4</span><span>第4章 类与对象简介</span></a><ul class="menu-list"><li><a class="is-flex" href="#关于using指令"><span class="mr-2">4.1</span><span>关于using指令</span></a></li><li><a class="is-flex" href="#GradeBook类带实例变量与属性"><span class="mr-2">4.2</span><span>GradeBook类带实例变量与属性</span></a></li><li><a class="is-flex" href="#访问修饰符public与private"><span class="mr-2">4.3</span><span>访问修饰符public与private</span></a></li><li><a class="is-flex" href="#设置与读取专用实例变量、属性"><span class="mr-2">4.4</span><span>设置与读取专用实例变量、属性</span></a></li><li><a class="is-flex" href="#get和set访问方法"><span class="mr-2">4.5</span><span>get和set访问方法</span></a></li><li><a class="is-flex" href="#值类型与引用类型"><span class="mr-2">4.6</span><span>值类型与引用类型</span></a></li><li><a class="is-flex" href="#用构造函数初始化对象"><span class="mr-2">4.7</span><span>用构造函数初始化对象</span></a></li><li><a class="is-flex" href="#浮点数与decimal类型"><span class="mr-2">4.8</span><span>浮点数与decimal类型</span></a></li><li><a class="is-flex" href="#课后习题-3"><span class="mr-2">4.9</span><span>课后习题</span></a><ul class="menu-list"><li><a class="is-flex" href="#4-1-填空题"><span class="mr-2">4.9.1</span><span>4.1 填空题</span></a></li><li><a class="is-flex" href="#4-2-判断题"><span class="mr-2">4.9.2</span><span>4.2 判断题</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#第5章-控制语句：第一部分"><span class="mr-2">5</span><span>第5章 控制语句：第一部分</span></a><ul class="menu-list"><li><a class="is-flex" href="#算法"><span class="mr-2">5.1</span><span>算法</span></a></li><li><a class="is-flex" href="#伪代码"><span class="mr-2">5.2</span><span>伪代码</span></a></li><li><a class="is-flex" href="#控制结构"><span class="mr-2">5.3</span><span>控制结构</span></a></li><li><a class="is-flex" href="#课后习题-4"><span class="mr-2">5.4</span><span>课后习题</span></a><ul class="menu-list"><li><a class="is-flex" href="#5-1-填空题"><span class="mr-2">5.4.1</span><span>5.1 填空题</span></a></li><li><a class="is-flex" href="#5-2-判断题"><span class="mr-2">5.4.2</span><span>5.2 判断题</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#第6章-控制语句：第二部分"><span class="mr-2">6</span><span>第6章 控制语句：第二部分</span></a><ul class="menu-list"><li><a class="is-flex" href="#逻辑运算符"><span class="mr-2">6.1</span><span>逻辑运算符</span></a></li><li><a class="is-flex" href="#课后习题-5"><span class="mr-2">6.2</span><span>课后习题</span></a><ul class="menu-list"><li><a class="is-flex" href="#6-1-填空题"><span class="mr-2">6.2.1</span><span>6.1 填空题</span></a></li><li><a class="is-flex" href="#6-2-判断题"><span class="mr-2">6.2.2</span><span>6.2 判断题</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#第7章-方法详述"><span class="mr-2">7</span><span>第7章 方法详述</span></a><ul class="menu-list"><li><a class="is-flex" href="#C-代码包装"><span class="mr-2">7.1</span><span>C#代码包装</span></a></li><li><a class="is-flex" href="#静态方法，静态变量和Math类"><span class="mr-2">7.2</span><span>静态方法，静态变量和Math类</span></a></li><li><a class="is-flex" href="#关于方法的声明与使用"><span class="mr-2">7.3</span><span>关于方法的声明与使用</span></a></li><li><a class="is-flex" href="#方法调用堆栈云激活记录"><span class="mr-2">7.4</span><span>方法调用堆栈云激活记录</span></a></li><li><a class="is-flex" href="#变元提升与类型转换"><span class="mr-2">7.5</span><span>变元提升与类型转换</span></a></li><li><a class="is-flex" href="#NET框架类库"><span class="mr-2">7.6</span><span>.NET框架类库</span></a></li><li><a class="is-flex" href="#随机数生成"><span class="mr-2">7.7</span><span>随机数生成</span></a></li><li><a class="is-flex" href="#比例缩放与移动随机数"><span class="mr-2">7.8</span><span>比例缩放与移动随机数</span></a></li><li><a class="is-flex" href="#随机数可重复性与测试-调试"><span class="mr-2">7.9</span><span>随机数可重复性与测试/调试</span></a></li><li><a class="is-flex" href="#案例"><span class="mr-2">7.10</span><span>案例</span></a></li><li><a class="is-flex" href="#声明作用域"><span class="mr-2">7.11</span><span>声明作用域</span></a></li><li><a class="is-flex" href="#方法重载"><span class="mr-2">7.12</span><span>方法重载</span></a></li><li><a class="is-flex" href="#递归"><span class="mr-2">7.13</span><span>递归</span></a></li><li><a class="is-flex" href="#按值与按引用传递变元"><span class="mr-2">7.14</span><span>按值与按引用传递变元</span></a></li><li><a class="is-flex" href="#课后习题-6"><span class="mr-2">7.15</span><span>课后习题</span></a><ul class="menu-list"><li><a class="is-flex" href="#7-1-填空题"><span class="mr-2">7.15.1</span><span>7.1 填空题</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#第8章-数组"><span class="mr-2">8</span><span>第8章 数组</span></a><ul class="menu-list"><li><a class="is-flex" href="#多维数组"><span class="mr-2">8.1</span><span>多维数组</span></a></li><li><a class="is-flex" href="#课后习题-7"><span class="mr-2">8.2</span><span>课后习题</span></a><ul class="menu-list"><li><a class="is-flex" href="#8-1-填空题"><span class="mr-2">8.2.1</span><span>8.1 填空题</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#第9章-LINQ与泛型集合简介"><span class="mr-2">9</span><span>第9章 LINQ与泛型集合简介</span></a><ul class="menu-list"><li><a class="is-flex" href="#集合简介"><span class="mr-2">9.1</span><span>集合简介</span></a></li><li><a class="is-flex" href="#用LINQ查询泛型集合"><span class="mr-2">9.2</span><span>用LINQ查询泛型集合</span></a></li><li><a class="is-flex" href="#课后习题-8"><span class="mr-2">9.3</span><span>课后习题</span></a><ul class="menu-list"><li><a class="is-flex" href="#9-1-填空题"><span class="mr-2">9.3.1</span><span>9.1 填空题</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#第10章-再论类与对象"><span class="mr-2">10</span><span>第10章 再论类与对象</span></a><ul class="menu-list"><li><a class="is-flex" href="#用this引用访问当前对象成员"><span class="mr-2">10.1</span><span>用this引用访问当前对象成员</span></a></li><li><a class="is-flex" href="#索引器"><span class="mr-2">10.2</span><span>索引器</span></a></li><li><a class="is-flex" href="#重载构造函数"><span class="mr-2">10.3</span><span>重载构造函数</span></a></li><li><a class="is-flex" href="#默认与无参数构造函数"><span class="mr-2">10.4</span><span>默认与无参数构造函数</span></a></li><li><a class="is-flex" href="#合成"><span class="mr-2">10.5</span><span>合成</span></a></li><li><a class="is-flex" href="#内存回收与析构函数"><span class="mr-2">10.6</span><span>内存回收与析构函数</span></a></li><li><a class="is-flex" href="#静态类成员"><span class="mr-2">10.7</span><span>静态类成员</span></a></li><li><a class="is-flex" href="#只读实例变量"><span class="mr-2">10.8</span><span>只读实例变量</span></a></li><li><a class="is-flex" href="#软件复用性"><span class="mr-2">10.9</span><span>软件复用性</span></a></li><li><a class="is-flex" href="#数据抽象与封装"><span class="mr-2">10.10</span><span>数据抽象与封装</span></a></li><li><a class="is-flex" href="#internal-Access"><span class="mr-2">10.11</span><span>internal Access</span></a></li><li><a class="is-flex" href="#Class-View-and-Object-Browser"><span class="mr-2">10.12</span><span>Class View and Object Browser</span></a></li><li><a class="is-flex" href="#对象初始化器"><span class="mr-2">10.13</span><span>对象初始化器</span></a></li><li><a class="is-flex" href="#代理delegate"><span class="mr-2">10.14</span><span>代理delegate</span></a></li><li><a class="is-flex" href="#Lambda-Expressions"><span class="mr-2">10.15</span><span>Lambda Expressions</span></a></li><li><a class="is-flex" href="#匿名类型"><span class="mr-2">10.16</span><span>匿名类型</span></a></li><li><a class="is-flex" href="#课后习题-9"><span class="mr-2">10.17</span><span>课后习题</span></a><ul class="menu-list"><li><a class="is-flex" href="#10-1-填空题"><span class="mr-2">10.17.1</span><span>10.1 填空题</span></a></li><li><a class="is-flex" href="#10-2-判断题"><span class="mr-2">10.17.2</span><span>10.2 判断题</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#第11章-面向对象编程：继承"><span class="mr-2">11</span><span>第11章 面向对象编程：继承</span></a><ul class="menu-list"><li><a class="is-flex" href="#基类和派生类"><span class="mr-2">11.1</span><span>基类和派生类</span></a></li><li><a class="is-flex" href="#protected成员"><span class="mr-2">11.2</span><span>protected成员</span></a></li><li><a class="is-flex" href="#基类和派生类的关系"><span class="mr-2">11.3</span><span>基类和派生类的关系</span></a></li><li><a class="is-flex" href="#派生类的构造函数"><span class="mr-2">11.4</span><span>派生类的构造函数</span></a></li><li><a class="is-flex" href="#继承和软件工程"><span class="mr-2">11.5</span><span>继承和软件工程</span></a></li><li><a class="is-flex" href="#Object类"><span class="mr-2">11.6</span><span>Object类</span></a></li></ul></li><li><a class="is-flex" href="#第12章-多态、接口与运算符重载"><span class="mr-2">12</span><span>第12章 多态、接口与运算符重载</span></a><ul class="menu-list"><li><a class="is-flex" href="#多态举例"><span class="mr-2">12.1</span><span>多态举例</span></a></li><li><a class="is-flex" href="#抽象类与方法"><span class="mr-2">12.2</span><span>抽象类与方法</span></a></li><li><a class="is-flex" href="#sealed方法与类"><span class="mr-2">12.3</span><span>sealed方法与类</span></a></li><li><a class="is-flex" href="#创建与使用接口"><span class="mr-2">12.4</span><span>创建与使用接口</span></a></li><li><a class="is-flex" href="#运算符重载"><span class="mr-2">12.5</span><span>运算符重载</span></a></li></ul></li><li><a class="is-flex" href="#第13章-异常处理"><span class="mr-2">13</span><span>第13章 异常处理</span></a><ul class="menu-list"><li><a class="is-flex" href="#异常处理概述"><span class="mr-2">13.1</span><span>异常处理概述</span></a></li><li><a class="is-flex" href="#例子：除数为0不用异常处理"><span class="mr-2">13.2</span><span>例子：除数为0不用异常处理</span></a></li><li><a class="is-flex" href="#使用异常处理"><span class="mr-2">13.3</span><span>使用异常处理</span></a></li><li><a class="is-flex" href="#NET-Exception层次"><span class="mr-2">13.4</span><span>.NET Exception层次</span></a></li><li><a class="is-flex" href="#finally块"><span class="mr-2">13.5</span><span>finally块</span></a></li><li><a class="is-flex" href="#用户定义异常类（User-Defined-Exception-Classes）"><span class="mr-2">13.6</span><span>用户定义异常类（User-Defined Exception Classes）</span></a></li></ul></li><li><a class="is-flex" href="#第14章-图形用户界面概念：第一部分"><span class="mr-2">14</span><span>第14章 图形用户界面概念：第一部分</span></a><ul class="menu-list"><li><a class="is-flex" href="#Windows-Forms"><span class="mr-2">14.1</span><span>Windows Forms</span></a></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://spring.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Spring</span></span><span class="level-right"><span class="level-item tag">spring.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://redis.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Redis</span></span><span class="level-right"><span class="level-item tag">redis.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://docker.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Docker</span></span><span class="level-right"><span class="level-item tag">docker.com</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Axios/"><span class="level-start"><span class="level-item">Axios</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/C/"><span class="level-start"><span class="level-item">C</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CSharp/"><span class="level-start"><span class="level-item">CSharp</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/ElasticSearch/"><span class="level-start"><span class="level-item">ElasticSearch</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Electron-Vue/"><span class="level-start"><span class="level-item">Electron-Vue</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Element-UI/"><span class="level-start"><span class="level-item">Element-UI</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/GitHub/"><span class="level-start"><span class="level-item">GitHub</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Hexo/"><span class="level-start"><span class="level-item">Hexo</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Interview/"><span class="level-start"><span class="level-item">Interview</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/OS/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Study/"><span class="level-start"><span class="level-item">Study</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/TypeScript/"><span class="level-start"><span class="level-item">TypeScript</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/English/"><span class="tag">English</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%BB%E9%A2%98/"><span class="tag">主题</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%89%8D%E7%AB%AF/"><span class="tag">前端</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8E%9F%E7%90%86/"><span class="tag">原理</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%8D%E8%AF%95/"><span class="tag">复试</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"><span class="tag">搜索引擎</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">数据库</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%A1%E6%8B%9B/"><span class="tag">校招</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A1%86%E6%9E%B6/"><span class="tag">框架</span><span class="tag is-grey-lightest">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A7%AF%E7%B4%AF/"><span class="tag">积累</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag is-grey-lightest">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%80%83%E7%A0%94/"><span class="tag">考研</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"><span class="tag">计算机基础</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BE%E7%A8%8B/"><span class="tag">课程</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%85%8D%E7%BD%AE/"><span class="tag">配置</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/"><span class="tag">面试题集</span><span class="tag is-grey-lightest">2</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/mylogo.svg" alt="Longing(MysteryGuest的博客)" height="28"></a><p class="size-small"><span>&copy; 2021 MysticalGuest</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener nofollow">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener nofollow">Icarus</a><br><br><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><span><script>	var now = new Date();	function createtime() {		var grt= new Date("4/2/2020 08:00:00");		now.setTime(now.getTime()+250);		days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 		hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 		if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 		mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 		seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 		snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 		document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 		document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";	}	setInterval("createtime()",250);</script></span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/MysticalGuest"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://mysticalguest.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="/js/click.js"></script><script src="/js/anime.min.js"></script><canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"></canvas><script src="/js/snow.js"></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>