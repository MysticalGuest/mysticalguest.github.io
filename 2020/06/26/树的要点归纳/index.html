<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>树的要点归纳 | Longing(MysteryGuest的博客)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="数据结构第六章要点归纳">
<meta property="og:type" content="article">
<meta property="og:title" content="树的要点归纳">
<meta property="og:url" content="http://yoursite.com/2020/06/26/%E6%A0%91%E7%9A%84%E8%A6%81%E7%82%B9%E5%BD%92%E7%BA%B3/index.html">
<meta property="og:site_name" content="Longing(MysteryGuest的博客)">
<meta property="og:description" content="数据结构第六章要点归纳">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-06-26T13:02:31.007Z">
<meta property="article:modified_time" content="2020-07-01T01:54:38.271Z">
<meta property="article:author" content="MysticalGuest">
<meta property="article:tag" content="C">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Longing(MysteryGuest的博客)" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Longing(MysteryGuest的博客)</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">MysticalGuest Blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-树的要点归纳" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/26/%E6%A0%91%E7%9A%84%E8%A6%81%E7%82%B9%E5%BD%92%E7%BA%B3/" class="article-date">
  <time datetime="2020-06-26T13:02:31.007Z" itemprop="datePublished">2020-06-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      树的要点归纳
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>
    <em>数据结构第六章要点归纳</em>
</p>

<a id="more"></a>
<h1 id="1-树的基础知识点"><a href="#1-树的基础知识点" class="headerlink" title="1.树的基础知识点"></a>1.树的基础知识点</h1><h2 id="1-1-树的相关概念"><a href="#1-1-树的相关概念" class="headerlink" title="1.1 树的相关概念"></a>1.1 树的相关概念</h2><ul>
<li><p>结点拥有的子树数称为节点的<strong>度</strong>（Degree）。</p>
</li>
<li><p>度为0的结点称为<strong>叶结点</strong>（Leaf）或<strong>终端结点</strong>；度不为0的结点称为<strong>非终端结点</strong>或<strong>分支节点</strong>。</p>
</li>
<li><p>除根节点之外，分支节点也称为<strong>内部结点</strong>。</p>
</li>
<li><p>树的度是树内部各结点的度的最大值。</p>
</li>
<li><p>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为<strong>有序树</strong>，否则称为<strong>无序树</strong>。</p>
</li>
<li><p><strong>森林</strong>是$m(m \geq 0)$棵互不相交的树的集合。</p>
</li>
</ul>
<h2 id="1-2-树的存储结构"><a href="#1-2-树的存储结构" class="headerlink" title="1.2 树的存储结构"></a>1.2 树的存储结构</h2><ul>
<li><p>双亲表示法</p>
</li>
<li><p>孩子表示法</p>
</li>
<li><p>孩子兄弟表示法</p>
</li>
</ul>
<h2 id="1-3-二叉树的相关概念"><a href="#1-3-二叉树的相关概念" class="headerlink" title="1.3 二叉树的相关概念"></a>1.3 二叉树的相关概念</h2><ul>
<li><p><strong>斜树</strong>：所有的结点都只有左子树的二叉树叫左斜树。所有结点都只有右子树的二叉树叫右斜树。这二者统称为斜树。</p>
</li>
<li><p><strong>满二叉树</strong>：在一颗二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。</p>
</li>
<li><p><strong>完全二叉树</strong>：对一棵具有n个结点的二叉树按层序编号，如果编号为$i(1 \leq i \leq n)$的节点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。</p>
</li>
</ul>
<ul>
<li>完全二叉树的特点：</li>
</ul>
<p>​    （1）叶子结点只能出现在最下两层。</p>
<p>​    （2）最下层的叶子一定集中在左部连续位置。</p>
<p>​    （3）倒数二层，若有叶子结点，一定都在右部连续位置。</p>
<p>​    （4）如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况。</p>
<p>​    （5）同样结点数的二叉树，完全二叉树的深度最小。</p>
<h2 id="1-4-二叉树的存储结构"><a href="#1-4-二叉树的存储结构" class="headerlink" title="1.4 二叉树的存储结构"></a>1.4 二叉树的存储结构</h2><ul>
<li><p>顺序存储结构</p>
</li>
<li><p>二叉链表</p>
</li>
</ul>
<h1 id="2-二叉树5个基本性质及灵活应用"><a href="#2-二叉树5个基本性质及灵活应用" class="headerlink" title="2.二叉树5个基本性质及灵活应用"></a>2.二叉树5个基本性质及灵活应用</h1><blockquote>
<p><strong>二叉树的定义：二叉树(Binary Tree)是n(n≥0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根节点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</strong></p>
</blockquote>
<h2 id="2-1-性质1"><a href="#2-1-性质1" class="headerlink" title="2.1 性质1"></a>2.1 性质1</h2><p>在二叉树的第i层上至多有$2^{i-1}$个结点（$i \geq 1$）。</p>
<h2 id="2-2-性质2"><a href="#2-2-性质2" class="headerlink" title="2.2 性质2"></a>2.2 性质2</h2><p>深度为k的二叉树至多有$2^k-1$个结点（$k \geq1$）。</p>
<h2 id="2-3-性质3"><a href="#2-3-性质3" class="headerlink" title="2.3 性质3"></a>2.3 性质3</h2><p>对任何一棵二叉树T，如果其终端结点数为$n_0$，度为2的结点数为$n_2$，则$n_0=n_2+1$。</p>
<h2 id="2-4-性质4"><a href="#2-4-性质4" class="headerlink" title="2.4 性质4"></a>2.4 性质4</h2><p>具有n个结点的完全二叉树的深度为$\lfloor log_2{n} \rfloor +1$ （$\lfloor x \rfloor$表示不大于x的最大整数）。</p>
<h2 id="2-5-性质5"><a href="#2-5-性质5" class="headerlink" title="2.5 性质5"></a>2.5 性质5</h2><p>如果对一棵有$n$个结点的完全二叉树（其深度为$\lfloor log_2{n} \rfloor +1$）的结点按层序编号（从第1层到第$\lfloor log_2{n} \rfloor+1$层，每层从左到右），对任一结点$i(1 \leq i \leq n)$有：</p>
<ol>
<li>如果$i=1$，则节点$i$是二叉树的根，无双亲；如果$i \geq 1$，则其双亲是节点$\lfloor \frac{i}{2} \rfloor$。</li>
<li>如果$2i &gt; n$，则结点$i$无左孩子（结点i为叶子节点）；否则其左孩子是结点$2i$。</li>
<li>如果$2i+1 &gt; n$，则结点$i$无右孩子；否则其右孩子是结点$2i+1$。</li>
</ol>
<h1 id="3-二叉树遍历（基础知识掌握）"><a href="#3-二叉树遍历（基础知识掌握）" class="headerlink" title="3.二叉树遍历（基础知识掌握）"></a>3.二叉树遍历（基础知识掌握）</h1><blockquote>
<p><strong>二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。</strong></p>
</blockquote>
<h2 id="3-1-前、中、后序遍历"><a href="#3-1-前、中、后序遍历" class="headerlink" title="3.1 前、中、后序遍历"></a>3.1 前、中、后序遍历</h2><h2 id="3-2-二叉树的建立"><a href="#3-2-二叉树的建立" class="headerlink" title="3.2 二叉树的建立"></a>3.2 二叉树的建立</h2><h2 id="3-3-线索二叉树"><a href="#3-3-线索二叉树" class="headerlink" title="3.3 线索二叉树"></a>3.3 线索二叉树</h2><p>3.3.1 对于一个有$n$个结点的二叉链表，每个结点有指向左右孩子的两个指针域，所以一共是$2n$个指针域。而$n$个结点的二叉树一共有$n-1$条分支线数，也就是说，其实是存在$2n-(n-1) =n+1$个空指针域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">       A</span><br><span class="line">     &#x2F;   \</span><br><span class="line">    B     C</span><br><span class="line">   &#x2F; \   &#x2F; \</span><br><span class="line">  D   E F   G</span><br><span class="line"> &#x2F; \ &#x2F;</span><br><span class="line">H  I J </span><br><span class="line">     图3-1</span><br></pre></td></tr></table></figure>
<p>3.3.2 如上图，中序遍历得到<code>HDIBJEAFCG</code>这样的字符，可以知道，结点I的前驱是D，后继是B，结点F的前驱是A，后继是C。</p>
<p>3.3.3 指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为<strong>线索二叉树</strong>(Threaded Binary Tree)。</p>
<p>3.3.4 其实线索二叉树，等于是把一棵二叉树转变成了一个<strong>双向链表</strong>，这样对我们的插入删除结点都带来了方便。</p>
<p>3.3.5 对二叉树以某种次序遍历使其变为线索二叉树的过程称做是<strong>线索化</strong>。</p>
<p>3.3.6 在每个节点再增设两个标志域ltag和rtag，只存放0或1数字的布尔型变量，其占用的内存空间要小于像lchild和rchild的指针变量。结点结构如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">lchild</td>
<td style="text-align:center">ltag</td>
<td style="text-align:center">data</td>
<td style="text-align:center">rtag</td>
<td style="text-align:center">rchild</td>
</tr>
</tbody>
</table>
</div>
<p>其中：</p>
<ul>
<li>ltag为0时指向该结点的左孩子，为1时指向该结点的前驱。</li>
<li>rtag为0时指向该结点的右孩子，为1时指向该结点的后继。</li>
<li>因此对于图3-1的二叉链表图可以修改为图3-2的样子。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">          0A0</span><br><span class="line">       &#x2F;       \</span><br><span class="line">     0B0       0C0</span><br><span class="line">    &#x2F;   \     &#x2F;   \</span><br><span class="line">  0D0   0E1 1F1   1G1</span><br><span class="line">  &#x2F; \    &#x2F;</span><br><span class="line">1H1 1I1 1J1 </span><br><span class="line">         图3-2</span><br></pre></td></tr></table></figure>
<h2 id="3-4-线索二叉树结构实现"><a href="#3-4-线索二叉树结构实现" class="headerlink" title="3.4 线索二叉树结构实现"></a>3.4 线索二叉树结构实现</h2><ul>
<li>线索化的过程就是在遍历的过程中修改空指针的过程。</li>
</ul>
<ul>
<li>中序遍历线索化的递归函数代码如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BiThrTree pre;	<span class="comment">/* 全局变量，始终指向刚刚访问过的节点 */</span></span><br><span class="line"><span class="comment">/* 中序遍历进行中序线索化 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p)&#123;</span><br><span class="line">    InThreading(p-&gt;lchild); <span class="comment">/* 递归左子树线索化 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!p-&gt;lchild)&#123;				<span class="comment">/* 没有左孩子 */</span></span><br><span class="line">      p-&gt;LTag=Thread;				<span class="comment">/* 前驱线索 */</span></span><br><span class="line">      p-&gt;lchild=pre;				<span class="comment">/* 左孩子指针指向前驱 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!pre-&gt;rchild)&#123;				<span class="comment">/* 前驱没有右孩子 */</span></span><br><span class="line">      p-&gt;RTag=Thread;				<span class="comment">/* 后继线索 */</span></span><br><span class="line">      p-&gt;rchild=p;				<span class="comment">/* 前驱右孩子指针指向后继（当前结点p） */</span></span><br><span class="line">    &#125;</span><br><span class="line">    pre=p;		<span class="comment">/* 保持pre指向p的前驱 */</span></span><br><span class="line">    </span><br><span class="line">    InThreading(p-&gt;rchild); <span class="comment">/* 递归右子树线索化 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>有了线索二叉树后，我们对它进行遍历时发现，其实就等于是操作一个双向链表结构。</p>
</li>
<li><p>和双向链表结构一样，在二叉树线索链表上添加一个头结点，如图3-3所示，并另其lchild域的指针指向二叉树的根节点（图中的a），其rchild域的指针指向中序遍历时访问的最后一个结点（图中的b）。</p>
</li>
<li>反之，令中序序列中的第一个结点H的lchild域指针和最后一个结点的rchild域指针均指向头结点。这样定义的好处就是我们既可以从第一个节点起顺后继进行遍历，也可以从最后一个结点起顺前驱进行遍历。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">     头指针-&gt;| |0#1| | </span><br><span class="line">           a&#x2F;      | </span><br><span class="line">          0A0      |</span><br><span class="line">       &#x2F;       \   |b</span><br><span class="line">     0B0       0C0 |</span><br><span class="line">    &#x2F;   \     &#x2F;   \|</span><br><span class="line">  0D0   0E1 1F1   1G1</span><br><span class="line">  &#x2F; \    &#x2F;</span><br><span class="line">1H1 1I1 1J1 </span><br><span class="line">         图3-3</span><br></pre></td></tr></table></figure>
<ul>
<li>遍历代码如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* T指向头结点，头结点左链lchild指向根节点，头结点右键rchild指向中序遍历的 */</span></span><br><span class="line"><span class="comment">/* 最后一个结点。中序遍历二叉线索链表表示的二叉树T */</span></span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse_Thr</span><span class="params">(BiThrTree T)</span></span>&#123;</span><br><span class="line">  BiThrTree p;</span><br><span class="line">  p = T-&gt;lchild;			<span class="comment">/* p指向根结点 */</span></span><br><span class="line">  <span class="keyword">while</span>(p != T)&#123;			<span class="comment">/* 空树或遍历结束时，p==T */</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;LTag==Link)	<span class="comment">/* 当LTag==0时循环到中序序列第一个结点 */</span></span><br><span class="line">      p = p-&gt;lchild;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data);	<span class="comment">/* 显示结点数据，可以更改为其他对结点操作 */</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;RTag==Thread &amp;&amp; p-&gt;rchild!=T)&#123;</span><br><span class="line">      p = p-&gt;rchild;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    p = p-&gt;rchild;		<span class="comment">/* p进至其右子树根 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于是一个链表的扫描，所以时间复杂度为O(n)。</p>
<p>如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。</p>
<h1 id="4-二叉树遍历算法应用"><a href="#4-二叉树遍历算法应用" class="headerlink" title="4.二叉树遍历算法应用"></a>4.二叉树遍历算法应用</h1><p>算法都在<a href="https://mysticalguest.github.io/2020/06/21/数据结构进阶实训九/" target="_blank" rel="noopener">二叉树的应用</a>和<a href="https://mysticalguest.github.io/2020/06/26/数据结构进阶实训十/" target="_blank" rel="noopener">二叉排序树</a>噢！</p>
<h1 id="5-树遍历算法应用"><a href="#5-树遍历算法应用" class="headerlink" title="5.树遍历算法应用"></a>5.树遍历算法应用</h1><ul>
<li>树转换为二叉树</li>
<li>森林转换为二叉树</li>
<li>二叉树转换为树</li>
<li>二叉树转换为森林</li>
</ul>
<h2 id="5-1-树的遍历"><a href="#5-1-树的遍历" class="headerlink" title="5.1 树的遍历"></a>5.1 树的遍历</h2><p>两种方式</p>
<ul>
<li>一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。</li>
<li>另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。</li>
<li>比如图5-1中的树，它的先根遍历序列为<code>ABEFCDG</code>，后根遍历序列为<code>EFBCGDA</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     A</span><br><span class="line">   &#x2F; | \</span><br><span class="line">  B  C  D</span><br><span class="line"> &#x2F; \   &#x2F;</span><br><span class="line">E   F G</span><br><span class="line">   图5-1</span><br></pre></td></tr></table></figure>
<h2 id="5-2-森林的遍历"><a href="#5-2-森林的遍历" class="headerlink" title="5.2 森林的遍历"></a>5.2 森林的遍历</h2><p>两种方式</p>
<ul>
<li><strong>前序遍历</strong>：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。比如图5-2中的森林，前序遍历序列的结果就是<code>ABCDEFGHJI</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   A           E             G</span><br><span class="line"> &#x2F; | \         |            &#x2F; \</span><br><span class="line">B  C  D        F           H   I</span><br><span class="line">                           |</span><br><span class="line">                           J</span><br><span class="line">              图5-2</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>后序遍历</strong>：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。比如图5-2中的森林，后序遍历序列的结果就是<code>BCDAFEJHIG</code>。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/26/%E6%A0%91%E7%9A%84%E8%A6%81%E7%82%B9%E5%BD%92%E7%BA%B3/" data-id="ckcfohq4a001skw562y3sakbm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/06/28/Electron+vue-cli3/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Electron+vue-cli3开发跨平台桌面应用
        
      </div>
    </a>
  
  
    <a href="/2020/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E5%8D%81/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">数据结构进阶实训十 二叉排序树</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Compile/">Compile</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%BB%E9%A2%98/">主题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%85%8D%E7%BD%AE/">配置</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Axios/" rel="tag">Axios</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Electron-Vue/" rel="tag">Electron-Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Element-UI/" rel="tag">Element-UI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Axios/" style="font-size: 10px;">Axios</a> <a href="/tags/C/" style="font-size: 20px;">C</a> <a href="/tags/Electron-Vue/" style="font-size: 10px;">Electron-Vue</a> <a href="/tags/Element-UI/" style="font-size: 10px;">Element-UI</a> <a href="/tags/Hexo/" style="font-size: 16.67px;">Hexo</a> <a href="/tags/Java/" style="font-size: 13.33px;">Java</a> <a href="/tags/OS/" style="font-size: 13.33px;">OS</a> <a href="/tags/TypeScript/" style="font-size: 10px;">TypeScript</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E5%8D%81%E4%BA%8C/">数据结构进阶实训十二 图</a>
          </li>
        
          <li>
            <a href="/2020/07/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%AE%AD%E5%8D%81%E4%B8%80/">数据结构进阶实训十一 树</a>
          </li>
        
          <li>
            <a href="/2020/07/01/OS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">高级操作系统</a>
          </li>
        
          <li>
            <a href="/2020/06/30/AdvancedOS/">高级操作系统</a>
          </li>
        
          <li>
            <a href="/2020/06/30/TypeScript/">TypeScript入门</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 MysticalGuest<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>